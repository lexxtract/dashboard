import * as _syscalls1_0 from "spacetime:sys@1.0";
import { register_hooks } from "spacetime:sys@1.0";
import { register_hooks as register_hooks$1 } from "spacetime:sys@1.1";
import * as _syscalls1_2 from "spacetime:sys@1.2";
import { register_hooks as register_hooks$2 } from "spacetime:sys@1.2";

//#region rolldown:runtime
var __create$2 = Object.create;
var __defProp$2 = Object.defineProperty;
var __getOwnPropDesc$2 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames$2 = Object.getOwnPropertyNames;
var __getProtoOf$2 = Object.getPrototypeOf;
var __hasOwnProp$2 = Object.prototype.hasOwnProperty;
var __commonJS$2 = (cb, mod) => function() {
	return mod || (0, cb[__getOwnPropNames$2(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps$2 = (to, from, except, desc) => {
	if (from && typeof from === "object" || typeof from === "function") for (var keys = __getOwnPropNames$2(from), i = 0, n = keys.length, key; i < n; i++) {
		key = keys[i];
		if (!__hasOwnProp$2.call(to, key) && key !== except) __defProp$2(to, key, {
			get: ((k) => from[k]).bind(null, key),
			enumerable: !(desc = __getOwnPropDesc$2(from, key)) || desc.enumerable
		});
	}
	return to;
};
var __toESM$2 = (mod, isNodeMode, target) => (target = mod != null ? __create$2(__getProtoOf$2(mod)) : {}, __copyProps$2(isNodeMode || !mod || !mod.__esModule ? __defProp$2(target, "default", {
	value: mod,
	enumerable: true
}) : target, mod));

//#endregion
//#region node_modules/headers-polyfill/lib/index.mjs
var __create$1 = Object.create;
var __defProp$1 = Object.defineProperty;
var __getOwnPropDesc$1 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames$1 = Object.getOwnPropertyNames;
var __getProtoOf$1 = Object.getPrototypeOf;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __commonJS$1 = (cb, mod) => function __require() {
	return mod || (0, cb[__getOwnPropNames$1(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps$1 = (to, from, except, desc) => {
	if (from && typeof from === "object" || typeof from === "function") {
		for (let key of __getOwnPropNames$1(from)) if (!__hasOwnProp$1.call(to, key) && key !== except) __defProp$1(to, key, {
			get: () => from[key],
			enumerable: !(desc = __getOwnPropDesc$1(from, key)) || desc.enumerable
		});
	}
	return to;
};
var __toESM$1 = (mod, isNodeMode, target) => (target = mod != null ? __create$1(__getProtoOf$1(mod)) : {}, __copyProps$1(isNodeMode || !mod || !mod.__esModule ? __defProp$1(target, "default", {
	value: mod,
	enumerable: true
}) : target, mod));
var import_set_cookie_parser = __toESM$1(__commonJS$1({ "node_modules/set-cookie-parser/lib/set-cookie.js"(exports$1, module$1) {
	var defaultParseOptions = {
		decodeValues: true,
		map: false,
		silent: false
	};
	function isNonEmptyString(str$1) {
		return typeof str$1 === "string" && !!str$1.trim();
	}
	function parseString(setCookieValue, options) {
		var parts = setCookieValue.split(";").filter(isNonEmptyString);
		var parsed = parseNameValuePair(parts.shift());
		var name = parsed.name;
		var value = parsed.value;
		options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
		try {
			value = options.decodeValues ? decodeURIComponent(value) : value;
		} catch (e) {
			console.error("set-cookie-parser encountered an error while decoding a cookie with value '" + value + "'. Set options.decodeValues to false to disable this feature.", e);
		}
		var cookie = {
			name,
			value
		};
		parts.forEach(function(part) {
			var sides = part.split("=");
			var key = sides.shift().trimLeft().toLowerCase();
			var value2 = sides.join("=");
			if (key === "expires") cookie.expires = new Date(value2);
			else if (key === "max-age") cookie.maxAge = parseInt(value2, 10);
			else if (key === "secure") cookie.secure = true;
			else if (key === "httponly") cookie.httpOnly = true;
			else if (key === "samesite") cookie.sameSite = value2;
			else cookie[key] = value2;
		});
		return cookie;
	}
	function parseNameValuePair(nameValuePairStr) {
		var name = "";
		var value = "";
		var nameValueArr = nameValuePairStr.split("=");
		if (nameValueArr.length > 1) {
			name = nameValueArr.shift();
			value = nameValueArr.join("=");
		} else value = nameValuePairStr;
		return {
			name,
			value
		};
	}
	function parse$1(input, options) {
		options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
		if (!input) if (!options.map) return [];
		else return {};
		if (input.headers) if (typeof input.headers.getSetCookie === "function") input = input.headers.getSetCookie();
		else if (input.headers["set-cookie"]) input = input.headers["set-cookie"];
		else {
			var sch = input.headers[Object.keys(input.headers).find(function(key) {
				return key.toLowerCase() === "set-cookie";
			})];
			if (!sch && input.headers.cookie && !options.silent) console.warn("Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning.");
			input = sch;
		}
		if (!Array.isArray(input)) input = [input];
		options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
		if (!options.map) return input.filter(isNonEmptyString).map(function(str$1) {
			return parseString(str$1, options);
		});
		else return input.filter(isNonEmptyString).reduce(function(cookies2, str$1) {
			var cookie = parseString(str$1, options);
			cookies2[cookie.name] = cookie;
			return cookies2;
		}, {});
	}
	function splitCookiesString2(cookiesString) {
		if (Array.isArray(cookiesString)) return cookiesString;
		if (typeof cookiesString !== "string") return [];
		var cookiesStrings = [];
		var pos = 0;
		var start;
		var ch;
		var lastComma;
		var nextStart;
		var cookiesSeparatorFound;
		function skipWhitespace() {
			while (pos < cookiesString.length && /\s/.test(cookiesString.charAt(pos))) pos += 1;
			return pos < cookiesString.length;
		}
		function notSpecialChar() {
			ch = cookiesString.charAt(pos);
			return ch !== "=" && ch !== ";" && ch !== ",";
		}
		while (pos < cookiesString.length) {
			start = pos;
			cookiesSeparatorFound = false;
			while (skipWhitespace()) {
				ch = cookiesString.charAt(pos);
				if (ch === ",") {
					lastComma = pos;
					pos += 1;
					skipWhitespace();
					nextStart = pos;
					while (pos < cookiesString.length && notSpecialChar()) pos += 1;
					if (pos < cookiesString.length && cookiesString.charAt(pos) === "=") {
						cookiesSeparatorFound = true;
						pos = nextStart;
						cookiesStrings.push(cookiesString.substring(start, lastComma));
						start = pos;
					} else pos = lastComma + 1;
				} else pos += 1;
			}
			if (!cookiesSeparatorFound || pos >= cookiesString.length) cookiesStrings.push(cookiesString.substring(start, cookiesString.length));
		}
		return cookiesStrings;
	}
	module$1.exports = parse$1;
	module$1.exports.parse = parse$1;
	module$1.exports.parseString = parseString;
	module$1.exports.splitCookiesString = splitCookiesString2;
} })());
var HEADERS_INVALID_CHARACTERS = /[^a-z0-9\-#$%&'*+.^_`|~]/i;
function normalizeHeaderName(name) {
	if (HEADERS_INVALID_CHARACTERS.test(name) || name.trim() === "") throw new TypeError("Invalid character in header field name");
	return name.trim().toLowerCase();
}
var charCodesToRemove = [
	String.fromCharCode(10),
	String.fromCharCode(13),
	String.fromCharCode(9),
	String.fromCharCode(32)
];
var HEADER_VALUE_REMOVE_REGEXP = new RegExp(`(^[${charCodesToRemove.join("")}]|$[${charCodesToRemove.join("")}])`, "g");
function normalizeHeaderValue(value) {
	return value.replace(HEADER_VALUE_REMOVE_REGEXP, "");
}
function isValidHeaderName(value) {
	if (typeof value !== "string") return false;
	if (value.length === 0) return false;
	for (let i = 0; i < value.length; i++) {
		const character = value.charCodeAt(i);
		if (character > 127 || !isToken(character)) return false;
	}
	return true;
}
function isToken(value) {
	return ![
		127,
		32,
		"(",
		")",
		"<",
		">",
		"@",
		",",
		";",
		":",
		"\\",
		"\"",
		"/",
		"[",
		"]",
		"?",
		"=",
		"{",
		"}"
	].includes(value);
}
function isValidHeaderValue(value) {
	if (typeof value !== "string") return false;
	if (value.trim() !== value) return false;
	for (let i = 0; i < value.length; i++) {
		const character = value.charCodeAt(i);
		if (character === 0 || character === 10 || character === 13) return false;
	}
	return true;
}
var NORMALIZED_HEADERS = Symbol("normalizedHeaders");
var RAW_HEADER_NAMES = Symbol("rawHeaderNames");
var HEADER_VALUE_DELIMITER = ", ";
var _a, _b, _c;
var Headers = class _Headers {
	constructor(init$1) {
		this[_a] = {};
		this[_b] = /* @__PURE__ */ new Map();
		this[_c] = "Headers";
		if (["Headers", "HeadersPolyfill"].includes(init$1?.constructor.name) || init$1 instanceof _Headers || typeof globalThis.Headers !== "undefined" && init$1 instanceof globalThis.Headers) init$1.forEach((value, name) => {
			this.append(name, value);
		}, this);
		else if (Array.isArray(init$1)) init$1.forEach(([name, value]) => {
			this.append(name, Array.isArray(value) ? value.join(HEADER_VALUE_DELIMITER) : value);
		});
		else if (init$1) Object.getOwnPropertyNames(init$1).forEach((name) => {
			const value = init$1[name];
			this.append(name, Array.isArray(value) ? value.join(HEADER_VALUE_DELIMITER) : value);
		});
	}
	[(_a = NORMALIZED_HEADERS, _b = RAW_HEADER_NAMES, _c = Symbol.toStringTag, Symbol.iterator)]() {
		return this.entries();
	}
	*keys() {
		for (const [name] of this.entries()) yield name;
	}
	*values() {
		for (const [, value] of this.entries()) yield value;
	}
	*entries() {
		let sortedKeys = Object.keys(this[NORMALIZED_HEADERS]).sort((a, b) => a.localeCompare(b));
		for (const name of sortedKeys) if (name === "set-cookie") for (const value of this.getSetCookie()) yield [name, value];
		else yield [name, this.get(name)];
	}
	/**
	* Returns a boolean stating whether a `Headers` object contains a certain header.
	*/
	has(name) {
		if (!isValidHeaderName(name)) throw new TypeError(`Invalid header name "${name}"`);
		return this[NORMALIZED_HEADERS].hasOwnProperty(normalizeHeaderName(name));
	}
	/**
	* Returns a `ByteString` sequence of all the values of a header with a given name.
	*/
	get(name) {
		if (!isValidHeaderName(name)) throw TypeError(`Invalid header name "${name}"`);
		return this[NORMALIZED_HEADERS][normalizeHeaderName(name)] ?? null;
	}
	/**
	* Sets a new value for an existing header inside a `Headers` object, or adds the header if it does not already exist.
	*/
	set(name, value) {
		if (!isValidHeaderName(name) || !isValidHeaderValue(value)) return;
		const normalizedName = normalizeHeaderName(name);
		const normalizedValue = normalizeHeaderValue(value);
		this[NORMALIZED_HEADERS][normalizedName] = normalizeHeaderValue(normalizedValue);
		this[RAW_HEADER_NAMES].set(normalizedName, name);
	}
	/**
	* Appends a new value onto an existing header inside a `Headers` object, or adds the header if it does not already exist.
	*/
	append(name, value) {
		if (!isValidHeaderName(name) || !isValidHeaderValue(value)) return;
		const normalizedName = normalizeHeaderName(name);
		const normalizedValue = normalizeHeaderValue(value);
		let resolvedValue = this.has(normalizedName) ? `${this.get(normalizedName)}, ${normalizedValue}` : normalizedValue;
		this.set(name, resolvedValue);
	}
	/**
	* Deletes a header from the `Headers` object.
	*/
	delete(name) {
		if (!isValidHeaderName(name)) return;
		if (!this.has(name)) return;
		const normalizedName = normalizeHeaderName(name);
		delete this[NORMALIZED_HEADERS][normalizedName];
		this[RAW_HEADER_NAMES].delete(normalizedName);
	}
	/**
	* Traverses the `Headers` object,
	* calling the given callback for each header.
	*/
	forEach(callback, thisArg) {
		for (const [name, value] of this.entries()) callback.call(thisArg, value, name, this);
	}
	/**
	* Returns an array containing the values
	* of all Set-Cookie headers associated
	* with a response
	*/
	getSetCookie() {
		const setCookieHeader = this.get("set-cookie");
		if (setCookieHeader === null) return [];
		if (setCookieHeader === "") return [""];
		return (0, import_set_cookie_parser.splitCookiesString)(setCookieHeader);
	}
};
function headersToList(headers) {
	const headersList = [];
	headers.forEach((value, name) => {
		const resolvedValue = value.includes(",") ? value.split(",").map((value2) => value2.trim()) : value;
		headersList.push([name, resolvedValue]);
	});
	return headersList;
}

//#endregion
//#region node_modules/spacetimedb/dist/server/index.mjs
typeof globalThis !== "undefined" && (globalThis.global = globalThis.global || globalThis, globalThis.window = globalThis.window || globalThis);
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError = (msg) => {
	throw TypeError(msg);
};
var __commonJS = (cb, mod) => function __require() {
	return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
	if (from && typeof from === "object" || typeof from === "function") {
		for (let key of __getOwnPropNames(from)) if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
			get: () => from[key],
			enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
		});
	}
	return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(__defProp(target, "default", {
	value: mod,
	enumerable: true
}), mod));
var __using = (stack, value, async) => {
	if (value != null) {
		if (typeof value !== "object" && typeof value !== "function") __typeError("Object expected");
		var dispose, inner;
		if (dispose === void 0) dispose = value[__knownSymbol("dispose")];
		if (typeof dispose !== "function") __typeError("Object not disposable");
		if (inner) dispose = function() {
			try {
				inner.call(this);
			} catch (e) {
				return Promise.reject(e);
			}
		};
		stack.push([
			async,
			dispose,
			value
		]);
	}
	return value;
};
var __callDispose = (stack, error, hasError) => {
	var E$1 = typeof SuppressedError === "function" ? SuppressedError : function(e, s, m, _$1) {
		return _$1 = Error(m), _$1.name = "SuppressedError", _$1.error = e, _$1.suppressed = s, _$1;
	};
	var fail = (e) => error = hasError ? new E$1(e, error, "An error was suppressed during disposal") : (hasError = true, e);
	var next = (it) => {
		while (it = stack.pop()) try {
			var result = it[1] && it[1].call(it[2]);
			if (it[0]) return Promise.resolve(result).then(next, (e) => (fail(e), next()));
		} catch (e) {
			fail(e);
		}
		if (hasError) throw error;
	};
	return next();
};
var require_base64_js = __commonJS({ "../../node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js"(exports$1) {
	exports$1.byteLength = byteLength;
	exports$1.toByteArray = toByteArray;
	exports$1.fromByteArray = fromByteArray2;
	var lookup = [];
	var revLookup = [];
	var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
	var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
	for (i = 0, len = code.length; i < len; ++i) {
		lookup[i] = code[i];
		revLookup[code.charCodeAt(i)] = i;
	}
	var i;
	var len;
	revLookup["-".charCodeAt(0)] = 62;
	revLookup["_".charCodeAt(0)] = 63;
	function getLens(b64) {
		var len2 = b64.length;
		if (len2 % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
		var validLen = b64.indexOf("=");
		if (validLen === -1) validLen = len2;
		var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
		return [validLen, placeHoldersLen];
	}
	function byteLength(b64) {
		var lens = getLens(b64);
		var validLen = lens[0];
		var placeHoldersLen = lens[1];
		return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
	}
	function _byteLength(b64, validLen, placeHoldersLen) {
		return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
	}
	function toByteArray(b64) {
		var tmp;
		var lens = getLens(b64);
		var validLen = lens[0];
		var placeHoldersLen = lens[1];
		var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
		var curByte = 0;
		var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
		var i2;
		for (i2 = 0; i2 < len2; i2 += 4) {
			tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
			arr[curByte++] = tmp >> 16 & 255;
			arr[curByte++] = tmp >> 8 & 255;
			arr[curByte++] = tmp & 255;
		}
		if (placeHoldersLen === 2) {
			tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
			arr[curByte++] = tmp & 255;
		}
		if (placeHoldersLen === 1) {
			tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
			arr[curByte++] = tmp >> 8 & 255;
			arr[curByte++] = tmp & 255;
		}
		return arr;
	}
	function tripletToBase64(num) {
		return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
	}
	function encodeChunk(uint8, start, end) {
		var tmp;
		var output = [];
		for (var i2 = start; i2 < end; i2 += 3) {
			tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
			output.push(tripletToBase64(tmp));
		}
		return output.join("");
	}
	function fromByteArray2(uint8) {
		var tmp;
		var len2 = uint8.length;
		var extraBytes = len2 % 3;
		var parts = [];
		var maxChunkLength = 16383;
		for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
		if (extraBytes === 1) {
			tmp = uint8[len2 - 1];
			parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
		} else if (extraBytes === 2) {
			tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
			parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
		}
		return parts.join("");
	}
} });
var require_text_min = __commonJS({ "../../node_modules/.pnpm/fast-text-encoding@1.0.6/node_modules/fast-text-encoding/text.min.js"(exports$1) {
	(function(scope) {
		function B(r, e) {
			var f;
			return r instanceof Buffer ? f = r : f = Buffer.from(r.buffer, r.byteOffset, r.byteLength), f.toString(e);
		}
		var w = function(r) {
			return Buffer.from(r);
		};
		function h(r) {
			for (var e = 0, f = Math.min(256 * 256, r.length + 1), n = new Uint16Array(f), i = [], o = 0;;) {
				var t2 = e < r.length;
				if (!t2 || o >= f - 1) {
					var m = n.subarray(0, o);
					if (i.push(String.fromCharCode.apply(null, m)), !t2) return i.join("");
					r = r.subarray(e), e = 0, o = 0;
				}
				var a = r[e++];
				if ((a & 128) === 0) n[o++] = a;
				else if ((a & 224) === 192) {
					var d = r[e++] & 63;
					n[o++] = (a & 31) << 6 | d;
				} else if ((a & 240) === 224) {
					var d = r[e++] & 63, l = r[e++] & 63;
					n[o++] = (a & 31) << 12 | d << 6 | l;
				} else if ((a & 248) === 240) {
					var d = r[e++] & 63, l = r[e++] & 63, R = r[e++] & 63, c = (a & 7) << 18 | d << 12 | l << 6 | R;
					c > 65535 && (c -= 65536, n[o++] = c >>> 10 & 1023 | 55296, c = 56320 | c & 1023), n[o++] = c;
				}
			}
		}
		function F(r) {
			for (var e = 0, f = r.length, n = 0, i = Math.max(32, f + (f >>> 1) + 7), o = new Uint8Array(i >>> 3 << 3); e < f;) {
				var t2 = r.charCodeAt(e++);
				if (t2 >= 55296 && t2 <= 56319) {
					if (e < f) {
						var s = r.charCodeAt(e);
						(s & 64512) === 56320 && (++e, t2 = ((t2 & 1023) << 10) + (s & 1023) + 65536);
					}
					if (t2 >= 55296 && t2 <= 56319) continue;
				}
				if (n + 4 > o.length) {
					i += 8, i *= 1 + e / r.length * 2, i = i >>> 3 << 3;
					var m = new Uint8Array(i);
					m.set(o), o = m;
				}
				if ((t2 & 4294967168) === 0) {
					o[n++] = t2;
					continue;
				} else if ((t2 & 4294965248) === 0) o[n++] = t2 >>> 6 & 31 | 192;
				else if ((t2 & 4294901760) === 0) o[n++] = t2 >>> 12 & 15 | 224, o[n++] = t2 >>> 6 & 63 | 128;
				else if ((t2 & 4292870144) === 0) o[n++] = t2 >>> 18 & 7 | 240, o[n++] = t2 >>> 12 & 63 | 128, o[n++] = t2 >>> 6 & 63 | 128;
				else continue;
				o[n++] = t2 & 63 | 128;
			}
			return o.slice ? o.slice(0, n) : o.subarray(0, n);
		}
		var u = "Failed to ", p = function(r, e, f) {
			if (r) throw new Error("".concat(u).concat(e, ": the '").concat(f, "' option is unsupported."));
		};
		var x = typeof Buffer == "function" && Buffer.from;
		var A = x ? w : F;
		function v() {
			this.encoding = "utf-8";
		}
		v.prototype.encode = function(r, e) {
			return p(e && e.stream, "encode", "stream"), A(r);
		};
		function U(r) {
			var e;
			try {
				var f = new Blob([r], { type: "text/plain;charset=UTF-8" });
				e = URL.createObjectURL(f);
				var n = new XMLHttpRequest();
				return n.open("GET", e, false), n.send(), n.responseText;
			} finally {
				e && URL.revokeObjectURL(e);
			}
		}
		var O = !x && typeof Blob == "function" && typeof URL == "function" && typeof URL.createObjectURL == "function", S = [
			"utf-8",
			"utf8",
			"unicode-1-1-utf-8"
		], T = h;
		x ? T = B : O && (T = function(r) {
			try {
				return U(r);
			} catch (e) {
				return h(r);
			}
		});
		var y = "construct 'TextDecoder'", E$1 = "".concat(u, " ").concat(y, ": the ");
		function g(r, e) {
			p(e && e.fatal, y, "fatal"), r = r || "utf-8";
			var f;
			if (x ? f = Buffer.isEncoding(r) : f = S.indexOf(r.toLowerCase()) !== -1, !f) throw new RangeError("".concat(E$1, " encoding label provided ('").concat(r, "') is invalid."));
			this.encoding = r, this.fatal = false, this.ignoreBOM = false;
		}
		g.prototype.decode = function(r, e) {
			p(e && e.stream, "decode", "stream");
			var f;
			return r instanceof Uint8Array ? f = r : r.buffer instanceof ArrayBuffer ? f = new Uint8Array(r.buffer) : f = new Uint8Array(r), T(f, this.encoding);
		};
		scope.TextEncoder = scope.TextEncoder || v;
		scope.TextDecoder = scope.TextDecoder || g;
	})(typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : exports$1);
} });
var require_codes = __commonJS({ "../../node_modules/.pnpm/statuses@2.0.2/node_modules/statuses/codes.json"(exports$1, module$1) {
	module$1.exports = {
		"100": "Continue",
		"101": "Switching Protocols",
		"102": "Processing",
		"103": "Early Hints",
		"200": "OK",
		"201": "Created",
		"202": "Accepted",
		"203": "Non-Authoritative Information",
		"204": "No Content",
		"205": "Reset Content",
		"206": "Partial Content",
		"207": "Multi-Status",
		"208": "Already Reported",
		"226": "IM Used",
		"300": "Multiple Choices",
		"301": "Moved Permanently",
		"302": "Found",
		"303": "See Other",
		"304": "Not Modified",
		"305": "Use Proxy",
		"307": "Temporary Redirect",
		"308": "Permanent Redirect",
		"400": "Bad Request",
		"401": "Unauthorized",
		"402": "Payment Required",
		"403": "Forbidden",
		"404": "Not Found",
		"405": "Method Not Allowed",
		"406": "Not Acceptable",
		"407": "Proxy Authentication Required",
		"408": "Request Timeout",
		"409": "Conflict",
		"410": "Gone",
		"411": "Length Required",
		"412": "Precondition Failed",
		"413": "Payload Too Large",
		"414": "URI Too Long",
		"415": "Unsupported Media Type",
		"416": "Range Not Satisfiable",
		"417": "Expectation Failed",
		"418": "I'm a Teapot",
		"421": "Misdirected Request",
		"422": "Unprocessable Entity",
		"423": "Locked",
		"424": "Failed Dependency",
		"425": "Too Early",
		"426": "Upgrade Required",
		"428": "Precondition Required",
		"429": "Too Many Requests",
		"431": "Request Header Fields Too Large",
		"451": "Unavailable For Legal Reasons",
		"500": "Internal Server Error",
		"501": "Not Implemented",
		"502": "Bad Gateway",
		"503": "Service Unavailable",
		"504": "Gateway Timeout",
		"505": "HTTP Version Not Supported",
		"506": "Variant Also Negotiates",
		"507": "Insufficient Storage",
		"508": "Loop Detected",
		"509": "Bandwidth Limit Exceeded",
		"510": "Not Extended",
		"511": "Network Authentication Required"
	};
} });
var require_statuses = __commonJS({ "../../node_modules/.pnpm/statuses@2.0.2/node_modules/statuses/index.js"(exports$1, module$1) {
	var codes = require_codes();
	module$1.exports = status2;
	status2.message = codes;
	status2.code = createMessageToStatusCodeMap(codes);
	status2.codes = createStatusCodeList(codes);
	status2.redirect = {
		300: true,
		301: true,
		302: true,
		303: true,
		305: true,
		307: true,
		308: true
	};
	status2.empty = {
		204: true,
		205: true,
		304: true
	};
	status2.retry = {
		502: true,
		503: true,
		504: true
	};
	function createMessageToStatusCodeMap(codes2) {
		var map = {};
		Object.keys(codes2).forEach(function forEachCode(code) {
			var message = codes2[code];
			var status3 = Number(code);
			map[message.toLowerCase()] = status3;
		});
		return map;
	}
	function createStatusCodeList(codes2) {
		return Object.keys(codes2).map(function mapCode(code) {
			return Number(code);
		});
	}
	function getStatusCode(message) {
		var msg = message.toLowerCase();
		if (!Object.prototype.hasOwnProperty.call(status2.code, msg)) throw new Error("invalid status message: \"" + message + "\"");
		return status2.code[msg];
	}
	function getStatusMessage(code) {
		if (!Object.prototype.hasOwnProperty.call(status2.message, code)) throw new Error("invalid status code: " + code);
		return status2.message[code];
	}
	function status2(code) {
		if (typeof code === "number") return getStatusMessage(code);
		if (typeof code !== "string") throw new TypeError("code must be a number or string");
		var n = parseInt(code, 10);
		if (!isNaN(n)) return getStatusMessage(n);
		return getStatusCode(code);
	}
} });
var TimeDuration = class _TimeDuration {
	__time_duration_micros__;
	static MICROS_PER_MILLIS = 1000n;
	/**
	* Get the algebraic type representation of the {@link TimeDuration} type.
	* @returns The algebraic type representation of the type.
	*/
	static getAlgebraicType() {
		return AlgebraicType.Product({ elements: [{
			name: "__time_duration_micros__",
			algebraicType: AlgebraicType.I64
		}] });
	}
	static isTimeDuration(algebraicType) {
		if (algebraicType.tag !== "Product") return false;
		const elements = algebraicType.value.elements;
		if (elements.length !== 1) return false;
		const microsElement = elements[0];
		return microsElement.name === "__time_duration_micros__" && microsElement.algebraicType.tag === "I64";
	}
	get micros() {
		return this.__time_duration_micros__;
	}
	get millis() {
		return Number(this.micros / _TimeDuration.MICROS_PER_MILLIS);
	}
	constructor(micros) {
		this.__time_duration_micros__ = micros;
	}
	static fromMillis(millis) {
		return new _TimeDuration(BigInt(millis) * _TimeDuration.MICROS_PER_MILLIS);
	}
	/** This outputs the same string format that we use in the host and in Rust modules */
	toString() {
		const micros = this.micros;
		const sign = micros < 0 ? "-" : "+";
		const pos = micros < 0 ? -micros : micros;
		const secs = pos / 1000000n;
		const micros_remaining = pos % 1000000n;
		return `${sign}${secs}.${String(micros_remaining).padStart(6, "0")}`;
	}
};
var Timestamp = class _Timestamp {
	__timestamp_micros_since_unix_epoch__;
	static MICROS_PER_MILLIS = 1000n;
	get microsSinceUnixEpoch() {
		return this.__timestamp_micros_since_unix_epoch__;
	}
	constructor(micros) {
		this.__timestamp_micros_since_unix_epoch__ = micros;
	}
	/**
	* Get the algebraic type representation of the {@link Timestamp} type.
	* @returns The algebraic type representation of the type.
	*/
	static getAlgebraicType() {
		return AlgebraicType.Product({ elements: [{
			name: "__timestamp_micros_since_unix_epoch__",
			algebraicType: AlgebraicType.I64
		}] });
	}
	static isTimestamp(algebraicType) {
		if (algebraicType.tag !== "Product") return false;
		const elements = algebraicType.value.elements;
		if (elements.length !== 1) return false;
		const microsElement = elements[0];
		return microsElement.name === "__timestamp_micros_since_unix_epoch__" && microsElement.algebraicType.tag === "I64";
	}
	/**
	* The Unix epoch, the midnight at the beginning of January 1, 1970, UTC.
	*/
	static UNIX_EPOCH = new _Timestamp(0n);
	/**
	* Get a `Timestamp` representing the execution environment's belief of the current moment in time.
	*/
	static now() {
		return _Timestamp.fromDate(/* @__PURE__ */ new Date());
	}
	/** Convert to milliseconds since Unix epoch. */
	toMillis() {
		return this.microsSinceUnixEpoch / 1000n;
	}
	/**
	* Get a `Timestamp` representing the same point in time as `date`.
	*/
	static fromDate(date) {
		const millis = date.getTime();
		return new _Timestamp(BigInt(millis) * _Timestamp.MICROS_PER_MILLIS);
	}
	/**
	* Get a `Date` representing approximately the same point in time as `this`.
	*
	* This method truncates to millisecond precision,
	* and throws `RangeError` if the `Timestamp` is outside the range representable as a `Date`.
	*/
	toDate() {
		const millis = this.__timestamp_micros_since_unix_epoch__ / _Timestamp.MICROS_PER_MILLIS;
		if (millis > BigInt(Number.MAX_SAFE_INTEGER) || millis < BigInt(Number.MIN_SAFE_INTEGER)) throw new RangeError("Timestamp is outside of the representable range of JS's Date");
		return new Date(Number(millis));
	}
	since(other) {
		return new TimeDuration(this.__timestamp_micros_since_unix_epoch__ - other.__timestamp_micros_since_unix_epoch__);
	}
};
var Uuid = class _Uuid {
	__uuid__;
	/**
	* The nil UUID (all zeros).
	*
	* @example
	* ```ts
	* const uuid = Uuid.NIL;
	* console.assert(
	*   uuid.toString() === "00000000-0000-0000-0000-000000000000"
	* );
	* ```
	*/
	static NIL = new _Uuid(0n);
	static MAX_UUID_BIGINT = 340282366920938463463374607431768211455n;
	/**
	* The max UUID (all ones).
	*
	* @example
	* ```ts
	* const uuid = Uuid.MAX;
	* console.assert(
	*   uuid.toString() === "ffffffff-ffff-ffff-ffff-ffffffffffff"
	* );
	* ```
	*/
	static MAX = new _Uuid(_Uuid.MAX_UUID_BIGINT);
	/**
	* Create a UUID from a raw 128-bit value.
	*
	* @param u - Unsigned 128-bit integer
	* @throws {Error} If the value is outside the valid UUID range
	*/
	constructor(u) {
		if (u < 0n || u > _Uuid.MAX_UUID_BIGINT) throw new Error("Invalid UUID: must be between 0 and `MAX_UUID_BIGINT`");
		this.__uuid__ = u;
	}
	/**
	* Create a UUID `v4` from explicit random bytes.
	*
	* This method assumes the bytes are already sufficiently random.
	* It only sets the appropriate bits for the UUID version and variant.
	*
	* @param bytes - Exactly 16 random bytes
	* @returns A UUID `v4`
	* @throws {Error} If `bytes.length !== 16`
	*
	* @example
	* ```ts
	* const randomBytes = new Uint8Array(16);
	* const uuid = Uuid.fromRandomBytesV4(randomBytes);
	*
	* console.assert(
	*   uuid.toString() === "00000000-0000-4000-8000-000000000000"
	* );
	* ```
	*/
	static fromRandomBytesV4(bytes) {
		if (bytes.length !== 16) throw new Error("UUID v4 requires 16 bytes");
		const arr = new Uint8Array(bytes);
		arr[6] = arr[6] & 15 | 64;
		arr[8] = arr[8] & 63 | 128;
		return new _Uuid(_Uuid.bytesToBigInt(arr));
	}
	/**
	* Generate a UUID `v7` using a monotonic counter from `0` to `2^31 - 1`,
	* a timestamp, and 4 random bytes.
	*
	* The counter wraps around on overflow.
	*
	* The UUID `v7` is structured as follows:
	*
	* ```ascii
	* ┌───────────────────────────────────────────────┬───────────────────┐
	* | B0  | B1  | B2  | B3  | B4  | B5              |         B6        |
	* ├───────────────────────────────────────────────┼───────────────────┤
	* |                 unix_ts_ms                    |      version 7    |
	* └───────────────────────────────────────────────┴───────────────────┘
	* ┌──────────────┬─────────┬──────────────────┬───────────────────────┐
	* | B7           | B8      | B9  | B10 | B11  | B12 | B13 | B14 | B15 |
	* ├──────────────┼─────────┼──────────────────┼───────────────────────┤
	* | counter_high | variant |    counter_low   |        random         |
	* └──────────────┴─────────┴──────────────────┴───────────────────────┘
	* ```
	*
	* @param counter - Mutable monotonic counter (31-bit)
	* @param now - Timestamp since the Unix epoch
	* @param randomBytes - Exactly 4 random bytes
	* @returns A UUID `v7`
	*
	* @throws {Error} If the `counter` is negative
	* @throws {Error} If the `timestamp` is before the Unix epoch
	* @throws {Error} If `randomBytes.length !== 4`
	*
	* @example
	* ```ts
	* const now = Timestamp.fromMillis(1_686_000_000_000n);
	* const counter = { value: 1 };
	* const randomBytes = new Uint8Array(4);
	*
	* const uuid = Uuid.fromCounterV7(counter, now, randomBytes);
	*
	* console.assert(
	*   uuid.toString() === "0000647e-5180-7000-8000-000200000000"
	* );
	* ```
	*/
	static fromCounterV7(counter, now, randomBytes) {
		if (randomBytes.length !== 4) throw new Error("`fromCounterV7` requires `randomBytes.length == 4`");
		if (counter.value < 0) throw new Error("`fromCounterV7` uuid `counter` must be non-negative");
		if (now.__timestamp_micros_since_unix_epoch__ < 0) throw new Error("`fromCounterV7` `timestamp` before unix epoch");
		const counterVal = counter.value;
		counter.value = counterVal + 1 & 2147483647;
		const tsMs = now.toMillis() & 281474976710655n;
		const bytes = new Uint8Array(16);
		bytes[0] = Number(tsMs >> 40n & 255n);
		bytes[1] = Number(tsMs >> 32n & 255n);
		bytes[2] = Number(tsMs >> 24n & 255n);
		bytes[3] = Number(tsMs >> 16n & 255n);
		bytes[4] = Number(tsMs >> 8n & 255n);
		bytes[5] = Number(tsMs & 255n);
		bytes[7] = counterVal >>> 23 & 255;
		bytes[9] = counterVal >>> 15 & 255;
		bytes[10] = counterVal >>> 7 & 255;
		bytes[11] = (counterVal & 127) << 1 & 255;
		bytes[12] |= randomBytes[0] & 127;
		bytes[13] = randomBytes[1];
		bytes[14] = randomBytes[2];
		bytes[15] = randomBytes[3];
		bytes[6] = bytes[6] & 15 | 112;
		bytes[8] = bytes[8] & 63 | 128;
		return new _Uuid(_Uuid.bytesToBigInt(bytes));
	}
	/**
	* Parse a UUID from a string representation.
	*
	* @param s - UUID string
	* @returns Parsed UUID
	* @throws {Error} If the string is not a valid UUID
	*
	* @example
	* ```ts
	* const s = "01888d6e-5c00-7000-8000-000000000000";
	* const uuid = Uuid.parse(s);
	*
	* console.assert(uuid.toString() === s);
	* ```
	*/
	static parse(s) {
		const hex = s.replace(/-/g, "");
		if (hex.length !== 32) throw new Error("Invalid hex UUID");
		let v = 0n;
		for (let i = 0; i < 32; i += 2) v = v << 8n | BigInt(parseInt(hex.slice(i, i + 2), 16));
		return new _Uuid(v);
	}
	/** Convert to string (hyphenated form). */
	toString() {
		const hex = [..._Uuid.bigIntToBytes(this.__uuid__)].map((b) => b.toString(16).padStart(2, "0")).join("");
		return hex.slice(0, 8) + "-" + hex.slice(8, 12) + "-" + hex.slice(12, 16) + "-" + hex.slice(16, 20) + "-" + hex.slice(20);
	}
	/** Convert to bigint (u128). */
	asBigInt() {
		return this.__uuid__;
	}
	/** Return a `Uint8Array` of 16 bytes. */
	toBytes() {
		return _Uuid.bigIntToBytes(this.__uuid__);
	}
	static bytesToBigInt(bytes) {
		let result = 0n;
		for (const b of bytes) result = result << 8n | BigInt(b);
		return result;
	}
	static bigIntToBytes(value) {
		const bytes = new Uint8Array(16);
		for (let i = 15; i >= 0; i--) {
			bytes[i] = Number(value & 255n);
			value >>= 8n;
		}
		return bytes;
	}
	/**
	* Returns the version of this UUID.
	*
	* This represents the algorithm used to generate the value.
	*
	* @returns A `UuidVersion`
	* @throws {Error} If the version field is not recognized
	*/
	getVersion() {
		const version = this.toBytes()[6] >> 4 & 15;
		switch (version) {
			case 4: return "V4";
			case 7: return "V7";
			default:
				if (this == _Uuid.NIL) return "Nil";
				if (this == _Uuid.MAX) return "Max";
				throw new Error(`Unsupported UUID version: ${version}`);
		}
	}
	/**
	* Extract the monotonic counter from a UUIDv7.
	*
	* Intended for testing and diagnostics.
	* Behavior is undefined if called on a non-V7 UUID.
	*
	* @returns 31-bit counter value
	*/
	getCounter() {
		const bytes = this.toBytes();
		const high = bytes[7];
		const mid1 = bytes[9];
		const mid2 = bytes[10];
		const low = bytes[11] >>> 1;
		return high << 23 | mid1 << 15 | mid2 << 7 | low | 0;
	}
	compareTo(other) {
		if (this.__uuid__ < other.__uuid__) return -1;
		if (this.__uuid__ > other.__uuid__) return 1;
		return 0;
	}
	static getAlgebraicType() {
		return AlgebraicType.Product({ elements: [{
			name: "__uuid__",
			algebraicType: AlgebraicType.U128
		}] });
	}
};
var BinaryReader = class {
	/**
	* The DataView used to read values from the binary data.
	*
	* Note: The DataView's `byteOffset` is relative to the beginning of the
	* underlying ArrayBuffer, not the start of the provided Uint8Array input.
	* This `BinaryReader`'s `#offset` field is used to track the current read position
	* relative to the start of the provided Uint8Array input.
	*/
	#view;
	/**
	* Represents the offset (in bytes) relative to the start of the DataView
	* and provided Uint8Array input.
	*
	* Note: This is *not* the absolute byte offset within the underlying ArrayBuffer.
	*/
	#offset = 0;
	constructor(input) {
		this.#view = new DataView(input.buffer, input.byteOffset, input.byteLength);
		this.#offset = 0;
	}
	get offset() {
		return this.#offset;
	}
	get remaining() {
		return this.#view.byteLength - this.#offset;
	}
	/** Ensure we have at least `n` bytes left to read */
	#ensure(n) {
		if (this.#offset + n > this.#view.byteLength) throw new RangeError(`Tried to read ${n} byte(s) at relative offset ${this.#offset}, but only ${this.remaining} byte(s) remain`);
	}
	readUInt8Array() {
		const length = this.readU32();
		this.#ensure(length);
		return this.readBytes(length);
	}
	readBool() {
		const value = this.#view.getUint8(this.#offset);
		this.#offset += 1;
		return value !== 0;
	}
	readByte() {
		const value = this.#view.getUint8(this.#offset);
		this.#offset += 1;
		return value;
	}
	readBytes(length) {
		const array = new Uint8Array(this.#view.buffer, this.#view.byteOffset + this.#offset, length);
		this.#offset += length;
		return array;
	}
	readI8() {
		const value = this.#view.getInt8(this.#offset);
		this.#offset += 1;
		return value;
	}
	readU8() {
		return this.readByte();
	}
	readI16() {
		const value = this.#view.getInt16(this.#offset, true);
		this.#offset += 2;
		return value;
	}
	readU16() {
		const value = this.#view.getUint16(this.#offset, true);
		this.#offset += 2;
		return value;
	}
	readI32() {
		const value = this.#view.getInt32(this.#offset, true);
		this.#offset += 4;
		return value;
	}
	readU32() {
		const value = this.#view.getUint32(this.#offset, true);
		this.#offset += 4;
		return value;
	}
	readI64() {
		const value = this.#view.getBigInt64(this.#offset, true);
		this.#offset += 8;
		return value;
	}
	readU64() {
		const value = this.#view.getBigUint64(this.#offset, true);
		this.#offset += 8;
		return value;
	}
	readU128() {
		const lowerPart = this.#view.getBigUint64(this.#offset, true);
		const upperPart = this.#view.getBigUint64(this.#offset + 8, true);
		this.#offset += 16;
		return (upperPart << BigInt(64)) + lowerPart;
	}
	readI128() {
		const lowerPart = this.#view.getBigUint64(this.#offset, true);
		const upperPart = this.#view.getBigInt64(this.#offset + 8, true);
		this.#offset += 16;
		return (upperPart << BigInt(64)) + lowerPart;
	}
	readU256() {
		const p0 = this.#view.getBigUint64(this.#offset, true);
		const p1 = this.#view.getBigUint64(this.#offset + 8, true);
		const p2 = this.#view.getBigUint64(this.#offset + 16, true);
		const p3 = this.#view.getBigUint64(this.#offset + 24, true);
		this.#offset += 32;
		return (p3 << BigInt(192)) + (p2 << BigInt(128)) + (p1 << BigInt(64)) + p0;
	}
	readI256() {
		const p0 = this.#view.getBigUint64(this.#offset, true);
		const p1 = this.#view.getBigUint64(this.#offset + 8, true);
		const p2 = this.#view.getBigUint64(this.#offset + 16, true);
		const p3 = this.#view.getBigInt64(this.#offset + 24, true);
		this.#offset += 32;
		return (p3 << BigInt(192)) + (p2 << BigInt(128)) + (p1 << BigInt(64)) + p0;
	}
	readF32() {
		const value = this.#view.getFloat32(this.#offset, true);
		this.#offset += 4;
		return value;
	}
	readF64() {
		const value = this.#view.getFloat64(this.#offset, true);
		this.#offset += 8;
		return value;
	}
	readString() {
		const uint8Array = this.readUInt8Array();
		return new TextDecoder("utf-8").decode(uint8Array);
	}
};
var import_base64_js = __toESM(require_base64_js());
var BinaryWriter = class {
	#buffer;
	#view;
	#offset = 0;
	constructor(size) {
		this.#buffer = new Uint8Array(size);
		this.#view = new DataView(this.#buffer.buffer);
	}
	#expandBuffer(additionalCapacity) {
		const minCapacity = this.#offset + additionalCapacity + 1;
		if (minCapacity <= this.#buffer.length) return;
		let newCapacity = this.#buffer.length * 2;
		if (newCapacity < minCapacity) newCapacity = minCapacity;
		const newBuffer = new Uint8Array(newCapacity);
		newBuffer.set(this.#buffer);
		this.#buffer = newBuffer;
		this.#view = new DataView(this.#buffer.buffer);
	}
	toBase64() {
		return (0, import_base64_js.fromByteArray)(this.#buffer.subarray(0, this.#offset));
	}
	getBuffer() {
		return this.#buffer.slice(0, this.#offset);
	}
	get offset() {
		return this.#offset;
	}
	writeUInt8Array(value) {
		const length = value.length;
		this.#expandBuffer(4 + length);
		this.writeU32(length);
		this.#buffer.set(value, this.#offset);
		this.#offset += value.length;
	}
	writeBool(value) {
		this.#expandBuffer(1);
		this.#view.setUint8(this.#offset, value ? 1 : 0);
		this.#offset += 1;
	}
	writeByte(value) {
		this.#expandBuffer(1);
		this.#view.setUint8(this.#offset, value);
		this.#offset += 1;
	}
	writeI8(value) {
		this.#expandBuffer(1);
		this.#view.setInt8(this.#offset, value);
		this.#offset += 1;
	}
	writeU8(value) {
		this.#expandBuffer(1);
		this.#view.setUint8(this.#offset, value);
		this.#offset += 1;
	}
	writeI16(value) {
		this.#expandBuffer(2);
		this.#view.setInt16(this.#offset, value, true);
		this.#offset += 2;
	}
	writeU16(value) {
		this.#expandBuffer(2);
		this.#view.setUint16(this.#offset, value, true);
		this.#offset += 2;
	}
	writeI32(value) {
		this.#expandBuffer(4);
		this.#view.setInt32(this.#offset, value, true);
		this.#offset += 4;
	}
	writeU32(value) {
		this.#expandBuffer(4);
		this.#view.setUint32(this.#offset, value, true);
		this.#offset += 4;
	}
	writeI64(value) {
		this.#expandBuffer(8);
		this.#view.setBigInt64(this.#offset, value, true);
		this.#offset += 8;
	}
	writeU64(value) {
		this.#expandBuffer(8);
		this.#view.setBigUint64(this.#offset, value, true);
		this.#offset += 8;
	}
	writeU128(value) {
		this.#expandBuffer(16);
		const lowerPart = value & BigInt("0xFFFFFFFFFFFFFFFF");
		const upperPart = value >> BigInt(64);
		this.#view.setBigUint64(this.#offset, lowerPart, true);
		this.#view.setBigUint64(this.#offset + 8, upperPart, true);
		this.#offset += 16;
	}
	writeI128(value) {
		this.#expandBuffer(16);
		const lowerPart = value & BigInt("0xFFFFFFFFFFFFFFFF");
		const upperPart = value >> BigInt(64);
		this.#view.setBigInt64(this.#offset, lowerPart, true);
		this.#view.setBigInt64(this.#offset + 8, upperPart, true);
		this.#offset += 16;
	}
	writeU256(value) {
		this.#expandBuffer(32);
		const low_64_mask = BigInt("0xFFFFFFFFFFFFFFFF");
		const p0 = value & low_64_mask;
		const p1 = value >> BigInt(64) & low_64_mask;
		const p2 = value >> BigInt(128) & low_64_mask;
		const p3 = value >> BigInt(192);
		this.#view.setBigUint64(this.#offset + 0, p0, true);
		this.#view.setBigUint64(this.#offset + 8, p1, true);
		this.#view.setBigUint64(this.#offset + 16, p2, true);
		this.#view.setBigUint64(this.#offset + 24, p3, true);
		this.#offset += 32;
	}
	writeI256(value) {
		this.#expandBuffer(32);
		const low_64_mask = BigInt("0xFFFFFFFFFFFFFFFF");
		const p0 = value & low_64_mask;
		const p1 = value >> BigInt(64) & low_64_mask;
		const p2 = value >> BigInt(128) & low_64_mask;
		const p3 = value >> BigInt(192);
		this.#view.setBigUint64(this.#offset + 0, p0, true);
		this.#view.setBigUint64(this.#offset + 8, p1, true);
		this.#view.setBigUint64(this.#offset + 16, p2, true);
		this.#view.setBigInt64(this.#offset + 24, p3, true);
		this.#offset += 32;
	}
	writeF32(value) {
		this.#expandBuffer(4);
		this.#view.setFloat32(this.#offset, value, true);
		this.#offset += 4;
	}
	writeF64(value) {
		this.#expandBuffer(8);
		this.#view.setFloat64(this.#offset, value, true);
		this.#offset += 8;
	}
	writeString(value) {
		const encodedString = new TextEncoder().encode(value);
		this.writeU32(encodedString.length);
		this.#expandBuffer(encodedString.length);
		this.#buffer.set(encodedString, this.#offset);
		this.#offset += encodedString.length;
	}
};
function toPascalCase(s) {
	const str$1 = s.replace(/([-_][a-z])/gi, ($1) => {
		return $1.toUpperCase().replace("-", "").replace("_", "");
	});
	return str$1.charAt(0).toUpperCase() + str$1.slice(1);
}
function uint8ArrayToHexString(array) {
	return Array.prototype.map.call(array.reverse(), (x) => ("00" + x.toString(16)).slice(-2)).join("");
}
function uint8ArrayToU128(array) {
	if (array.length != 16) throw new Error(`Uint8Array is not 16 bytes long: ${array}`);
	return new BinaryReader(array).readU128();
}
function uint8ArrayToU256(array) {
	if (array.length != 32) throw new Error(`Uint8Array is not 32 bytes long: [${array}]`);
	return new BinaryReader(array).readU256();
}
function hexStringToUint8Array(str$1) {
	if (str$1.startsWith("0x")) str$1 = str$1.slice(2);
	const matches = str$1.match(/.{1,2}/g) || [];
	return Uint8Array.from(matches.map((byte) => parseInt(byte, 16))).reverse();
}
function hexStringToU128(str$1) {
	return uint8ArrayToU128(hexStringToUint8Array(str$1));
}
function hexStringToU256(str$1) {
	return uint8ArrayToU256(hexStringToUint8Array(str$1));
}
function u128ToUint8Array(data) {
	const writer = new BinaryWriter(16);
	writer.writeU128(data);
	return writer.getBuffer();
}
function u128ToHexString(data) {
	return uint8ArrayToHexString(u128ToUint8Array(data));
}
function u256ToUint8Array(data) {
	const writer = new BinaryWriter(32);
	writer.writeU256(data);
	return writer.getBuffer();
}
function u256ToHexString(data) {
	return uint8ArrayToHexString(u256ToUint8Array(data));
}
function toCamelCase(str$1) {
	return str$1.replace(/[-_]+/g, "_").replace(/_([a-zA-Z0-9])/g, (_$1, c) => c.toUpperCase());
}
function bsatnBaseSize(typespace, ty) {
	const assumedArrayLength = 4;
	while (ty.tag === "Ref") ty = typespace.types[ty.value];
	if (ty.tag === "Product") {
		let sum = 0;
		for (const { algebraicType: elem } of ty.value.elements) sum += bsatnBaseSize(typespace, elem);
		return sum;
	} else if (ty.tag === "Sum") {
		let min = Infinity;
		for (const { algebraicType: vari } of ty.value.variants) {
			const vSize = bsatnBaseSize(typespace, vari);
			if (vSize < min) min = vSize;
		}
		if (min === Infinity) min = 0;
		return 4 + min;
	} else if (ty.tag == "Array") return 4 + assumedArrayLength * bsatnBaseSize(typespace, ty.value);
	return {
		String: 4 + assumedArrayLength,
		Sum: 1,
		Bool: 1,
		I8: 1,
		U8: 1,
		I16: 2,
		U16: 2,
		I32: 4,
		U32: 4,
		F32: 4,
		I64: 8,
		U64: 8,
		F64: 8,
		I128: 16,
		U128: 16,
		I256: 32,
		U256: 32
	}[ty.tag];
}
var ConnectionId = class _ConnectionId {
	__connection_id__;
	/**
	* Creates a new `ConnectionId`.
	*/
	constructor(data) {
		this.__connection_id__ = data;
	}
	/**
	* Get the algebraic type representation of the {@link ConnectionId} type.
	* @returns The algebraic type representation of the type.
	*/
	static getAlgebraicType() {
		return AlgebraicType.Product({ elements: [{
			name: "__connection_id__",
			algebraicType: AlgebraicType.U128
		}] });
	}
	isZero() {
		return this.__connection_id__ === BigInt(0);
	}
	static nullIfZero(addr) {
		if (addr.isZero()) return null;
		else return addr;
	}
	static random() {
		function randomU8() {
			return Math.floor(Math.random() * 255);
		}
		let result = BigInt(0);
		for (let i = 0; i < 16; i++) result = result << BigInt(8) | BigInt(randomU8());
		return new _ConnectionId(result);
	}
	/**
	* Compare two connection IDs for equality.
	*/
	isEqual(other) {
		return this.__connection_id__ == other.__connection_id__;
	}
	/**
	* Check if two connection IDs are equal.
	*/
	equals(other) {
		return this.isEqual(other);
	}
	/**
	* Print the connection ID as a hexadecimal string.
	*/
	toHexString() {
		return u128ToHexString(this.__connection_id__);
	}
	/**
	* Convert the connection ID to a Uint8Array.
	*/
	toUint8Array() {
		return u128ToUint8Array(this.__connection_id__);
	}
	/**
	* Parse a connection ID from a hexadecimal string.
	*/
	static fromString(str$1) {
		return new _ConnectionId(hexStringToU128(str$1));
	}
	static fromStringOrNull(str$1) {
		const addr = _ConnectionId.fromString(str$1);
		if (addr.isZero()) return null;
		else return addr;
	}
};
var Identity = class _Identity {
	__identity__;
	/**
	* Creates a new `Identity`.
	*
	* `data` can be a hexadecimal string or a `bigint`.
	*/
	constructor(data) {
		this.__identity__ = typeof data === "string" ? hexStringToU256(data) : data;
	}
	/**
	* Get the algebraic type representation of the {@link Identity} type.
	* @returns The algebraic type representation of the type.
	*/
	static getAlgebraicType() {
		return AlgebraicType.Product({ elements: [{
			name: "__identity__",
			algebraicType: AlgebraicType.U256
		}] });
	}
	/**
	* Check if two identities are equal.
	*/
	isEqual(other) {
		return this.toHexString() === other.toHexString();
	}
	/**
	* Check if two identities are equal.
	*/
	equals(other) {
		return this.isEqual(other);
	}
	/**
	* Print the identity as a hexadecimal string.
	*/
	toHexString() {
		return u256ToHexString(this.__identity__);
	}
	/**
	* Convert the address to a Uint8Array.
	*/
	toUint8Array() {
		return u256ToUint8Array(this.__identity__);
	}
	/**
	* Parse an Identity from a hexadecimal string.
	*/
	static fromString(str$1) {
		return new _Identity(str$1);
	}
	/**
	* Zero identity (0x0000000000000000000000000000000000000000000000000000000000000000)
	*/
	static zero() {
		return new _Identity(0n);
	}
	toString() {
		return this.toHexString();
	}
};
var AlgebraicType = {
	Ref: (value) => ({
		tag: "Ref",
		value
	}),
	Sum: (value) => ({
		tag: "Sum",
		value
	}),
	Product: (value) => ({
		tag: "Product",
		value
	}),
	Array: (value) => ({
		tag: "Array",
		value
	}),
	String: { tag: "String" },
	Bool: { tag: "Bool" },
	I8: { tag: "I8" },
	U8: { tag: "U8" },
	I16: { tag: "I16" },
	U16: { tag: "U16" },
	I32: { tag: "I32" },
	U32: { tag: "U32" },
	I64: { tag: "I64" },
	U64: { tag: "U64" },
	I128: { tag: "I128" },
	U128: { tag: "U128" },
	I256: { tag: "I256" },
	U256: { tag: "U256" },
	F32: { tag: "F32" },
	F64: { tag: "F64" },
	serializeValue(writer, ty, value, typespace) {
		if (ty.tag === "Ref") {
			if (!typespace) throw new Error("cannot serialize refs without a typespace");
			while (ty.tag === "Ref") ty = typespace.types[ty.value];
		}
		switch (ty.tag) {
			case "Product":
				ProductType.serializeValue(writer, ty.value, value, typespace);
				break;
			case "Sum":
				SumType.serializeValue(writer, ty.value, value, typespace);
				break;
			case "Array":
				if (ty.value.tag === "U8") writer.writeUInt8Array(value);
				else {
					const elemType = ty.value;
					writer.writeU32(value.length);
					for (const elem of value) AlgebraicType.serializeValue(writer, elemType, elem, typespace);
				}
				break;
			case "Bool":
				writer.writeBool(value);
				break;
			case "I8":
				writer.writeI8(value);
				break;
			case "U8":
				writer.writeU8(value);
				break;
			case "I16":
				writer.writeI16(value);
				break;
			case "U16":
				writer.writeU16(value);
				break;
			case "I32":
				writer.writeI32(value);
				break;
			case "U32":
				writer.writeU32(value);
				break;
			case "I64":
				writer.writeI64(value);
				break;
			case "U64":
				writer.writeU64(value);
				break;
			case "I128":
				writer.writeI128(value);
				break;
			case "U128":
				writer.writeU128(value);
				break;
			case "I256":
				writer.writeI256(value);
				break;
			case "U256":
				writer.writeU256(value);
				break;
			case "F32":
				writer.writeF32(value);
				break;
			case "F64":
				writer.writeF64(value);
				break;
			case "String":
				writer.writeString(value);
				break;
		}
	},
	deserializeValue: function(reader, ty, typespace) {
		if (ty.tag === "Ref") {
			if (!typespace) throw new Error("cannot deserialize refs without a typespace");
			while (ty.tag === "Ref") ty = typespace.types[ty.value];
		}
		switch (ty.tag) {
			case "Product": return ProductType.deserializeValue(reader, ty.value, typespace);
			case "Sum": return SumType.deserializeValue(reader, ty.value, typespace);
			case "Array": if (ty.value.tag === "U8") return reader.readUInt8Array();
			else {
				const elemType = ty.value;
				const length = reader.readU32();
				const result = [];
				for (let i = 0; i < length; i++) result.push(AlgebraicType.deserializeValue(reader, elemType, typespace));
				return result;
			}
			case "Bool": return reader.readBool();
			case "I8": return reader.readI8();
			case "U8": return reader.readU8();
			case "I16": return reader.readI16();
			case "U16": return reader.readU16();
			case "I32": return reader.readI32();
			case "U32": return reader.readU32();
			case "I64": return reader.readI64();
			case "U64": return reader.readU64();
			case "I128": return reader.readI128();
			case "U128": return reader.readU128();
			case "I256": return reader.readI256();
			case "U256": return reader.readU256();
			case "F32": return reader.readF32();
			case "F64": return reader.readF64();
			case "String": return reader.readString();
		}
	},
	intoMapKey: function(ty, value) {
		switch (ty.tag) {
			case "U8":
			case "U16":
			case "U32":
			case "U64":
			case "U128":
			case "U256":
			case "I8":
			case "I16":
			case "I32":
			case "I64":
			case "I128":
			case "I256":
			case "F32":
			case "F64":
			case "String":
			case "Bool": return value;
			case "Product": return ProductType.intoMapKey(ty.value, value);
			default: {
				const writer = new BinaryWriter(10);
				AlgebraicType.serializeValue(writer, ty, value);
				return writer.toBase64();
			}
		}
	}
};
var ProductType = {
	serializeValue(writer, ty, value, typespace) {
		for (const element of ty.elements) AlgebraicType.serializeValue(writer, element.algebraicType, value[element.name], typespace);
	},
	deserializeValue(reader, ty, typespace) {
		const result = {};
		if (ty.elements.length === 1) {
			if (ty.elements[0].name === "__time_duration_micros__") return new TimeDuration(reader.readI64());
			if (ty.elements[0].name === "__timestamp_micros_since_unix_epoch__") return new Timestamp(reader.readI64());
			if (ty.elements[0].name === "__identity__") return new Identity(reader.readU256());
			if (ty.elements[0].name === "__connection_id__") return new ConnectionId(reader.readU128());
			if (ty.elements[0].name === "__uuid__") return new Uuid(reader.readU128());
		}
		for (const element of ty.elements) result[element.name] = AlgebraicType.deserializeValue(reader, element.algebraicType, typespace);
		return result;
	},
	intoMapKey(ty, value) {
		if (ty.elements.length === 1) {
			if (ty.elements[0].name === "__time_duration_micros__") return value.__time_duration_micros__;
			if (ty.elements[0].name === "__timestamp_micros_since_unix_epoch__") return value.__timestamp_micros_since_unix_epoch__;
			if (ty.elements[0].name === "__identity__") return value.__identity__;
			if (ty.elements[0].name === "__connection_id__") return value.__connection_id__;
			if (ty.elements[0].name === "__uuid__") return value.__uuid__;
		}
		const writer = new BinaryWriter(10);
		AlgebraicType.serializeValue(writer, AlgebraicType.Product(ty), value);
		return writer.toBase64();
	}
};
var SumType = {
	serializeValue: function(writer, ty, value, typespace) {
		if (ty.variants.length == 2 && ty.variants[0].name === "some" && ty.variants[1].name === "none") if (value !== null && value !== void 0) {
			writer.writeByte(0);
			AlgebraicType.serializeValue(writer, ty.variants[0].algebraicType, value, typespace);
		} else writer.writeByte(1);
		else if (ty.variants.length == 2 && ty.variants[0].name === "ok" && ty.variants[1].name === "err") {
			let variantName;
			let innerValue;
			let index;
			if ("ok" in value) {
				variantName = "ok";
				innerValue = value.ok;
				index = 0;
			} else {
				variantName = "err";
				innerValue = value.err;
				index = 1;
			}
			if (index < 0) throw `Result serialization error: variant '${variantName}' not found in ${JSON.stringify(ty)}`;
			writer.writeU8(index);
			AlgebraicType.serializeValue(writer, ty.variants[index].algebraicType, innerValue, typespace);
		} else {
			const variant = value["tag"];
			const index = ty.variants.findIndex((v) => v.name === variant);
			if (index < 0) throw `Can't serialize a sum type, couldn't find ${value.tag} tag ${JSON.stringify(value)} in variants ${JSON.stringify(ty)}`;
			writer.writeU8(index);
			AlgebraicType.serializeValue(writer, ty.variants[index].algebraicType, value["value"], typespace);
		}
	},
	deserializeValue: function(reader, ty, typespace) {
		const tag = reader.readU8();
		if (ty.variants.length == 2 && ty.variants[0].name === "some" && ty.variants[1].name === "none") if (tag === 0) return AlgebraicType.deserializeValue(reader, ty.variants[0].algebraicType, typespace);
		else if (tag === 1) return;
		else throw `Can't deserialize an option type, couldn't find ${tag} tag`;
		else if (ty.variants.length == 2 && ty.variants[0].name === "ok" && ty.variants[1].name === "err") if (tag === 0) return { ok: AlgebraicType.deserializeValue(reader, ty.variants[0].algebraicType, typespace) };
		else if (tag === 1) return { err: AlgebraicType.deserializeValue(reader, ty.variants[1].algebraicType, typespace) };
		else throw `Can't deserialize a result type, couldn't find ${tag} tag`;
		else {
			const variant = ty.variants[tag];
			const value = AlgebraicType.deserializeValue(reader, variant.algebraicType, typespace);
			return {
				tag: variant.name,
				value
			};
		}
	}
};
var Option = { getAlgebraicType(innerType) {
	return AlgebraicType.Sum({ variants: [{
		name: "some",
		algebraicType: innerType
	}, {
		name: "none",
		algebraicType: AlgebraicType.Product({ elements: [] })
	}] });
} };
var Result = { getAlgebraicType(okType, errType) {
	return AlgebraicType.Sum({ variants: [{
		name: "ok",
		algebraicType: okType
	}, {
		name: "err",
		algebraicType: errType
	}] });
} };
var ScheduleAt = {
	interval(value) {
		return Interval(value);
	},
	time(value) {
		return Time(value);
	},
	getAlgebraicType() {
		return AlgebraicType.Sum({ variants: [{
			name: "Interval",
			algebraicType: TimeDuration.getAlgebraicType()
		}, {
			name: "Time",
			algebraicType: Timestamp.getAlgebraicType()
		}] });
	},
	isScheduleAt(algebraicType) {
		if (algebraicType.tag !== "Sum") return false;
		const variants = algebraicType.value.variants;
		if (variants.length !== 2) return false;
		const intervalVariant = variants.find((v) => v.name === "Interval");
		const timeVariant = variants.find((v) => v.name === "Time");
		if (!intervalVariant || !timeVariant) return false;
		return TimeDuration.isTimeDuration(intervalVariant.algebraicType) && Timestamp.isTimestamp(timeVariant.algebraicType);
	}
};
var Interval = (micros) => ({
	tag: "Interval",
	value: new TimeDuration(micros)
});
var Time = (microsSinceUnixEpoch) => ({
	tag: "Time",
	value: new Timestamp(microsSinceUnixEpoch)
});
var schedule_at_default = ScheduleAt;
function set(x, t2) {
	return {
		...x,
		...t2
	};
}
var TypeBuilder = class {
	/**
	* The TypeScript phantom type. This is not stored at runtime,
	* but is visible to the compiler
	*/
	type;
	/**
	* The SpacetimeDB algebraic type (run‑time value). In addition to storing
	* the runtime representation of the `AlgebraicType`, it also captures
	* the TypeScript type information of the `AlgebraicType`. That is to say
	* the value is not merely an `AlgebraicType`, but is constructed to be
	* the corresponding concrete `AlgebraicType` for the TypeScript type `Type`.
	*
	* e.g. `string` corresponds to `AlgebraicType.String`
	*/
	algebraicType;
	constructor(algebraicType) {
		this.algebraicType = algebraicType;
	}
	optional() {
		return new OptionBuilder(this);
	}
	serialize(writer, value) {
		AlgebraicType.serializeValue(writer, this.algebraicType, value);
	}
	deserialize(reader) {
		return AlgebraicType.deserializeValue(reader, this.algebraicType);
	}
};
var U8Builder = class extends TypeBuilder {
	constructor() {
		super(AlgebraicType.U8);
	}
	index(algorithm = "btree") {
		return new U8ColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	unique() {
		return new U8ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new U8ColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new U8ColumnBuilder(this, set(defaultMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new U8ColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new U8ColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var U16Builder = class extends TypeBuilder {
	constructor() {
		super(AlgebraicType.U16);
	}
	index(algorithm = "btree") {
		return new U16ColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	unique() {
		return new U16ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new U16ColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new U16ColumnBuilder(this, set(defaultMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new U16ColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new U16ColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var U32Builder = class extends TypeBuilder {
	constructor() {
		super(AlgebraicType.U32);
	}
	index(algorithm = "btree") {
		return new U32ColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	unique() {
		return new U32ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new U32ColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new U32ColumnBuilder(this, set(defaultMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new U32ColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new U32ColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var U64Builder = class extends TypeBuilder {
	constructor() {
		super(AlgebraicType.U64);
	}
	index(algorithm = "btree") {
		return new U64ColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	unique() {
		return new U64ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new U64ColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new U64ColumnBuilder(this, set(defaultMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new U64ColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new U64ColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var U128Builder = class extends TypeBuilder {
	constructor() {
		super(AlgebraicType.U128);
	}
	index(algorithm = "btree") {
		return new U128ColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	unique() {
		return new U128ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new U128ColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new U128ColumnBuilder(this, set(defaultMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new U128ColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new U128ColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var U256Builder = class extends TypeBuilder {
	constructor() {
		super(AlgebraicType.U256);
	}
	index(algorithm = "btree") {
		return new U256ColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	unique() {
		return new U256ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new U256ColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new U256ColumnBuilder(this, set(defaultMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new U256ColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new U256ColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var I8Builder = class extends TypeBuilder {
	constructor() {
		super(AlgebraicType.I8);
	}
	index(algorithm = "btree") {
		return new I8ColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	unique() {
		return new I8ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new I8ColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new I8ColumnBuilder(this, set(defaultMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new I8ColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new I8ColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var I16Builder = class extends TypeBuilder {
	constructor() {
		super(AlgebraicType.I16);
	}
	index(algorithm = "btree") {
		return new I16ColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	unique() {
		return new I16ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new I16ColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new I16ColumnBuilder(this, set(defaultMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new I16ColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new I16ColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var I32Builder = class extends TypeBuilder {
	constructor() {
		super(AlgebraicType.I32);
	}
	index(algorithm = "btree") {
		return new I32ColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	unique() {
		return new I32ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new I32ColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new I32ColumnBuilder(this, set(defaultMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new I32ColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new I32ColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var I64Builder = class extends TypeBuilder {
	constructor() {
		super(AlgebraicType.I64);
	}
	index(algorithm = "btree") {
		return new I64ColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	unique() {
		return new I64ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new I64ColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new I64ColumnBuilder(this, set(defaultMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new I64ColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new I64ColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var I128Builder = class extends TypeBuilder {
	constructor() {
		super(AlgebraicType.I128);
	}
	index(algorithm = "btree") {
		return new I128ColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	unique() {
		return new I128ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new I128ColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new I128ColumnBuilder(this, set(defaultMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new I128ColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new I128ColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var I256Builder = class extends TypeBuilder {
	constructor() {
		super(AlgebraicType.I256);
	}
	index(algorithm = "btree") {
		return new I256ColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	unique() {
		return new I256ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new I256ColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new I256ColumnBuilder(this, set(defaultMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new I256ColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new I256ColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var F32Builder = class extends TypeBuilder {
	constructor() {
		super(AlgebraicType.F32);
	}
	default(value) {
		return new F32ColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new F32ColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var F64Builder = class extends TypeBuilder {
	constructor() {
		super(AlgebraicType.F64);
	}
	default(value) {
		return new F64ColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new F64ColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var BoolBuilder = class extends TypeBuilder {
	constructor() {
		super(AlgebraicType.Bool);
	}
	index(algorithm = "btree") {
		return new BoolColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	unique() {
		return new BoolColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new BoolColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
	default(value) {
		return new BoolColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new BoolColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var StringBuilder = class extends TypeBuilder {
	constructor() {
		super(AlgebraicType.String);
	}
	index(algorithm = "btree") {
		return new StringColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	unique() {
		return new StringColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new StringColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
	default(value) {
		return new StringColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new StringColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var ArrayBuilder = class extends TypeBuilder {
	element;
	constructor(element) {
		super(AlgebraicType.Array(element.algebraicType));
		this.element = element;
	}
	default(value) {
		return new ArrayColumnBuilder(this.element, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new ArrayColumnBuilder(this.element, set(defaultMetadata, { name }));
	}
};
var ByteArrayBuilder = class extends TypeBuilder {
	constructor() {
		super(AlgebraicType.Array(AlgebraicType.U8));
	}
	default(value) {
		return new ByteArrayColumnBuilder(set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new ByteArrayColumnBuilder(set(defaultMetadata, { name }));
	}
};
var OptionBuilder = class extends TypeBuilder {
	value;
	constructor(value) {
		super(Option.getAlgebraicType(value.algebraicType));
		this.value = value;
	}
	default(value) {
		return new OptionColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new OptionColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var ProductBuilder = class extends TypeBuilder {
	typeName;
	elements;
	constructor(elements, name) {
		function elementsArrayFromElementsObj(obj) {
			return Object.keys(obj).map((key) => ({
				name: key,
				get algebraicType() {
					return obj[key].algebraicType;
				}
			}));
		}
		super(AlgebraicType.Product({ elements: elementsArrayFromElementsObj(elements) }));
		this.typeName = name;
		this.elements = elements;
	}
	default(value) {
		return new ProductColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new ProductColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var ResultBuilder = class extends TypeBuilder {
	ok;
	err;
	constructor(ok, err) {
		super(Result.getAlgebraicType(ok.algebraicType, err.algebraicType));
		this.ok = ok;
		this.err = err;
	}
	default(value) {
		return new ResultColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
};
var UnitBuilder = class extends TypeBuilder {
	constructor() {
		super({
			tag: "Product",
			value: { elements: [] }
		});
	}
};
var RowBuilder = class extends TypeBuilder {
	row;
	typeName;
	constructor(row, name) {
		const mappedRow = Object.fromEntries(Object.entries(row).map(([colName, builder]) => [colName, builder instanceof ColumnBuilder ? builder : new ColumnBuilder(builder, {})]));
		const elements = Object.keys(mappedRow).map((name2) => ({
			name: name2,
			get algebraicType() {
				return mappedRow[name2].typeBuilder.algebraicType;
			}
		}));
		super(AlgebraicType.Product({ elements }));
		this.row = mappedRow;
		this.typeName = name;
	}
};
var SumBuilderImpl = class extends TypeBuilder {
	variants;
	typeName;
	constructor(variants, name) {
		function variantsArrayFromVariantsObj(variants2) {
			return Object.keys(variants2).map((key) => ({
				name: key,
				get algebraicType() {
					return variants2[key].algebraicType;
				}
			}));
		}
		super(AlgebraicType.Sum({ variants: variantsArrayFromVariantsObj(variants) }));
		this.variants = variants;
		this.typeName = name;
		for (const key of Object.keys(variants)) {
			const desc = Object.getOwnPropertyDescriptor(variants, key);
			const isAccessor = !!desc && (typeof desc.get === "function" || typeof desc.set === "function");
			let isUnit2 = false;
			if (!isAccessor) isUnit2 = variants[key] instanceof UnitBuilder;
			if (isUnit2) {
				const constant = this.create(key);
				Object.defineProperty(this, key, {
					value: constant,
					writable: false,
					enumerable: true,
					configurable: false
				});
			} else {
				const fn = ((value) => this.create(key, value));
				Object.defineProperty(this, key, {
					value: fn,
					writable: false,
					enumerable: true,
					configurable: false
				});
			}
		}
	}
	create(tag, value) {
		return value === void 0 ? { tag } : {
			tag,
			value
		};
	}
	default(value) {
		return new SumColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new SumColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var SumBuilder = SumBuilderImpl;
var SimpleSumBuilderImpl = class extends SumBuilderImpl {
	index(algorithm = "btree") {
		return new SimpleSumColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	primaryKey() {
		return new SimpleSumColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
};
var ScheduleAtBuilder = class extends TypeBuilder {
	constructor() {
		super(schedule_at_default.getAlgebraicType());
	}
	default(value) {
		return new ScheduleAtColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new ScheduleAtColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var IdentityBuilder = class extends TypeBuilder {
	constructor() {
		super(Identity.getAlgebraicType());
	}
	index(algorithm = "btree") {
		return new IdentityColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	unique() {
		return new IdentityColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new IdentityColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new IdentityColumnBuilder(this, set(defaultMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new IdentityColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new IdentityColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var ConnectionIdBuilder = class extends TypeBuilder {
	constructor() {
		super(ConnectionId.getAlgebraicType());
	}
	index(algorithm = "btree") {
		return new ConnectionIdColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	unique() {
		return new ConnectionIdColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new ConnectionIdColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new ConnectionIdColumnBuilder(this, set(defaultMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new ConnectionIdColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new ConnectionIdColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var TimestampBuilder = class extends TypeBuilder {
	constructor() {
		super(Timestamp.getAlgebraicType());
	}
	index(algorithm = "btree") {
		return new TimestampColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	unique() {
		return new TimestampColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new TimestampColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new TimestampColumnBuilder(this, set(defaultMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new TimestampColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new TimestampColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var TimeDurationBuilder = class extends TypeBuilder {
	constructor() {
		super(TimeDuration.getAlgebraicType());
	}
	index(algorithm = "btree") {
		return new TimeDurationColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	unique() {
		return new TimeDurationColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new TimeDurationColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new TimeDurationColumnBuilder(this, set(defaultMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new TimeDurationColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new TimeDurationColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var UuidBuilder = class extends TypeBuilder {
	constructor() {
		super(Uuid.getAlgebraicType());
	}
	index(algorithm = "btree") {
		return new UuidColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	unique() {
		return new UuidColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new UuidColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new UuidColumnBuilder(this, set(defaultMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new UuidColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
};
var defaultMetadata = {};
var ColumnBuilder = class {
	typeBuilder;
	columnMetadata;
	constructor(typeBuilder, metadata) {
		this.typeBuilder = typeBuilder;
		this.columnMetadata = metadata;
	}
	serialize(writer, value) {
		AlgebraicType.serializeValue(writer, this.typeBuilder.algebraicType, value);
	}
	deserialize(reader) {
		return AlgebraicType.deserializeValue(reader, this.typeBuilder.algebraicType);
	}
};
var U8ColumnBuilder = class _U8ColumnBuilder extends ColumnBuilder {
	index(algorithm = "btree") {
		return new _U8ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	unique() {
		return new _U8ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new _U8ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new _U8ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new _U8ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _U8ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var U16ColumnBuilder = class _U16ColumnBuilder extends ColumnBuilder {
	index(algorithm = "btree") {
		return new _U16ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	unique() {
		return new _U16ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new _U16ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new _U16ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new _U16ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _U16ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var U32ColumnBuilder = class _U32ColumnBuilder extends ColumnBuilder {
	index(algorithm = "btree") {
		return new _U32ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	unique() {
		return new _U32ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new _U32ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new _U32ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new _U32ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _U32ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var U64ColumnBuilder = class _U64ColumnBuilder extends ColumnBuilder {
	index(algorithm = "btree") {
		return new _U64ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	unique() {
		return new _U64ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new _U64ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new _U64ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new _U64ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _U64ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var U128ColumnBuilder = class _U128ColumnBuilder extends ColumnBuilder {
	index(algorithm = "btree") {
		return new _U128ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	unique() {
		return new _U128ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new _U128ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new _U128ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new _U128ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _U128ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var U256ColumnBuilder = class _U256ColumnBuilder extends ColumnBuilder {
	index(algorithm = "btree") {
		return new _U256ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	unique() {
		return new _U256ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new _U256ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new _U256ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new _U256ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _U256ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var I8ColumnBuilder = class _I8ColumnBuilder extends ColumnBuilder {
	index(algorithm = "btree") {
		return new _I8ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	unique() {
		return new _I8ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new _I8ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new _I8ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new _I8ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _I8ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var I16ColumnBuilder = class _I16ColumnBuilder extends ColumnBuilder {
	index(algorithm = "btree") {
		return new _I16ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	unique() {
		return new _I16ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new _I16ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new _I16ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new _I16ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _I16ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var I32ColumnBuilder = class _I32ColumnBuilder extends ColumnBuilder {
	index(algorithm = "btree") {
		return new _I32ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	unique() {
		return new _I32ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new _I32ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new _I32ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new _I32ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _I32ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var I64ColumnBuilder = class _I64ColumnBuilder extends ColumnBuilder {
	index(algorithm = "btree") {
		return new _I64ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	unique() {
		return new _I64ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new _I64ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new _I64ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new _I64ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _I64ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var I128ColumnBuilder = class _I128ColumnBuilder extends ColumnBuilder {
	index(algorithm = "btree") {
		return new _I128ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	unique() {
		return new _I128ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new _I128ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new _I128ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new _I128ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _I128ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var I256ColumnBuilder = class _I256ColumnBuilder extends ColumnBuilder {
	index(algorithm = "btree") {
		return new _I256ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	unique() {
		return new _I256ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new _I256ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new _I256ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new _I256ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _I256ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var F32ColumnBuilder = class _F32ColumnBuilder extends ColumnBuilder {
	default(value) {
		return new _F32ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _F32ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var F64ColumnBuilder = class _F64ColumnBuilder extends ColumnBuilder {
	default(value) {
		return new _F64ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _F64ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var BoolColumnBuilder = class _BoolColumnBuilder extends ColumnBuilder {
	index(algorithm = "btree") {
		return new _BoolColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	unique() {
		return new _BoolColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new _BoolColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
	default(value) {
		return new _BoolColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _BoolColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var StringColumnBuilder = class _StringColumnBuilder extends ColumnBuilder {
	index(algorithm = "btree") {
		return new _StringColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	unique() {
		return new _StringColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new _StringColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
	default(value) {
		return new _StringColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _StringColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var ArrayColumnBuilder = class _ArrayColumnBuilder extends ColumnBuilder {
	default(value) {
		return new _ArrayColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _ArrayColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var ByteArrayColumnBuilder = class _ByteArrayColumnBuilder extends ColumnBuilder {
	constructor(metadata) {
		super(new TypeBuilder(AlgebraicType.Array(AlgebraicType.U8)), metadata);
	}
	default(value) {
		return new _ByteArrayColumnBuilder(set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _ByteArrayColumnBuilder(set(this.columnMetadata, { name }));
	}
};
var OptionColumnBuilder = class _OptionColumnBuilder extends ColumnBuilder {
	default(value) {
		return new _OptionColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _OptionColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var ResultColumnBuilder = class _ResultColumnBuilder extends ColumnBuilder {
	constructor(typeBuilder, metadata) {
		super(typeBuilder, metadata);
	}
	default(value) {
		return new _ResultColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
};
var ProductColumnBuilder = class _ProductColumnBuilder extends ColumnBuilder {
	default(value) {
		return new _ProductColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _ProductColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var SumColumnBuilder = class _SumColumnBuilder extends ColumnBuilder {
	default(value) {
		return new _SumColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _SumColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var SimpleSumColumnBuilder = class _SimpleSumColumnBuilder extends SumColumnBuilder {
	index(algorithm = "btree") {
		return new _SimpleSumColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	primaryKey() {
		return new _SimpleSumColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
};
var ScheduleAtColumnBuilder = class _ScheduleAtColumnBuilder extends ColumnBuilder {
	default(value) {
		return new _ScheduleAtColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _ScheduleAtColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var IdentityColumnBuilder = class _IdentityColumnBuilder extends ColumnBuilder {
	index(algorithm = "btree") {
		return new _IdentityColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	unique() {
		return new _IdentityColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new _IdentityColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
	default(value) {
		return new _IdentityColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _IdentityColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var ConnectionIdColumnBuilder = class _ConnectionIdColumnBuilder extends ColumnBuilder {
	index(algorithm = "btree") {
		return new _ConnectionIdColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	unique() {
		return new _ConnectionIdColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new _ConnectionIdColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
	default(value) {
		return new _ConnectionIdColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _ConnectionIdColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var TimestampColumnBuilder = class _TimestampColumnBuilder extends ColumnBuilder {
	index(algorithm = "btree") {
		return new _TimestampColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	unique() {
		return new _TimestampColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new _TimestampColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
	default(value) {
		return new _TimestampColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _TimestampColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var TimeDurationColumnBuilder = class _TimeDurationColumnBuilder extends ColumnBuilder {
	index(algorithm = "btree") {
		return new _TimeDurationColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	unique() {
		return new _TimeDurationColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new _TimeDurationColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
	default(value) {
		return new _TimeDurationColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _TimeDurationColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var UuidColumnBuilder = class _UuidColumnBuilder extends ColumnBuilder {
	index(algorithm = "btree") {
		return new _UuidColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	unique() {
		return new _UuidColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new _UuidColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
	default(value) {
		return new _UuidColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
};
var RefBuilder = class extends TypeBuilder {
	ref;
	/** The phantom type of the pointee of this ref. */
	__spacetimeType;
	constructor(ref) {
		super(AlgebraicType.Ref(ref));
		this.ref = ref;
	}
};
var enumImpl = ((nameOrObj, maybeObj) => {
	let obj = nameOrObj;
	let name = void 0;
	if (typeof nameOrObj === "string") {
		if (!maybeObj) throw new TypeError("When providing a name, you must also provide the variants object or array.");
		obj = maybeObj;
		name = nameOrObj;
	}
	if (Array.isArray(obj)) {
		const simpleVariantsObj = {};
		for (const variant of obj) simpleVariantsObj[variant] = new UnitBuilder();
		return new SimpleSumBuilderImpl(simpleVariantsObj, name);
	}
	return new SumBuilder(obj, name);
});
var t = {
	bool: () => new BoolBuilder(),
	string: () => new StringBuilder(),
	number: () => new F64Builder(),
	i8: () => new I8Builder(),
	u8: () => new U8Builder(),
	i16: () => new I16Builder(),
	u16: () => new U16Builder(),
	i32: () => new I32Builder(),
	u32: () => new U32Builder(),
	i64: () => new I64Builder(),
	u64: () => new U64Builder(),
	i128: () => new I128Builder(),
	u128: () => new U128Builder(),
	i256: () => new I256Builder(),
	u256: () => new U256Builder(),
	f32: () => new F32Builder(),
	f64: () => new F64Builder(),
	object: ((nameOrObj, maybeObj) => {
		if (typeof nameOrObj === "string") {
			if (!maybeObj) throw new TypeError("When providing a name, you must also provide the object.");
			return new ProductBuilder(maybeObj, nameOrObj);
		}
		return new ProductBuilder(nameOrObj, void 0);
	}),
	row: ((nameOrObj, maybeObj) => {
		const [obj, name] = typeof nameOrObj === "string" ? [maybeObj, nameOrObj] : [nameOrObj, void 0];
		return new RowBuilder(obj, name);
	}),
	array(e) {
		return new ArrayBuilder(e);
	},
	enum: enumImpl,
	unit() {
		return new UnitBuilder();
	},
	lazy(thunk) {
		let cached = null;
		const get = () => cached ??= thunk();
		return new Proxy({}, {
			get(_t, prop, recv) {
				const target = get();
				const val = Reflect.get(target, prop, recv);
				return typeof val === "function" ? val.bind(target) : val;
			},
			set(_t, prop, value, recv) {
				return Reflect.set(get(), prop, value, recv);
			},
			has(_t, prop) {
				return prop in get();
			},
			ownKeys() {
				return Reflect.ownKeys(get());
			},
			getOwnPropertyDescriptor(_t, prop) {
				return Object.getOwnPropertyDescriptor(get(), prop);
			},
			getPrototypeOf() {
				return Object.getPrototypeOf(get());
			}
		});
	},
	scheduleAt: () => {
		return new ScheduleAtBuilder();
	},
	option(value) {
		return new OptionBuilder(value);
	},
	result(ok, err) {
		return new ResultBuilder(ok, err);
	},
	identity: () => {
		return new IdentityBuilder();
	},
	connectionId: () => {
		return new ConnectionIdBuilder();
	},
	timestamp: () => {
		return new TimestampBuilder();
	},
	timeDuration: () => {
		return new TimeDurationBuilder();
	},
	uuid: () => {
		return new UuidBuilder();
	},
	byteArray: () => {
		return new ByteArrayBuilder();
	}
};
var lifecycle_type_default = t.enum("Lifecycle", {
	Init: t.unit(),
	OnConnect: t.unit(),
	OnDisconnect: t.unit()
});
function pushReducer(name, params, fn, lifecycle) {
	if (existingReducers.has(name)) throw new TypeError(`There is already a reducer with the name '${name}'`);
	existingReducers.add(name);
	if (!(params instanceof RowBuilder)) params = new RowBuilder(params);
	if (params.typeName === void 0) params.typeName = toPascalCase(name);
	const ref = registerTypesRecursively(params);
	const paramsType = resolveType(MODULE_DEF.typespace, ref).value;
	MODULE_DEF.reducers.push({
		name,
		params: paramsType,
		lifecycle
	});
	if (!fn.name) Object.defineProperty(fn, "name", {
		value: name,
		writable: false
	});
	REDUCERS.push(fn);
}
var existingReducers = /* @__PURE__ */ new Set();
var REDUCERS = [];
function reducer(name, params, fn) {
	pushReducer(name, params, fn);
}
function init(name, params, fn) {
	pushReducer(name, params, fn, lifecycle_type_default.Init);
}
function clientConnected(name, params, fn) {
	pushReducer(name, params, fn, lifecycle_type_default.OnConnect);
}
function clientDisconnected(name, params, fn) {
	pushReducer(name, params, fn, lifecycle_type_default.OnDisconnect);
}
var QueryBrand = Symbol("QueryBrand");
var isRowTypedQuery = (val) => !!val && typeof val === "object" && QueryBrand in val;
function toSql(q) {
	return q.toSql();
}
var SemijoinImpl = class _SemijoinImpl {
	constructor(sourceQuery, filterQuery, joinCondition) {
		this.sourceQuery = sourceQuery;
		this.filterQuery = filterQuery;
		this.joinCondition = joinCondition;
		if (sourceQuery.table.name === filterQuery.table.name) throw new Error("Cannot semijoin a table to itself");
	}
	[QueryBrand] = true;
	type = "semijoin";
	build() {
		return this;
	}
	where(predicate) {
		return new _SemijoinImpl(this.sourceQuery.where(predicate), this.filterQuery, this.joinCondition);
	}
	toSql() {
		const left = this.filterQuery;
		const right = this.sourceQuery;
		const leftTable = quoteIdentifier(left.table.name);
		const rightTable = quoteIdentifier(right.table.name);
		let sql = `SELECT ${rightTable}.* FROM ${leftTable} JOIN ${rightTable} ON ${booleanExprToSql(this.joinCondition)}`;
		const clauses = [];
		if (left.whereClause) clauses.push(booleanExprToSql(left.whereClause));
		if (right.whereClause) clauses.push(booleanExprToSql(right.whereClause));
		if (clauses.length > 0) {
			const whereSql = clauses.length === 1 ? clauses[0] : clauses.map(wrapInParens).join(" AND ");
			sql += ` WHERE ${whereSql}`;
		}
		return sql;
	}
};
var FromBuilder = class _FromBuilder {
	constructor(table2, whereClause) {
		this.table = table2;
		this.whereClause = whereClause;
	}
	[QueryBrand] = true;
	where(predicate) {
		const newCondition = predicate(this.table.cols);
		const nextWhere = this.whereClause ? and$1(this.whereClause, newCondition) : newCondition;
		return new _FromBuilder(this.table, nextWhere);
	}
	rightSemijoin(right, on) {
		const sourceQuery = new _FromBuilder(right);
		const joinCondition = on(this.table.indexedCols, right.indexedCols);
		return new SemijoinImpl(sourceQuery, this, joinCondition);
	}
	leftSemijoin(right, on) {
		const filterQuery = new _FromBuilder(right);
		const joinCondition = on(this.table.indexedCols, right.indexedCols);
		return new SemijoinImpl(this, filterQuery, joinCondition);
	}
	toSql() {
		return renderSelectSqlWithJoins(this.table, this.whereClause);
	}
	build() {
		return this;
	}
};
var TableRefImpl = class {
	type = "table";
	name;
	cols;
	indexedCols;
	tableDef;
	constructor(tableDef) {
		this.name = tableDef.name;
		this.cols = createRowExpr(tableDef);
		this.indexedCols = this.cols;
		this.tableDef = tableDef;
		Object.freeze(this);
	}
	asFrom() {
		return new FromBuilder(this);
	}
	rightSemijoin(other, on) {
		return this.asFrom().rightSemijoin(other, on);
	}
	leftSemijoin(other, on) {
		return this.asFrom().leftSemijoin(other, on);
	}
	build() {
		return this.asFrom().build();
	}
	toSql() {
		return this.asFrom().toSql();
	}
	where(predicate) {
		return this.asFrom().where(predicate);
	}
};
function createTableRefFromDef(tableDef) {
	return new TableRefImpl(tableDef);
}
function makeQueryBuilder(schema2) {
	const qb = /* @__PURE__ */ Object.create(null);
	for (const table2 of schema2.tables) {
		const ref = createTableRefFromDef(table2);
		qb[table2.name] = ref;
	}
	return Object.freeze(qb);
}
function createRowExpr(tableDef) {
	const row = {};
	for (const columnName of Object.keys(tableDef.columns)) {
		const columnBuilder = tableDef.columns[columnName];
		const column = new ColumnExpression(tableDef.name, columnName, columnBuilder.typeBuilder.algebraicType);
		row[columnName] = Object.freeze(column);
	}
	return Object.freeze(row);
}
function renderSelectSqlWithJoins(table2, where, extraClauses = []) {
	const sql = `SELECT * FROM ${quoteIdentifier(table2.name)}`;
	const clauses = [];
	if (where) clauses.push(booleanExprToSql(where));
	clauses.push(...extraClauses);
	if (clauses.length === 0) return sql;
	return `${sql} WHERE ${clauses.length === 1 ? clauses[0] : clauses.map(wrapInParens).join(" AND ")}`;
}
var ColumnExpression = class {
	type = "column";
	column;
	table;
	tsValueType;
	spacetimeType;
	constructor(table2, column, spacetimeType) {
		this.table = table2;
		this.column = column;
		this.spacetimeType = spacetimeType;
	}
	eq(x) {
		return {
			type: "eq",
			left: this,
			right: normalizeValue(x)
		};
	}
	lt(x) {
		return {
			type: "lt",
			left: this,
			right: normalizeValue(x)
		};
	}
	lte(x) {
		return {
			type: "lte",
			left: this,
			right: normalizeValue(x)
		};
	}
	gt(x) {
		return {
			type: "gt",
			left: this,
			right: normalizeValue(x)
		};
	}
	gte(x) {
		return {
			type: "gte",
			left: this,
			right: normalizeValue(x)
		};
	}
};
function literal(value) {
	return {
		type: "literal",
		value
	};
}
function normalizeValue(val) {
	if (val.type === "literal") return val;
	if (typeof val === "object" && val != null && "type" in val && val.type === "column") return val;
	return literal(val);
}
function and$1(...clauses) {
	return {
		type: "and",
		clauses
	};
}
function booleanExprToSql(expr, tableAlias) {
	switch (expr.type) {
		case "eq": return `${valueExprToSql(expr.left)} = ${valueExprToSql(expr.right)}`;
		case "ne": return `${valueExprToSql(expr.left)} <> ${valueExprToSql(expr.right)}`;
		case "gt": return `${valueExprToSql(expr.left)} > ${valueExprToSql(expr.right)}`;
		case "gte": return `${valueExprToSql(expr.left)} >= ${valueExprToSql(expr.right)}`;
		case "lt": return `${valueExprToSql(expr.left)} < ${valueExprToSql(expr.right)}`;
		case "lte": return `${valueExprToSql(expr.left)} <= ${valueExprToSql(expr.right)}`;
		case "and": return expr.clauses.map((c) => booleanExprToSql(c)).map(wrapInParens).join(" AND ");
		case "or": return expr.clauses.map((c) => booleanExprToSql(c)).map(wrapInParens).join(" OR ");
		case "not": return `NOT ${wrapInParens(booleanExprToSql(expr.clause))}`;
	}
}
function wrapInParens(sql) {
	return `(${sql})`;
}
function valueExprToSql(expr, tableAlias) {
	if (isLiteralExpr(expr)) return literalValueToSql(expr.value);
	const table2 = expr.table;
	return `${quoteIdentifier(table2)}.${quoteIdentifier(expr.column)}`;
}
function literalValueToSql(value) {
	if (value === null || value === void 0) return "NULL";
	if (value instanceof Identity || value instanceof ConnectionId) return `0x${value.toHexString()}`;
	switch (typeof value) {
		case "number":
		case "bigint": return String(value);
		case "boolean": return value ? "TRUE" : "FALSE";
		case "string": return `'${value.replace(/'/g, "''")}'`;
		default: return `'${JSON.stringify(value).replace(/'/g, "''")}'`;
	}
}
function quoteIdentifier(name) {
	return `"${name.replace(/"/g, "\"\"")}"`;
}
function isLiteralExpr(expr) {
	return expr.type === "literal";
}
function defineView(opts, anon, params, ret, fn) {
	const paramsBuilder = new RowBuilder(params, toPascalCase(opts.name));
	let returnType = registerTypesRecursively(ret).algebraicType;
	const { value: paramType } = resolveType(MODULE_DEF.typespace, registerTypesRecursively(paramsBuilder));
	MODULE_DEF.miscExports.push({
		tag: "View",
		value: {
			name: opts.name,
			index: (anon ? ANON_VIEWS : VIEWS).length,
			isPublic: opts.public,
			isAnonymous: anon,
			params: paramType,
			returnType
		}
	});
	if (returnType.tag == "Sum") {
		const originalFn = fn;
		fn = ((ctx, args) => {
			const ret2 = originalFn(ctx, args);
			return ret2 == null ? [] : [ret2];
		});
		returnType = AlgebraicType.Array(returnType.value.variants[0].algebraicType);
	}
	(anon ? ANON_VIEWS : VIEWS).push({
		fn,
		params: paramType,
		returnType,
		returnTypeBaseSize: bsatnBaseSize(MODULE_DEF.typespace, returnType)
	});
}
var VIEWS = [];
var ANON_VIEWS = [];
function procedure(name, params, ret, fn) {
	const paramsType = { elements: Object.entries(params).map(([n, c]) => ({
		name: n,
		algebraicType: registerTypesRecursively("typeBuilder" in c ? c.typeBuilder : c).algebraicType
	})) };
	const returnType = registerTypesRecursively(ret).algebraicType;
	MODULE_DEF.miscExports.push({
		tag: "Procedure",
		value: {
			name,
			params: paramsType,
			returnType
		}
	});
	PROCEDURES.push({
		fn,
		paramsType,
		returnType,
		returnTypeBaseSize: bsatnBaseSize(MODULE_DEF.typespace, returnType)
	});
}
var PROCEDURES = [];
var REGISTERED_SCHEMA = null;
function getRegisteredSchema() {
	if (REGISTERED_SCHEMA == null) throw new Error("Schema has not been registered yet. Call schema() first.");
	return REGISTERED_SCHEMA;
}
function tablesToSchema(tables) {
	return { tables: tables.map(tableToSchema) };
}
function tableToSchema(schema2) {
	const getColName = (i) => schema2.rowType.algebraicType.value.elements[i].name;
	return {
		name: schema2.tableName,
		accessorName: toCamelCase(schema2.tableName),
		columns: schema2.rowType.row,
		rowType: schema2.rowSpacetimeType,
		constraints: schema2.tableDef.constraints.map((c) => ({
			name: c.name,
			constraint: "unique",
			columns: c.data.value.columns.map(getColName)
		})),
		indexes: schema2.tableDef.indexes.map((idx) => {
			const columnIds = idx.algorithm.tag === "Direct" ? [idx.algorithm.value] : idx.algorithm.value;
			return {
				name: idx.accessorName,
				unique: schema2.tableDef.constraints.some((c) => c.data.value.columns.every((col) => columnIds.includes(col))),
				algorithm: idx.algorithm.tag.toLowerCase(),
				columns: columnIds.map(getColName)
			};
		})
	};
}
var MODULE_DEF = {
	typespace: { types: [] },
	tables: [],
	reducers: [],
	types: [],
	miscExports: [],
	rowLevelSecurity: []
};
var COMPOUND_TYPES = /* @__PURE__ */ new Map();
function resolveType(typespace, typeBuilder) {
	let ty = typeBuilder.algebraicType;
	while (ty.tag === "Ref") ty = typespace.types[ty.value];
	return ty;
}
function registerTypesRecursively(typeBuilder) {
	if (typeBuilder instanceof ProductBuilder && !isUnit(typeBuilder) || typeBuilder instanceof SumBuilder || typeBuilder instanceof RowBuilder) return registerCompoundTypeRecursively(typeBuilder);
	else if (typeBuilder instanceof OptionBuilder) return new OptionBuilder(registerTypesRecursively(typeBuilder.value));
	else if (typeBuilder instanceof ResultBuilder) return new ResultBuilder(registerTypesRecursively(typeBuilder.ok), registerTypesRecursively(typeBuilder.err));
	else if (typeBuilder instanceof ArrayBuilder) return new ArrayBuilder(registerTypesRecursively(typeBuilder.element));
	else return typeBuilder;
}
function registerCompoundTypeRecursively(typeBuilder) {
	const ty = typeBuilder.algebraicType;
	const name = typeBuilder.typeName;
	if (name === void 0) throw new Error(`Missing type name for ${typeBuilder.constructor.name ?? "TypeBuilder"} ${JSON.stringify(typeBuilder)}`);
	let r = COMPOUND_TYPES.get(ty);
	if (r != null) return r;
	const newTy = typeBuilder instanceof RowBuilder || typeBuilder instanceof ProductBuilder ? {
		tag: "Product",
		value: { elements: [] }
	} : {
		tag: "Sum",
		value: { variants: [] }
	};
	r = new RefBuilder(MODULE_DEF.typespace.types.length);
	MODULE_DEF.typespace.types.push(newTy);
	COMPOUND_TYPES.set(ty, r);
	if (typeBuilder instanceof RowBuilder) for (const [name2, elem] of Object.entries(typeBuilder.row)) newTy.value.elements.push({
		name: name2,
		algebraicType: registerTypesRecursively(elem.typeBuilder).algebraicType
	});
	else if (typeBuilder instanceof ProductBuilder) for (const [name2, elem] of Object.entries(typeBuilder.elements)) newTy.value.elements.push({
		name: name2,
		algebraicType: registerTypesRecursively(elem).algebraicType
	});
	else if (typeBuilder instanceof SumBuilder) for (const [name2, variant] of Object.entries(typeBuilder.variants)) newTy.value.variants.push({
		name: name2,
		algebraicType: registerTypesRecursively(variant).algebraicType
	});
	MODULE_DEF.types.push({
		name: splitName(name),
		ty: r.ref,
		customOrdering: true
	});
	return r;
}
function isUnit(typeBuilder) {
	return typeBuilder.typeName == null && typeBuilder.algebraicType.value.elements.length === 0;
}
function splitName(name) {
	const scope = name.split(".");
	return {
		name: scope.pop(),
		scope
	};
}
var Schema = class {
	tablesDef;
	typespace;
	schemaType;
	constructor(tables, typespace, handles) {
		this.tablesDef = { tables };
		this.typespace = typespace;
		this.schemaType = tablesToSchema(handles);
	}
	reducer(name, paramsOrFn, fn) {
		if (typeof paramsOrFn === "function") {
			reducer(name, {}, paramsOrFn);
			return paramsOrFn;
		} else {
			reducer(name, paramsOrFn, fn);
			return fn;
		}
	}
	init(nameOrFn, maybeFn) {
		const [name, fn] = typeof nameOrFn === "string" ? [nameOrFn, maybeFn] : ["init", nameOrFn];
		init(name, {}, fn);
	}
	clientConnected(nameOrFn, maybeFn) {
		const [name, fn] = typeof nameOrFn === "string" ? [nameOrFn, maybeFn] : ["on_connect", nameOrFn];
		clientConnected(name, {}, fn);
	}
	clientDisconnected(nameOrFn, maybeFn) {
		const [name, fn] = typeof nameOrFn === "string" ? [nameOrFn, maybeFn] : ["on_disconnect", nameOrFn];
		clientDisconnected(name, {}, fn);
	}
	view(opts, ret, fn) {
		defineView(opts, false, {}, ret, fn);
	}
	anonymousView(opts, ret, fn) {
		defineView(opts, true, {}, ret, fn);
	}
	procedure(name, paramsOrRet, retOrFn, maybeFn) {
		if (typeof retOrFn === "function") {
			procedure(name, {}, paramsOrRet, retOrFn);
			return retOrFn;
		} else {
			procedure(name, paramsOrRet, retOrFn, maybeFn);
			return maybeFn;
		}
	}
	clientVisibilityFilter = { sql(filter) {
		MODULE_DEF.rowLevelSecurity.push({ sql: filter });
	} };
};
function schema(...args) {
	const handles = args.length === 1 && Array.isArray(args[0]) ? args[0] : args;
	const tableDefs = handles.map((h) => h.tableDef);
	MODULE_DEF.tables.push(...tableDefs);
	REGISTERED_SCHEMA = { tables: handles.map((handle) => ({
		name: handle.tableName,
		accessorName: handle.tableName,
		columns: handle.rowType.row,
		rowType: handle.rowSpacetimeType,
		indexes: handle.idxs,
		constraints: handle.constraints
	})) };
	return new Schema(tableDefs, MODULE_DEF.typespace, handles);
}
var raw_index_algorithm_type_default = t.enum("RawIndexAlgorithm", {
	BTree: t.array(t.u16()),
	Hash: t.array(t.u16()),
	Direct: t.u16()
});
function table(opts, row) {
	const { name, public: isPublic = false, indexes: userIndexes = [], scheduled } = opts;
	const colIds = /* @__PURE__ */ new Map();
	const colNameList = [];
	if (!(row instanceof RowBuilder)) row = new RowBuilder(row);
	if (row.typeName === void 0) row.typeName = toPascalCase(name);
	const rowTypeRef = registerTypesRecursively(row);
	row.algebraicType.value.elements.forEach((elem, i) => {
		colIds.set(elem.name, i);
		colNameList.push(elem.name);
	});
	const pk = [];
	const indexes = [];
	const constraints = [];
	const sequences = [];
	let scheduleAtCol;
	for (const [name2, builder] of Object.entries(row.row)) {
		const meta = builder.columnMetadata;
		if (meta.isPrimaryKey) pk.push(colIds.get(name2));
		const isUnique = meta.isUnique || meta.isPrimaryKey;
		if (meta.indexType || isUnique) {
			const algo = meta.indexType ?? "btree";
			const id = colIds.get(name2);
			let algorithm;
			switch (algo) {
				case "btree":
					algorithm = raw_index_algorithm_type_default.BTree([id]);
					break;
				case "direct":
					algorithm = raw_index_algorithm_type_default.Direct(id);
					break;
			}
			indexes.push({
				name: void 0,
				accessorName: name2,
				algorithm
			});
		}
		if (isUnique) constraints.push({
			name: void 0,
			data: {
				tag: "Unique",
				value: { columns: [colIds.get(name2)] }
			}
		});
		if (meta.isAutoIncrement) sequences.push({
			name: void 0,
			start: void 0,
			minValue: void 0,
			maxValue: void 0,
			column: colIds.get(name2),
			increment: 1n
		});
		if (scheduled) {
			const algebraicType = builder.typeBuilder.algebraicType;
			if (schedule_at_default.isScheduleAt(algebraicType)) scheduleAtCol = colIds.get(name2);
		}
	}
	for (const indexOpts of userIndexes ?? []) {
		let algorithm;
		switch (indexOpts.algorithm) {
			case "btree":
				algorithm = {
					tag: "BTree",
					value: indexOpts.columns.map((c) => colIds.get(c))
				};
				break;
			case "direct":
				algorithm = {
					tag: "Direct",
					value: colIds.get(indexOpts.column)
				};
				break;
		}
		indexes.push({
			name: void 0,
			accessorName: indexOpts.name,
			algorithm
		});
	}
	for (const constraintOpts of opts.constraints ?? []) if (constraintOpts.constraint === "unique") {
		const data = {
			tag: "Unique",
			value: { columns: constraintOpts.columns.map((c) => colIds.get(c)) }
		};
		constraints.push({
			name: constraintOpts.name,
			data
		});
		continue;
	}
	for (const index of indexes) index.name = `${name}_${(index.algorithm.tag === "Direct" ? [index.algorithm.value] : index.algorithm.value).map((i) => colNameList[i]).join("_")}_idx_${index.algorithm.tag.toLowerCase()}`;
	const tableDef = {
		name,
		productTypeRef: rowTypeRef.ref,
		primaryKey: pk,
		indexes,
		constraints,
		sequences,
		schedule: scheduled && scheduleAtCol !== void 0 ? {
			name: void 0,
			reducerName: scheduled,
			scheduledAtColumn: scheduleAtCol
		} : void 0,
		tableType: { tag: "User" },
		tableAccess: { tag: isPublic ? "Public" : "Private" }
	};
	const productType = row.algebraicType.value;
	return {
		rowType: row,
		tableName: name,
		rowSpacetimeType: productType,
		tableDef,
		idxs: {},
		constraints
	};
}
var SpacetimeHostError = class _SpacetimeHostError extends Error {
	code;
	message;
	constructor(code, message) {
		super();
		const proto = Object.getPrototypeOf(this);
		let cls;
		if (errorProtoypes.has(proto)) {
			cls = proto.constructor;
			if (code !== cls.CODE) throw new TypeError(`invalid error code for ${cls.name}`);
		} else if (proto === _SpacetimeHostError.prototype) {
			cls = errnoToClass.get(code);
			if (!cls) throw new RangeError(`unknown error code ${code}`);
		} else throw new TypeError("cannot subclass SpacetimeError");
		Object.setPrototypeOf(this, cls.prototype);
		this.code = cls.CODE;
		this.message = message ?? cls.MESSAGE;
	}
	get name() {
		return errnoToClass.get(this.code)?.name ?? "SpacetimeHostError";
	}
};
var SenderError = class extends Error {
	constructor(message) {
		super(message);
	}
	get name() {
		return "SenderError";
	}
};
var errorData = {
	HostCallFailure: [1, "ABI called by host returned an error"],
	NotInTransaction: [2, "ABI call can only be made while in a transaction"],
	BsatnDecodeError: [3, "Couldn't decode the BSATN to the expected type"],
	NoSuchTable: [4, "No such table"],
	NoSuchIndex: [5, "No such index"],
	NoSuchIter: [6, "The provided row iterator is not valid"],
	NoSuchConsoleTimer: [7, "The provided console timer does not exist"],
	NoSuchBytes: [8, "The provided bytes source or sink is not valid"],
	NoSpace: [9, "The provided sink has no more space left"],
	BufferTooSmall: [11, "The provided buffer is not large enough to store the data"],
	UniqueAlreadyExists: [12, "Value with given unique identifier already exists"],
	ScheduleAtDelayTooLong: [13, "Specified delay in scheduling row was too long"],
	IndexNotUnique: [14, "The index was not unique"],
	NoSuchRow: [15, "The row was not found, e.g., in an update call"],
	AutoIncOverflow: [16, "The auto-increment sequence overflowed"],
	WouldBlockTransaction: [17, "Attempted async or blocking op while holding open a transaction"],
	TransactionNotAnonymous: [18, "Not in an anonymous transaction. Called by a reducer?"],
	TransactionIsReadOnly: [19, "ABI call can only be made while within a mutable transaction"],
	TransactionIsMut: [20, "ABI call can only be made while within a read-only transaction"],
	HttpError: [21, "The HTTP request failed"]
};
function mapEntries(x, f) {
	return Object.fromEntries(Object.entries(x).map(([k, v]) => [k, f(k, v)]));
}
var errors = Object.freeze(mapEntries(errorData, (name, [code, message]) => Object.defineProperty(class extends SpacetimeHostError {
	static CODE = code;
	static MESSAGE = message;
	constructor() {
		super(code);
	}
}, "name", {
	value: name,
	writable: false
})));
var errorProtoypes = new Set(Object.values(errors).map((cls) => cls.prototype));
var errnoToClass = new Map(Object.values(errors).map((cls) => [cls.CODE, cls]));
__toESM(require_text_min());
var sum_type_variant_type_default = t.object("SumTypeVariant", {
	name: t.option(t.string()),
	get algebraicType() {
		return algebraic_type_type_default;
	}
});
var sum_type_type_default = t.object("SumType", { get variants() {
	return t.array(sum_type_variant_type_default);
} });
var product_type_element_type_default = t.object("ProductTypeElement", {
	name: t.option(t.string()),
	get algebraicType() {
		return algebraic_type_type_default;
	}
});
var product_type_type_default = t.object("ProductType", { get elements() {
	return t.array(product_type_element_type_default);
} });
var AlgebraicType2 = t.enum("AlgebraicType", {
	Ref: t.u32(),
	get Sum() {
		return sum_type_type_default;
	},
	get Product() {
		return product_type_type_default;
	},
	get Array() {
		return AlgebraicType2;
	},
	String: t.unit(),
	Bool: t.unit(),
	I8: t.unit(),
	U8: t.unit(),
	I16: t.unit(),
	U16: t.unit(),
	I32: t.unit(),
	U32: t.unit(),
	I64: t.unit(),
	U64: t.unit(),
	I128: t.unit(),
	U128: t.unit(),
	I256: t.unit(),
	U256: t.unit(),
	F32: t.unit(),
	F64: t.unit()
});
var algebraic_type_type_default = AlgebraicType2;
var typespace_type_default = t.object("Typespace", { get types() {
	return t.array(algebraic_type_type_default);
} });
var raw_column_def_v_8_type_default = t.object("RawColumnDefV8", {
	colName: t.string(),
	get colType() {
		return algebraic_type_type_default;
	}
});
var index_type_type_default = t.enum("IndexType", {
	BTree: t.unit(),
	Hash: t.unit()
});
var raw_index_def_v_8_type_default = t.object("RawIndexDefV8", {
	indexName: t.string(),
	isUnique: t.bool(),
	get indexType() {
		return index_type_type_default;
	},
	columns: t.array(t.u16())
});
var raw_constraint_def_v_8_type_default = t.object("RawConstraintDefV8", {
	constraintName: t.string(),
	constraints: t.u8(),
	columns: t.array(t.u16())
});
var raw_sequence_def_v_8_type_default = t.object("RawSequenceDefV8", {
	sequenceName: t.string(),
	colPos: t.u16(),
	increment: t.i128(),
	start: t.option(t.i128()),
	minValue: t.option(t.i128()),
	maxValue: t.option(t.i128()),
	allocated: t.i128()
});
var raw_table_def_v_8_type_default = t.object("RawTableDefV8", {
	tableName: t.string(),
	get columns() {
		return t.array(raw_column_def_v_8_type_default);
	},
	get indexes() {
		return t.array(raw_index_def_v_8_type_default);
	},
	get constraints() {
		return t.array(raw_constraint_def_v_8_type_default);
	},
	get sequences() {
		return t.array(raw_sequence_def_v_8_type_default);
	},
	tableType: t.string(),
	tableAccess: t.string(),
	scheduled: t.option(t.string())
});
var table_desc_type_default = t.object("TableDesc", {
	get schema() {
		return raw_table_def_v_8_type_default;
	},
	data: t.u32()
});
var reducer_def_type_default = t.object("ReducerDef", {
	name: t.string(),
	get args() {
		return t.array(product_type_element_type_default);
	}
});
var type_alias_type_default = t.object("TypeAlias", {
	name: t.string(),
	ty: t.u32()
});
var misc_module_export_type_default = t.enum("MiscModuleExport", { get TypeAlias() {
	return type_alias_type_default;
} });
var raw_module_def_v_8_type_default = t.object("RawModuleDefV8", {
	get typespace() {
		return typespace_type_default;
	},
	get tables() {
		return t.array(table_desc_type_default);
	},
	get reducers() {
		return t.array(reducer_def_type_default);
	},
	get miscExports() {
		return t.array(misc_module_export_type_default);
	}
});
var raw_index_def_v_9_type_default = t.object("RawIndexDefV9", {
	name: t.option(t.string()),
	accessorName: t.option(t.string()),
	get algorithm() {
		return raw_index_algorithm_type_default;
	}
});
var raw_unique_constraint_data_v_9_type_default = t.object("RawUniqueConstraintDataV9", { columns: t.array(t.u16()) });
var raw_constraint_data_v_9_type_default = t.enum("RawConstraintDataV9", { get Unique() {
	return raw_unique_constraint_data_v_9_type_default;
} });
var raw_constraint_def_v_9_type_default = t.object("RawConstraintDefV9", {
	name: t.option(t.string()),
	get data() {
		return raw_constraint_data_v_9_type_default;
	}
});
var raw_sequence_def_v_9_type_default = t.object("RawSequenceDefV9", {
	name: t.option(t.string()),
	column: t.u16(),
	start: t.option(t.i128()),
	minValue: t.option(t.i128()),
	maxValue: t.option(t.i128()),
	increment: t.i128()
});
var raw_schedule_def_v_9_type_default = t.object("RawScheduleDefV9", {
	name: t.option(t.string()),
	reducerName: t.string(),
	scheduledAtColumn: t.u16()
});
var table_type_type_default = t.enum("TableType", {
	System: t.unit(),
	User: t.unit()
});
var table_access_type_default = t.enum("TableAccess", {
	Public: t.unit(),
	Private: t.unit()
});
var raw_table_def_v_9_type_default = t.object("RawTableDefV9", {
	name: t.string(),
	productTypeRef: t.u32(),
	primaryKey: t.array(t.u16()),
	get indexes() {
		return t.array(raw_index_def_v_9_type_default);
	},
	get constraints() {
		return t.array(raw_constraint_def_v_9_type_default);
	},
	get sequences() {
		return t.array(raw_sequence_def_v_9_type_default);
	},
	get schedule() {
		return t.option(raw_schedule_def_v_9_type_default);
	},
	get tableType() {
		return table_type_type_default;
	},
	get tableAccess() {
		return table_access_type_default;
	}
});
var raw_reducer_def_v_9_type_default = t.object("RawReducerDefV9", {
	name: t.string(),
	get params() {
		return product_type_type_default;
	},
	get lifecycle() {
		return t.option(lifecycle_type_default);
	}
});
var raw_scoped_type_name_v_9_type_default = t.object("RawScopedTypeNameV9", {
	scope: t.array(t.string()),
	name: t.string()
});
var raw_type_def_v_9_type_default = t.object("RawTypeDefV9", {
	get name() {
		return raw_scoped_type_name_v_9_type_default;
	},
	ty: t.u32(),
	customOrdering: t.bool()
});
var raw_column_default_value_v_9_type_default = t.object("RawColumnDefaultValueV9", {
	table: t.string(),
	colId: t.u16(),
	value: t.byteArray()
});
var raw_procedure_def_v_9_type_default = t.object("RawProcedureDefV9", {
	name: t.string(),
	get params() {
		return product_type_type_default;
	},
	get returnType() {
		return algebraic_type_type_default;
	}
});
var raw_view_def_v_9_type_default = t.object("RawViewDefV9", {
	name: t.string(),
	index: t.u32(),
	isPublic: t.bool(),
	isAnonymous: t.bool(),
	get params() {
		return product_type_type_default;
	},
	get returnType() {
		return algebraic_type_type_default;
	}
});
var raw_misc_module_export_v_9_type_default = t.enum("RawMiscModuleExportV9", {
	get ColumnDefaultValue() {
		return raw_column_default_value_v_9_type_default;
	},
	get Procedure() {
		return raw_procedure_def_v_9_type_default;
	},
	get View() {
		return raw_view_def_v_9_type_default;
	}
});
var raw_row_level_security_def_v_9_type_default = t.object("RawRowLevelSecurityDefV9", { sql: t.string() });
var raw_module_def_v_9_type_default = t.object("RawModuleDefV9", {
	get typespace() {
		return typespace_type_default;
	},
	get tables() {
		return t.array(raw_table_def_v_9_type_default);
	},
	get reducers() {
		return t.array(raw_reducer_def_v_9_type_default);
	},
	get types() {
		return t.array(raw_type_def_v_9_type_default);
	},
	get miscExports() {
		return t.array(raw_misc_module_export_v_9_type_default);
	},
	get rowLevelSecurity() {
		return t.array(raw_row_level_security_def_v_9_type_default);
	}
});
var raw_module_def_type_default = t.enum("RawModuleDef", {
	get V8BackCompat() {
		return raw_module_def_v_8_type_default;
	},
	get V9() {
		return raw_module_def_v_9_type_default;
	}
});
var Range = class {
	#from;
	#to;
	constructor(from, to) {
		this.#from = from ?? { tag: "unbounded" };
		this.#to = to ?? { tag: "unbounded" };
	}
	get from() {
		return this.#from;
	}
	get to() {
		return this.#to;
	}
};
var import_statuses = __toESM(require_statuses());
var http_header_pair_type_default = t.object("HttpHeaderPair", {
	name: t.string(),
	value: t.byteArray()
});
var http_headers_type_default = t.object("HttpHeaders", { get entries() {
	return t.array(http_header_pair_type_default);
} });
var http_method_type_default = t.enum("HttpMethod", {
	Get: t.unit(),
	Head: t.unit(),
	Post: t.unit(),
	Put: t.unit(),
	Delete: t.unit(),
	Connect: t.unit(),
	Options: t.unit(),
	Trace: t.unit(),
	Patch: t.unit(),
	Extension: t.string()
});
var http_version_type_default = t.enum("HttpVersion", {
	Http09: t.unit(),
	Http10: t.unit(),
	Http11: t.unit(),
	Http2: t.unit(),
	Http3: t.unit()
});
var http_request_type_default = t.object("HttpRequest", {
	get method() {
		return http_method_type_default;
	},
	get headers() {
		return http_headers_type_default;
	},
	timeout: t.option(t.timeDuration()),
	uri: t.string(),
	get version() {
		return http_version_type_default;
	}
});
var http_response_type_default = t.object("HttpResponse", {
	get headers() {
		return http_headers_type_default;
	},
	get version() {
		return http_version_type_default;
	},
	code: t.u16()
});
var { freeze } = Object;
var textEncoder = new TextEncoder();
var textDecoder = new TextDecoder("utf-8");
var makeResponse = Symbol("makeResponse");
var SyncResponse = class _SyncResponse {
	#body;
	#inner;
	constructor(body, init2) {
		if (body == null) this.#body = null;
		else if (typeof body === "string") this.#body = body;
		else this.#body = new Uint8Array(body).buffer;
		this.#inner = {
			headers: new Headers(init2?.headers),
			status: init2?.status ?? 200,
			statusText: init2?.statusText ?? "",
			type: "default",
			url: null,
			aborted: false
		};
	}
	static [makeResponse](body, inner) {
		const me = new _SyncResponse(body);
		me.#inner = inner;
		return me;
	}
	get headers() {
		return this.#inner.headers;
	}
	get status() {
		return this.#inner.status;
	}
	get statusText() {
		return this.#inner.statusText;
	}
	get ok() {
		return 200 <= this.#inner.status && this.#inner.status <= 299;
	}
	get url() {
		return this.#inner.url ?? "";
	}
	get type() {
		return this.#inner.type;
	}
	arrayBuffer() {
		return this.bytes().buffer;
	}
	bytes() {
		if (this.#body == null) return new Uint8Array();
		else if (typeof this.#body === "string") return textEncoder.encode(this.#body);
		else return new Uint8Array(this.#body);
	}
	json() {
		return JSON.parse(this.text());
	}
	text() {
		if (this.#body == null) return "";
		else if (typeof this.#body === "string") return this.#body;
		else return textDecoder.decode(this.#body);
	}
};
var requestBaseSize = bsatnBaseSize({ types: [] }, http_request_type_default.algebraicType);
var methods = /* @__PURE__ */ new Map([
	["GET", { tag: "Get" }],
	["HEAD", { tag: "Head" }],
	["POST", { tag: "Post" }],
	["PUT", { tag: "Put" }],
	["DELETE", { tag: "Delete" }],
	["CONNECT", { tag: "Connect" }],
	["OPTIONS", { tag: "Options" }],
	["TRACE", { tag: "Trace" }],
	["PATCH", { tag: "Patch" }]
]);
function fetch(url, init2 = {}) {
	const method = methods.get(init2.method?.toUpperCase() ?? "GET") ?? {
		tag: "Extension",
		value: init2.method
	};
	const headers = { entries: headersToList(new Headers(init2.headers)).flatMap(([k, v]) => Array.isArray(v) ? v.map((v2) => [k, v2]) : [[k, v]]).map(([name, value]) => ({
		name,
		value: textEncoder.encode(value)
	})) };
	const uri$1 = "" + url;
	const request = freeze({
		method,
		headers,
		timeout: init2.timeout,
		uri: uri$1,
		version: { tag: "Http11" }
	});
	const requestBuf = new BinaryWriter(requestBaseSize);
	http_request_type_default.serialize(requestBuf, request);
	const body = init2.body == null ? new Uint8Array() : typeof init2.body === "string" ? init2.body : new Uint8Array(init2.body);
	const [responseBuf, responseBody] = sys.procedure_http_request(requestBuf.getBuffer(), body);
	const response = http_response_type_default.deserialize(new BinaryReader(responseBuf));
	return SyncResponse[makeResponse](responseBody, {
		type: "basic",
		url: uri$1,
		status: response.code,
		statusText: (0, import_statuses.default)(response.code),
		headers: new Headers(),
		aborted: false
	});
}
freeze(fetch);
var httpClient = freeze({ fetch });
var { freeze: freeze2 } = Object;
function callProcedure(id, sender, connectionId, timestamp, argsBuf) {
	const { fn, paramsType, returnType, returnTypeBaseSize } = PROCEDURES[id];
	const args = ProductType.deserializeValue(new BinaryReader(argsBuf), paramsType, MODULE_DEF.typespace);
	const ctx = {
		sender,
		timestamp,
		connectionId,
		http: httpClient,
		counter_uuid: { value: 0 },
		get identity() {
			return new Identity(sys.identity().__identity__);
		},
		withTx(body) {
			const run = () => {
				const timestamp2 = sys.procedure_start_mut_tx();
				try {
					return body(new ReducerCtxImpl(sender, new Timestamp(timestamp2), connectionId));
				} catch (e) {
					sys.procedure_abort_mut_tx();
					throw e;
				}
			};
			let res = run();
			try {
				sys.procedure_commit_mut_tx();
				return res;
			} catch {}
			console.warn("committing anonymous transaction failed");
			res = run();
			try {
				sys.procedure_commit_mut_tx();
				return res;
			} catch (e) {
				throw new Error("transaction retry failed again", { cause: e });
			}
		},
		newUuidV4() {
			const bytes = crypto.getRandomValues(new Uint8Array(16));
			return Uuid.fromRandomBytesV4(bytes);
		},
		newUuidV7() {
			const bytes = crypto.getRandomValues(new Uint8Array(10));
			return Uuid.fromCounterV7(this.counter_uuid, this.timestamp, bytes);
		}
	};
	freeze2(ctx);
	const ret = callUserFunction(fn, ctx, args);
	const retBuf = new BinaryWriter(returnTypeBaseSize);
	AlgebraicType.serializeValue(retBuf, returnType, ret, MODULE_DEF.typespace);
	return retBuf.getBuffer();
}
var view_result_header_type_default = t.enum("ViewResultHeader", {
	RowData: t.unit(),
	RawSql: t.string()
});
var { freeze: freeze3 } = Object;
var sys = freeze3(wrapSyscalls(_syscalls1_0, _syscalls1_2));
function parseJsonObject(json) {
	let value;
	try {
		value = JSON.parse(json);
	} catch {
		throw new Error("Invalid JSON: failed to parse string");
	}
	if (value === null || typeof value !== "object" || Array.isArray(value)) throw new Error("Expected a JSON object at the top level");
	return value;
}
var JwtClaimsImpl = class {
	/**
	* Creates a new JwtClaims instance.
	* @param rawPayload The JWT payload as a raw JSON string.
	* @param identity The identity for this JWT. We are only taking this because we don't have a blake3 implementation (which we need to compute it).
	*/
	constructor(rawPayload, identity) {
		this.rawPayload = rawPayload;
		this.fullPayload = parseJsonObject(rawPayload);
		this._identity = identity;
	}
	fullPayload;
	_identity;
	get identity() {
		return this._identity;
	}
	get subject() {
		return this.fullPayload["sub"];
	}
	get issuer() {
		return this.fullPayload["iss"];
	}
	get audience() {
		const aud = this.fullPayload["aud"];
		if (aud == null) return [];
		return typeof aud === "string" ? [aud] : aud;
	}
};
var AuthCtxImpl = class _AuthCtxImpl {
	isInternal;
	_jwtSource;
	_initializedJWT = false;
	_jwtClaims;
	_senderIdentity;
	constructor(opts) {
		this.isInternal = opts.isInternal;
		this._jwtSource = opts.jwtSource;
		this._senderIdentity = opts.senderIdentity;
	}
	_initializeJWT() {
		if (this._initializedJWT) return;
		this._initializedJWT = true;
		const token = this._jwtSource();
		if (!token) this._jwtClaims = null;
		else this._jwtClaims = new JwtClaimsImpl(token, this._senderIdentity);
		Object.freeze(this);
	}
	/** Lazily compute whether a JWT exists and is parseable. */
	get hasJWT() {
		this._initializeJWT();
		return this._jwtClaims !== null;
	}
	/** Lazily parse the JwtClaims only when accessed. */
	get jwt() {
		this._initializeJWT();
		return this._jwtClaims;
	}
	/** Create a context representing internal (non-user) requests. */
	static internal() {
		return new _AuthCtxImpl({
			isInternal: true,
			jwtSource: () => null,
			senderIdentity: Identity.zero()
		});
	}
	/** If there is a connection id, look up the JWT payload from the system tables. */
	static fromSystemTables(connectionId, sender) {
		if (connectionId === null) return new _AuthCtxImpl({
			isInternal: false,
			jwtSource: () => null,
			senderIdentity: sender
		});
		return new _AuthCtxImpl({
			isInternal: false,
			jwtSource: () => {
				const payloadBuf = sys.get_jwt_payload(connectionId.__connection_id__);
				if (payloadBuf.length === 0) return null;
				return new TextDecoder().decode(payloadBuf);
			},
			senderIdentity: sender
		});
	}
};
var ReducerCtxImpl = class ReducerCtx {
	#identity;
	#senderAuth;
	#uuidCounter;
	sender;
	timestamp;
	connectionId;
	db;
	constructor(sender, timestamp, connectionId) {
		Object.seal(this);
		this.sender = sender;
		this.timestamp = timestamp;
		this.connectionId = connectionId;
		this.db = getDbView();
	}
	get identity() {
		return this.#identity ??= new Identity(sys.identity().__identity__);
	}
	get senderAuth() {
		return this.#senderAuth ??= AuthCtxImpl.fromSystemTables(this.connectionId, this.sender);
	}
	/**
	* Create a new random {@link Uuid} `v4` using the {@link crypto} RNG.
	*
	* WARN: Until we use a spacetime RNG this make calls non-deterministic.
	*/
	newUuidV4() {
		const bytes = crypto.getRandomValues(new Uint8Array(16));
		return Uuid.fromRandomBytesV4(bytes);
	}
	/**
	* Create a new sortable {@link Uuid} `v7` using the {@link crypto} RNG, counter,
	* and the timestamp.
	*
	* WARN: Until we use a spacetime RNG this make calls non-deterministic.
	*/
	newUuidV7() {
		const bytes = crypto.getRandomValues(new Uint8Array(4));
		const counter = this.#uuidCounter ??= { value: 0 };
		return Uuid.fromCounterV7(counter, this.timestamp, bytes);
	}
};
var callUserFunction = function __spacetimedb_end_short_backtrace(fn, ...args) {
	return fn(...args);
};
var hooks = {
	__describe_module__() {
		const writer = new BinaryWriter(128);
		AlgebraicType.serializeValue(writer, raw_module_def_type_default.algebraicType, raw_module_def_type_default.V9(MODULE_DEF));
		return writer.getBuffer();
	},
	__call_reducer__(reducerId, sender, connId, timestamp, argsBuf) {
		const argsType = AlgebraicType.Product(MODULE_DEF.reducers[reducerId].params);
		const args = AlgebraicType.deserializeValue(new BinaryReader(argsBuf), argsType, MODULE_DEF.typespace);
		const ctx = new ReducerCtxImpl(new Identity(sender), new Timestamp(timestamp), ConnectionId.nullIfZero(new ConnectionId(connId)));
		try {
			return callUserFunction(REDUCERS[reducerId], ctx, args) ?? { tag: "ok" };
		} catch (e) {
			if (e instanceof SenderError) return {
				tag: "err",
				value: e.message
			};
			throw e;
		}
	}
};
var hooks_v1_1 = {
	__call_view__(id, sender, argsBuf) {
		const { fn, params, returnType, returnTypeBaseSize } = VIEWS[id];
		const ret = callUserFunction(fn, freeze3({
			sender: new Identity(sender),
			db: getDbView(),
			from: makeQueryBuilder(getRegisteredSchema())
		}), ProductType.deserializeValue(new BinaryReader(argsBuf), params, MODULE_DEF.typespace));
		const retBuf = new BinaryWriter(returnTypeBaseSize);
		if (isRowTypedQuery(ret)) {
			const query = toSql(ret);
			const v = view_result_header_type_default.RawSql(query);
			AlgebraicType.serializeValue(retBuf, view_result_header_type_default.algebraicType, v, MODULE_DEF.typespace);
			return { data: retBuf.getBuffer() };
		} else {
			AlgebraicType.serializeValue(retBuf, view_result_header_type_default.algebraicType, view_result_header_type_default.RowData, MODULE_DEF.typespace);
			AlgebraicType.serializeValue(retBuf, returnType, ret, MODULE_DEF.typespace);
			return { data: retBuf.getBuffer() };
		}
	},
	__call_view_anon__(id, argsBuf) {
		const { fn, params, returnType, returnTypeBaseSize } = ANON_VIEWS[id];
		const ret = callUserFunction(fn, freeze3({
			db: getDbView(),
			from: makeQueryBuilder(getRegisteredSchema())
		}), ProductType.deserializeValue(new BinaryReader(argsBuf), params, MODULE_DEF.typespace));
		const retBuf = new BinaryWriter(returnTypeBaseSize);
		if (isRowTypedQuery(ret)) {
			const query = toSql(ret);
			const v = view_result_header_type_default.RawSql(query);
			AlgebraicType.serializeValue(retBuf, view_result_header_type_default.algebraicType, v, MODULE_DEF.typespace);
			return { data: retBuf.getBuffer() };
		} else {
			AlgebraicType.serializeValue(retBuf, view_result_header_type_default.algebraicType, view_result_header_type_default.RowData, MODULE_DEF.typespace);
			AlgebraicType.serializeValue(retBuf, returnType, ret, MODULE_DEF.typespace);
			return { data: retBuf.getBuffer() };
		}
	}
};
var hooks_v1_2 = { __call_procedure__(id, sender, connection_id, timestamp, args) {
	return callProcedure(id, new Identity(sender), ConnectionId.nullIfZero(new ConnectionId(connection_id)), new Timestamp(timestamp), args);
} };
var DB_VIEW = null;
function getDbView() {
	DB_VIEW ??= makeDbView(MODULE_DEF);
	return DB_VIEW;
}
function makeDbView(moduleDef) {
	return freeze3(Object.fromEntries(moduleDef.tables.map((table2) => [toCamelCase(table2.name), makeTableView(moduleDef.typespace, table2)])));
}
function makeTableView(typespace, table2) {
	const table_id = sys.table_id_from_name(table2.name);
	const rowType = typespace.types[table2.productTypeRef];
	if (rowType.tag !== "Product") throw "impossible";
	const baseSize = bsatnBaseSize(typespace, rowType);
	const sequences = table2.sequences.map((seq) => {
		const col = rowType.value.elements[seq.column];
		const colType = col.algebraicType;
		let sequenceTrigger;
		switch (colType.tag) {
			case "U8":
			case "I8":
			case "U16":
			case "I16":
			case "U32":
			case "I32":
				sequenceTrigger = 0;
				break;
			case "U64":
			case "I64":
			case "U128":
			case "I128":
			case "U256":
			case "I256":
				sequenceTrigger = 0n;
				break;
			default: throw new TypeError("invalid sequence type");
		}
		return {
			colName: col.name,
			sequenceTrigger,
			read: (reader) => AlgebraicType.deserializeValue(reader, colType, typespace)
		};
	});
	const hasAutoIncrement = sequences.length > 0;
	const iter = () => tableIterator(sys.datastore_table_scan_bsatn(table_id), rowType);
	const integrateGeneratedColumns = hasAutoIncrement ? (row, ret_buf) => {
		const reader = new BinaryReader(ret_buf);
		for (const { colName, read, sequenceTrigger } of sequences) if (row[colName] === sequenceTrigger) row[colName] = read(reader);
	} : null;
	const tableMethods = {
		count: () => sys.datastore_table_row_count(table_id),
		iter,
		[Symbol.iterator]: () => iter(),
		insert: (row) => {
			const writer = new BinaryWriter(baseSize);
			AlgebraicType.serializeValue(writer, rowType, row, typespace);
			const ret_buf = sys.datastore_insert_bsatn(table_id, writer.getBuffer());
			const ret = { ...row };
			integrateGeneratedColumns?.(ret, ret_buf);
			return ret;
		},
		delete: (row) => {
			const writer = new BinaryWriter(4 + baseSize);
			writer.writeU32(1);
			AlgebraicType.serializeValue(writer, rowType, row, typespace);
			return sys.datastore_delete_all_by_eq_bsatn(table_id, writer.getBuffer()) > 0;
		}
	};
	const tableView = Object.assign(/* @__PURE__ */ Object.create(null), tableMethods);
	for (const indexDef of table2.indexes) {
		const index_id = sys.index_id_from_name(indexDef.name);
		let column_ids;
		switch (indexDef.algorithm.tag) {
			case "BTree":
				column_ids = indexDef.algorithm.value;
				break;
			case "Hash": throw new Error("impossible");
			case "Direct":
				column_ids = [indexDef.algorithm.value];
				break;
		}
		const numColumns = column_ids.length;
		const columnSet = new Set(column_ids);
		const isUnique = table2.constraints.filter((x) => x.data.tag === "Unique").some((x) => columnSet.isSubsetOf(new Set(x.data.value.columns)));
		const indexType = AlgebraicType.Product({ elements: column_ids.map((id) => rowType.value.elements[id]) });
		const baseSize2 = bsatnBaseSize(typespace, indexType);
		const serializePrefix = (writer, prefix, prefix_elems) => {
			if (prefix_elems > numColumns - 1) throw new TypeError("too many elements in prefix");
			for (let i = 0; i < prefix_elems; i++) {
				const elemType = indexType.value.elements[i].algebraicType;
				AlgebraicType.serializeValue(writer, elemType, prefix[i], typespace);
			}
			return writer;
		};
		let index;
		if (isUnique) {
			const serializeBound = (colVal) => {
				if (colVal.length !== numColumns) throw new TypeError("wrong number of elements");
				const writer = new BinaryWriter(baseSize2 + 1);
				const prefix_elems = numColumns - 1;
				serializePrefix(writer, colVal, prefix_elems);
				const rstartOffset = writer.offset;
				writer.writeU8(0);
				AlgebraicType.serializeValue(writer, indexType.value.elements[numColumns - 1].algebraicType, colVal[numColumns - 1], typespace);
				const buffer = writer.getBuffer();
				const prefix = buffer.slice(0, rstartOffset);
				const rstart = buffer.slice(rstartOffset);
				return [
					prefix,
					prefix_elems,
					rstart,
					rstart
				];
			};
			index = {
				find: (colVal) => {
					if (numColumns === 1) colVal = [colVal];
					const args = serializeBound(colVal);
					const iter2 = tableIterator(sys.datastore_index_scan_range_bsatn(index_id, ...args), rowType);
					const { value, done } = iter2.next();
					if (done) return null;
					if (!iter2.next().done) throw new Error("`datastore_index_scan_range_bsatn` on unique field cannot return >1 rows");
					return value;
				},
				delete: (colVal) => {
					if (numColumns === 1) colVal = [colVal];
					const args = serializeBound(colVal);
					return sys.datastore_delete_by_index_scan_range_bsatn(index_id, ...args) > 0;
				},
				update: (row) => {
					const writer = new BinaryWriter(baseSize2);
					AlgebraicType.serializeValue(writer, rowType, row, typespace);
					const ret_buf = sys.datastore_update_bsatn(table_id, index_id, writer.getBuffer());
					integrateGeneratedColumns?.(row, ret_buf);
					return row;
				}
			};
		} else {
			const serializeRange = (range) => {
				if (range.length > numColumns) throw new TypeError("too many elements");
				const writer = new BinaryWriter(baseSize2 + 1);
				const prefix_elems = range.length - 1;
				serializePrefix(writer, range, prefix_elems);
				const rstartOffset = writer.offset;
				const term = range[range.length - 1];
				const termType = indexType.value.elements[range.length - 1].algebraicType;
				let rstart, rend;
				if (term instanceof Range) {
					const writeBound = (bound) => {
						writer.writeU8({
							included: 0,
							excluded: 1,
							unbounded: 2
						}[bound.tag]);
						if (bound.tag !== "unbounded") AlgebraicType.serializeValue(writer, termType, bound.value, typespace);
					};
					writeBound(term.from);
					const rendOffset = writer.offset;
					writeBound(term.to);
					rstart = writer.getBuffer().slice(rstartOffset, rendOffset);
					rend = writer.getBuffer().slice(rendOffset);
				} else {
					writer.writeU8(0);
					AlgebraicType.serializeValue(writer, termType, term, typespace);
					rstart = rend = writer.getBuffer().slice(rstartOffset);
				}
				return [
					writer.getBuffer().slice(0, rstartOffset),
					prefix_elems,
					rstart,
					rend
				];
			};
			index = {
				filter: (range) => {
					if (numColumns === 1) range = [range];
					const args = serializeRange(range);
					return tableIterator(sys.datastore_index_scan_range_bsatn(index_id, ...args), rowType);
				},
				delete: (range) => {
					if (numColumns === 1) range = [range];
					const args = serializeRange(range);
					return sys.datastore_delete_by_index_scan_range_bsatn(index_id, ...args);
				}
			};
		}
		if (Object.hasOwn(tableView, indexDef.accessorName)) freeze3(Object.assign(tableView[indexDef.accessorName], index));
		else tableView[indexDef.accessorName] = freeze3(index);
	}
	return freeze3(tableView);
}
function hasOwn(o, k) {
	return Object.hasOwn(o, k);
}
function* tableIterator(id, ty) {
	var _stack = [];
	try {
		const iter = __using(_stack, new IteratorHandle(id));
		const { typespace } = MODULE_DEF;
		let buf;
		while ((buf = advanceIter(iter)) != null) {
			const reader = new BinaryReader(buf);
			while (reader.remaining > 0) yield AlgebraicType.deserializeValue(reader, ty, typespace);
		}
	} catch (_$1) {
		var _error = _$1, _hasError = true;
	} finally {
		__callDispose(_stack, _error, _hasError);
	}
}
function advanceIter(iter) {
	let buf_max_len = 65536;
	while (true) try {
		return iter.advance(buf_max_len);
	} catch (e) {
		if (e && typeof e === "object" && hasOwn(e, "__buffer_too_small__")) {
			buf_max_len = e.__buffer_too_small__;
			continue;
		}
		throw e;
	}
}
var IteratorHandle = class _IteratorHandle {
	#id;
	static #finalizationRegistry = new FinalizationRegistry(sys.row_iter_bsatn_close);
	constructor(id) {
		this.#id = id;
		_IteratorHandle.#finalizationRegistry.register(this, id, this);
	}
	/** Unregister this object with the finalization registry and return the id */
	#detach() {
		const id = this.#id;
		this.#id = -1;
		_IteratorHandle.#finalizationRegistry.unregister(this);
		return id;
	}
	/** Call `row_iter_bsatn_advance`, returning null if this iterator was already exhausted. */
	advance(buf_max_len) {
		if (this.#id === -1) return null;
		const { 0: done, 1: buf } = sys.row_iter_bsatn_advance(this.#id, buf_max_len);
		if (done) this.#detach();
		return buf;
	}
	[Symbol.dispose]() {
		if (this.#id >= 0) {
			const id = this.#detach();
			sys.row_iter_bsatn_close(id);
		}
	}
};
function wrapSyscalls(...modules) {
	return Object.fromEntries(modules.flatMap(Object.entries).map(([k, v]) => [k, wrapSyscall(v)]));
}
function wrapSyscall(func) {
	const name = func.name;
	return { [name](...args) {
		try {
			return func(...args);
		} catch (e) {
			if (e !== null && typeof e === "object" && hasOwn(e, "__code_error__") && typeof e.__code_error__ == "number") {
				const message = hasOwn(e, "__error_message__") && typeof e.__error_message__ === "string" ? e.__error_message__ : void 0;
				throw new SpacetimeHostError(e.__code_error__, message);
			}
			throw e;
		}
	} }[name];
}
function fmtLog(...data) {
	return data.join(" ");
}
var console_level_error = 0;
var console_level_warn = 1;
var console_level_info = 2;
var console_level_debug = 3;
var console_level_trace = 4;
var timerMap = /* @__PURE__ */ new Map();
var console2 = {
	__proto__: {},
	[Symbol.toStringTag]: "console",
	assert: (condition = false, ...data) => {
		if (!condition) sys.console_log(console_level_error, fmtLog(...data));
	},
	clear: () => {},
	debug: (...data) => {
		sys.console_log(console_level_debug, fmtLog(...data));
	},
	error: (...data) => {
		sys.console_log(console_level_error, fmtLog(...data));
	},
	info: (...data) => {
		sys.console_log(console_level_info, fmtLog(...data));
	},
	log: (...data) => {
		sys.console_log(console_level_info, fmtLog(...data));
	},
	table: (tabularData, _properties) => {
		sys.console_log(console_level_info, fmtLog(tabularData));
	},
	trace: (...data) => {
		sys.console_log(console_level_trace, fmtLog(...data));
	},
	warn: (...data) => {
		sys.console_log(console_level_warn, fmtLog(...data));
	},
	dir: (_item, _options) => {},
	dirxml: (..._data) => {},
	count: (_label = "default") => {},
	countReset: (_label = "default") => {},
	group: (..._data) => {},
	groupCollapsed: (..._data) => {},
	groupEnd: () => {},
	time: (label = "default") => {
		if (timerMap.has(label)) {
			sys.console_log(console_level_warn, `Timer '${label}' already exists.`);
			return;
		}
		timerMap.set(label, sys.console_timer_start(label));
	},
	timeLog: (label = "default", ...data) => {
		sys.console_log(console_level_info, fmtLog(label, ...data));
	},
	timeEnd: (label = "default") => {
		const spanId = timerMap.get(label);
		if (spanId === void 0) {
			sys.console_log(console_level_warn, `Timer '${label}' does not exist.`);
			return;
		}
		sys.console_timer_end(spanId);
		timerMap.delete(label);
	},
	timeStamp: () => {},
	profile: () => {},
	profileEnd: () => {}
};
console2.Console = console2;
globalThis.console = console2;
register_hooks(hooks);
register_hooks$1(hooks_v1_1);
register_hooks$2(hooks_v1_2);

//#endregion
//#region node_modules/ajv/dist/compile/codegen/code.js
var require_code$1 = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/compile/codegen/code.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.regexpCode = exports.getEsmExportName = exports.getProperty = exports.safeStringify = exports.stringify = exports.strConcat = exports.addCodeArg = exports.str = exports._ = exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = void 0;
	var _CodeOrName = class {};
	exports._CodeOrName = _CodeOrName;
	exports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
	var Name = class extends _CodeOrName {
		constructor(s) {
			super();
			if (!exports.IDENTIFIER.test(s)) throw new Error("CodeGen: name must be a valid identifier");
			this.str = s;
		}
		toString() {
			return this.str;
		}
		emptyStr() {
			return false;
		}
		get names() {
			return { [this.str]: 1 };
		}
	};
	exports.Name = Name;
	var _Code = class extends _CodeOrName {
		constructor(code) {
			super();
			this._items = typeof code === "string" ? [code] : code;
		}
		toString() {
			return this.str;
		}
		emptyStr() {
			if (this._items.length > 1) return false;
			const item = this._items[0];
			return item === "" || item === "\"\"";
		}
		get str() {
			var _a$1;
			return (_a$1 = this._str) !== null && _a$1 !== void 0 ? _a$1 : this._str = this._items.reduce((s, c) => `${s}${c}`, "");
		}
		get names() {
			var _a$1;
			return (_a$1 = this._names) !== null && _a$1 !== void 0 ? _a$1 : this._names = this._items.reduce((names$1, c) => {
				if (c instanceof Name) names$1[c.str] = (names$1[c.str] || 0) + 1;
				return names$1;
			}, {});
		}
	};
	exports._Code = _Code;
	exports.nil = new _Code("");
	function _(strs, ...args) {
		const code = [strs[0]];
		let i = 0;
		while (i < args.length) {
			addCodeArg(code, args[i]);
			code.push(strs[++i]);
		}
		return new _Code(code);
	}
	exports._ = _;
	const plus = new _Code("+");
	function str(strs, ...args) {
		const expr = [safeStringify(strs[0])];
		let i = 0;
		while (i < args.length) {
			expr.push(plus);
			addCodeArg(expr, args[i]);
			expr.push(plus, safeStringify(strs[++i]));
		}
		optimize(expr);
		return new _Code(expr);
	}
	exports.str = str;
	function addCodeArg(code, arg) {
		if (arg instanceof _Code) code.push(...arg._items);
		else if (arg instanceof Name) code.push(arg);
		else code.push(interpolate(arg));
	}
	exports.addCodeArg = addCodeArg;
	function optimize(expr) {
		let i = 1;
		while (i < expr.length - 1) {
			if (expr[i] === plus) {
				const res = mergeExprItems(expr[i - 1], expr[i + 1]);
				if (res !== void 0) {
					expr.splice(i - 1, 3, res);
					continue;
				}
				expr[i++] = "+";
			}
			i++;
		}
	}
	function mergeExprItems(a, b) {
		if (b === "\"\"") return a;
		if (a === "\"\"") return b;
		if (typeof a == "string") {
			if (b instanceof Name || a[a.length - 1] !== "\"") return;
			if (typeof b != "string") return `${a.slice(0, -1)}${b}"`;
			if (b[0] === "\"") return a.slice(0, -1) + b.slice(1);
			return;
		}
		if (typeof b == "string" && b[0] === "\"" && !(a instanceof Name)) return `"${a}${b.slice(1)}`;
	}
	function strConcat(c1, c2) {
		return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`;
	}
	exports.strConcat = strConcat;
	function interpolate(x) {
		return typeof x == "number" || typeof x == "boolean" || x === null ? x : safeStringify(Array.isArray(x) ? x.join(",") : x);
	}
	function stringify(x) {
		return new _Code(safeStringify(x));
	}
	exports.stringify = stringify;
	function safeStringify(x) {
		return JSON.stringify(x).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
	}
	exports.safeStringify = safeStringify;
	function getProperty(key) {
		return typeof key == "string" && exports.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`;
	}
	exports.getProperty = getProperty;
	function getEsmExportName(key) {
		if (typeof key == "string" && exports.IDENTIFIER.test(key)) return new _Code(`${key}`);
		throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
	}
	exports.getEsmExportName = getEsmExportName;
	function regexpCode(rx) {
		return new _Code(rx.toString());
	}
	exports.regexpCode = regexpCode;
}) });

//#endregion
//#region node_modules/ajv/dist/compile/codegen/scope.js
var require_scope = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/compile/codegen/scope.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;
	const code_1$12 = require_code$1();
	var ValueError = class extends Error {
		constructor(name) {
			super(`CodeGen: "code" for ${name} not defined`);
			this.value = name.value;
		}
	};
	var UsedValueState;
	(function(UsedValueState$1) {
		UsedValueState$1[UsedValueState$1["Started"] = 0] = "Started";
		UsedValueState$1[UsedValueState$1["Completed"] = 1] = "Completed";
	})(UsedValueState || (exports.UsedValueState = UsedValueState = {}));
	exports.varKinds = {
		const: new code_1$12.Name("const"),
		let: new code_1$12.Name("let"),
		var: new code_1$12.Name("var")
	};
	var Scope = class {
		constructor({ prefixes, parent } = {}) {
			this._names = {};
			this._prefixes = prefixes;
			this._parent = parent;
		}
		toName(nameOrPrefix) {
			return nameOrPrefix instanceof code_1$12.Name ? nameOrPrefix : this.name(nameOrPrefix);
		}
		name(prefix) {
			return new code_1$12.Name(this._newName(prefix));
		}
		_newName(prefix) {
			const ng = this._names[prefix] || this._nameGroup(prefix);
			return `${prefix}${ng.index++}`;
		}
		_nameGroup(prefix) {
			var _a$1, _b$1;
			if (((_b$1 = (_a$1 = this._parent) === null || _a$1 === void 0 ? void 0 : _a$1._prefixes) === null || _b$1 === void 0 ? void 0 : _b$1.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
			return this._names[prefix] = {
				prefix,
				index: 0
			};
		}
	};
	exports.Scope = Scope;
	var ValueScopeName = class extends code_1$12.Name {
		constructor(prefix, nameStr) {
			super(nameStr);
			this.prefix = prefix;
		}
		setValue(value, { property, itemIndex }) {
			this.value = value;
			this.scopePath = (0, code_1$12._)`.${new code_1$12.Name(property)}[${itemIndex}]`;
		}
	};
	exports.ValueScopeName = ValueScopeName;
	const line = (0, code_1$12._)`\n`;
	var ValueScope = class extends Scope {
		constructor(opts) {
			super(opts);
			this._values = {};
			this._scope = opts.scope;
			this.opts = {
				...opts,
				_n: opts.lines ? line : code_1$12.nil
			};
		}
		get() {
			return this._scope;
		}
		name(prefix) {
			return new ValueScopeName(prefix, this._newName(prefix));
		}
		value(nameOrPrefix, value) {
			var _a$1;
			if (value.ref === void 0) throw new Error("CodeGen: ref must be passed in value");
			const name = this.toName(nameOrPrefix);
			const { prefix } = name;
			const valueKey = (_a$1 = value.key) !== null && _a$1 !== void 0 ? _a$1 : value.ref;
			let vs = this._values[prefix];
			if (vs) {
				const _name = vs.get(valueKey);
				if (_name) return _name;
			} else vs = this._values[prefix] = /* @__PURE__ */ new Map();
			vs.set(valueKey, name);
			const s = this._scope[prefix] || (this._scope[prefix] = []);
			const itemIndex = s.length;
			s[itemIndex] = value.ref;
			name.setValue(value, {
				property: prefix,
				itemIndex
			});
			return name;
		}
		getValue(prefix, keyOrRef) {
			const vs = this._values[prefix];
			if (!vs) return;
			return vs.get(keyOrRef);
		}
		scopeRefs(scopeName, values = this._values) {
			return this._reduceValues(values, (name) => {
				if (name.scopePath === void 0) throw new Error(`CodeGen: name "${name}" has no value`);
				return (0, code_1$12._)`${scopeName}${name.scopePath}`;
			});
		}
		scopeCode(values = this._values, usedValues, getCode) {
			return this._reduceValues(values, (name) => {
				if (name.value === void 0) throw new Error(`CodeGen: name "${name}" has no value`);
				return name.value.code;
			}, usedValues, getCode);
		}
		_reduceValues(values, valueCode, usedValues = {}, getCode) {
			let code = code_1$12.nil;
			for (const prefix in values) {
				const vs = values[prefix];
				if (!vs) continue;
				const nameSet = usedValues[prefix] = usedValues[prefix] || /* @__PURE__ */ new Map();
				vs.forEach((name) => {
					if (nameSet.has(name)) return;
					nameSet.set(name, UsedValueState.Started);
					let c = valueCode(name);
					if (c) {
						const def$30 = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;
						code = (0, code_1$12._)`${code}${def$30} ${name} = ${c};${this.opts._n}`;
					} else if (c = getCode === null || getCode === void 0 ? void 0 : getCode(name)) code = (0, code_1$12._)`${code}${c}${this.opts._n}`;
					else throw new ValueError(name);
					nameSet.set(name, UsedValueState.Completed);
				});
			}
			return code;
		}
	};
	exports.ValueScope = ValueScope;
}) });

//#endregion
//#region node_modules/ajv/dist/compile/codegen/index.js
var require_codegen = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/compile/codegen/index.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;
	const code_1$11 = require_code$1();
	const scope_1 = require_scope();
	var code_2 = require_code$1();
	Object.defineProperty(exports, "_", {
		enumerable: true,
		get: function() {
			return code_2._;
		}
	});
	Object.defineProperty(exports, "str", {
		enumerable: true,
		get: function() {
			return code_2.str;
		}
	});
	Object.defineProperty(exports, "strConcat", {
		enumerable: true,
		get: function() {
			return code_2.strConcat;
		}
	});
	Object.defineProperty(exports, "nil", {
		enumerable: true,
		get: function() {
			return code_2.nil;
		}
	});
	Object.defineProperty(exports, "getProperty", {
		enumerable: true,
		get: function() {
			return code_2.getProperty;
		}
	});
	Object.defineProperty(exports, "stringify", {
		enumerable: true,
		get: function() {
			return code_2.stringify;
		}
	});
	Object.defineProperty(exports, "regexpCode", {
		enumerable: true,
		get: function() {
			return code_2.regexpCode;
		}
	});
	Object.defineProperty(exports, "Name", {
		enumerable: true,
		get: function() {
			return code_2.Name;
		}
	});
	var scope_2 = require_scope();
	Object.defineProperty(exports, "Scope", {
		enumerable: true,
		get: function() {
			return scope_2.Scope;
		}
	});
	Object.defineProperty(exports, "ValueScope", {
		enumerable: true,
		get: function() {
			return scope_2.ValueScope;
		}
	});
	Object.defineProperty(exports, "ValueScopeName", {
		enumerable: true,
		get: function() {
			return scope_2.ValueScopeName;
		}
	});
	Object.defineProperty(exports, "varKinds", {
		enumerable: true,
		get: function() {
			return scope_2.varKinds;
		}
	});
	exports.operators = {
		GT: new code_1$11._Code(">"),
		GTE: new code_1$11._Code(">="),
		LT: new code_1$11._Code("<"),
		LTE: new code_1$11._Code("<="),
		EQ: new code_1$11._Code("==="),
		NEQ: new code_1$11._Code("!=="),
		NOT: new code_1$11._Code("!"),
		OR: new code_1$11._Code("||"),
		AND: new code_1$11._Code("&&"),
		ADD: new code_1$11._Code("+")
	};
	var Node = class {
		optimizeNodes() {
			return this;
		}
		optimizeNames(_names, _constants) {
			return this;
		}
	};
	var Def = class extends Node {
		constructor(varKind, name, rhs) {
			super();
			this.varKind = varKind;
			this.name = name;
			this.rhs = rhs;
		}
		render({ es5, _n }) {
			const varKind = es5 ? scope_1.varKinds.var : this.varKind;
			const rhs = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
			return `${varKind} ${this.name}${rhs};` + _n;
		}
		optimizeNames(names$1, constants) {
			if (!names$1[this.name.str]) return;
			if (this.rhs) this.rhs = optimizeExpr(this.rhs, names$1, constants);
			return this;
		}
		get names() {
			return this.rhs instanceof code_1$11._CodeOrName ? this.rhs.names : {};
		}
	};
	var Assign = class extends Node {
		constructor(lhs, rhs, sideEffects) {
			super();
			this.lhs = lhs;
			this.rhs = rhs;
			this.sideEffects = sideEffects;
		}
		render({ _n }) {
			return `${this.lhs} = ${this.rhs};` + _n;
		}
		optimizeNames(names$1, constants) {
			if (this.lhs instanceof code_1$11.Name && !names$1[this.lhs.str] && !this.sideEffects) return;
			this.rhs = optimizeExpr(this.rhs, names$1, constants);
			return this;
		}
		get names() {
			return addExprNames(this.lhs instanceof code_1$11.Name ? {} : { ...this.lhs.names }, this.rhs);
		}
	};
	var AssignOp = class extends Assign {
		constructor(lhs, op, rhs, sideEffects) {
			super(lhs, rhs, sideEffects);
			this.op = op;
		}
		render({ _n }) {
			return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
		}
	};
	var Label = class extends Node {
		constructor(label) {
			super();
			this.label = label;
			this.names = {};
		}
		render({ _n }) {
			return `${this.label}:` + _n;
		}
	};
	var Break = class extends Node {
		constructor(label) {
			super();
			this.label = label;
			this.names = {};
		}
		render({ _n }) {
			return `break${this.label ? ` ${this.label}` : ""};` + _n;
		}
	};
	var Throw = class extends Node {
		constructor(error) {
			super();
			this.error = error;
		}
		render({ _n }) {
			return `throw ${this.error};` + _n;
		}
		get names() {
			return this.error.names;
		}
	};
	var AnyCode = class extends Node {
		constructor(code) {
			super();
			this.code = code;
		}
		render({ _n }) {
			return `${this.code};` + _n;
		}
		optimizeNodes() {
			return `${this.code}` ? this : void 0;
		}
		optimizeNames(names$1, constants) {
			this.code = optimizeExpr(this.code, names$1, constants);
			return this;
		}
		get names() {
			return this.code instanceof code_1$11._CodeOrName ? this.code.names : {};
		}
	};
	var ParentNode = class extends Node {
		constructor(nodes = []) {
			super();
			this.nodes = nodes;
		}
		render(opts) {
			return this.nodes.reduce((code, n) => code + n.render(opts), "");
		}
		optimizeNodes() {
			const { nodes } = this;
			let i = nodes.length;
			while (i--) {
				const n = nodes[i].optimizeNodes();
				if (Array.isArray(n)) nodes.splice(i, 1, ...n);
				else if (n) nodes[i] = n;
				else nodes.splice(i, 1);
			}
			return nodes.length > 0 ? this : void 0;
		}
		optimizeNames(names$1, constants) {
			const { nodes } = this;
			let i = nodes.length;
			while (i--) {
				const n = nodes[i];
				if (n.optimizeNames(names$1, constants)) continue;
				subtractNames(names$1, n.names);
				nodes.splice(i, 1);
			}
			return nodes.length > 0 ? this : void 0;
		}
		get names() {
			return this.nodes.reduce((names$1, n) => addNames(names$1, n.names), {});
		}
	};
	var BlockNode = class extends ParentNode {
		render(opts) {
			return "{" + opts._n + super.render(opts) + "}" + opts._n;
		}
	};
	var Root = class extends ParentNode {};
	var Else = class extends BlockNode {};
	Else.kind = "else";
	var If = class If extends BlockNode {
		constructor(condition, nodes) {
			super(nodes);
			this.condition = condition;
		}
		render(opts) {
			let code = `if(${this.condition})` + super.render(opts);
			if (this.else) code += "else " + this.else.render(opts);
			return code;
		}
		optimizeNodes() {
			super.optimizeNodes();
			const cond = this.condition;
			if (cond === true) return this.nodes;
			let e = this.else;
			if (e) {
				const ns = e.optimizeNodes();
				e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
			}
			if (e) {
				if (cond === false) return e instanceof If ? e : e.nodes;
				if (this.nodes.length) return this;
				return new If(not(cond), e instanceof If ? [e] : e.nodes);
			}
			if (cond === false || !this.nodes.length) return void 0;
			return this;
		}
		optimizeNames(names$1, constants) {
			var _a$1;
			this.else = (_a$1 = this.else) === null || _a$1 === void 0 ? void 0 : _a$1.optimizeNames(names$1, constants);
			if (!(super.optimizeNames(names$1, constants) || this.else)) return;
			this.condition = optimizeExpr(this.condition, names$1, constants);
			return this;
		}
		get names() {
			const names$1 = super.names;
			addExprNames(names$1, this.condition);
			if (this.else) addNames(names$1, this.else.names);
			return names$1;
		}
	};
	If.kind = "if";
	var For = class extends BlockNode {};
	For.kind = "for";
	var ForLoop = class extends For {
		constructor(iteration) {
			super();
			this.iteration = iteration;
		}
		render(opts) {
			return `for(${this.iteration})` + super.render(opts);
		}
		optimizeNames(names$1, constants) {
			if (!super.optimizeNames(names$1, constants)) return;
			this.iteration = optimizeExpr(this.iteration, names$1, constants);
			return this;
		}
		get names() {
			return addNames(super.names, this.iteration.names);
		}
	};
	var ForRange = class extends For {
		constructor(varKind, name, from, to) {
			super();
			this.varKind = varKind;
			this.name = name;
			this.from = from;
			this.to = to;
		}
		render(opts) {
			const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
			const { name, from, to } = this;
			return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);
		}
		get names() {
			return addExprNames(addExprNames(super.names, this.from), this.to);
		}
	};
	var ForIter = class extends For {
		constructor(loop, varKind, name, iterable) {
			super();
			this.loop = loop;
			this.varKind = varKind;
			this.name = name;
			this.iterable = iterable;
		}
		render(opts) {
			return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
		}
		optimizeNames(names$1, constants) {
			if (!super.optimizeNames(names$1, constants)) return;
			this.iterable = optimizeExpr(this.iterable, names$1, constants);
			return this;
		}
		get names() {
			return addNames(super.names, this.iterable.names);
		}
	};
	var Func = class extends BlockNode {
		constructor(name, args, async) {
			super();
			this.name = name;
			this.args = args;
			this.async = async;
		}
		render(opts) {
			return `${this.async ? "async " : ""}function ${this.name}(${this.args})` + super.render(opts);
		}
	};
	Func.kind = "func";
	var Return = class extends ParentNode {
		render(opts) {
			return "return " + super.render(opts);
		}
	};
	Return.kind = "return";
	var Try = class extends BlockNode {
		render(opts) {
			let code = "try" + super.render(opts);
			if (this.catch) code += this.catch.render(opts);
			if (this.finally) code += this.finally.render(opts);
			return code;
		}
		optimizeNodes() {
			var _a$1, _b$1;
			super.optimizeNodes();
			(_a$1 = this.catch) === null || _a$1 === void 0 || _a$1.optimizeNodes();
			(_b$1 = this.finally) === null || _b$1 === void 0 || _b$1.optimizeNodes();
			return this;
		}
		optimizeNames(names$1, constants) {
			var _a$1, _b$1;
			super.optimizeNames(names$1, constants);
			(_a$1 = this.catch) === null || _a$1 === void 0 || _a$1.optimizeNames(names$1, constants);
			(_b$1 = this.finally) === null || _b$1 === void 0 || _b$1.optimizeNames(names$1, constants);
			return this;
		}
		get names() {
			const names$1 = super.names;
			if (this.catch) addNames(names$1, this.catch.names);
			if (this.finally) addNames(names$1, this.finally.names);
			return names$1;
		}
	};
	var Catch = class extends BlockNode {
		constructor(error) {
			super();
			this.error = error;
		}
		render(opts) {
			return `catch(${this.error})` + super.render(opts);
		}
	};
	Catch.kind = "catch";
	var Finally = class extends BlockNode {
		render(opts) {
			return "finally" + super.render(opts);
		}
	};
	Finally.kind = "finally";
	var CodeGen = class {
		constructor(extScope, opts = {}) {
			this._values = {};
			this._blockStarts = [];
			this._constants = {};
			this.opts = {
				...opts,
				_n: opts.lines ? "\n" : ""
			};
			this._extScope = extScope;
			this._scope = new scope_1.Scope({ parent: extScope });
			this._nodes = [new Root()];
		}
		toString() {
			return this._root.render(this.opts);
		}
		name(prefix) {
			return this._scope.name(prefix);
		}
		scopeName(prefix) {
			return this._extScope.name(prefix);
		}
		scopeValue(prefixOrName, value) {
			const name = this._extScope.value(prefixOrName, value);
			(this._values[name.prefix] || (this._values[name.prefix] = /* @__PURE__ */ new Set())).add(name);
			return name;
		}
		getScopeValue(prefix, keyOrRef) {
			return this._extScope.getValue(prefix, keyOrRef);
		}
		scopeRefs(scopeName) {
			return this._extScope.scopeRefs(scopeName, this._values);
		}
		scopeCode() {
			return this._extScope.scopeCode(this._values);
		}
		_def(varKind, nameOrPrefix, rhs, constant) {
			const name = this._scope.toName(nameOrPrefix);
			if (rhs !== void 0 && constant) this._constants[name.str] = rhs;
			this._leafNode(new Def(varKind, name, rhs));
			return name;
		}
		const(nameOrPrefix, rhs, _constant) {
			return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
		}
		let(nameOrPrefix, rhs, _constant) {
			return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
		}
		var(nameOrPrefix, rhs, _constant) {
			return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
		}
		assign(lhs, rhs, sideEffects) {
			return this._leafNode(new Assign(lhs, rhs, sideEffects));
		}
		add(lhs, rhs) {
			return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));
		}
		code(c) {
			if (typeof c == "function") c();
			else if (c !== code_1$11.nil) this._leafNode(new AnyCode(c));
			return this;
		}
		object(...keyValues) {
			const code = ["{"];
			for (const [key, value] of keyValues) {
				if (code.length > 1) code.push(",");
				code.push(key);
				if (key !== value || this.opts.es5) {
					code.push(":");
					(0, code_1$11.addCodeArg)(code, value);
				}
			}
			code.push("}");
			return new code_1$11._Code(code);
		}
		if(condition, thenBody, elseBody) {
			this._blockNode(new If(condition));
			if (thenBody && elseBody) this.code(thenBody).else().code(elseBody).endIf();
			else if (thenBody) this.code(thenBody).endIf();
			else if (elseBody) throw new Error("CodeGen: \"else\" body without \"then\" body");
			return this;
		}
		elseIf(condition) {
			return this._elseNode(new If(condition));
		}
		else() {
			return this._elseNode(new Else());
		}
		endIf() {
			return this._endBlockNode(If, Else);
		}
		_for(node, forBody) {
			this._blockNode(node);
			if (forBody) this.code(forBody).endFor();
			return this;
		}
		for(iteration, forBody) {
			return this._for(new ForLoop(iteration), forBody);
		}
		forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
			const name = this._scope.toName(nameOrPrefix);
			return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
		}
		forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
			const name = this._scope.toName(nameOrPrefix);
			if (this.opts.es5) {
				const arr = iterable instanceof code_1$11.Name ? iterable : this.var("_arr", iterable);
				return this.forRange("_i", 0, (0, code_1$11._)`${arr}.length`, (i) => {
					this.var(name, (0, code_1$11._)`${arr}[${i}]`);
					forBody(name);
				});
			}
			return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
		}
		forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
			if (this.opts.ownProperties) return this.forOf(nameOrPrefix, (0, code_1$11._)`Object.keys(${obj})`, forBody);
			const name = this._scope.toName(nameOrPrefix);
			return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
		}
		endFor() {
			return this._endBlockNode(For);
		}
		label(label) {
			return this._leafNode(new Label(label));
		}
		break(label) {
			return this._leafNode(new Break(label));
		}
		return(value) {
			const node = new Return();
			this._blockNode(node);
			this.code(value);
			if (node.nodes.length !== 1) throw new Error("CodeGen: \"return\" should have one node");
			return this._endBlockNode(Return);
		}
		try(tryBody, catchCode, finallyCode) {
			if (!catchCode && !finallyCode) throw new Error("CodeGen: \"try\" without \"catch\" and \"finally\"");
			const node = new Try();
			this._blockNode(node);
			this.code(tryBody);
			if (catchCode) {
				const error = this.name("e");
				this._currNode = node.catch = new Catch(error);
				catchCode(error);
			}
			if (finallyCode) {
				this._currNode = node.finally = new Finally();
				this.code(finallyCode);
			}
			return this._endBlockNode(Catch, Finally);
		}
		throw(error) {
			return this._leafNode(new Throw(error));
		}
		block(body, nodeCount) {
			this._blockStarts.push(this._nodes.length);
			if (body) this.code(body).endBlock(nodeCount);
			return this;
		}
		endBlock(nodeCount) {
			const len = this._blockStarts.pop();
			if (len === void 0) throw new Error("CodeGen: not in self-balancing block");
			const toClose = this._nodes.length - len;
			if (toClose < 0 || nodeCount !== void 0 && toClose !== nodeCount) throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
			this._nodes.length = len;
			return this;
		}
		func(name, args = code_1$11.nil, async, funcBody) {
			this._blockNode(new Func(name, args, async));
			if (funcBody) this.code(funcBody).endFunc();
			return this;
		}
		endFunc() {
			return this._endBlockNode(Func);
		}
		optimize(n = 1) {
			while (n-- > 0) {
				this._root.optimizeNodes();
				this._root.optimizeNames(this._root.names, this._constants);
			}
		}
		_leafNode(node) {
			this._currNode.nodes.push(node);
			return this;
		}
		_blockNode(node) {
			this._currNode.nodes.push(node);
			this._nodes.push(node);
		}
		_endBlockNode(N1, N2) {
			const n = this._currNode;
			if (n instanceof N1 || N2 && n instanceof N2) {
				this._nodes.pop();
				return this;
			}
			throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
		}
		_elseNode(node) {
			const n = this._currNode;
			if (!(n instanceof If)) throw new Error("CodeGen: \"else\" without \"if\"");
			this._currNode = n.else = node;
			return this;
		}
		get _root() {
			return this._nodes[0];
		}
		get _currNode() {
			const ns = this._nodes;
			return ns[ns.length - 1];
		}
		set _currNode(node) {
			const ns = this._nodes;
			ns[ns.length - 1] = node;
		}
	};
	exports.CodeGen = CodeGen;
	function addNames(names$1, from) {
		for (const n in from) names$1[n] = (names$1[n] || 0) + (from[n] || 0);
		return names$1;
	}
	function addExprNames(names$1, from) {
		return from instanceof code_1$11._CodeOrName ? addNames(names$1, from.names) : names$1;
	}
	function optimizeExpr(expr, names$1, constants) {
		if (expr instanceof code_1$11.Name) return replaceName(expr);
		if (!canOptimize(expr)) return expr;
		return new code_1$11._Code(expr._items.reduce((items, c) => {
			if (c instanceof code_1$11.Name) c = replaceName(c);
			if (c instanceof code_1$11._Code) items.push(...c._items);
			else items.push(c);
			return items;
		}, []));
		function replaceName(n) {
			const c = constants[n.str];
			if (c === void 0 || names$1[n.str] !== 1) return n;
			delete names$1[n.str];
			return c;
		}
		function canOptimize(e) {
			return e instanceof code_1$11._Code && e._items.some((c) => c instanceof code_1$11.Name && names$1[c.str] === 1 && constants[c.str] !== void 0);
		}
	}
	function subtractNames(names$1, from) {
		for (const n in from) names$1[n] = (names$1[n] || 0) - (from[n] || 0);
	}
	function not(x) {
		return typeof x == "boolean" || typeof x == "number" || x === null ? !x : (0, code_1$11._)`!${par(x)}`;
	}
	exports.not = not;
	const andCode = mappend(exports.operators.AND);
	function and(...args) {
		return args.reduce(andCode);
	}
	exports.and = and;
	const orCode = mappend(exports.operators.OR);
	function or(...args) {
		return args.reduce(orCode);
	}
	exports.or = or;
	function mappend(op) {
		return (x, y) => x === code_1$11.nil ? y : y === code_1$11.nil ? x : (0, code_1$11._)`${par(x)} ${op} ${par(y)}`;
	}
	function par(x) {
		return x instanceof code_1$11.Name ? x : (0, code_1$11._)`(${x})`;
	}
}) });

//#endregion
//#region node_modules/ajv/dist/compile/util.js
var require_util = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/compile/util.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$35 = require_codegen();
	const code_1$10 = require_code$1();
	function toHash(arr) {
		const hash = {};
		for (const item of arr) hash[item] = true;
		return hash;
	}
	exports.toHash = toHash;
	function alwaysValidSchema(it, schema$1) {
		if (typeof schema$1 == "boolean") return schema$1;
		if (Object.keys(schema$1).length === 0) return true;
		checkUnknownRules(it, schema$1);
		return !schemaHasRules(schema$1, it.self.RULES.all);
	}
	exports.alwaysValidSchema = alwaysValidSchema;
	function checkUnknownRules(it, schema$1 = it.schema) {
		const { opts, self } = it;
		if (!opts.strictSchema) return;
		if (typeof schema$1 === "boolean") return;
		const rules = self.RULES.keywords;
		for (const key in schema$1) if (!rules[key]) checkStrictMode(it, `unknown keyword: "${key}"`);
	}
	exports.checkUnknownRules = checkUnknownRules;
	function schemaHasRules(schema$1, rules) {
		if (typeof schema$1 == "boolean") return !schema$1;
		for (const key in schema$1) if (rules[key]) return true;
		return false;
	}
	exports.schemaHasRules = schemaHasRules;
	function schemaHasRulesButRef(schema$1, RULES) {
		if (typeof schema$1 == "boolean") return !schema$1;
		for (const key in schema$1) if (key !== "$ref" && RULES.all[key]) return true;
		return false;
	}
	exports.schemaHasRulesButRef = schemaHasRulesButRef;
	function schemaRefOrVal({ topSchemaRef, schemaPath }, schema$1, keyword, $data) {
		if (!$data) {
			if (typeof schema$1 == "number" || typeof schema$1 == "boolean") return schema$1;
			if (typeof schema$1 == "string") return (0, codegen_1$35._)`${schema$1}`;
		}
		return (0, codegen_1$35._)`${topSchemaRef}${schemaPath}${(0, codegen_1$35.getProperty)(keyword)}`;
	}
	exports.schemaRefOrVal = schemaRefOrVal;
	function unescapeFragment(str$1) {
		return unescapeJsonPointer(decodeURIComponent(str$1));
	}
	exports.unescapeFragment = unescapeFragment;
	function escapeFragment(str$1) {
		return encodeURIComponent(escapeJsonPointer(str$1));
	}
	exports.escapeFragment = escapeFragment;
	function escapeJsonPointer(str$1) {
		if (typeof str$1 == "number") return `${str$1}`;
		return str$1.replace(/~/g, "~0").replace(/\//g, "~1");
	}
	exports.escapeJsonPointer = escapeJsonPointer;
	function unescapeJsonPointer(str$1) {
		return str$1.replace(/~1/g, "/").replace(/~0/g, "~");
	}
	exports.unescapeJsonPointer = unescapeJsonPointer;
	function eachItem(xs, f) {
		if (Array.isArray(xs)) for (const x of xs) f(x);
		else f(xs);
	}
	exports.eachItem = eachItem;
	function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName }) {
		return (gen, from, to, toName) => {
			const res = to === void 0 ? from : to instanceof codegen_1$35.Name ? (from instanceof codegen_1$35.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to) : from instanceof codegen_1$35.Name ? (mergeToName(gen, to, from), from) : mergeValues(from, to);
			return toName === codegen_1$35.Name && !(res instanceof codegen_1$35.Name) ? resultToName(gen, res) : res;
		};
	}
	exports.mergeEvaluated = {
		props: makeMergeEvaluated({
			mergeNames: (gen, from, to) => gen.if((0, codegen_1$35._)`${to} !== true && ${from} !== undefined`, () => {
				gen.if((0, codegen_1$35._)`${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1$35._)`${to} || {}`).code((0, codegen_1$35._)`Object.assign(${to}, ${from})`));
			}),
			mergeToName: (gen, from, to) => gen.if((0, codegen_1$35._)`${to} !== true`, () => {
				if (from === true) gen.assign(to, true);
				else {
					gen.assign(to, (0, codegen_1$35._)`${to} || {}`);
					setEvaluated(gen, to, from);
				}
			}),
			mergeValues: (from, to) => from === true ? true : {
				...from,
				...to
			},
			resultToName: evaluatedPropsToName
		}),
		items: makeMergeEvaluated({
			mergeNames: (gen, from, to) => gen.if((0, codegen_1$35._)`${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1$35._)`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
			mergeToName: (gen, from, to) => gen.if((0, codegen_1$35._)`${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1$35._)`${to} > ${from} ? ${to} : ${from}`)),
			mergeValues: (from, to) => from === true ? true : Math.max(from, to),
			resultToName: (gen, items) => gen.var("items", items)
		})
	};
	function evaluatedPropsToName(gen, ps) {
		if (ps === true) return gen.var("props", true);
		const props = gen.var("props", (0, codegen_1$35._)`{}`);
		if (ps !== void 0) setEvaluated(gen, props, ps);
		return props;
	}
	exports.evaluatedPropsToName = evaluatedPropsToName;
	function setEvaluated(gen, props, ps) {
		Object.keys(ps).forEach((p) => gen.assign((0, codegen_1$35._)`${props}${(0, codegen_1$35.getProperty)(p)}`, true));
	}
	exports.setEvaluated = setEvaluated;
	const snippets = {};
	function useFunc(gen, f) {
		return gen.scopeValue("func", {
			ref: f,
			code: snippets[f.code] || (snippets[f.code] = new code_1$10._Code(f.code))
		});
	}
	exports.useFunc = useFunc;
	var Type;
	(function(Type$1) {
		Type$1[Type$1["Num"] = 0] = "Num";
		Type$1[Type$1["Str"] = 1] = "Str";
	})(Type || (exports.Type = Type = {}));
	function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
		if (dataProp instanceof codegen_1$35.Name) {
			const isNumber = dataPropType === Type.Num;
			return jsPropertySyntax ? isNumber ? (0, codegen_1$35._)`"[" + ${dataProp} + "]"` : (0, codegen_1$35._)`"['" + ${dataProp} + "']"` : isNumber ? (0, codegen_1$35._)`"/" + ${dataProp}` : (0, codegen_1$35._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
		}
		return jsPropertySyntax ? (0, codegen_1$35.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
	}
	exports.getErrorPath = getErrorPath;
	function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
		if (!mode) return;
		msg = `strict mode: ${msg}`;
		if (mode === true) throw new Error(msg);
		it.self.logger.warn(msg);
	}
	exports.checkStrictMode = checkStrictMode;
}) });

//#endregion
//#region node_modules/ajv/dist/compile/names.js
var require_names = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/compile/names.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$34 = require_codegen();
	const names = {
		data: new codegen_1$34.Name("data"),
		valCxt: new codegen_1$34.Name("valCxt"),
		instancePath: new codegen_1$34.Name("instancePath"),
		parentData: new codegen_1$34.Name("parentData"),
		parentDataProperty: new codegen_1$34.Name("parentDataProperty"),
		rootData: new codegen_1$34.Name("rootData"),
		dynamicAnchors: new codegen_1$34.Name("dynamicAnchors"),
		vErrors: new codegen_1$34.Name("vErrors"),
		errors: new codegen_1$34.Name("errors"),
		this: new codegen_1$34.Name("this"),
		self: new codegen_1$34.Name("self"),
		scope: new codegen_1$34.Name("scope"),
		json: new codegen_1$34.Name("json"),
		jsonPos: new codegen_1$34.Name("jsonPos"),
		jsonLen: new codegen_1$34.Name("jsonLen"),
		jsonPart: new codegen_1$34.Name("jsonPart")
	};
	exports.default = names;
}) });

//#endregion
//#region node_modules/ajv/dist/compile/errors.js
var require_errors = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/compile/errors.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = void 0;
	const codegen_1$33 = require_codegen();
	const util_1$29 = require_util();
	const names_1$7 = require_names();
	exports.keywordError = { message: ({ keyword }) => (0, codegen_1$33.str)`must pass "${keyword}" keyword validation` };
	exports.keyword$DataError = { message: ({ keyword, schemaType }) => schemaType ? (0, codegen_1$33.str)`"${keyword}" keyword must be ${schemaType} ($data)` : (0, codegen_1$33.str)`"${keyword}" keyword is invalid ($data)` };
	function reportError(cxt, error = exports.keywordError, errorPaths, overrideAllErrors) {
		const { it } = cxt;
		const { gen, compositeRule, allErrors } = it;
		const errObj = errorObjectCode(cxt, error, errorPaths);
		if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : compositeRule || allErrors) addError(gen, errObj);
		else returnErrors(it, (0, codegen_1$33._)`[${errObj}]`);
	}
	exports.reportError = reportError;
	function reportExtraError(cxt, error = exports.keywordError, errorPaths) {
		const { it } = cxt;
		const { gen, compositeRule, allErrors } = it;
		addError(gen, errorObjectCode(cxt, error, errorPaths));
		if (!(compositeRule || allErrors)) returnErrors(it, names_1$7.default.vErrors);
	}
	exports.reportExtraError = reportExtraError;
	function resetErrorsCount(gen, errsCount) {
		gen.assign(names_1$7.default.errors, errsCount);
		gen.if((0, codegen_1$33._)`${names_1$7.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1$33._)`${names_1$7.default.vErrors}.length`, errsCount), () => gen.assign(names_1$7.default.vErrors, null)));
	}
	exports.resetErrorsCount = resetErrorsCount;
	function extendErrors({ gen, keyword, schemaValue, data, errsCount, it }) {
		/* istanbul ignore if */
		if (errsCount === void 0) throw new Error("ajv implementation error");
		const err = gen.name("err");
		gen.forRange("i", errsCount, names_1$7.default.errors, (i) => {
			gen.const(err, (0, codegen_1$33._)`${names_1$7.default.vErrors}[${i}]`);
			gen.if((0, codegen_1$33._)`${err}.instancePath === undefined`, () => gen.assign((0, codegen_1$33._)`${err}.instancePath`, (0, codegen_1$33.strConcat)(names_1$7.default.instancePath, it.errorPath)));
			gen.assign((0, codegen_1$33._)`${err}.schemaPath`, (0, codegen_1$33.str)`${it.errSchemaPath}/${keyword}`);
			if (it.opts.verbose) {
				gen.assign((0, codegen_1$33._)`${err}.schema`, schemaValue);
				gen.assign((0, codegen_1$33._)`${err}.data`, data);
			}
		});
	}
	exports.extendErrors = extendErrors;
	function addError(gen, errObj) {
		const err = gen.const("err", errObj);
		gen.if((0, codegen_1$33._)`${names_1$7.default.vErrors} === null`, () => gen.assign(names_1$7.default.vErrors, (0, codegen_1$33._)`[${err}]`), (0, codegen_1$33._)`${names_1$7.default.vErrors}.push(${err})`);
		gen.code((0, codegen_1$33._)`${names_1$7.default.errors}++`);
	}
	function returnErrors(it, errs) {
		const { gen, validateName, schemaEnv } = it;
		if (schemaEnv.$async) gen.throw((0, codegen_1$33._)`new ${it.ValidationError}(${errs})`);
		else {
			gen.assign((0, codegen_1$33._)`${validateName}.errors`, errs);
			gen.return(false);
		}
	}
	const E = {
		keyword: new codegen_1$33.Name("keyword"),
		schemaPath: new codegen_1$33.Name("schemaPath"),
		params: new codegen_1$33.Name("params"),
		propertyName: new codegen_1$33.Name("propertyName"),
		message: new codegen_1$33.Name("message"),
		schema: new codegen_1$33.Name("schema"),
		parentSchema: new codegen_1$33.Name("parentSchema")
	};
	function errorObjectCode(cxt, error, errorPaths) {
		const { createErrors } = cxt.it;
		if (createErrors === false) return (0, codegen_1$33._)`{}`;
		return errorObject(cxt, error, errorPaths);
	}
	function errorObject(cxt, error, errorPaths = {}) {
		const { gen, it } = cxt;
		const keyValues = [errorInstancePath(it, errorPaths), errorSchemaPath(cxt, errorPaths)];
		extraErrorProps(cxt, error, keyValues);
		return gen.object(...keyValues);
	}
	function errorInstancePath({ errorPath }, { instancePath }) {
		const instPath = instancePath ? (0, codegen_1$33.str)`${errorPath}${(0, util_1$29.getErrorPath)(instancePath, util_1$29.Type.Str)}` : errorPath;
		return [names_1$7.default.instancePath, (0, codegen_1$33.strConcat)(names_1$7.default.instancePath, instPath)];
	}
	function errorSchemaPath({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
		let schPath = parentSchema ? errSchemaPath : (0, codegen_1$33.str)`${errSchemaPath}/${keyword}`;
		if (schemaPath) schPath = (0, codegen_1$33.str)`${schPath}${(0, util_1$29.getErrorPath)(schemaPath, util_1$29.Type.Str)}`;
		return [E.schemaPath, schPath];
	}
	function extraErrorProps(cxt, { params, message }, keyValues) {
		const { keyword, data, schemaValue, it } = cxt;
		const { opts, propertyName, topSchemaRef, schemaPath } = it;
		keyValues.push([E.keyword, keyword], [E.params, typeof params == "function" ? params(cxt) : params || (0, codegen_1$33._)`{}`]);
		if (opts.messages) keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);
		if (opts.verbose) keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1$33._)`${topSchemaRef}${schemaPath}`], [names_1$7.default.data, data]);
		if (propertyName) keyValues.push([E.propertyName, propertyName]);
	}
}) });

//#endregion
//#region node_modules/ajv/dist/compile/validate/boolSchema.js
var require_boolSchema = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/compile/validate/boolSchema.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const errors_1$3 = require_errors();
	const codegen_1$32 = require_codegen();
	const names_1$6 = require_names();
	const boolError = { message: "boolean schema is false" };
	function topBoolOrEmptySchema(it) {
		const { gen, schema: schema$1, validateName } = it;
		if (schema$1 === false) falseSchemaError(it, false);
		else if (typeof schema$1 == "object" && schema$1.$async === true) gen.return(names_1$6.default.data);
		else {
			gen.assign((0, codegen_1$32._)`${validateName}.errors`, null);
			gen.return(true);
		}
	}
	exports.topBoolOrEmptySchema = topBoolOrEmptySchema;
	function boolOrEmptySchema(it, valid) {
		const { gen, schema: schema$1 } = it;
		if (schema$1 === false) {
			gen.var(valid, false);
			falseSchemaError(it);
		} else gen.var(valid, true);
	}
	exports.boolOrEmptySchema = boolOrEmptySchema;
	function falseSchemaError(it, overrideAllErrors) {
		const { gen, data } = it;
		const cxt = {
			gen,
			keyword: "false schema",
			data,
			schema: false,
			schemaCode: false,
			schemaValue: false,
			params: {},
			it
		};
		(0, errors_1$3.reportError)(cxt, boolError, void 0, overrideAllErrors);
	}
}) });

//#endregion
//#region node_modules/ajv/dist/compile/rules.js
var require_rules = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/compile/rules.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const jsonTypes = new Set([
		"string",
		"number",
		"integer",
		"boolean",
		"null",
		"object",
		"array"
	]);
	function isJSONType(x) {
		return typeof x == "string" && jsonTypes.has(x);
	}
	exports.isJSONType = isJSONType;
	function getRules() {
		const groups = {
			number: {
				type: "number",
				rules: []
			},
			string: {
				type: "string",
				rules: []
			},
			array: {
				type: "array",
				rules: []
			},
			object: {
				type: "object",
				rules: []
			}
		};
		return {
			types: {
				...groups,
				integer: true,
				boolean: true,
				null: true
			},
			rules: [
				{ rules: [] },
				groups.number,
				groups.string,
				groups.array,
				groups.object
			],
			post: { rules: [] },
			all: {},
			keywords: {}
		};
	}
	exports.getRules = getRules;
}) });

//#endregion
//#region node_modules/ajv/dist/compile/validate/applicability.js
var require_applicability = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/compile/validate/applicability.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	function schemaHasRulesForType({ schema: schema$1, self }, type) {
		const group = self.RULES.types[type];
		return group && group !== true && shouldUseGroup(schema$1, group);
	}
	exports.schemaHasRulesForType = schemaHasRulesForType;
	function shouldUseGroup(schema$1, group) {
		return group.rules.some((rule) => shouldUseRule(schema$1, rule));
	}
	exports.shouldUseGroup = shouldUseGroup;
	function shouldUseRule(schema$1, rule) {
		var _a$1;
		return schema$1[rule.keyword] !== void 0 || ((_a$1 = rule.definition.implements) === null || _a$1 === void 0 ? void 0 : _a$1.some((kwd) => schema$1[kwd] !== void 0));
	}
	exports.shouldUseRule = shouldUseRule;
}) });

//#endregion
//#region node_modules/ajv/dist/compile/validate/dataType.js
var require_dataType = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/compile/validate/dataType.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const rules_1$1 = require_rules();
	const applicability_1$1 = require_applicability();
	const errors_1$2 = require_errors();
	const codegen_1$31 = require_codegen();
	const util_1$28 = require_util();
	var DataType;
	(function(DataType$1) {
		DataType$1[DataType$1["Correct"] = 0] = "Correct";
		DataType$1[DataType$1["Wrong"] = 1] = "Wrong";
	})(DataType || (exports.DataType = DataType = {}));
	function getSchemaTypes(schema$1) {
		const types = getJSONTypes(schema$1.type);
		if (types.includes("null")) {
			if (schema$1.nullable === false) throw new Error("type: null contradicts nullable: false");
		} else {
			if (!types.length && schema$1.nullable !== void 0) throw new Error("\"nullable\" cannot be used without \"type\"");
			if (schema$1.nullable === true) types.push("null");
		}
		return types;
	}
	exports.getSchemaTypes = getSchemaTypes;
	function getJSONTypes(ts) {
		const types = Array.isArray(ts) ? ts : ts ? [ts] : [];
		if (types.every(rules_1$1.isJSONType)) return types;
		throw new Error("type must be JSONType or JSONType[]: " + types.join(","));
	}
	exports.getJSONTypes = getJSONTypes;
	function coerceAndCheckDataType(it, types) {
		const { gen, data, opts } = it;
		const coerceTo = coerceToTypes(types, opts.coerceTypes);
		const checkTypes = types.length > 0 && !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1$1.schemaHasRulesForType)(it, types[0]));
		if (checkTypes) {
			const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);
			gen.if(wrongType, () => {
				if (coerceTo.length) coerceData(it, types, coerceTo);
				else reportTypeError(it);
			});
		}
		return checkTypes;
	}
	exports.coerceAndCheckDataType = coerceAndCheckDataType;
	const COERCIBLE = new Set([
		"string",
		"number",
		"integer",
		"boolean",
		"null"
	]);
	function coerceToTypes(types, coerceTypes) {
		return coerceTypes ? types.filter((t$1) => COERCIBLE.has(t$1) || coerceTypes === "array" && t$1 === "array") : [];
	}
	function coerceData(it, types, coerceTo) {
		const { gen, data, opts } = it;
		const dataType = gen.let("dataType", (0, codegen_1$31._)`typeof ${data}`);
		const coerced = gen.let("coerced", (0, codegen_1$31._)`undefined`);
		if (opts.coerceTypes === "array") gen.if((0, codegen_1$31._)`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, (0, codegen_1$31._)`${data}[0]`).assign(dataType, (0, codegen_1$31._)`typeof ${data}`).if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data)));
		gen.if((0, codegen_1$31._)`${coerced} !== undefined`);
		for (const t$1 of coerceTo) if (COERCIBLE.has(t$1) || t$1 === "array" && opts.coerceTypes === "array") coerceSpecificType(t$1);
		gen.else();
		reportTypeError(it);
		gen.endIf();
		gen.if((0, codegen_1$31._)`${coerced} !== undefined`, () => {
			gen.assign(data, coerced);
			assignParentData(it, coerced);
		});
		function coerceSpecificType(t$1) {
			switch (t$1) {
				case "string":
					gen.elseIf((0, codegen_1$31._)`${dataType} == "number" || ${dataType} == "boolean"`).assign(coerced, (0, codegen_1$31._)`"" + ${data}`).elseIf((0, codegen_1$31._)`${data} === null`).assign(coerced, (0, codegen_1$31._)`""`);
					return;
				case "number":
					gen.elseIf((0, codegen_1$31._)`${dataType} == "boolean" || ${data} === null
              || (${dataType} == "string" && ${data} && ${data} == +${data})`).assign(coerced, (0, codegen_1$31._)`+${data}`);
					return;
				case "integer":
					gen.elseIf((0, codegen_1$31._)`${dataType} === "boolean" || ${data} === null
              || (${dataType} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, (0, codegen_1$31._)`+${data}`);
					return;
				case "boolean":
					gen.elseIf((0, codegen_1$31._)`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf((0, codegen_1$31._)`${data} === "true" || ${data} === 1`).assign(coerced, true);
					return;
				case "null":
					gen.elseIf((0, codegen_1$31._)`${data} === "" || ${data} === 0 || ${data} === false`);
					gen.assign(coerced, null);
					return;
				case "array": gen.elseIf((0, codegen_1$31._)`${dataType} === "string" || ${dataType} === "number"
              || ${dataType} === "boolean" || ${data} === null`).assign(coerced, (0, codegen_1$31._)`[${data}]`);
			}
		}
	}
	function assignParentData({ gen, parentData, parentDataProperty }, expr) {
		gen.if((0, codegen_1$31._)`${parentData} !== undefined`, () => gen.assign((0, codegen_1$31._)`${parentData}[${parentDataProperty}]`, expr));
	}
	function checkDataType(dataType, data, strictNums, correct = DataType.Correct) {
		const EQ = correct === DataType.Correct ? codegen_1$31.operators.EQ : codegen_1$31.operators.NEQ;
		let cond;
		switch (dataType) {
			case "null": return (0, codegen_1$31._)`${data} ${EQ} null`;
			case "array":
				cond = (0, codegen_1$31._)`Array.isArray(${data})`;
				break;
			case "object":
				cond = (0, codegen_1$31._)`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
				break;
			case "integer":
				cond = numCond((0, codegen_1$31._)`!(${data} % 1) && !isNaN(${data})`);
				break;
			case "number":
				cond = numCond();
				break;
			default: return (0, codegen_1$31._)`typeof ${data} ${EQ} ${dataType}`;
		}
		return correct === DataType.Correct ? cond : (0, codegen_1$31.not)(cond);
		function numCond(_cond = codegen_1$31.nil) {
			return (0, codegen_1$31.and)((0, codegen_1$31._)`typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1$31._)`isFinite(${data})` : codegen_1$31.nil);
		}
	}
	exports.checkDataType = checkDataType;
	function checkDataTypes(dataTypes, data, strictNums, correct) {
		if (dataTypes.length === 1) return checkDataType(dataTypes[0], data, strictNums, correct);
		let cond;
		const types = (0, util_1$28.toHash)(dataTypes);
		if (types.array && types.object) {
			const notObj = (0, codegen_1$31._)`typeof ${data} != "object"`;
			cond = types.null ? notObj : (0, codegen_1$31._)`!${data} || ${notObj}`;
			delete types.null;
			delete types.array;
			delete types.object;
		} else cond = codegen_1$31.nil;
		if (types.number) delete types.integer;
		for (const t$1 in types) cond = (0, codegen_1$31.and)(cond, checkDataType(t$1, data, strictNums, correct));
		return cond;
	}
	exports.checkDataTypes = checkDataTypes;
	const typeError = {
		message: ({ schema: schema$1 }) => `must be ${schema$1}`,
		params: ({ schema: schema$1, schemaValue }) => typeof schema$1 == "string" ? (0, codegen_1$31._)`{type: ${schema$1}}` : (0, codegen_1$31._)`{type: ${schemaValue}}`
	};
	function reportTypeError(it) {
		const cxt = getTypeErrorContext(it);
		(0, errors_1$2.reportError)(cxt, typeError);
	}
	exports.reportTypeError = reportTypeError;
	function getTypeErrorContext(it) {
		const { gen, data, schema: schema$1 } = it;
		const schemaCode = (0, util_1$28.schemaRefOrVal)(it, schema$1, "type");
		return {
			gen,
			keyword: "type",
			data,
			schema: schema$1.type,
			schemaCode,
			schemaValue: schemaCode,
			parentSchema: schema$1,
			params: {},
			it
		};
	}
}) });

//#endregion
//#region node_modules/ajv/dist/compile/validate/defaults.js
var require_defaults = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/compile/validate/defaults.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$30 = require_codegen();
	const util_1$27 = require_util();
	function assignDefaults(it, ty) {
		const { properties, items } = it.schema;
		if (ty === "object" && properties) for (const key in properties) assignDefault(it, key, properties[key].default);
		else if (ty === "array" && Array.isArray(items)) items.forEach((sch, i) => assignDefault(it, i, sch.default));
	}
	exports.assignDefaults = assignDefaults;
	function assignDefault(it, prop, defaultValue) {
		const { gen, compositeRule, data, opts } = it;
		if (defaultValue === void 0) return;
		const childData = (0, codegen_1$30._)`${data}${(0, codegen_1$30.getProperty)(prop)}`;
		if (compositeRule) {
			(0, util_1$27.checkStrictMode)(it, `default is ignored for: ${childData}`);
			return;
		}
		let condition = (0, codegen_1$30._)`${childData} === undefined`;
		if (opts.useDefaults === "empty") condition = (0, codegen_1$30._)`${condition} || ${childData} === null || ${childData} === ""`;
		gen.if(condition, (0, codegen_1$30._)`${childData} = ${(0, codegen_1$30.stringify)(defaultValue)}`);
	}
}) });

//#endregion
//#region node_modules/ajv/dist/vocabularies/code.js
var require_code = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/vocabularies/code.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$29 = require_codegen();
	const util_1$26 = require_util();
	const names_1$5 = require_names();
	const util_2$1 = require_util();
	function checkReportMissingProp(cxt, prop) {
		const { gen, data, it } = cxt;
		gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
			cxt.setParams({ missingProperty: (0, codegen_1$29._)`${prop}` }, true);
			cxt.error();
		});
	}
	exports.checkReportMissingProp = checkReportMissingProp;
	function checkMissingProp({ gen, data, it: { opts } }, properties, missing) {
		return (0, codegen_1$29.or)(...properties.map((prop) => (0, codegen_1$29.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1$29._)`${missing} = ${prop}`)));
	}
	exports.checkMissingProp = checkMissingProp;
	function reportMissingProp(cxt, missing) {
		cxt.setParams({ missingProperty: missing }, true);
		cxt.error();
	}
	exports.reportMissingProp = reportMissingProp;
	function hasPropFunc(gen) {
		return gen.scopeValue("func", {
			ref: Object.prototype.hasOwnProperty,
			code: (0, codegen_1$29._)`Object.prototype.hasOwnProperty`
		});
	}
	exports.hasPropFunc = hasPropFunc;
	function isOwnProperty(gen, data, property) {
		return (0, codegen_1$29._)`${hasPropFunc(gen)}.call(${data}, ${property})`;
	}
	exports.isOwnProperty = isOwnProperty;
	function propertyInData(gen, data, property, ownProperties) {
		const cond = (0, codegen_1$29._)`${data}${(0, codegen_1$29.getProperty)(property)} !== undefined`;
		return ownProperties ? (0, codegen_1$29._)`${cond} && ${isOwnProperty(gen, data, property)}` : cond;
	}
	exports.propertyInData = propertyInData;
	function noPropertyInData(gen, data, property, ownProperties) {
		const cond = (0, codegen_1$29._)`${data}${(0, codegen_1$29.getProperty)(property)} === undefined`;
		return ownProperties ? (0, codegen_1$29.or)(cond, (0, codegen_1$29.not)(isOwnProperty(gen, data, property))) : cond;
	}
	exports.noPropertyInData = noPropertyInData;
	function allSchemaProperties(schemaMap) {
		return schemaMap ? Object.keys(schemaMap).filter((p) => p !== "__proto__") : [];
	}
	exports.allSchemaProperties = allSchemaProperties;
	function schemaProperties(it, schemaMap) {
		return allSchemaProperties(schemaMap).filter((p) => !(0, util_1$26.alwaysValidSchema)(it, schemaMap[p]));
	}
	exports.schemaProperties = schemaProperties;
	function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {
		const dataAndSchema = passSchema ? (0, codegen_1$29._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
		const valCxt = [
			[names_1$5.default.instancePath, (0, codegen_1$29.strConcat)(names_1$5.default.instancePath, errorPath)],
			[names_1$5.default.parentData, it.parentData],
			[names_1$5.default.parentDataProperty, it.parentDataProperty],
			[names_1$5.default.rootData, names_1$5.default.rootData]
		];
		if (it.opts.dynamicRef) valCxt.push([names_1$5.default.dynamicAnchors, names_1$5.default.dynamicAnchors]);
		const args = (0, codegen_1$29._)`${dataAndSchema}, ${gen.object(...valCxt)}`;
		return context !== codegen_1$29.nil ? (0, codegen_1$29._)`${func}.call(${context}, ${args})` : (0, codegen_1$29._)`${func}(${args})`;
	}
	exports.callValidateCode = callValidateCode;
	const newRegExp = (0, codegen_1$29._)`new RegExp`;
	function usePattern({ gen, it: { opts } }, pattern) {
		const u = opts.unicodeRegExp ? "u" : "";
		const { regExp } = opts.code;
		const rx = regExp(pattern, u);
		return gen.scopeValue("pattern", {
			key: rx.toString(),
			ref: rx,
			code: (0, codegen_1$29._)`${regExp.code === "new RegExp" ? newRegExp : (0, util_2$1.useFunc)(gen, regExp)}(${pattern}, ${u})`
		});
	}
	exports.usePattern = usePattern;
	function validateArray(cxt) {
		const { gen, data, keyword, it } = cxt;
		const valid = gen.name("valid");
		if (it.allErrors) {
			const validArr = gen.let("valid", true);
			validateItems(() => gen.assign(validArr, false));
			return validArr;
		}
		gen.var(valid, true);
		validateItems(() => gen.break());
		return valid;
		function validateItems(notValid) {
			const len = gen.const("len", (0, codegen_1$29._)`${data}.length`);
			gen.forRange("i", 0, len, (i) => {
				cxt.subschema({
					keyword,
					dataProp: i,
					dataPropType: util_1$26.Type.Num
				}, valid);
				gen.if((0, codegen_1$29.not)(valid), notValid);
			});
		}
	}
	exports.validateArray = validateArray;
	function validateUnion(cxt) {
		const { gen, schema: schema$1, keyword, it } = cxt;
		/* istanbul ignore if */
		if (!Array.isArray(schema$1)) throw new Error("ajv implementation error");
		if (schema$1.some((sch) => (0, util_1$26.alwaysValidSchema)(it, sch)) && !it.opts.unevaluated) return;
		const valid = gen.let("valid", false);
		const schValid = gen.name("_valid");
		gen.block(() => schema$1.forEach((_sch, i) => {
			const schCxt = cxt.subschema({
				keyword,
				schemaProp: i,
				compositeRule: true
			}, schValid);
			gen.assign(valid, (0, codegen_1$29._)`${valid} || ${schValid}`);
			if (!cxt.mergeValidEvaluated(schCxt, schValid)) gen.if((0, codegen_1$29.not)(valid));
		}));
		cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
	}
	exports.validateUnion = validateUnion;
}) });

//#endregion
//#region node_modules/ajv/dist/compile/validate/keyword.js
var require_keyword = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/compile/validate/keyword.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$28 = require_codegen();
	const names_1$4 = require_names();
	const code_1$9 = require_code();
	const errors_1$1 = require_errors();
	function macroKeywordCode(cxt, def$30) {
		const { gen, keyword, schema: schema$1, parentSchema, it } = cxt;
		const macroSchema = def$30.macro.call(it.self, schema$1, parentSchema, it);
		const schemaRef = useKeyword(gen, keyword, macroSchema);
		if (it.opts.validateSchema !== false) it.self.validateSchema(macroSchema, true);
		const valid = gen.name("valid");
		cxt.subschema({
			schema: macroSchema,
			schemaPath: codegen_1$28.nil,
			errSchemaPath: `${it.errSchemaPath}/${keyword}`,
			topSchemaRef: schemaRef,
			compositeRule: true
		}, valid);
		cxt.pass(valid, () => cxt.error(true));
	}
	exports.macroKeywordCode = macroKeywordCode;
	function funcKeywordCode(cxt, def$30) {
		var _a$1;
		const { gen, keyword, schema: schema$1, parentSchema, $data, it } = cxt;
		checkAsyncKeyword(it, def$30);
		const validateRef = useKeyword(gen, keyword, !$data && def$30.compile ? def$30.compile.call(it.self, schema$1, parentSchema, it) : def$30.validate);
		const valid = gen.let("valid");
		cxt.block$data(valid, validateKeyword);
		cxt.ok((_a$1 = def$30.valid) !== null && _a$1 !== void 0 ? _a$1 : valid);
		function validateKeyword() {
			if (def$30.errors === false) {
				assignValid();
				if (def$30.modifying) modifyData(cxt);
				reportErrs(() => cxt.error());
			} else {
				const ruleErrs = def$30.async ? validateAsync() : validateSync();
				if (def$30.modifying) modifyData(cxt);
				reportErrs(() => addErrs(cxt, ruleErrs));
			}
		}
		function validateAsync() {
			const ruleErrs = gen.let("ruleErrs", null);
			gen.try(() => assignValid((0, codegen_1$28._)`await `), (e) => gen.assign(valid, false).if((0, codegen_1$28._)`${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1$28._)`${e}.errors`), () => gen.throw(e)));
			return ruleErrs;
		}
		function validateSync() {
			const validateErrs = (0, codegen_1$28._)`${validateRef}.errors`;
			gen.assign(validateErrs, null);
			assignValid(codegen_1$28.nil);
			return validateErrs;
		}
		function assignValid(_await = def$30.async ? (0, codegen_1$28._)`await ` : codegen_1$28.nil) {
			const passCxt = it.opts.passContext ? names_1$4.default.this : names_1$4.default.self;
			const passSchema = !("compile" in def$30 && !$data || def$30.schema === false);
			gen.assign(valid, (0, codegen_1$28._)`${_await}${(0, code_1$9.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def$30.modifying);
		}
		function reportErrs(errors$1) {
			var _a$2;
			gen.if((0, codegen_1$28.not)((_a$2 = def$30.valid) !== null && _a$2 !== void 0 ? _a$2 : valid), errors$1);
		}
	}
	exports.funcKeywordCode = funcKeywordCode;
	function modifyData(cxt) {
		const { gen, data, it } = cxt;
		gen.if(it.parentData, () => gen.assign(data, (0, codegen_1$28._)`${it.parentData}[${it.parentDataProperty}]`));
	}
	function addErrs(cxt, errs) {
		const { gen } = cxt;
		gen.if((0, codegen_1$28._)`Array.isArray(${errs})`, () => {
			gen.assign(names_1$4.default.vErrors, (0, codegen_1$28._)`${names_1$4.default.vErrors} === null ? ${errs} : ${names_1$4.default.vErrors}.concat(${errs})`).assign(names_1$4.default.errors, (0, codegen_1$28._)`${names_1$4.default.vErrors}.length`);
			(0, errors_1$1.extendErrors)(cxt);
		}, () => cxt.error());
	}
	function checkAsyncKeyword({ schemaEnv }, def$30) {
		if (def$30.async && !schemaEnv.$async) throw new Error("async keyword in sync schema");
	}
	function useKeyword(gen, keyword, result) {
		if (result === void 0) throw new Error(`keyword "${keyword}" failed to compile`);
		return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : {
			ref: result,
			code: (0, codegen_1$28.stringify)(result)
		});
	}
	function validSchemaType(schema$1, schemaType, allowUndefined = false) {
		return !schemaType.length || schemaType.some((st) => st === "array" ? Array.isArray(schema$1) : st === "object" ? schema$1 && typeof schema$1 == "object" && !Array.isArray(schema$1) : typeof schema$1 == st || allowUndefined && typeof schema$1 == "undefined");
	}
	exports.validSchemaType = validSchemaType;
	function validateKeywordUsage({ schema: schema$1, opts, self, errSchemaPath }, def$30, keyword) {
		/* istanbul ignore if */
		if (Array.isArray(def$30.keyword) ? !def$30.keyword.includes(keyword) : def$30.keyword !== keyword) throw new Error("ajv implementation error");
		const deps = def$30.dependencies;
		if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema$1, kwd))) throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(",")}`);
		if (def$30.validateSchema) {
			if (!def$30.validateSchema(schema$1[keyword])) {
				const msg = `keyword "${keyword}" value is invalid at path "${errSchemaPath}": ` + self.errorsText(def$30.validateSchema.errors);
				if (opts.validateSchema === "log") self.logger.error(msg);
				else throw new Error(msg);
			}
		}
	}
	exports.validateKeywordUsage = validateKeywordUsage;
}) });

//#endregion
//#region node_modules/ajv/dist/compile/validate/subschema.js
var require_subschema = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/compile/validate/subschema.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$27 = require_codegen();
	const util_1$25 = require_util();
	function getSubschema(it, { keyword, schemaProp, schema: schema$1, schemaPath, errSchemaPath, topSchemaRef }) {
		if (keyword !== void 0 && schema$1 !== void 0) throw new Error("both \"keyword\" and \"schema\" passed, only one allowed");
		if (keyword !== void 0) {
			const sch = it.schema[keyword];
			return schemaProp === void 0 ? {
				schema: sch,
				schemaPath: (0, codegen_1$27._)`${it.schemaPath}${(0, codegen_1$27.getProperty)(keyword)}`,
				errSchemaPath: `${it.errSchemaPath}/${keyword}`
			} : {
				schema: sch[schemaProp],
				schemaPath: (0, codegen_1$27._)`${it.schemaPath}${(0, codegen_1$27.getProperty)(keyword)}${(0, codegen_1$27.getProperty)(schemaProp)}`,
				errSchemaPath: `${it.errSchemaPath}/${keyword}/${(0, util_1$25.escapeFragment)(schemaProp)}`
			};
		}
		if (schema$1 !== void 0) {
			if (schemaPath === void 0 || errSchemaPath === void 0 || topSchemaRef === void 0) throw new Error("\"schemaPath\", \"errSchemaPath\" and \"topSchemaRef\" are required with \"schema\"");
			return {
				schema: schema$1,
				schemaPath,
				topSchemaRef,
				errSchemaPath
			};
		}
		throw new Error("either \"keyword\" or \"schema\" must be passed");
	}
	exports.getSubschema = getSubschema;
	function extendSubschemaData(subschema, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
		if (data !== void 0 && dataProp !== void 0) throw new Error("both \"data\" and \"dataProp\" passed, only one allowed");
		const { gen } = it;
		if (dataProp !== void 0) {
			const { errorPath, dataPathArr, opts } = it;
			dataContextProps(gen.let("data", (0, codegen_1$27._)`${it.data}${(0, codegen_1$27.getProperty)(dataProp)}`, true));
			subschema.errorPath = (0, codegen_1$27.str)`${errorPath}${(0, util_1$25.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
			subschema.parentDataProperty = (0, codegen_1$27._)`${dataProp}`;
			subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];
		}
		if (data !== void 0) {
			dataContextProps(data instanceof codegen_1$27.Name ? data : gen.let("data", data, true));
			if (propertyName !== void 0) subschema.propertyName = propertyName;
		}
		if (dataTypes) subschema.dataTypes = dataTypes;
		function dataContextProps(_nextData) {
			subschema.data = _nextData;
			subschema.dataLevel = it.dataLevel + 1;
			subschema.dataTypes = [];
			it.definedProperties = /* @__PURE__ */ new Set();
			subschema.parentData = it.data;
			subschema.dataNames = [...it.dataNames, _nextData];
		}
	}
	exports.extendSubschemaData = extendSubschemaData;
	function extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
		if (compositeRule !== void 0) subschema.compositeRule = compositeRule;
		if (createErrors !== void 0) subschema.createErrors = createErrors;
		if (allErrors !== void 0) subschema.allErrors = allErrors;
		subschema.jtdDiscriminator = jtdDiscriminator;
		subschema.jtdMetadata = jtdMetadata;
	}
	exports.extendSubschemaMode = extendSubschemaMode;
}) });

//#endregion
//#region node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = /* @__PURE__ */ __commonJS$2({ "node_modules/fast-deep-equal/index.js": ((exports, module) => {
	module.exports = function equal$3(a, b) {
		if (a === b) return true;
		if (a && b && typeof a == "object" && typeof b == "object") {
			if (a.constructor !== b.constructor) return false;
			var length, i, keys;
			if (Array.isArray(a)) {
				length = a.length;
				if (length != b.length) return false;
				for (i = length; i-- !== 0;) if (!equal$3(a[i], b[i])) return false;
				return true;
			}
			if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
			if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
			if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
			keys = Object.keys(a);
			length = keys.length;
			if (length !== Object.keys(b).length) return false;
			for (i = length; i-- !== 0;) if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
			for (i = length; i-- !== 0;) {
				var key = keys[i];
				if (!equal$3(a[key], b[key])) return false;
			}
			return true;
		}
		return a !== a && b !== b;
	};
}) });

//#endregion
//#region node_modules/json-schema-traverse/index.js
var require_json_schema_traverse = /* @__PURE__ */ __commonJS$2({ "node_modules/json-schema-traverse/index.js": ((exports, module) => {
	var traverse$1 = module.exports = function(schema$1, opts, cb) {
		if (typeof opts == "function") {
			cb = opts;
			opts = {};
		}
		cb = opts.cb || cb;
		var pre = typeof cb == "function" ? cb : cb.pre || function() {};
		var post = cb.post || function() {};
		_traverse(opts, pre, post, schema$1, "", schema$1);
	};
	traverse$1.keywords = {
		additionalItems: true,
		items: true,
		contains: true,
		additionalProperties: true,
		propertyNames: true,
		not: true,
		if: true,
		then: true,
		else: true
	};
	traverse$1.arrayKeywords = {
		items: true,
		allOf: true,
		anyOf: true,
		oneOf: true
	};
	traverse$1.propsKeywords = {
		$defs: true,
		definitions: true,
		properties: true,
		patternProperties: true,
		dependencies: true
	};
	traverse$1.skipKeywords = {
		default: true,
		enum: true,
		const: true,
		required: true,
		maximum: true,
		minimum: true,
		exclusiveMaximum: true,
		exclusiveMinimum: true,
		multipleOf: true,
		maxLength: true,
		minLength: true,
		pattern: true,
		format: true,
		maxItems: true,
		minItems: true,
		uniqueItems: true,
		maxProperties: true,
		minProperties: true
	};
	function _traverse(opts, pre, post, schema$1, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
		if (schema$1 && typeof schema$1 == "object" && !Array.isArray(schema$1)) {
			pre(schema$1, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
			for (var key in schema$1) {
				var sch = schema$1[key];
				if (Array.isArray(sch)) {
					if (key in traverse$1.arrayKeywords) for (var i = 0; i < sch.length; i++) _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema$1, i);
				} else if (key in traverse$1.propsKeywords) {
					if (sch && typeof sch == "object") for (var prop in sch) _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema$1, prop);
				} else if (key in traverse$1.keywords || opts.allKeys && !(key in traverse$1.skipKeywords)) _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema$1);
			}
			post(schema$1, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
		}
	}
	function escapeJsonPtr(str$1) {
		return str$1.replace(/~/g, "~0").replace(/\//g, "~1");
	}
}) });

//#endregion
//#region node_modules/ajv/dist/compile/resolve.js
var require_resolve = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/compile/resolve.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const util_1$24 = require_util();
	const equal$2 = require_fast_deep_equal();
	const traverse = require_json_schema_traverse();
	const SIMPLE_INLINED = new Set([
		"type",
		"format",
		"pattern",
		"maxLength",
		"minLength",
		"maxProperties",
		"minProperties",
		"maxItems",
		"minItems",
		"maximum",
		"minimum",
		"uniqueItems",
		"multipleOf",
		"required",
		"enum",
		"const"
	]);
	function inlineRef(schema$1, limit = true) {
		if (typeof schema$1 == "boolean") return true;
		if (limit === true) return !hasRef(schema$1);
		if (!limit) return false;
		return countKeys(schema$1) <= limit;
	}
	exports.inlineRef = inlineRef;
	const REF_KEYWORDS = new Set([
		"$ref",
		"$recursiveRef",
		"$recursiveAnchor",
		"$dynamicRef",
		"$dynamicAnchor"
	]);
	function hasRef(schema$1) {
		for (const key in schema$1) {
			if (REF_KEYWORDS.has(key)) return true;
			const sch = schema$1[key];
			if (Array.isArray(sch) && sch.some(hasRef)) return true;
			if (typeof sch == "object" && hasRef(sch)) return true;
		}
		return false;
	}
	function countKeys(schema$1) {
		let count = 0;
		for (const key in schema$1) {
			if (key === "$ref") return Infinity;
			count++;
			if (SIMPLE_INLINED.has(key)) continue;
			if (typeof schema$1[key] == "object") (0, util_1$24.eachItem)(schema$1[key], (sch) => count += countKeys(sch));
			if (count === Infinity) return Infinity;
		}
		return count;
	}
	function getFullPath(resolver, id = "", normalize$1) {
		if (normalize$1 !== false) id = normalizeId(id);
		return _getFullPath(resolver, resolver.parse(id));
	}
	exports.getFullPath = getFullPath;
	function _getFullPath(resolver, p) {
		return resolver.serialize(p).split("#")[0] + "#";
	}
	exports._getFullPath = _getFullPath;
	const TRAILING_SLASH_HASH = /#\/?$/;
	function normalizeId(id) {
		return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
	}
	exports.normalizeId = normalizeId;
	function resolveUrl(resolver, baseId, id) {
		id = normalizeId(id);
		return resolver.resolve(baseId, id);
	}
	exports.resolveUrl = resolveUrl;
	const ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
	function getSchemaRefs(schema$1, baseId) {
		if (typeof schema$1 == "boolean") return {};
		const { schemaId, uriResolver } = this.opts;
		const schId = normalizeId(schema$1[schemaId] || baseId);
		const baseIds = { "": schId };
		const pathPrefix = getFullPath(uriResolver, schId, false);
		const localRefs = {};
		const schemaRefs = /* @__PURE__ */ new Set();
		traverse(schema$1, { allKeys: true }, (sch, jsonPtr, _$1, parentJsonPtr) => {
			if (parentJsonPtr === void 0) return;
			const fullPath = pathPrefix + jsonPtr;
			let innerBaseId = baseIds[parentJsonPtr];
			if (typeof sch[schemaId] == "string") innerBaseId = addRef.call(this, sch[schemaId]);
			addAnchor.call(this, sch.$anchor);
			addAnchor.call(this, sch.$dynamicAnchor);
			baseIds[jsonPtr] = innerBaseId;
			function addRef(ref) {
				const _resolve = this.opts.uriResolver.resolve;
				ref = normalizeId(innerBaseId ? _resolve(innerBaseId, ref) : ref);
				if (schemaRefs.has(ref)) throw ambiguos(ref);
				schemaRefs.add(ref);
				let schOrRef = this.refs[ref];
				if (typeof schOrRef == "string") schOrRef = this.refs[schOrRef];
				if (typeof schOrRef == "object") checkAmbiguosRef(sch, schOrRef.schema, ref);
				else if (ref !== normalizeId(fullPath)) if (ref[0] === "#") {
					checkAmbiguosRef(sch, localRefs[ref], ref);
					localRefs[ref] = sch;
				} else this.refs[ref] = fullPath;
				return ref;
			}
			function addAnchor(anchor) {
				if (typeof anchor == "string") {
					if (!ANCHOR.test(anchor)) throw new Error(`invalid anchor "${anchor}"`);
					addRef.call(this, `#${anchor}`);
				}
			}
		});
		return localRefs;
		function checkAmbiguosRef(sch1, sch2, ref) {
			if (sch2 !== void 0 && !equal$2(sch1, sch2)) throw ambiguos(ref);
		}
		function ambiguos(ref) {
			return /* @__PURE__ */ new Error(`reference "${ref}" resolves to more than one schema`);
		}
	}
	exports.getSchemaRefs = getSchemaRefs;
}) });

//#endregion
//#region node_modules/ajv/dist/compile/validate/index.js
var require_validate = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/compile/validate/index.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const boolSchema_1 = require_boolSchema();
	const dataType_1$2 = require_dataType();
	const applicability_1 = require_applicability();
	const dataType_2 = require_dataType();
	const defaults_1 = require_defaults();
	const keyword_1 = require_keyword();
	const subschema_1 = require_subschema();
	const codegen_1$26 = require_codegen();
	const names_1$3 = require_names();
	const resolve_1$3 = require_resolve();
	const util_1$23 = require_util();
	const errors_1 = require_errors();
	function validateFunctionCode(it) {
		if (isSchemaObj(it)) {
			checkKeywords(it);
			if (schemaCxtHasRules(it)) {
				topSchemaObjCode(it);
				return;
			}
		}
		validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));
	}
	exports.validateFunctionCode = validateFunctionCode;
	function validateFunction({ gen, validateName, schema: schema$1, schemaEnv, opts }, body) {
		if (opts.code.es5) gen.func(validateName, (0, codegen_1$26._)`${names_1$3.default.data}, ${names_1$3.default.valCxt}`, schemaEnv.$async, () => {
			gen.code((0, codegen_1$26._)`"use strict"; ${funcSourceUrl(schema$1, opts)}`);
			destructureValCxtES5(gen, opts);
			gen.code(body);
		});
		else gen.func(validateName, (0, codegen_1$26._)`${names_1$3.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema$1, opts)).code(body));
	}
	function destructureValCxt(opts) {
		return (0, codegen_1$26._)`{${names_1$3.default.instancePath}="", ${names_1$3.default.parentData}, ${names_1$3.default.parentDataProperty}, ${names_1$3.default.rootData}=${names_1$3.default.data}${opts.dynamicRef ? (0, codegen_1$26._)`, ${names_1$3.default.dynamicAnchors}={}` : codegen_1$26.nil}}={}`;
	}
	function destructureValCxtES5(gen, opts) {
		gen.if(names_1$3.default.valCxt, () => {
			gen.var(names_1$3.default.instancePath, (0, codegen_1$26._)`${names_1$3.default.valCxt}.${names_1$3.default.instancePath}`);
			gen.var(names_1$3.default.parentData, (0, codegen_1$26._)`${names_1$3.default.valCxt}.${names_1$3.default.parentData}`);
			gen.var(names_1$3.default.parentDataProperty, (0, codegen_1$26._)`${names_1$3.default.valCxt}.${names_1$3.default.parentDataProperty}`);
			gen.var(names_1$3.default.rootData, (0, codegen_1$26._)`${names_1$3.default.valCxt}.${names_1$3.default.rootData}`);
			if (opts.dynamicRef) gen.var(names_1$3.default.dynamicAnchors, (0, codegen_1$26._)`${names_1$3.default.valCxt}.${names_1$3.default.dynamicAnchors}`);
		}, () => {
			gen.var(names_1$3.default.instancePath, (0, codegen_1$26._)`""`);
			gen.var(names_1$3.default.parentData, (0, codegen_1$26._)`undefined`);
			gen.var(names_1$3.default.parentDataProperty, (0, codegen_1$26._)`undefined`);
			gen.var(names_1$3.default.rootData, names_1$3.default.data);
			if (opts.dynamicRef) gen.var(names_1$3.default.dynamicAnchors, (0, codegen_1$26._)`{}`);
		});
	}
	function topSchemaObjCode(it) {
		const { schema: schema$1, opts, gen } = it;
		validateFunction(it, () => {
			if (opts.$comment && schema$1.$comment) commentKeyword(it);
			checkNoDefault(it);
			gen.let(names_1$3.default.vErrors, null);
			gen.let(names_1$3.default.errors, 0);
			if (opts.unevaluated) resetEvaluated(it);
			typeAndKeywords(it);
			returnResults(it);
		});
	}
	function resetEvaluated(it) {
		const { gen, validateName } = it;
		it.evaluated = gen.const("evaluated", (0, codegen_1$26._)`${validateName}.evaluated`);
		gen.if((0, codegen_1$26._)`${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1$26._)`${it.evaluated}.props`, (0, codegen_1$26._)`undefined`));
		gen.if((0, codegen_1$26._)`${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1$26._)`${it.evaluated}.items`, (0, codegen_1$26._)`undefined`));
	}
	function funcSourceUrl(schema$1, opts) {
		const schId = typeof schema$1 == "object" && schema$1[opts.schemaId];
		return schId && (opts.code.source || opts.code.process) ? (0, codegen_1$26._)`/*# sourceURL=${schId} */` : codegen_1$26.nil;
	}
	function subschemaCode(it, valid) {
		if (isSchemaObj(it)) {
			checkKeywords(it);
			if (schemaCxtHasRules(it)) {
				subSchemaObjCode(it, valid);
				return;
			}
		}
		(0, boolSchema_1.boolOrEmptySchema)(it, valid);
	}
	function schemaCxtHasRules({ schema: schema$1, self }) {
		if (typeof schema$1 == "boolean") return !schema$1;
		for (const key in schema$1) if (self.RULES.all[key]) return true;
		return false;
	}
	function isSchemaObj(it) {
		return typeof it.schema != "boolean";
	}
	function subSchemaObjCode(it, valid) {
		const { schema: schema$1, gen, opts } = it;
		if (opts.$comment && schema$1.$comment) commentKeyword(it);
		updateContext(it);
		checkAsyncSchema(it);
		const errsCount = gen.const("_errs", names_1$3.default.errors);
		typeAndKeywords(it, errsCount);
		gen.var(valid, (0, codegen_1$26._)`${errsCount} === ${names_1$3.default.errors}`);
	}
	function checkKeywords(it) {
		(0, util_1$23.checkUnknownRules)(it);
		checkRefsAndKeywords(it);
	}
	function typeAndKeywords(it, errsCount) {
		if (it.opts.jtd) return schemaKeywords(it, [], false, errsCount);
		const types = (0, dataType_1$2.getSchemaTypes)(it.schema);
		schemaKeywords(it, types, !(0, dataType_1$2.coerceAndCheckDataType)(it, types), errsCount);
	}
	function checkRefsAndKeywords(it) {
		const { schema: schema$1, errSchemaPath, opts, self } = it;
		if (schema$1.$ref && opts.ignoreKeywordsWithRef && (0, util_1$23.schemaHasRulesButRef)(schema$1, self.RULES)) self.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
	}
	function checkNoDefault(it) {
		const { schema: schema$1, opts } = it;
		if (schema$1.default !== void 0 && opts.useDefaults && opts.strictSchema) (0, util_1$23.checkStrictMode)(it, "default is ignored in the schema root");
	}
	function updateContext(it) {
		const schId = it.schema[it.opts.schemaId];
		if (schId) it.baseId = (0, resolve_1$3.resolveUrl)(it.opts.uriResolver, it.baseId, schId);
	}
	function checkAsyncSchema(it) {
		if (it.schema.$async && !it.schemaEnv.$async) throw new Error("async schema in sync schema");
	}
	function commentKeyword({ gen, schemaEnv, schema: schema$1, errSchemaPath, opts }) {
		const msg = schema$1.$comment;
		if (opts.$comment === true) gen.code((0, codegen_1$26._)`${names_1$3.default.self}.logger.log(${msg})`);
		else if (typeof opts.$comment == "function") {
			const schemaPath = (0, codegen_1$26.str)`${errSchemaPath}/$comment`;
			const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
			gen.code((0, codegen_1$26._)`${names_1$3.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
		}
	}
	function returnResults(it) {
		const { gen, schemaEnv, validateName, ValidationError: ValidationError$1, opts } = it;
		if (schemaEnv.$async) gen.if((0, codegen_1$26._)`${names_1$3.default.errors} === 0`, () => gen.return(names_1$3.default.data), () => gen.throw((0, codegen_1$26._)`new ${ValidationError$1}(${names_1$3.default.vErrors})`));
		else {
			gen.assign((0, codegen_1$26._)`${validateName}.errors`, names_1$3.default.vErrors);
			if (opts.unevaluated) assignEvaluated(it);
			gen.return((0, codegen_1$26._)`${names_1$3.default.errors} === 0`);
		}
	}
	function assignEvaluated({ gen, evaluated, props, items }) {
		if (props instanceof codegen_1$26.Name) gen.assign((0, codegen_1$26._)`${evaluated}.props`, props);
		if (items instanceof codegen_1$26.Name) gen.assign((0, codegen_1$26._)`${evaluated}.items`, items);
	}
	function schemaKeywords(it, types, typeErrors, errsCount) {
		const { gen, schema: schema$1, data, allErrors, opts, self } = it;
		const { RULES } = self;
		if (schema$1.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1$23.schemaHasRulesButRef)(schema$1, RULES))) {
			gen.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition));
			return;
		}
		if (!opts.jtd) checkStrictTypes(it, types);
		gen.block(() => {
			for (const group of RULES.rules) groupKeywords(group);
			groupKeywords(RULES.post);
		});
		function groupKeywords(group) {
			if (!(0, applicability_1.shouldUseGroup)(schema$1, group)) return;
			if (group.type) {
				gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));
				iterateKeywords(it, group);
				if (types.length === 1 && types[0] === group.type && typeErrors) {
					gen.else();
					(0, dataType_2.reportTypeError)(it);
				}
				gen.endIf();
			} else iterateKeywords(it, group);
			if (!allErrors) gen.if((0, codegen_1$26._)`${names_1$3.default.errors} === ${errsCount || 0}`);
		}
	}
	function iterateKeywords(it, group) {
		const { gen, schema: schema$1, opts: { useDefaults } } = it;
		if (useDefaults) (0, defaults_1.assignDefaults)(it, group.type);
		gen.block(() => {
			for (const rule of group.rules) if ((0, applicability_1.shouldUseRule)(schema$1, rule)) keywordCode(it, rule.keyword, rule.definition, group.type);
		});
	}
	function checkStrictTypes(it, types) {
		if (it.schemaEnv.meta || !it.opts.strictTypes) return;
		checkContextTypes(it, types);
		if (!it.opts.allowUnionTypes) checkMultipleTypes(it, types);
		checkKeywordTypes(it, it.dataTypes);
	}
	function checkContextTypes(it, types) {
		if (!types.length) return;
		if (!it.dataTypes.length) {
			it.dataTypes = types;
			return;
		}
		types.forEach((t$1) => {
			if (!includesType(it.dataTypes, t$1)) strictTypesError(it, `type "${t$1}" not allowed by context "${it.dataTypes.join(",")}"`);
		});
		narrowSchemaTypes(it, types);
	}
	function checkMultipleTypes(it, ts) {
		if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) strictTypesError(it, "use allowUnionTypes to allow union type keyword");
	}
	function checkKeywordTypes(it, ts) {
		const rules = it.self.RULES.all;
		for (const keyword in rules) {
			const rule = rules[keyword];
			if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {
				const { type } = rule.definition;
				if (type.length && !type.some((t$1) => hasApplicableType(ts, t$1))) strictTypesError(it, `missing type "${type.join(",")}" for keyword "${keyword}"`);
			}
		}
	}
	function hasApplicableType(schTs, kwdT) {
		return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
	}
	function includesType(ts, t$1) {
		return ts.includes(t$1) || t$1 === "integer" && ts.includes("number");
	}
	function narrowSchemaTypes(it, withTypes) {
		const ts = [];
		for (const t$1 of it.dataTypes) if (includesType(withTypes, t$1)) ts.push(t$1);
		else if (withTypes.includes("integer") && t$1 === "number") ts.push("integer");
		it.dataTypes = ts;
	}
	function strictTypesError(it, msg) {
		const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
		msg += ` at "${schemaPath}" (strictTypes)`;
		(0, util_1$23.checkStrictMode)(it, msg, it.opts.strictTypes);
	}
	var KeywordCxt = class {
		constructor(it, def$30, keyword) {
			(0, keyword_1.validateKeywordUsage)(it, def$30, keyword);
			this.gen = it.gen;
			this.allErrors = it.allErrors;
			this.keyword = keyword;
			this.data = it.data;
			this.schema = it.schema[keyword];
			this.$data = def$30.$data && it.opts.$data && this.schema && this.schema.$data;
			this.schemaValue = (0, util_1$23.schemaRefOrVal)(it, this.schema, keyword, this.$data);
			this.schemaType = def$30.schemaType;
			this.parentSchema = it.schema;
			this.params = {};
			this.it = it;
			this.def = def$30;
			if (this.$data) this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
			else {
				this.schemaCode = this.schemaValue;
				if (!(0, keyword_1.validSchemaType)(this.schema, def$30.schemaType, def$30.allowUndefined)) throw new Error(`${keyword} value must be ${JSON.stringify(def$30.schemaType)}`);
			}
			if ("code" in def$30 ? def$30.trackErrors : def$30.errors !== false) this.errsCount = it.gen.const("_errs", names_1$3.default.errors);
		}
		result(condition, successAction, failAction) {
			this.failResult((0, codegen_1$26.not)(condition), successAction, failAction);
		}
		failResult(condition, successAction, failAction) {
			this.gen.if(condition);
			if (failAction) failAction();
			else this.error();
			if (successAction) {
				this.gen.else();
				successAction();
				if (this.allErrors) this.gen.endIf();
			} else if (this.allErrors) this.gen.endIf();
			else this.gen.else();
		}
		pass(condition, failAction) {
			this.failResult((0, codegen_1$26.not)(condition), void 0, failAction);
		}
		fail(condition) {
			if (condition === void 0) {
				this.error();
				if (!this.allErrors) this.gen.if(false);
				return;
			}
			this.gen.if(condition);
			this.error();
			if (this.allErrors) this.gen.endIf();
			else this.gen.else();
		}
		fail$data(condition) {
			if (!this.$data) return this.fail(condition);
			const { schemaCode } = this;
			this.fail((0, codegen_1$26._)`${schemaCode} !== undefined && (${(0, codegen_1$26.or)(this.invalid$data(), condition)})`);
		}
		error(append, errorParams, errorPaths) {
			if (errorParams) {
				this.setParams(errorParams);
				this._error(append, errorPaths);
				this.setParams({});
				return;
			}
			this._error(append, errorPaths);
		}
		_error(append, errorPaths) {
			(append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
		}
		$dataError() {
			(0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
		}
		reset() {
			if (this.errsCount === void 0) throw new Error("add \"trackErrors\" to keyword definition");
			(0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
		}
		ok(cond) {
			if (!this.allErrors) this.gen.if(cond);
		}
		setParams(obj, assign) {
			if (assign) Object.assign(this.params, obj);
			else this.params = obj;
		}
		block$data(valid, codeBlock, $dataValid = codegen_1$26.nil) {
			this.gen.block(() => {
				this.check$data(valid, $dataValid);
				codeBlock();
			});
		}
		check$data(valid = codegen_1$26.nil, $dataValid = codegen_1$26.nil) {
			if (!this.$data) return;
			const { gen, schemaCode, schemaType, def: def$30 } = this;
			gen.if((0, codegen_1$26.or)((0, codegen_1$26._)`${schemaCode} === undefined`, $dataValid));
			if (valid !== codegen_1$26.nil) gen.assign(valid, true);
			if (schemaType.length || def$30.validateSchema) {
				gen.elseIf(this.invalid$data());
				this.$dataError();
				if (valid !== codegen_1$26.nil) gen.assign(valid, false);
			}
			gen.else();
		}
		invalid$data() {
			const { gen, schemaCode, schemaType, def: def$30, it } = this;
			return (0, codegen_1$26.or)(wrong$DataType(), invalid$DataSchema());
			function wrong$DataType() {
				if (schemaType.length) {
					/* istanbul ignore if */
					if (!(schemaCode instanceof codegen_1$26.Name)) throw new Error("ajv implementation error");
					const st = Array.isArray(schemaType) ? schemaType : [schemaType];
					return (0, codegen_1$26._)`${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
				}
				return codegen_1$26.nil;
			}
			function invalid$DataSchema() {
				if (def$30.validateSchema) {
					const validateSchemaRef = gen.scopeValue("validate$data", { ref: def$30.validateSchema });
					return (0, codegen_1$26._)`!${validateSchemaRef}(${schemaCode})`;
				}
				return codegen_1$26.nil;
			}
		}
		subschema(appl, valid) {
			const subschema = (0, subschema_1.getSubschema)(this.it, appl);
			(0, subschema_1.extendSubschemaData)(subschema, this.it, appl);
			(0, subschema_1.extendSubschemaMode)(subschema, appl);
			const nextContext = {
				...this.it,
				...subschema,
				items: void 0,
				props: void 0
			};
			subschemaCode(nextContext, valid);
			return nextContext;
		}
		mergeEvaluated(schemaCxt, toName) {
			const { it, gen } = this;
			if (!it.opts.unevaluated) return;
			if (it.props !== true && schemaCxt.props !== void 0) it.props = util_1$23.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);
			if (it.items !== true && schemaCxt.items !== void 0) it.items = util_1$23.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);
		}
		mergeValidEvaluated(schemaCxt, valid) {
			const { it, gen } = this;
			if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
				gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1$26.Name));
				return true;
			}
		}
	};
	exports.KeywordCxt = KeywordCxt;
	function keywordCode(it, keyword, def$30, ruleType) {
		const cxt = new KeywordCxt(it, def$30, keyword);
		if ("code" in def$30) def$30.code(cxt, ruleType);
		else if (cxt.$data && def$30.validate) (0, keyword_1.funcKeywordCode)(cxt, def$30);
		else if ("macro" in def$30) (0, keyword_1.macroKeywordCode)(cxt, def$30);
		else if (def$30.compile || def$30.validate) (0, keyword_1.funcKeywordCode)(cxt, def$30);
	}
	const JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
	const RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
	function getData($data, { dataLevel, dataNames, dataPathArr }) {
		let jsonPointer;
		let data;
		if ($data === "") return names_1$3.default.rootData;
		if ($data[0] === "/") {
			if (!JSON_POINTER.test($data)) throw new Error(`Invalid JSON-pointer: ${$data}`);
			jsonPointer = $data;
			data = names_1$3.default.rootData;
		} else {
			const matches = RELATIVE_JSON_POINTER.exec($data);
			if (!matches) throw new Error(`Invalid JSON-pointer: ${$data}`);
			const up = +matches[1];
			jsonPointer = matches[2];
			if (jsonPointer === "#") {
				if (up >= dataLevel) throw new Error(errorMsg("property/index", up));
				return dataPathArr[dataLevel - up];
			}
			if (up > dataLevel) throw new Error(errorMsg("data", up));
			data = dataNames[dataLevel - up];
			if (!jsonPointer) return data;
		}
		let expr = data;
		const segments = jsonPointer.split("/");
		for (const segment of segments) if (segment) {
			data = (0, codegen_1$26._)`${data}${(0, codegen_1$26.getProperty)((0, util_1$23.unescapeJsonPointer)(segment))}`;
			expr = (0, codegen_1$26._)`${expr} && ${data}`;
		}
		return expr;
		function errorMsg(pointerType, up) {
			return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
		}
	}
	exports.getData = getData;
}) });

//#endregion
//#region node_modules/ajv/dist/runtime/validation_error.js
var require_validation_error = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/runtime/validation_error.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var ValidationError = class extends Error {
		constructor(errors$1) {
			super("validation failed");
			this.errors = errors$1;
			this.ajv = this.validation = true;
		}
	};
	exports.default = ValidationError;
}) });

//#endregion
//#region node_modules/ajv/dist/compile/ref_error.js
var require_ref_error = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/compile/ref_error.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const resolve_1$2 = require_resolve();
	var MissingRefError = class extends Error {
		constructor(resolver, baseId, ref, msg) {
			super(msg || `can't resolve reference ${ref} from id ${baseId}`);
			this.missingRef = (0, resolve_1$2.resolveUrl)(resolver, baseId, ref);
			this.missingSchema = (0, resolve_1$2.normalizeId)((0, resolve_1$2.getFullPath)(resolver, this.missingRef));
		}
	};
	exports.default = MissingRefError;
}) });

//#endregion
//#region node_modules/ajv/dist/compile/index.js
var require_compile = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/compile/index.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$25 = require_codegen();
	const validation_error_1$2 = require_validation_error();
	const names_1$2 = require_names();
	const resolve_1$1 = require_resolve();
	const util_1$22 = require_util();
	const validate_1$3 = require_validate();
	var SchemaEnv = class {
		constructor(env) {
			var _a$1;
			this.refs = {};
			this.dynamicAnchors = {};
			let schema$1;
			if (typeof env.schema == "object") schema$1 = env.schema;
			this.schema = env.schema;
			this.schemaId = env.schemaId;
			this.root = env.root || this;
			this.baseId = (_a$1 = env.baseId) !== null && _a$1 !== void 0 ? _a$1 : (0, resolve_1$1.normalizeId)(schema$1 === null || schema$1 === void 0 ? void 0 : schema$1[env.schemaId || "$id"]);
			this.schemaPath = env.schemaPath;
			this.localRefs = env.localRefs;
			this.meta = env.meta;
			this.$async = schema$1 === null || schema$1 === void 0 ? void 0 : schema$1.$async;
			this.refs = {};
		}
	};
	exports.SchemaEnv = SchemaEnv;
	function compileSchema(sch) {
		const _sch = getCompilingSchema.call(this, sch);
		if (_sch) return _sch;
		const rootId = (0, resolve_1$1.getFullPath)(this.opts.uriResolver, sch.root.baseId);
		const { es5, lines } = this.opts.code;
		const { ownProperties } = this.opts;
		const gen = new codegen_1$25.CodeGen(this.scope, {
			es5,
			lines,
			ownProperties
		});
		let _ValidationError;
		if (sch.$async) _ValidationError = gen.scopeValue("Error", {
			ref: validation_error_1$2.default,
			code: (0, codegen_1$25._)`require("ajv/dist/runtime/validation_error").default`
		});
		const validateName = gen.scopeName("validate");
		sch.validateName = validateName;
		const schemaCxt = {
			gen,
			allErrors: this.opts.allErrors,
			data: names_1$2.default.data,
			parentData: names_1$2.default.parentData,
			parentDataProperty: names_1$2.default.parentDataProperty,
			dataNames: [names_1$2.default.data],
			dataPathArr: [codegen_1$25.nil],
			dataLevel: 0,
			dataTypes: [],
			definedProperties: /* @__PURE__ */ new Set(),
			topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true ? {
				ref: sch.schema,
				code: (0, codegen_1$25.stringify)(sch.schema)
			} : { ref: sch.schema }),
			validateName,
			ValidationError: _ValidationError,
			schema: sch.schema,
			schemaEnv: sch,
			rootId,
			baseId: sch.baseId || rootId,
			schemaPath: codegen_1$25.nil,
			errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
			errorPath: (0, codegen_1$25._)`""`,
			opts: this.opts,
			self: this
		};
		let sourceCode;
		try {
			this._compilations.add(sch);
			(0, validate_1$3.validateFunctionCode)(schemaCxt);
			gen.optimize(this.opts.code.optimize);
			const validateCode = gen.toString();
			sourceCode = `${gen.scopeRefs(names_1$2.default.scope)}return ${validateCode}`;
			if (this.opts.code.process) sourceCode = this.opts.code.process(sourceCode, sch);
			const validate = new Function(`${names_1$2.default.self}`, `${names_1$2.default.scope}`, sourceCode)(this, this.scope.get());
			this.scope.value(validateName, { ref: validate });
			validate.errors = null;
			validate.schema = sch.schema;
			validate.schemaEnv = sch;
			if (sch.$async) validate.$async = true;
			if (this.opts.code.source === true) validate.source = {
				validateName,
				validateCode,
				scopeValues: gen._values
			};
			if (this.opts.unevaluated) {
				const { props, items } = schemaCxt;
				validate.evaluated = {
					props: props instanceof codegen_1$25.Name ? void 0 : props,
					items: items instanceof codegen_1$25.Name ? void 0 : items,
					dynamicProps: props instanceof codegen_1$25.Name,
					dynamicItems: items instanceof codegen_1$25.Name
				};
				if (validate.source) validate.source.evaluated = (0, codegen_1$25.stringify)(validate.evaluated);
			}
			sch.validate = validate;
			return sch;
		} catch (e) {
			delete sch.validate;
			delete sch.validateName;
			if (sourceCode) this.logger.error("Error compiling schema, function code:", sourceCode);
			throw e;
		} finally {
			this._compilations.delete(sch);
		}
	}
	exports.compileSchema = compileSchema;
	function resolveRef(root, baseId, ref) {
		var _a$1;
		ref = (0, resolve_1$1.resolveUrl)(this.opts.uriResolver, baseId, ref);
		const schOrFunc = root.refs[ref];
		if (schOrFunc) return schOrFunc;
		let _sch = resolve$1.call(this, root, ref);
		if (_sch === void 0) {
			const schema$1 = (_a$1 = root.localRefs) === null || _a$1 === void 0 ? void 0 : _a$1[ref];
			const { schemaId } = this.opts;
			if (schema$1) _sch = new SchemaEnv({
				schema: schema$1,
				schemaId,
				root,
				baseId
			});
		}
		if (_sch === void 0) return;
		return root.refs[ref] = inlineOrCompile.call(this, _sch);
	}
	exports.resolveRef = resolveRef;
	function inlineOrCompile(sch) {
		if ((0, resolve_1$1.inlineRef)(sch.schema, this.opts.inlineRefs)) return sch.schema;
		return sch.validate ? sch : compileSchema.call(this, sch);
	}
	function getCompilingSchema(schEnv) {
		for (const sch of this._compilations) if (sameSchemaEnv(sch, schEnv)) return sch;
	}
	exports.getCompilingSchema = getCompilingSchema;
	function sameSchemaEnv(s1, s2) {
		return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
	}
	function resolve$1(root, ref) {
		let sch;
		while (typeof (sch = this.refs[ref]) == "string") ref = sch;
		return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);
	}
	function resolveSchema(root, ref) {
		const p = this.opts.uriResolver.parse(ref);
		const refPath = (0, resolve_1$1._getFullPath)(this.opts.uriResolver, p);
		let baseId = (0, resolve_1$1.getFullPath)(this.opts.uriResolver, root.baseId, void 0);
		if (Object.keys(root.schema).length > 0 && refPath === baseId) return getJsonPointer.call(this, p, root);
		const id = (0, resolve_1$1.normalizeId)(refPath);
		const schOrRef = this.refs[id] || this.schemas[id];
		if (typeof schOrRef == "string") {
			const sch = resolveSchema.call(this, root, schOrRef);
			if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object") return;
			return getJsonPointer.call(this, p, sch);
		}
		if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object") return;
		if (!schOrRef.validate) compileSchema.call(this, schOrRef);
		if (id === (0, resolve_1$1.normalizeId)(ref)) {
			const { schema: schema$1 } = schOrRef;
			const { schemaId } = this.opts;
			const schId = schema$1[schemaId];
			if (schId) baseId = (0, resolve_1$1.resolveUrl)(this.opts.uriResolver, baseId, schId);
			return new SchemaEnv({
				schema: schema$1,
				schemaId,
				root,
				baseId
			});
		}
		return getJsonPointer.call(this, p, schOrRef);
	}
	exports.resolveSchema = resolveSchema;
	const PREVENT_SCOPE_CHANGE = new Set([
		"properties",
		"patternProperties",
		"enum",
		"dependencies",
		"definitions"
	]);
	function getJsonPointer(parsedRef, { baseId, schema: schema$1, root }) {
		var _a$1;
		if (((_a$1 = parsedRef.fragment) === null || _a$1 === void 0 ? void 0 : _a$1[0]) !== "/") return;
		for (const part of parsedRef.fragment.slice(1).split("/")) {
			if (typeof schema$1 === "boolean") return;
			const partSchema = schema$1[(0, util_1$22.unescapeFragment)(part)];
			if (partSchema === void 0) return;
			schema$1 = partSchema;
			const schId = typeof schema$1 === "object" && schema$1[this.opts.schemaId];
			if (!PREVENT_SCOPE_CHANGE.has(part) && schId) baseId = (0, resolve_1$1.resolveUrl)(this.opts.uriResolver, baseId, schId);
		}
		let env;
		if (typeof schema$1 != "boolean" && schema$1.$ref && !(0, util_1$22.schemaHasRulesButRef)(schema$1, this.RULES)) {
			const $ref = (0, resolve_1$1.resolveUrl)(this.opts.uriResolver, baseId, schema$1.$ref);
			env = resolveSchema.call(this, root, $ref);
		}
		const { schemaId } = this.opts;
		env = env || new SchemaEnv({
			schema: schema$1,
			schemaId,
			root,
			baseId
		});
		if (env.schema !== env.root.schema) return env;
	}
}) });

//#endregion
//#region node_modules/ajv/dist/refs/data.json
var require_data = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/refs/data.json": ((exports, module) => {
	module.exports = {
		"$id": "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
		"description": "Meta-schema for $data reference (JSON AnySchema extension proposal)",
		"type": "object",
		"required": ["$data"],
		"properties": { "$data": {
			"type": "string",
			"anyOf": [{ "format": "relative-json-pointer" }, { "format": "json-pointer" }]
		} },
		"additionalProperties": false
	};
}) });

//#endregion
//#region node_modules/fast-uri/lib/utils.js
var require_utils = /* @__PURE__ */ __commonJS$2({ "node_modules/fast-uri/lib/utils.js": ((exports, module) => {
	/** @type {(value: string) => boolean} */
	const isUUID$1 = RegExp.prototype.test.bind(/^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu);
	/** @type {(value: string) => boolean} */
	const isIPv4$1 = RegExp.prototype.test.bind(/^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u);
	/**
	* @param {Array<string>} input
	* @returns {string}
	*/
	function stringArrayToHexStripped(input) {
		let acc = "";
		let code = 0;
		let i = 0;
		for (i = 0; i < input.length; i++) {
			code = input[i].charCodeAt(0);
			if (code === 48) continue;
			if (!(code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102)) return "";
			acc += input[i];
			break;
		}
		for (i += 1; i < input.length; i++) {
			code = input[i].charCodeAt(0);
			if (!(code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102)) return "";
			acc += input[i];
		}
		return acc;
	}
	/**
	* @typedef {Object} GetIPV6Result
	* @property {boolean} error - Indicates if there was an error parsing the IPv6 address.
	* @property {string} address - The parsed IPv6 address.
	* @property {string} [zone] - The zone identifier, if present.
	*/
	/**
	* @param {string} value
	* @returns {boolean}
	*/
	const nonSimpleDomain$1 = RegExp.prototype.test.bind(/[^!"$&'()*+,\-.;=_`a-z{}~]/u);
	/**
	* @param {Array<string>} buffer
	* @returns {boolean}
	*/
	function consumeIsZone(buffer) {
		buffer.length = 0;
		return true;
	}
	/**
	* @param {Array<string>} buffer
	* @param {Array<string>} address
	* @param {GetIPV6Result} output
	* @returns {boolean}
	*/
	function consumeHextets(buffer, address, output) {
		if (buffer.length) {
			const hex = stringArrayToHexStripped(buffer);
			if (hex !== "") address.push(hex);
			else {
				output.error = true;
				return false;
			}
			buffer.length = 0;
		}
		return true;
	}
	/**
	* @param {string} input
	* @returns {GetIPV6Result}
	*/
	function getIPV6(input) {
		let tokenCount = 0;
		const output = {
			error: false,
			address: "",
			zone: ""
		};
		/** @type {Array<string>} */
		const address = [];
		/** @type {Array<string>} */
		const buffer = [];
		let endipv6Encountered = false;
		let endIpv6 = false;
		let consume = consumeHextets;
		for (let i = 0; i < input.length; i++) {
			const cursor = input[i];
			if (cursor === "[" || cursor === "]") continue;
			if (cursor === ":") {
				if (endipv6Encountered === true) endIpv6 = true;
				if (!consume(buffer, address, output)) break;
				if (++tokenCount > 7) {
					output.error = true;
					break;
				}
				if (i > 0 && input[i - 1] === ":") endipv6Encountered = true;
				address.push(":");
				continue;
			} else if (cursor === "%") {
				if (!consume(buffer, address, output)) break;
				consume = consumeIsZone;
			} else {
				buffer.push(cursor);
				continue;
			}
		}
		if (buffer.length) if (consume === consumeIsZone) output.zone = buffer.join("");
		else if (endIpv6) address.push(buffer.join(""));
		else address.push(stringArrayToHexStripped(buffer));
		output.address = address.join("");
		return output;
	}
	/**
	* @typedef {Object} NormalizeIPv6Result
	* @property {string} host - The normalized host.
	* @property {string} [escapedHost] - The escaped host.
	* @property {boolean} isIPV6 - Indicates if the host is an IPv6 address.
	*/
	/**
	* @param {string} host
	* @returns {NormalizeIPv6Result}
	*/
	function normalizeIPv6$1(host) {
		if (findToken(host, ":") < 2) return {
			host,
			isIPV6: false
		};
		const ipv6 = getIPV6(host);
		if (!ipv6.error) {
			let newHost = ipv6.address;
			let escapedHost = ipv6.address;
			if (ipv6.zone) {
				newHost += "%" + ipv6.zone;
				escapedHost += "%25" + ipv6.zone;
			}
			return {
				host: newHost,
				isIPV6: true,
				escapedHost
			};
		} else return {
			host,
			isIPV6: false
		};
	}
	/**
	* @param {string} str
	* @param {string} token
	* @returns {number}
	*/
	function findToken(str$1, token) {
		let ind = 0;
		for (let i = 0; i < str$1.length; i++) if (str$1[i] === token) ind++;
		return ind;
	}
	/**
	* @param {string} path
	* @returns {string}
	*
	* @see https://datatracker.ietf.org/doc/html/rfc3986#section-5.2.4
	*/
	function removeDotSegments$1(path) {
		let input = path;
		const output = [];
		let nextSlash = -1;
		let len = 0;
		while (len = input.length) {
			if (len === 1) if (input === ".") break;
			else if (input === "/") {
				output.push("/");
				break;
			} else {
				output.push(input);
				break;
			}
			else if (len === 2) {
				if (input[0] === ".") {
					if (input[1] === ".") break;
					else if (input[1] === "/") {
						input = input.slice(2);
						continue;
					}
				} else if (input[0] === "/") {
					if (input[1] === "." || input[1] === "/") {
						output.push("/");
						break;
					}
				}
			} else if (len === 3) {
				if (input === "/..") {
					if (output.length !== 0) output.pop();
					output.push("/");
					break;
				}
			}
			if (input[0] === ".") {
				if (input[1] === ".") {
					if (input[2] === "/") {
						input = input.slice(3);
						continue;
					}
				} else if (input[1] === "/") {
					input = input.slice(2);
					continue;
				}
			} else if (input[0] === "/") {
				if (input[1] === ".") {
					if (input[2] === "/") {
						input = input.slice(2);
						continue;
					} else if (input[2] === ".") {
						if (input[3] === "/") {
							input = input.slice(3);
							if (output.length !== 0) output.pop();
							continue;
						}
					}
				}
			}
			if ((nextSlash = input.indexOf("/", 1)) === -1) {
				output.push(input);
				break;
			} else {
				output.push(input.slice(0, nextSlash));
				input = input.slice(nextSlash);
			}
		}
		return output.join("");
	}
	/**
	* @param {import('../types/index').URIComponent} component
	* @param {boolean} esc
	* @returns {import('../types/index').URIComponent}
	*/
	function normalizeComponentEncoding$1(component, esc) {
		const func = esc !== true ? escape : unescape;
		if (component.scheme !== void 0) component.scheme = func(component.scheme);
		if (component.userinfo !== void 0) component.userinfo = func(component.userinfo);
		if (component.host !== void 0) component.host = func(component.host);
		if (component.path !== void 0) component.path = func(component.path);
		if (component.query !== void 0) component.query = func(component.query);
		if (component.fragment !== void 0) component.fragment = func(component.fragment);
		return component;
	}
	/**
	* @param {import('../types/index').URIComponent} component
	* @returns {string|undefined}
	*/
	function recomposeAuthority$1(component) {
		const uriTokens = [];
		if (component.userinfo !== void 0) {
			uriTokens.push(component.userinfo);
			uriTokens.push("@");
		}
		if (component.host !== void 0) {
			let host = unescape(component.host);
			if (!isIPv4$1(host)) {
				const ipV6res = normalizeIPv6$1(host);
				if (ipV6res.isIPV6 === true) host = `[${ipV6res.escapedHost}]`;
				else host = component.host;
			}
			uriTokens.push(host);
		}
		if (typeof component.port === "number" || typeof component.port === "string") {
			uriTokens.push(":");
			uriTokens.push(String(component.port));
		}
		return uriTokens.length ? uriTokens.join("") : void 0;
	}
	module.exports = {
		nonSimpleDomain: nonSimpleDomain$1,
		recomposeAuthority: recomposeAuthority$1,
		normalizeComponentEncoding: normalizeComponentEncoding$1,
		removeDotSegments: removeDotSegments$1,
		isIPv4: isIPv4$1,
		isUUID: isUUID$1,
		normalizeIPv6: normalizeIPv6$1,
		stringArrayToHexStripped
	};
}) });

//#endregion
//#region node_modules/fast-uri/lib/schemes.js
var require_schemes = /* @__PURE__ */ __commonJS$2({ "node_modules/fast-uri/lib/schemes.js": ((exports, module) => {
	const { isUUID } = require_utils();
	const URN_REG = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;
	const supportedSchemeNames = [
		"http",
		"https",
		"ws",
		"wss",
		"urn",
		"urn:uuid"
	];
	/** @typedef {supportedSchemeNames[number]} SchemeName */
	/**
	* @param {string} name
	* @returns {name is SchemeName}
	*/
	function isValidSchemeName(name) {
		return supportedSchemeNames.indexOf(name) !== -1;
	}
	/**
	* @callback SchemeFn
	* @param {import('../types/index').URIComponent} component
	* @param {import('../types/index').Options} options
	* @returns {import('../types/index').URIComponent}
	*/
	/**
	* @typedef {Object} SchemeHandler
	* @property {SchemeName} scheme - The scheme name.
	* @property {boolean} [domainHost] - Indicates if the scheme supports domain hosts.
	* @property {SchemeFn} parse - Function to parse the URI component for this scheme.
	* @property {SchemeFn} serialize - Function to serialize the URI component for this scheme.
	* @property {boolean} [skipNormalize] - Indicates if normalization should be skipped for this scheme.
	* @property {boolean} [absolutePath] - Indicates if the scheme uses absolute paths.
	* @property {boolean} [unicodeSupport] - Indicates if the scheme supports Unicode.
	*/
	/**
	* @param {import('../types/index').URIComponent} wsComponent
	* @returns {boolean}
	*/
	function wsIsSecure(wsComponent) {
		if (wsComponent.secure === true) return true;
		else if (wsComponent.secure === false) return false;
		else if (wsComponent.scheme) return wsComponent.scheme.length === 3 && (wsComponent.scheme[0] === "w" || wsComponent.scheme[0] === "W") && (wsComponent.scheme[1] === "s" || wsComponent.scheme[1] === "S") && (wsComponent.scheme[2] === "s" || wsComponent.scheme[2] === "S");
		else return false;
	}
	/** @type {SchemeFn} */
	function httpParse(component) {
		if (!component.host) component.error = component.error || "HTTP URIs must have a host.";
		return component;
	}
	/** @type {SchemeFn} */
	function httpSerialize(component) {
		const secure = String(component.scheme).toLowerCase() === "https";
		if (component.port === (secure ? 443 : 80) || component.port === "") component.port = void 0;
		if (!component.path) component.path = "/";
		return component;
	}
	/** @type {SchemeFn} */
	function wsParse(wsComponent) {
		wsComponent.secure = wsIsSecure(wsComponent);
		wsComponent.resourceName = (wsComponent.path || "/") + (wsComponent.query ? "?" + wsComponent.query : "");
		wsComponent.path = void 0;
		wsComponent.query = void 0;
		return wsComponent;
	}
	/** @type {SchemeFn} */
	function wsSerialize(wsComponent) {
		if (wsComponent.port === (wsIsSecure(wsComponent) ? 443 : 80) || wsComponent.port === "") wsComponent.port = void 0;
		if (typeof wsComponent.secure === "boolean") {
			wsComponent.scheme = wsComponent.secure ? "wss" : "ws";
			wsComponent.secure = void 0;
		}
		if (wsComponent.resourceName) {
			const [path, query] = wsComponent.resourceName.split("?");
			wsComponent.path = path && path !== "/" ? path : void 0;
			wsComponent.query = query;
			wsComponent.resourceName = void 0;
		}
		wsComponent.fragment = void 0;
		return wsComponent;
	}
	/** @type {SchemeFn} */
	function urnParse(urnComponent, options) {
		if (!urnComponent.path) {
			urnComponent.error = "URN can not be parsed";
			return urnComponent;
		}
		const matches = urnComponent.path.match(URN_REG);
		if (matches) {
			const scheme = options.scheme || urnComponent.scheme || "urn";
			urnComponent.nid = matches[1].toLowerCase();
			urnComponent.nss = matches[2];
			const schemeHandler = getSchemeHandler$1(`${scheme}:${options.nid || urnComponent.nid}`);
			urnComponent.path = void 0;
			if (schemeHandler) urnComponent = schemeHandler.parse(urnComponent, options);
		} else urnComponent.error = urnComponent.error || "URN can not be parsed.";
		return urnComponent;
	}
	/** @type {SchemeFn} */
	function urnSerialize(urnComponent, options) {
		if (urnComponent.nid === void 0) throw new Error("URN without nid cannot be serialized");
		const scheme = options.scheme || urnComponent.scheme || "urn";
		const nid = urnComponent.nid.toLowerCase();
		const schemeHandler = getSchemeHandler$1(`${scheme}:${options.nid || nid}`);
		if (schemeHandler) urnComponent = schemeHandler.serialize(urnComponent, options);
		const uriComponent = urnComponent;
		const nss = urnComponent.nss;
		uriComponent.path = `${nid || options.nid}:${nss}`;
		options.skipEscape = true;
		return uriComponent;
	}
	/** @type {SchemeFn} */
	function urnuuidParse(urnComponent, options) {
		const uuidComponent = urnComponent;
		uuidComponent.uuid = uuidComponent.nss;
		uuidComponent.nss = void 0;
		if (!options.tolerant && (!uuidComponent.uuid || !isUUID(uuidComponent.uuid))) uuidComponent.error = uuidComponent.error || "UUID is not valid.";
		return uuidComponent;
	}
	/** @type {SchemeFn} */
	function urnuuidSerialize(uuidComponent) {
		const urnComponent = uuidComponent;
		urnComponent.nss = (uuidComponent.uuid || "").toLowerCase();
		return urnComponent;
	}
	const http = {
		scheme: "http",
		domainHost: true,
		parse: httpParse,
		serialize: httpSerialize
	};
	const https = {
		scheme: "https",
		domainHost: http.domainHost,
		parse: httpParse,
		serialize: httpSerialize
	};
	const ws = {
		scheme: "ws",
		domainHost: true,
		parse: wsParse,
		serialize: wsSerialize
	};
	const wss = {
		scheme: "wss",
		domainHost: ws.domainHost,
		parse: ws.parse,
		serialize: ws.serialize
	};
	const urn = {
		scheme: "urn",
		parse: urnParse,
		serialize: urnSerialize,
		skipNormalize: true
	};
	const urnuuid = {
		scheme: "urn:uuid",
		parse: urnuuidParse,
		serialize: urnuuidSerialize,
		skipNormalize: true
	};
	const SCHEMES$1 = {
		http,
		https,
		ws,
		wss,
		urn,
		"urn:uuid": urnuuid
	};
	Object.setPrototypeOf(SCHEMES$1, null);
	/**
	* @param {string|undefined} scheme
	* @returns {SchemeHandler|undefined}
	*/
	function getSchemeHandler$1(scheme) {
		return scheme && (SCHEMES$1[scheme] || SCHEMES$1[scheme.toLowerCase()]) || void 0;
	}
	module.exports = {
		wsIsSecure,
		SCHEMES: SCHEMES$1,
		isValidSchemeName,
		getSchemeHandler: getSchemeHandler$1
	};
}) });

//#endregion
//#region node_modules/fast-uri/index.js
var require_fast_uri = /* @__PURE__ */ __commonJS$2({ "node_modules/fast-uri/index.js": ((exports, module) => {
	const { normalizeIPv6, removeDotSegments, recomposeAuthority, normalizeComponentEncoding, isIPv4, nonSimpleDomain } = require_utils();
	const { SCHEMES, getSchemeHandler } = require_schemes();
	/**
	* @template {import('./types/index').URIComponent|string} T
	* @param {T} uri
	* @param {import('./types/index').Options} [options]
	* @returns {T}
	*/
	function normalize(uri$1, options) {
		if (typeof uri$1 === "string") uri$1 = serialize(parse(uri$1, options), options);
		else if (typeof uri$1 === "object") uri$1 = parse(serialize(uri$1, options), options);
		return uri$1;
	}
	/**
	* @param {string} baseURI
	* @param {string} relativeURI
	* @param {import('./types/index').Options} [options]
	* @returns {string}
	*/
	function resolve(baseURI, relativeURI, options) {
		const schemelessOptions = options ? Object.assign({ scheme: "null" }, options) : { scheme: "null" };
		const resolved = resolveComponent(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true);
		schemelessOptions.skipEscape = true;
		return serialize(resolved, schemelessOptions);
	}
	/**
	* @param {import ('./types/index').URIComponent} base
	* @param {import ('./types/index').URIComponent} relative
	* @param {import('./types/index').Options} [options]
	* @param {boolean} [skipNormalization=false]
	* @returns {import ('./types/index').URIComponent}
	*/
	function resolveComponent(base, relative, options, skipNormalization) {
		/** @type {import('./types/index').URIComponent} */
		const target = {};
		if (!skipNormalization) {
			base = parse(serialize(base, options), options);
			relative = parse(serialize(relative, options), options);
		}
		options = options || {};
		if (!options.tolerant && relative.scheme) {
			target.scheme = relative.scheme;
			target.userinfo = relative.userinfo;
			target.host = relative.host;
			target.port = relative.port;
			target.path = removeDotSegments(relative.path || "");
			target.query = relative.query;
		} else {
			if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {
				target.userinfo = relative.userinfo;
				target.host = relative.host;
				target.port = relative.port;
				target.path = removeDotSegments(relative.path || "");
				target.query = relative.query;
			} else {
				if (!relative.path) {
					target.path = base.path;
					if (relative.query !== void 0) target.query = relative.query;
					else target.query = base.query;
				} else {
					if (relative.path[0] === "/") target.path = removeDotSegments(relative.path);
					else {
						if ((base.userinfo !== void 0 || base.host !== void 0 || base.port !== void 0) && !base.path) target.path = "/" + relative.path;
						else if (!base.path) target.path = relative.path;
						else target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path;
						target.path = removeDotSegments(target.path);
					}
					target.query = relative.query;
				}
				target.userinfo = base.userinfo;
				target.host = base.host;
				target.port = base.port;
			}
			target.scheme = base.scheme;
		}
		target.fragment = relative.fragment;
		return target;
	}
	/**
	* @param {import ('./types/index').URIComponent|string} uriA
	* @param {import ('./types/index').URIComponent|string} uriB
	* @param {import ('./types/index').Options} options
	* @returns {boolean}
	*/
	function equal$1(uriA, uriB, options) {
		if (typeof uriA === "string") {
			uriA = unescape(uriA);
			uriA = serialize(normalizeComponentEncoding(parse(uriA, options), true), {
				...options,
				skipEscape: true
			});
		} else if (typeof uriA === "object") uriA = serialize(normalizeComponentEncoding(uriA, true), {
			...options,
			skipEscape: true
		});
		if (typeof uriB === "string") {
			uriB = unescape(uriB);
			uriB = serialize(normalizeComponentEncoding(parse(uriB, options), true), {
				...options,
				skipEscape: true
			});
		} else if (typeof uriB === "object") uriB = serialize(normalizeComponentEncoding(uriB, true), {
			...options,
			skipEscape: true
		});
		return uriA.toLowerCase() === uriB.toLowerCase();
	}
	/**
	* @param {Readonly<import('./types/index').URIComponent>} cmpts
	* @param {import('./types/index').Options} [opts]
	* @returns {string}
	*/
	function serialize(cmpts, opts) {
		const component = {
			host: cmpts.host,
			scheme: cmpts.scheme,
			userinfo: cmpts.userinfo,
			port: cmpts.port,
			path: cmpts.path,
			query: cmpts.query,
			nid: cmpts.nid,
			nss: cmpts.nss,
			uuid: cmpts.uuid,
			fragment: cmpts.fragment,
			reference: cmpts.reference,
			resourceName: cmpts.resourceName,
			secure: cmpts.secure,
			error: ""
		};
		const options = Object.assign({}, opts);
		const uriTokens = [];
		const schemeHandler = getSchemeHandler(options.scheme || component.scheme);
		if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(component, options);
		if (component.path !== void 0) if (!options.skipEscape) {
			component.path = escape(component.path);
			if (component.scheme !== void 0) component.path = component.path.split("%3A").join(":");
		} else component.path = unescape(component.path);
		if (options.reference !== "suffix" && component.scheme) uriTokens.push(component.scheme, ":");
		const authority = recomposeAuthority(component);
		if (authority !== void 0) {
			if (options.reference !== "suffix") uriTokens.push("//");
			uriTokens.push(authority);
			if (component.path && component.path[0] !== "/") uriTokens.push("/");
		}
		if (component.path !== void 0) {
			let s = component.path;
			if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) s = removeDotSegments(s);
			if (authority === void 0 && s[0] === "/" && s[1] === "/") s = "/%2F" + s.slice(2);
			uriTokens.push(s);
		}
		if (component.query !== void 0) uriTokens.push("?", component.query);
		if (component.fragment !== void 0) uriTokens.push("#", component.fragment);
		return uriTokens.join("");
	}
	const URI_PARSE = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
	/**
	* @param {string} uri
	* @param {import('./types/index').Options} [opts]
	* @returns
	*/
	function parse(uri$1, opts) {
		const options = Object.assign({}, opts);
		/** @type {import('./types/index').URIComponent} */
		const parsed = {
			scheme: void 0,
			userinfo: void 0,
			host: "",
			port: void 0,
			path: "",
			query: void 0,
			fragment: void 0
		};
		let isIP = false;
		if (options.reference === "suffix") if (options.scheme) uri$1 = options.scheme + ":" + uri$1;
		else uri$1 = "//" + uri$1;
		const matches = uri$1.match(URI_PARSE);
		if (matches) {
			parsed.scheme = matches[1];
			parsed.userinfo = matches[3];
			parsed.host = matches[4];
			parsed.port = parseInt(matches[5], 10);
			parsed.path = matches[6] || "";
			parsed.query = matches[7];
			parsed.fragment = matches[8];
			if (isNaN(parsed.port)) parsed.port = matches[5];
			if (parsed.host) if (isIPv4(parsed.host) === false) {
				const ipv6result = normalizeIPv6(parsed.host);
				parsed.host = ipv6result.host.toLowerCase();
				isIP = ipv6result.isIPV6;
			} else isIP = true;
			if (parsed.scheme === void 0 && parsed.userinfo === void 0 && parsed.host === void 0 && parsed.port === void 0 && parsed.query === void 0 && !parsed.path) parsed.reference = "same-document";
			else if (parsed.scheme === void 0) parsed.reference = "relative";
			else if (parsed.fragment === void 0) parsed.reference = "absolute";
			else parsed.reference = "uri";
			if (options.reference && options.reference !== "suffix" && options.reference !== parsed.reference) parsed.error = parsed.error || "URI is not a " + options.reference + " reference.";
			const schemeHandler = getSchemeHandler(options.scheme || parsed.scheme);
			if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
				if (parsed.host && (options.domainHost || schemeHandler && schemeHandler.domainHost) && isIP === false && nonSimpleDomain(parsed.host)) try {
					parsed.host = URL.domainToASCII(parsed.host.toLowerCase());
				} catch (e) {
					parsed.error = parsed.error || "Host's domain name can not be converted to ASCII: " + e;
				}
			}
			if (!schemeHandler || schemeHandler && !schemeHandler.skipNormalize) {
				if (uri$1.indexOf("%") !== -1) {
					if (parsed.scheme !== void 0) parsed.scheme = unescape(parsed.scheme);
					if (parsed.host !== void 0) parsed.host = unescape(parsed.host);
				}
				if (parsed.path) parsed.path = escape(unescape(parsed.path));
				if (parsed.fragment) parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment));
			}
			if (schemeHandler && schemeHandler.parse) schemeHandler.parse(parsed, options);
		} else parsed.error = parsed.error || "URI can not be parsed.";
		return parsed;
	}
	const fastUri = {
		SCHEMES,
		normalize,
		resolve,
		resolveComponent,
		equal: equal$1,
		serialize,
		parse
	};
	module.exports = fastUri;
	module.exports.default = fastUri;
	module.exports.fastUri = fastUri;
}) });

//#endregion
//#region node_modules/ajv/dist/runtime/uri.js
var require_uri = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/runtime/uri.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const uri = require_fast_uri();
	uri.code = "require(\"ajv/dist/runtime/uri\").default";
	exports.default = uri;
}) });

//#endregion
//#region node_modules/ajv/dist/core.js
var require_core$1 = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/core.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
	var validate_1$2 = require_validate();
	Object.defineProperty(exports, "KeywordCxt", {
		enumerable: true,
		get: function() {
			return validate_1$2.KeywordCxt;
		}
	});
	var codegen_1$24 = require_codegen();
	Object.defineProperty(exports, "_", {
		enumerable: true,
		get: function() {
			return codegen_1$24._;
		}
	});
	Object.defineProperty(exports, "str", {
		enumerable: true,
		get: function() {
			return codegen_1$24.str;
		}
	});
	Object.defineProperty(exports, "stringify", {
		enumerable: true,
		get: function() {
			return codegen_1$24.stringify;
		}
	});
	Object.defineProperty(exports, "nil", {
		enumerable: true,
		get: function() {
			return codegen_1$24.nil;
		}
	});
	Object.defineProperty(exports, "Name", {
		enumerable: true,
		get: function() {
			return codegen_1$24.Name;
		}
	});
	Object.defineProperty(exports, "CodeGen", {
		enumerable: true,
		get: function() {
			return codegen_1$24.CodeGen;
		}
	});
	const validation_error_1$1 = require_validation_error();
	const ref_error_1$3 = require_ref_error();
	const rules_1 = require_rules();
	const compile_1$2 = require_compile();
	const codegen_2 = require_codegen();
	const resolve_1 = require_resolve();
	const dataType_1$1 = require_dataType();
	const util_1$21 = require_util();
	const $dataRefSchema = require_data();
	const uri_1 = require_uri();
	const defaultRegExp = (str$1, flags) => new RegExp(str$1, flags);
	defaultRegExp.code = "new RegExp";
	const META_IGNORE_OPTIONS = [
		"removeAdditional",
		"useDefaults",
		"coerceTypes"
	];
	const EXT_SCOPE_NAMES = new Set([
		"validate",
		"serialize",
		"parse",
		"wrapper",
		"root",
		"schema",
		"keyword",
		"pattern",
		"formats",
		"validate$data",
		"func",
		"obj",
		"Error"
	]);
	const removedOptions = {
		errorDataPath: "",
		format: "`validateFormats: false` can be used instead.",
		nullable: "\"nullable\" keyword is supported by default.",
		jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
		extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
		missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
		processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
		sourceCode: "Use option `code: {source: true}`",
		strictDefaults: "It is default now, see option `strict`.",
		strictKeywords: "It is default now, see option `strict`.",
		uniqueItems: "\"uniqueItems\" keyword is always validated.",
		unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
		cache: "Map is used as cache, schema object as key.",
		serialize: "Map is used as cache, schema object as key.",
		ajvErrors: "It is default now."
	};
	const deprecatedOptions = {
		ignoreKeywordsWithRef: "",
		jsPropertySyntax: "",
		unicode: "\"minLength\"/\"maxLength\" account for unicode characters by default."
	};
	const MAX_EXPRESSION = 200;
	function requiredOptions(o) {
		var _a$1, _b$1, _c$1, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
		const s = o.strict;
		const _optz = (_a$1 = o.code) === null || _a$1 === void 0 ? void 0 : _a$1.optimize;
		const optimize$1 = _optz === true || _optz === void 0 ? 1 : _optz || 0;
		const regExp = (_c$1 = (_b$1 = o.code) === null || _b$1 === void 0 ? void 0 : _b$1.regExp) !== null && _c$1 !== void 0 ? _c$1 : defaultRegExp;
		const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;
		return {
			strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,
			strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,
			strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : "log",
			strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : "log",
			strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,
			code: o.code ? {
				...o.code,
				optimize: optimize$1,
				regExp
			} : {
				optimize: optimize$1,
				regExp
			},
			loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
			loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,
			meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,
			messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,
			inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,
			schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : "$id",
			addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,
			validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,
			validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,
			unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
			int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,
			uriResolver
		};
	}
	var Ajv$2 = class {
		constructor(opts = {}) {
			this.schemas = {};
			this.refs = {};
			this.formats = {};
			this._compilations = /* @__PURE__ */ new Set();
			this._loading = {};
			this._cache = /* @__PURE__ */ new Map();
			opts = this.opts = {
				...opts,
				...requiredOptions(opts)
			};
			const { es5, lines } = this.opts.code;
			this.scope = new codegen_2.ValueScope({
				scope: {},
				prefixes: EXT_SCOPE_NAMES,
				es5,
				lines
			});
			this.logger = getLogger(opts.logger);
			const formatOpt = opts.validateFormats;
			opts.validateFormats = false;
			this.RULES = (0, rules_1.getRules)();
			checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
			checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
			this._metaOpts = getMetaSchemaOptions.call(this);
			if (opts.formats) addInitialFormats.call(this);
			this._addVocabularies();
			this._addDefaultMetaSchema();
			if (opts.keywords) addInitialKeywords.call(this, opts.keywords);
			if (typeof opts.meta == "object") this.addMetaSchema(opts.meta);
			addInitialSchemas.call(this);
			opts.validateFormats = formatOpt;
		}
		_addVocabularies() {
			this.addKeyword("$async");
		}
		_addDefaultMetaSchema() {
			const { $data, meta, schemaId } = this.opts;
			let _dataRefSchema = $dataRefSchema;
			if (schemaId === "id") {
				_dataRefSchema = { ...$dataRefSchema };
				_dataRefSchema.id = _dataRefSchema.$id;
				delete _dataRefSchema.$id;
			}
			if (meta && $data) this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
		}
		defaultMeta() {
			const { meta, schemaId } = this.opts;
			return this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : void 0;
		}
		validate(schemaKeyRef, data) {
			let v;
			if (typeof schemaKeyRef == "string") {
				v = this.getSchema(schemaKeyRef);
				if (!v) throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
			} else v = this.compile(schemaKeyRef);
			const valid = v(data);
			if (!("$async" in v)) this.errors = v.errors;
			return valid;
		}
		compile(schema$1, _meta) {
			const sch = this._addSchema(schema$1, _meta);
			return sch.validate || this._compileSchemaEnv(sch);
		}
		compileAsync(schema$1, meta) {
			if (typeof this.opts.loadSchema != "function") throw new Error("options.loadSchema should be a function");
			const { loadSchema } = this.opts;
			return runCompileAsync.call(this, schema$1, meta);
			async function runCompileAsync(_schema, _meta) {
				await loadMetaSchema.call(this, _schema.$schema);
				const sch = this._addSchema(_schema, _meta);
				return sch.validate || _compileAsync.call(this, sch);
			}
			async function loadMetaSchema($ref) {
				if ($ref && !this.getSchema($ref)) await runCompileAsync.call(this, { $ref }, true);
			}
			async function _compileAsync(sch) {
				try {
					return this._compileSchemaEnv(sch);
				} catch (e) {
					if (!(e instanceof ref_error_1$3.default)) throw e;
					checkLoaded.call(this, e);
					await loadMissingSchema.call(this, e.missingSchema);
					return _compileAsync.call(this, sch);
				}
			}
			function checkLoaded({ missingSchema: ref, missingRef }) {
				if (this.refs[ref]) throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);
			}
			async function loadMissingSchema(ref) {
				const _schema = await _loadSchema.call(this, ref);
				if (!this.refs[ref]) await loadMetaSchema.call(this, _schema.$schema);
				if (!this.refs[ref]) this.addSchema(_schema, ref, meta);
			}
			async function _loadSchema(ref) {
				const p = this._loading[ref];
				if (p) return p;
				try {
					return await (this._loading[ref] = loadSchema(ref));
				} finally {
					delete this._loading[ref];
				}
			}
		}
		addSchema(schema$1, key, _meta, _validateSchema = this.opts.validateSchema) {
			if (Array.isArray(schema$1)) {
				for (const sch of schema$1) this.addSchema(sch, void 0, _meta, _validateSchema);
				return this;
			}
			let id;
			if (typeof schema$1 === "object") {
				const { schemaId } = this.opts;
				id = schema$1[schemaId];
				if (id !== void 0 && typeof id != "string") throw new Error(`schema ${schemaId} must be string`);
			}
			key = (0, resolve_1.normalizeId)(key || id);
			this._checkUnique(key);
			this.schemas[key] = this._addSchema(schema$1, _meta, key, _validateSchema, true);
			return this;
		}
		addMetaSchema(schema$1, key, _validateSchema = this.opts.validateSchema) {
			this.addSchema(schema$1, key, true, _validateSchema);
			return this;
		}
		validateSchema(schema$1, throwOrLogError) {
			if (typeof schema$1 == "boolean") return true;
			let $schema;
			$schema = schema$1.$schema;
			if ($schema !== void 0 && typeof $schema != "string") throw new Error("$schema must be a string");
			$schema = $schema || this.opts.defaultMeta || this.defaultMeta();
			if (!$schema) {
				this.logger.warn("meta-schema not available");
				this.errors = null;
				return true;
			}
			const valid = this.validate($schema, schema$1);
			if (!valid && throwOrLogError) {
				const message = "schema is invalid: " + this.errorsText();
				if (this.opts.validateSchema === "log") this.logger.error(message);
				else throw new Error(message);
			}
			return valid;
		}
		getSchema(keyRef) {
			let sch;
			while (typeof (sch = getSchEnv.call(this, keyRef)) == "string") keyRef = sch;
			if (sch === void 0) {
				const { schemaId } = this.opts;
				const root = new compile_1$2.SchemaEnv({
					schema: {},
					schemaId
				});
				sch = compile_1$2.resolveSchema.call(this, root, keyRef);
				if (!sch) return;
				this.refs[keyRef] = sch;
			}
			return sch.validate || this._compileSchemaEnv(sch);
		}
		removeSchema(schemaKeyRef) {
			if (schemaKeyRef instanceof RegExp) {
				this._removeAllSchemas(this.schemas, schemaKeyRef);
				this._removeAllSchemas(this.refs, schemaKeyRef);
				return this;
			}
			switch (typeof schemaKeyRef) {
				case "undefined":
					this._removeAllSchemas(this.schemas);
					this._removeAllSchemas(this.refs);
					this._cache.clear();
					return this;
				case "string": {
					const sch = getSchEnv.call(this, schemaKeyRef);
					if (typeof sch == "object") this._cache.delete(sch.schema);
					delete this.schemas[schemaKeyRef];
					delete this.refs[schemaKeyRef];
					return this;
				}
				case "object": {
					const cacheKey = schemaKeyRef;
					this._cache.delete(cacheKey);
					let id = schemaKeyRef[this.opts.schemaId];
					if (id) {
						id = (0, resolve_1.normalizeId)(id);
						delete this.schemas[id];
						delete this.refs[id];
					}
					return this;
				}
				default: throw new Error("ajv.removeSchema: invalid parameter");
			}
		}
		addVocabulary(definitions) {
			for (const def$30 of definitions) this.addKeyword(def$30);
			return this;
		}
		addKeyword(kwdOrDef, def$30) {
			let keyword;
			if (typeof kwdOrDef == "string") {
				keyword = kwdOrDef;
				if (typeof def$30 == "object") {
					this.logger.warn("these parameters are deprecated, see docs for addKeyword");
					def$30.keyword = keyword;
				}
			} else if (typeof kwdOrDef == "object" && def$30 === void 0) {
				def$30 = kwdOrDef;
				keyword = def$30.keyword;
				if (Array.isArray(keyword) && !keyword.length) throw new Error("addKeywords: keyword must be string or non-empty array");
			} else throw new Error("invalid addKeywords parameters");
			checkKeyword.call(this, keyword, def$30);
			if (!def$30) {
				(0, util_1$21.eachItem)(keyword, (kwd) => addRule.call(this, kwd));
				return this;
			}
			keywordMetaschema.call(this, def$30);
			const definition = {
				...def$30,
				type: (0, dataType_1$1.getJSONTypes)(def$30.type),
				schemaType: (0, dataType_1$1.getJSONTypes)(def$30.schemaType)
			};
			(0, util_1$21.eachItem)(keyword, definition.type.length === 0 ? (k) => addRule.call(this, k, definition) : (k) => definition.type.forEach((t$1) => addRule.call(this, k, definition, t$1)));
			return this;
		}
		getKeyword(keyword) {
			const rule = this.RULES.all[keyword];
			return typeof rule == "object" ? rule.definition : !!rule;
		}
		removeKeyword(keyword) {
			const { RULES } = this;
			delete RULES.keywords[keyword];
			delete RULES.all[keyword];
			for (const group of RULES.rules) {
				const i = group.rules.findIndex((rule) => rule.keyword === keyword);
				if (i >= 0) group.rules.splice(i, 1);
			}
			return this;
		}
		addFormat(name, format$1) {
			if (typeof format$1 == "string") format$1 = new RegExp(format$1);
			this.formats[name] = format$1;
			return this;
		}
		errorsText(errors$1 = this.errors, { separator = ", ", dataVar = "data" } = {}) {
			if (!errors$1 || errors$1.length === 0) return "No errors";
			return errors$1.map((e) => `${dataVar}${e.instancePath} ${e.message}`).reduce((text, msg) => text + separator + msg);
		}
		$dataMetaSchema(metaSchema, keywordsJsonPointers) {
			const rules = this.RULES.all;
			metaSchema = JSON.parse(JSON.stringify(metaSchema));
			for (const jsonPointer of keywordsJsonPointers) {
				const segments = jsonPointer.split("/").slice(1);
				let keywords = metaSchema;
				for (const seg of segments) keywords = keywords[seg];
				for (const key in rules) {
					const rule = rules[key];
					if (typeof rule != "object") continue;
					const { $data } = rule.definition;
					const schema$1 = keywords[key];
					if ($data && schema$1) keywords[key] = schemaOrData(schema$1);
				}
			}
			return metaSchema;
		}
		_removeAllSchemas(schemas, regex) {
			for (const keyRef in schemas) {
				const sch = schemas[keyRef];
				if (!regex || regex.test(keyRef)) {
					if (typeof sch == "string") delete schemas[keyRef];
					else if (sch && !sch.meta) {
						this._cache.delete(sch.schema);
						delete schemas[keyRef];
					}
				}
			}
		}
		_addSchema(schema$1, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
			let id;
			const { schemaId } = this.opts;
			if (typeof schema$1 == "object") id = schema$1[schemaId];
			else if (this.opts.jtd) throw new Error("schema must be object");
			else if (typeof schema$1 != "boolean") throw new Error("schema must be object or boolean");
			let sch = this._cache.get(schema$1);
			if (sch !== void 0) return sch;
			baseId = (0, resolve_1.normalizeId)(id || baseId);
			const localRefs = resolve_1.getSchemaRefs.call(this, schema$1, baseId);
			sch = new compile_1$2.SchemaEnv({
				schema: schema$1,
				schemaId,
				meta,
				baseId,
				localRefs
			});
			this._cache.set(sch.schema, sch);
			if (addSchema && !baseId.startsWith("#")) {
				if (baseId) this._checkUnique(baseId);
				this.refs[baseId] = sch;
			}
			if (validateSchema) this.validateSchema(schema$1, true);
			return sch;
		}
		_checkUnique(id) {
			if (this.schemas[id] || this.refs[id]) throw new Error(`schema with key or id "${id}" already exists`);
		}
		_compileSchemaEnv(sch) {
			if (sch.meta) this._compileMetaSchema(sch);
			else compile_1$2.compileSchema.call(this, sch);
			/* istanbul ignore if */
			if (!sch.validate) throw new Error("ajv implementation error");
			return sch.validate;
		}
		_compileMetaSchema(sch) {
			const currentOpts = this.opts;
			this.opts = this._metaOpts;
			try {
				compile_1$2.compileSchema.call(this, sch);
			} finally {
				this.opts = currentOpts;
			}
		}
	};
	Ajv$2.ValidationError = validation_error_1$1.default;
	Ajv$2.MissingRefError = ref_error_1$3.default;
	exports.default = Ajv$2;
	function checkOptions(checkOpts, options, msg, log = "error") {
		for (const key in checkOpts) {
			const opt = key;
			if (opt in options) this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
		}
	}
	function getSchEnv(keyRef) {
		keyRef = (0, resolve_1.normalizeId)(keyRef);
		return this.schemas[keyRef] || this.refs[keyRef];
	}
	function addInitialSchemas() {
		const optsSchemas = this.opts.schemas;
		if (!optsSchemas) return;
		if (Array.isArray(optsSchemas)) this.addSchema(optsSchemas);
		else for (const key in optsSchemas) this.addSchema(optsSchemas[key], key);
	}
	function addInitialFormats() {
		for (const name in this.opts.formats) {
			const format$1 = this.opts.formats[name];
			if (format$1) this.addFormat(name, format$1);
		}
	}
	function addInitialKeywords(defs) {
		if (Array.isArray(defs)) {
			this.addVocabulary(defs);
			return;
		}
		this.logger.warn("keywords option as map is deprecated, pass array");
		for (const keyword in defs) {
			const def$30 = defs[keyword];
			if (!def$30.keyword) def$30.keyword = keyword;
			this.addKeyword(def$30);
		}
	}
	function getMetaSchemaOptions() {
		const metaOpts = { ...this.opts };
		for (const opt of META_IGNORE_OPTIONS) delete metaOpts[opt];
		return metaOpts;
	}
	const noLogs = {
		log() {},
		warn() {},
		error() {}
	};
	function getLogger(logger) {
		if (logger === false) return noLogs;
		if (logger === void 0) return console;
		if (logger.log && logger.warn && logger.error) return logger;
		throw new Error("logger must implement log, warn and error methods");
	}
	const KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
	function checkKeyword(keyword, def$30) {
		const { RULES } = this;
		(0, util_1$21.eachItem)(keyword, (kwd) => {
			if (RULES.keywords[kwd]) throw new Error(`Keyword ${kwd} is already defined`);
			if (!KEYWORD_NAME.test(kwd)) throw new Error(`Keyword ${kwd} has invalid name`);
		});
		if (!def$30) return;
		if (def$30.$data && !("code" in def$30 || "validate" in def$30)) throw new Error("$data keyword must have \"code\" or \"validate\" function");
	}
	function addRule(keyword, definition, dataType) {
		var _a$1;
		const post = definition === null || definition === void 0 ? void 0 : definition.post;
		if (dataType && post) throw new Error("keyword with \"post\" flag cannot have \"type\"");
		const { RULES } = this;
		let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t$1 }) => t$1 === dataType);
		if (!ruleGroup) {
			ruleGroup = {
				type: dataType,
				rules: []
			};
			RULES.rules.push(ruleGroup);
		}
		RULES.keywords[keyword] = true;
		if (!definition) return;
		const rule = {
			keyword,
			definition: {
				...definition,
				type: (0, dataType_1$1.getJSONTypes)(definition.type),
				schemaType: (0, dataType_1$1.getJSONTypes)(definition.schemaType)
			}
		};
		if (definition.before) addBeforeRule.call(this, ruleGroup, rule, definition.before);
		else ruleGroup.rules.push(rule);
		RULES.all[keyword] = rule;
		(_a$1 = definition.implements) === null || _a$1 === void 0 || _a$1.forEach((kwd) => this.addKeyword(kwd));
	}
	function addBeforeRule(ruleGroup, rule, before) {
		const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
		if (i >= 0) ruleGroup.rules.splice(i, 0, rule);
		else {
			ruleGroup.rules.push(rule);
			this.logger.warn(`rule ${before} is not defined`);
		}
	}
	function keywordMetaschema(def$30) {
		let { metaSchema } = def$30;
		if (metaSchema === void 0) return;
		if (def$30.$data && this.opts.$data) metaSchema = schemaOrData(metaSchema);
		def$30.validateSchema = this.compile(metaSchema, true);
	}
	const $dataRef = { $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#" };
	function schemaOrData(schema$1) {
		return { anyOf: [schema$1, $dataRef] };
	}
}) });

//#endregion
//#region node_modules/ajv/dist/vocabularies/core/id.js
var require_id = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/vocabularies/core/id.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const def$29 = {
		keyword: "id",
		code() {
			throw new Error("NOT SUPPORTED: keyword \"id\", use \"$id\" for schema ID");
		}
	};
	exports.default = def$29;
}) });

//#endregion
//#region node_modules/ajv/dist/vocabularies/core/ref.js
var require_ref = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/vocabularies/core/ref.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const ref_error_1$2 = require_ref_error();
	const code_1$8 = require_code();
	const codegen_1$23 = require_codegen();
	const names_1$1 = require_names();
	const compile_1$1 = require_compile();
	const util_1$20 = require_util();
	const def$28 = {
		keyword: "$ref",
		schemaType: "string",
		code(cxt) {
			const { gen, schema: $ref, it } = cxt;
			const { baseId, schemaEnv: env, validateName, opts, self } = it;
			const { root } = env;
			if (($ref === "#" || $ref === "#/") && baseId === root.baseId) return callRootRef();
			const schOrEnv = compile_1$1.resolveRef.call(self, root, baseId, $ref);
			if (schOrEnv === void 0) throw new ref_error_1$2.default(it.opts.uriResolver, baseId, $ref);
			if (schOrEnv instanceof compile_1$1.SchemaEnv) return callValidate(schOrEnv);
			return inlineRefSchema(schOrEnv);
			function callRootRef() {
				if (env === root) return callRef(cxt, validateName, env, env.$async);
				const rootName = gen.scopeValue("root", { ref: root });
				return callRef(cxt, (0, codegen_1$23._)`${rootName}.validate`, root, root.$async);
			}
			function callValidate(sch) {
				callRef(cxt, getValidate(cxt, sch), sch, sch.$async);
			}
			function inlineRefSchema(sch) {
				const schName = gen.scopeValue("schema", opts.code.source === true ? {
					ref: sch,
					code: (0, codegen_1$23.stringify)(sch)
				} : { ref: sch });
				const valid = gen.name("valid");
				const schCxt = cxt.subschema({
					schema: sch,
					dataTypes: [],
					schemaPath: codegen_1$23.nil,
					topSchemaRef: schName,
					errSchemaPath: $ref
				}, valid);
				cxt.mergeEvaluated(schCxt);
				cxt.ok(valid);
			}
		}
	};
	function getValidate(cxt, sch) {
		const { gen } = cxt;
		return sch.validate ? gen.scopeValue("validate", { ref: sch.validate }) : (0, codegen_1$23._)`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
	}
	exports.getValidate = getValidate;
	function callRef(cxt, v, sch, $async) {
		const { gen, it } = cxt;
		const { allErrors, schemaEnv: env, opts } = it;
		const passCxt = opts.passContext ? names_1$1.default.this : codegen_1$23.nil;
		if ($async) callAsyncRef();
		else callSyncRef();
		function callAsyncRef() {
			if (!env.$async) throw new Error("async schema referenced by sync schema");
			const valid = gen.let("valid");
			gen.try(() => {
				gen.code((0, codegen_1$23._)`await ${(0, code_1$8.callValidateCode)(cxt, v, passCxt)}`);
				addEvaluatedFrom(v);
				if (!allErrors) gen.assign(valid, true);
			}, (e) => {
				gen.if((0, codegen_1$23._)`!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));
				addErrorsFrom(e);
				if (!allErrors) gen.assign(valid, false);
			});
			cxt.ok(valid);
		}
		function callSyncRef() {
			cxt.result((0, code_1$8.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
		}
		function addErrorsFrom(source) {
			const errs = (0, codegen_1$23._)`${source}.errors`;
			gen.assign(names_1$1.default.vErrors, (0, codegen_1$23._)`${names_1$1.default.vErrors} === null ? ${errs} : ${names_1$1.default.vErrors}.concat(${errs})`);
			gen.assign(names_1$1.default.errors, (0, codegen_1$23._)`${names_1$1.default.vErrors}.length`);
		}
		function addEvaluatedFrom(source) {
			var _a$1;
			if (!it.opts.unevaluated) return;
			const schEvaluated = (_a$1 = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a$1 === void 0 ? void 0 : _a$1.evaluated;
			if (it.props !== true) if (schEvaluated && !schEvaluated.dynamicProps) {
				if (schEvaluated.props !== void 0) it.props = util_1$20.mergeEvaluated.props(gen, schEvaluated.props, it.props);
			} else {
				const props = gen.var("props", (0, codegen_1$23._)`${source}.evaluated.props`);
				it.props = util_1$20.mergeEvaluated.props(gen, props, it.props, codegen_1$23.Name);
			}
			if (it.items !== true) if (schEvaluated && !schEvaluated.dynamicItems) {
				if (schEvaluated.items !== void 0) it.items = util_1$20.mergeEvaluated.items(gen, schEvaluated.items, it.items);
			} else {
				const items = gen.var("items", (0, codegen_1$23._)`${source}.evaluated.items`);
				it.items = util_1$20.mergeEvaluated.items(gen, items, it.items, codegen_1$23.Name);
			}
		}
	}
	exports.callRef = callRef;
	exports.default = def$28;
}) });

//#endregion
//#region node_modules/ajv/dist/vocabularies/core/index.js
var require_core = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/vocabularies/core/index.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const id_1 = require_id();
	const ref_1 = require_ref();
	const core = [
		"$schema",
		"$id",
		"$defs",
		"$vocabulary",
		{ keyword: "$comment" },
		"definitions",
		id_1.default,
		ref_1.default
	];
	exports.default = core;
}) });

//#endregion
//#region node_modules/ajv/dist/vocabularies/validation/limitNumber.js
var require_limitNumber = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/vocabularies/validation/limitNumber.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$22 = require_codegen();
	const ops = codegen_1$22.operators;
	const KWDs = {
		maximum: {
			okStr: "<=",
			ok: ops.LTE,
			fail: ops.GT
		},
		minimum: {
			okStr: ">=",
			ok: ops.GTE,
			fail: ops.LT
		},
		exclusiveMaximum: {
			okStr: "<",
			ok: ops.LT,
			fail: ops.GTE
		},
		exclusiveMinimum: {
			okStr: ">",
			ok: ops.GT,
			fail: ops.LTE
		}
	};
	const def$27 = {
		keyword: Object.keys(KWDs),
		type: "number",
		schemaType: "number",
		$data: true,
		error: {
			message: ({ keyword, schemaCode }) => (0, codegen_1$22.str)`must be ${KWDs[keyword].okStr} ${schemaCode}`,
			params: ({ keyword, schemaCode }) => (0, codegen_1$22._)`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
		},
		code(cxt) {
			const { keyword, data, schemaCode } = cxt;
			cxt.fail$data((0, codegen_1$22._)`${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);
		}
	};
	exports.default = def$27;
}) });

//#endregion
//#region node_modules/ajv/dist/vocabularies/validation/multipleOf.js
var require_multipleOf = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/vocabularies/validation/multipleOf.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$21 = require_codegen();
	const def$26 = {
		keyword: "multipleOf",
		type: "number",
		schemaType: "number",
		$data: true,
		error: {
			message: ({ schemaCode }) => (0, codegen_1$21.str)`must be multiple of ${schemaCode}`,
			params: ({ schemaCode }) => (0, codegen_1$21._)`{multipleOf: ${schemaCode}}`
		},
		code(cxt) {
			const { gen, data, schemaCode, it } = cxt;
			const prec = it.opts.multipleOfPrecision;
			const res = gen.let("res");
			const invalid = prec ? (0, codegen_1$21._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : (0, codegen_1$21._)`${res} !== parseInt(${res})`;
			cxt.fail$data((0, codegen_1$21._)`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
		}
	};
	exports.default = def$26;
}) });

//#endregion
//#region node_modules/ajv/dist/runtime/ucs2length.js
var require_ucs2length = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/runtime/ucs2length.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	function ucs2length(str$1) {
		const len = str$1.length;
		let length = 0;
		let pos = 0;
		let value;
		while (pos < len) {
			length++;
			value = str$1.charCodeAt(pos++);
			if (value >= 55296 && value <= 56319 && pos < len) {
				value = str$1.charCodeAt(pos);
				if ((value & 64512) === 56320) pos++;
			}
		}
		return length;
	}
	exports.default = ucs2length;
	ucs2length.code = "require(\"ajv/dist/runtime/ucs2length\").default";
}) });

//#endregion
//#region node_modules/ajv/dist/vocabularies/validation/limitLength.js
var require_limitLength = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/vocabularies/validation/limitLength.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$20 = require_codegen();
	const util_1$19 = require_util();
	const ucs2length_1 = require_ucs2length();
	const def$25 = {
		keyword: ["maxLength", "minLength"],
		type: "string",
		schemaType: "number",
		$data: true,
		error: {
			message({ keyword, schemaCode }) {
				const comp = keyword === "maxLength" ? "more" : "fewer";
				return (0, codegen_1$20.str)`must NOT have ${comp} than ${schemaCode} characters`;
			},
			params: ({ schemaCode }) => (0, codegen_1$20._)`{limit: ${schemaCode}}`
		},
		code(cxt) {
			const { keyword, data, schemaCode, it } = cxt;
			const op = keyword === "maxLength" ? codegen_1$20.operators.GT : codegen_1$20.operators.LT;
			const len = it.opts.unicode === false ? (0, codegen_1$20._)`${data}.length` : (0, codegen_1$20._)`${(0, util_1$19.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
			cxt.fail$data((0, codegen_1$20._)`${len} ${op} ${schemaCode}`);
		}
	};
	exports.default = def$25;
}) });

//#endregion
//#region node_modules/ajv/dist/vocabularies/validation/pattern.js
var require_pattern = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/vocabularies/validation/pattern.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const code_1$7 = require_code();
	const codegen_1$19 = require_codegen();
	const def$24 = {
		keyword: "pattern",
		type: "string",
		schemaType: "string",
		$data: true,
		error: {
			message: ({ schemaCode }) => (0, codegen_1$19.str)`must match pattern "${schemaCode}"`,
			params: ({ schemaCode }) => (0, codegen_1$19._)`{pattern: ${schemaCode}}`
		},
		code(cxt) {
			const { data, $data, schema: schema$1, schemaCode, it } = cxt;
			const u = it.opts.unicodeRegExp ? "u" : "";
			const regExp = $data ? (0, codegen_1$19._)`(new RegExp(${schemaCode}, ${u}))` : (0, code_1$7.usePattern)(cxt, schema$1);
			cxt.fail$data((0, codegen_1$19._)`!${regExp}.test(${data})`);
		}
	};
	exports.default = def$24;
}) });

//#endregion
//#region node_modules/ajv/dist/vocabularies/validation/limitProperties.js
var require_limitProperties = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/vocabularies/validation/limitProperties.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$18 = require_codegen();
	const def$23 = {
		keyword: ["maxProperties", "minProperties"],
		type: "object",
		schemaType: "number",
		$data: true,
		error: {
			message({ keyword, schemaCode }) {
				const comp = keyword === "maxProperties" ? "more" : "fewer";
				return (0, codegen_1$18.str)`must NOT have ${comp} than ${schemaCode} properties`;
			},
			params: ({ schemaCode }) => (0, codegen_1$18._)`{limit: ${schemaCode}}`
		},
		code(cxt) {
			const { keyword, data, schemaCode } = cxt;
			const op = keyword === "maxProperties" ? codegen_1$18.operators.GT : codegen_1$18.operators.LT;
			cxt.fail$data((0, codegen_1$18._)`Object.keys(${data}).length ${op} ${schemaCode}`);
		}
	};
	exports.default = def$23;
}) });

//#endregion
//#region node_modules/ajv/dist/vocabularies/validation/required.js
var require_required = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/vocabularies/validation/required.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const code_1$6 = require_code();
	const codegen_1$17 = require_codegen();
	const util_1$18 = require_util();
	const def$22 = {
		keyword: "required",
		type: "object",
		schemaType: "array",
		$data: true,
		error: {
			message: ({ params: { missingProperty } }) => (0, codegen_1$17.str)`must have required property '${missingProperty}'`,
			params: ({ params: { missingProperty } }) => (0, codegen_1$17._)`{missingProperty: ${missingProperty}}`
		},
		code(cxt) {
			const { gen, schema: schema$1, schemaCode, data, $data, it } = cxt;
			const { opts } = it;
			if (!$data && schema$1.length === 0) return;
			const useLoop = schema$1.length >= opts.loopRequired;
			if (it.allErrors) allErrorsMode();
			else exitOnErrorMode();
			if (opts.strictRequired) {
				const props = cxt.parentSchema.properties;
				const { definedProperties } = cxt.it;
				for (const requiredKey of schema$1) if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === void 0 && !definedProperties.has(requiredKey)) {
					const msg = `required property "${requiredKey}" is not defined at "${it.schemaEnv.baseId + it.errSchemaPath}" (strictRequired)`;
					(0, util_1$18.checkStrictMode)(it, msg, it.opts.strictRequired);
				}
			}
			function allErrorsMode() {
				if (useLoop || $data) cxt.block$data(codegen_1$17.nil, loopAllRequired);
				else for (const prop of schema$1) (0, code_1$6.checkReportMissingProp)(cxt, prop);
			}
			function exitOnErrorMode() {
				const missing = gen.let("missing");
				if (useLoop || $data) {
					const valid = gen.let("valid", true);
					cxt.block$data(valid, () => loopUntilMissing(missing, valid));
					cxt.ok(valid);
				} else {
					gen.if((0, code_1$6.checkMissingProp)(cxt, schema$1, missing));
					(0, code_1$6.reportMissingProp)(cxt, missing);
					gen.else();
				}
			}
			function loopAllRequired() {
				gen.forOf("prop", schemaCode, (prop) => {
					cxt.setParams({ missingProperty: prop });
					gen.if((0, code_1$6.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
				});
			}
			function loopUntilMissing(missing, valid) {
				cxt.setParams({ missingProperty: missing });
				gen.forOf(missing, schemaCode, () => {
					gen.assign(valid, (0, code_1$6.propertyInData)(gen, data, missing, opts.ownProperties));
					gen.if((0, codegen_1$17.not)(valid), () => {
						cxt.error();
						gen.break();
					});
				}, codegen_1$17.nil);
			}
		}
	};
	exports.default = def$22;
}) });

//#endregion
//#region node_modules/ajv/dist/vocabularies/validation/limitItems.js
var require_limitItems = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/vocabularies/validation/limitItems.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$16 = require_codegen();
	const def$21 = {
		keyword: ["maxItems", "minItems"],
		type: "array",
		schemaType: "number",
		$data: true,
		error: {
			message({ keyword, schemaCode }) {
				const comp = keyword === "maxItems" ? "more" : "fewer";
				return (0, codegen_1$16.str)`must NOT have ${comp} than ${schemaCode} items`;
			},
			params: ({ schemaCode }) => (0, codegen_1$16._)`{limit: ${schemaCode}}`
		},
		code(cxt) {
			const { keyword, data, schemaCode } = cxt;
			const op = keyword === "maxItems" ? codegen_1$16.operators.GT : codegen_1$16.operators.LT;
			cxt.fail$data((0, codegen_1$16._)`${data}.length ${op} ${schemaCode}`);
		}
	};
	exports.default = def$21;
}) });

//#endregion
//#region node_modules/ajv/dist/runtime/equal.js
var require_equal = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/runtime/equal.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const equal = require_fast_deep_equal();
	equal.code = "require(\"ajv/dist/runtime/equal\").default";
	exports.default = equal;
}) });

//#endregion
//#region node_modules/ajv/dist/vocabularies/validation/uniqueItems.js
var require_uniqueItems = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/vocabularies/validation/uniqueItems.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const dataType_1 = require_dataType();
	const codegen_1$15 = require_codegen();
	const util_1$17 = require_util();
	const equal_1$2 = require_equal();
	const def$20 = {
		keyword: "uniqueItems",
		type: "array",
		schemaType: "boolean",
		$data: true,
		error: {
			message: ({ params: { i, j } }) => (0, codegen_1$15.str)`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
			params: ({ params: { i, j } }) => (0, codegen_1$15._)`{i: ${i}, j: ${j}}`
		},
		code(cxt) {
			const { gen, data, $data, schema: schema$1, parentSchema, schemaCode, it } = cxt;
			if (!$data && !schema$1) return;
			const valid = gen.let("valid");
			const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
			cxt.block$data(valid, validateUniqueItems, (0, codegen_1$15._)`${schemaCode} === false`);
			cxt.ok(valid);
			function validateUniqueItems() {
				const i = gen.let("i", (0, codegen_1$15._)`${data}.length`);
				const j = gen.let("j");
				cxt.setParams({
					i,
					j
				});
				gen.assign(valid, true);
				gen.if((0, codegen_1$15._)`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));
			}
			function canOptimize() {
				return itemTypes.length > 0 && !itemTypes.some((t$1) => t$1 === "object" || t$1 === "array");
			}
			function loopN(i, j) {
				const item = gen.name("item");
				const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);
				const indices = gen.const("indices", (0, codegen_1$15._)`{}`);
				gen.for((0, codegen_1$15._)`;${i}--;`, () => {
					gen.let(item, (0, codegen_1$15._)`${data}[${i}]`);
					gen.if(wrongType, (0, codegen_1$15._)`continue`);
					if (itemTypes.length > 1) gen.if((0, codegen_1$15._)`typeof ${item} == "string"`, (0, codegen_1$15._)`${item} += "_"`);
					gen.if((0, codegen_1$15._)`typeof ${indices}[${item}] == "number"`, () => {
						gen.assign(j, (0, codegen_1$15._)`${indices}[${item}]`);
						cxt.error();
						gen.assign(valid, false).break();
					}).code((0, codegen_1$15._)`${indices}[${item}] = ${i}`);
				});
			}
			function loopN2(i, j) {
				const eql = (0, util_1$17.useFunc)(gen, equal_1$2.default);
				const outer = gen.name("outer");
				gen.label(outer).for((0, codegen_1$15._)`;${i}--;`, () => gen.for((0, codegen_1$15._)`${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1$15._)`${eql}(${data}[${i}], ${data}[${j}])`, () => {
					cxt.error();
					gen.assign(valid, false).break(outer);
				})));
			}
		}
	};
	exports.default = def$20;
}) });

//#endregion
//#region node_modules/ajv/dist/vocabularies/validation/const.js
var require_const = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/vocabularies/validation/const.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$14 = require_codegen();
	const util_1$16 = require_util();
	const equal_1$1 = require_equal();
	const def$19 = {
		keyword: "const",
		$data: true,
		error: {
			message: "must be equal to constant",
			params: ({ schemaCode }) => (0, codegen_1$14._)`{allowedValue: ${schemaCode}}`
		},
		code(cxt) {
			const { gen, data, $data, schemaCode, schema: schema$1 } = cxt;
			if ($data || schema$1 && typeof schema$1 == "object") cxt.fail$data((0, codegen_1$14._)`!${(0, util_1$16.useFunc)(gen, equal_1$1.default)}(${data}, ${schemaCode})`);
			else cxt.fail((0, codegen_1$14._)`${schema$1} !== ${data}`);
		}
	};
	exports.default = def$19;
}) });

//#endregion
//#region node_modules/ajv/dist/vocabularies/validation/enum.js
var require_enum = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/vocabularies/validation/enum.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$13 = require_codegen();
	const util_1$15 = require_util();
	const equal_1 = require_equal();
	const def$18 = {
		keyword: "enum",
		schemaType: "array",
		$data: true,
		error: {
			message: "must be equal to one of the allowed values",
			params: ({ schemaCode }) => (0, codegen_1$13._)`{allowedValues: ${schemaCode}}`
		},
		code(cxt) {
			const { gen, data, $data, schema: schema$1, schemaCode, it } = cxt;
			if (!$data && schema$1.length === 0) throw new Error("enum must have non-empty array");
			const useLoop = schema$1.length >= it.opts.loopEnum;
			let eql;
			const getEql = () => eql !== null && eql !== void 0 ? eql : eql = (0, util_1$15.useFunc)(gen, equal_1.default);
			let valid;
			if (useLoop || $data) {
				valid = gen.let("valid");
				cxt.block$data(valid, loopEnum);
			} else {
				/* istanbul ignore if */
				if (!Array.isArray(schema$1)) throw new Error("ajv implementation error");
				const vSchema = gen.const("vSchema", schemaCode);
				valid = (0, codegen_1$13.or)(...schema$1.map((_x, i) => equalCode(vSchema, i)));
			}
			cxt.pass(valid);
			function loopEnum() {
				gen.assign(valid, false);
				gen.forOf("v", schemaCode, (v) => gen.if((0, codegen_1$13._)`${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break()));
			}
			function equalCode(vSchema, i) {
				const sch = schema$1[i];
				return typeof sch === "object" && sch !== null ? (0, codegen_1$13._)`${getEql()}(${data}, ${vSchema}[${i}])` : (0, codegen_1$13._)`${data} === ${sch}`;
			}
		}
	};
	exports.default = def$18;
}) });

//#endregion
//#region node_modules/ajv/dist/vocabularies/validation/index.js
var require_validation = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/vocabularies/validation/index.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const limitNumber_1 = require_limitNumber();
	const multipleOf_1 = require_multipleOf();
	const limitLength_1 = require_limitLength();
	const pattern_1 = require_pattern();
	const limitProperties_1 = require_limitProperties();
	const required_1 = require_required();
	const limitItems_1 = require_limitItems();
	const uniqueItems_1 = require_uniqueItems();
	const const_1 = require_const();
	const enum_1 = require_enum();
	const validation = [
		limitNumber_1.default,
		multipleOf_1.default,
		limitLength_1.default,
		pattern_1.default,
		limitProperties_1.default,
		required_1.default,
		limitItems_1.default,
		uniqueItems_1.default,
		{
			keyword: "type",
			schemaType: ["string", "array"]
		},
		{
			keyword: "nullable",
			schemaType: "boolean"
		},
		const_1.default,
		enum_1.default
	];
	exports.default = validation;
}) });

//#endregion
//#region node_modules/ajv/dist/vocabularies/applicator/additionalItems.js
var require_additionalItems = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/vocabularies/applicator/additionalItems.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$12 = require_codegen();
	const util_1$14 = require_util();
	const def$17 = {
		keyword: "additionalItems",
		type: "array",
		schemaType: ["boolean", "object"],
		before: "uniqueItems",
		error: {
			message: ({ params: { len } }) => (0, codegen_1$12.str)`must NOT have more than ${len} items`,
			params: ({ params: { len } }) => (0, codegen_1$12._)`{limit: ${len}}`
		},
		code(cxt) {
			const { parentSchema, it } = cxt;
			const { items } = parentSchema;
			if (!Array.isArray(items)) {
				(0, util_1$14.checkStrictMode)(it, "\"additionalItems\" is ignored when \"items\" is not an array of schemas");
				return;
			}
			validateAdditionalItems(cxt, items);
		}
	};
	function validateAdditionalItems(cxt, items) {
		const { gen, schema: schema$1, data, keyword, it } = cxt;
		it.items = true;
		const len = gen.const("len", (0, codegen_1$12._)`${data}.length`);
		if (schema$1 === false) {
			cxt.setParams({ len: items.length });
			cxt.pass((0, codegen_1$12._)`${len} <= ${items.length}`);
		} else if (typeof schema$1 == "object" && !(0, util_1$14.alwaysValidSchema)(it, schema$1)) {
			const valid = gen.var("valid", (0, codegen_1$12._)`${len} <= ${items.length}`);
			gen.if((0, codegen_1$12.not)(valid), () => validateItems(valid));
			cxt.ok(valid);
		}
		function validateItems(valid) {
			gen.forRange("i", items.length, len, (i) => {
				cxt.subschema({
					keyword,
					dataProp: i,
					dataPropType: util_1$14.Type.Num
				}, valid);
				if (!it.allErrors) gen.if((0, codegen_1$12.not)(valid), () => gen.break());
			});
		}
	}
	exports.validateAdditionalItems = validateAdditionalItems;
	exports.default = def$17;
}) });

//#endregion
//#region node_modules/ajv/dist/vocabularies/applicator/items.js
var require_items = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/vocabularies/applicator/items.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$11 = require_codegen();
	const util_1$13 = require_util();
	const code_1$5 = require_code();
	const def$16 = {
		keyword: "items",
		type: "array",
		schemaType: [
			"object",
			"array",
			"boolean"
		],
		before: "uniqueItems",
		code(cxt) {
			const { schema: schema$1, it } = cxt;
			if (Array.isArray(schema$1)) return validateTuple(cxt, "additionalItems", schema$1);
			it.items = true;
			if ((0, util_1$13.alwaysValidSchema)(it, schema$1)) return;
			cxt.ok((0, code_1$5.validateArray)(cxt));
		}
	};
	function validateTuple(cxt, extraItems, schArr = cxt.schema) {
		const { gen, parentSchema, data, keyword, it } = cxt;
		checkStrictTuple(parentSchema);
		if (it.opts.unevaluated && schArr.length && it.items !== true) it.items = util_1$13.mergeEvaluated.items(gen, schArr.length, it.items);
		const valid = gen.name("valid");
		const len = gen.const("len", (0, codegen_1$11._)`${data}.length`);
		schArr.forEach((sch, i) => {
			if ((0, util_1$13.alwaysValidSchema)(it, sch)) return;
			gen.if((0, codegen_1$11._)`${len} > ${i}`, () => cxt.subschema({
				keyword,
				schemaProp: i,
				dataProp: i
			}, valid));
			cxt.ok(valid);
		});
		function checkStrictTuple(sch) {
			const { opts, errSchemaPath } = it;
			const l = schArr.length;
			const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
			if (opts.strictTuples && !fullTuple) {
				const msg = `"${keyword}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
				(0, util_1$13.checkStrictMode)(it, msg, opts.strictTuples);
			}
		}
	}
	exports.validateTuple = validateTuple;
	exports.default = def$16;
}) });

//#endregion
//#region node_modules/ajv/dist/vocabularies/applicator/prefixItems.js
var require_prefixItems = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/vocabularies/applicator/prefixItems.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const items_1$1 = require_items();
	const def$15 = {
		keyword: "prefixItems",
		type: "array",
		schemaType: ["array"],
		before: "uniqueItems",
		code: (cxt) => (0, items_1$1.validateTuple)(cxt, "items")
	};
	exports.default = def$15;
}) });

//#endregion
//#region node_modules/ajv/dist/vocabularies/applicator/items2020.js
var require_items2020 = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/vocabularies/applicator/items2020.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$10 = require_codegen();
	const util_1$12 = require_util();
	const code_1$4 = require_code();
	const additionalItems_1$1 = require_additionalItems();
	const def$14 = {
		keyword: "items",
		type: "array",
		schemaType: ["object", "boolean"],
		before: "uniqueItems",
		error: {
			message: ({ params: { len } }) => (0, codegen_1$10.str)`must NOT have more than ${len} items`,
			params: ({ params: { len } }) => (0, codegen_1$10._)`{limit: ${len}}`
		},
		code(cxt) {
			const { schema: schema$1, parentSchema, it } = cxt;
			const { prefixItems } = parentSchema;
			it.items = true;
			if ((0, util_1$12.alwaysValidSchema)(it, schema$1)) return;
			if (prefixItems) (0, additionalItems_1$1.validateAdditionalItems)(cxt, prefixItems);
			else cxt.ok((0, code_1$4.validateArray)(cxt));
		}
	};
	exports.default = def$14;
}) });

//#endregion
//#region node_modules/ajv/dist/vocabularies/applicator/contains.js
var require_contains = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/vocabularies/applicator/contains.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$9 = require_codegen();
	const util_1$11 = require_util();
	const def$13 = {
		keyword: "contains",
		type: "array",
		schemaType: ["object", "boolean"],
		before: "uniqueItems",
		trackErrors: true,
		error: {
			message: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1$9.str)`must contain at least ${min} valid item(s)` : (0, codegen_1$9.str)`must contain at least ${min} and no more than ${max} valid item(s)`,
			params: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1$9._)`{minContains: ${min}}` : (0, codegen_1$9._)`{minContains: ${min}, maxContains: ${max}}`
		},
		code(cxt) {
			const { gen, schema: schema$1, parentSchema, data, it } = cxt;
			let min;
			let max;
			const { minContains, maxContains } = parentSchema;
			if (it.opts.next) {
				min = minContains === void 0 ? 1 : minContains;
				max = maxContains;
			} else min = 1;
			const len = gen.const("len", (0, codegen_1$9._)`${data}.length`);
			cxt.setParams({
				min,
				max
			});
			if (max === void 0 && min === 0) {
				(0, util_1$11.checkStrictMode)(it, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
				return;
			}
			if (max !== void 0 && min > max) {
				(0, util_1$11.checkStrictMode)(it, `"minContains" > "maxContains" is always invalid`);
				cxt.fail();
				return;
			}
			if ((0, util_1$11.alwaysValidSchema)(it, schema$1)) {
				let cond = (0, codegen_1$9._)`${len} >= ${min}`;
				if (max !== void 0) cond = (0, codegen_1$9._)`${cond} && ${len} <= ${max}`;
				cxt.pass(cond);
				return;
			}
			it.items = true;
			const valid = gen.name("valid");
			if (max === void 0 && min === 1) validateItems(valid, () => gen.if(valid, () => gen.break()));
			else if (min === 0) {
				gen.let(valid, true);
				if (max !== void 0) gen.if((0, codegen_1$9._)`${data}.length > 0`, validateItemsWithCount);
			} else {
				gen.let(valid, false);
				validateItemsWithCount();
			}
			cxt.result(valid, () => cxt.reset());
			function validateItemsWithCount() {
				const schValid = gen.name("_valid");
				const count = gen.let("count", 0);
				validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
			}
			function validateItems(_valid, block) {
				gen.forRange("i", 0, len, (i) => {
					cxt.subschema({
						keyword: "contains",
						dataProp: i,
						dataPropType: util_1$11.Type.Num,
						compositeRule: true
					}, _valid);
					block();
				});
			}
			function checkLimits(count) {
				gen.code((0, codegen_1$9._)`${count}++`);
				if (max === void 0) gen.if((0, codegen_1$9._)`${count} >= ${min}`, () => gen.assign(valid, true).break());
				else {
					gen.if((0, codegen_1$9._)`${count} > ${max}`, () => gen.assign(valid, false).break());
					if (min === 1) gen.assign(valid, true);
					else gen.if((0, codegen_1$9._)`${count} >= ${min}`, () => gen.assign(valid, true));
				}
			}
		}
	};
	exports.default = def$13;
}) });

//#endregion
//#region node_modules/ajv/dist/vocabularies/applicator/dependencies.js
var require_dependencies = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/vocabularies/applicator/dependencies.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;
	const codegen_1$8 = require_codegen();
	const util_1$10 = require_util();
	const code_1$3 = require_code();
	exports.error = {
		message: ({ params: { property, depsCount, deps } }) => {
			const property_ies = depsCount === 1 ? "property" : "properties";
			return (0, codegen_1$8.str)`must have ${property_ies} ${deps} when property ${property} is present`;
		},
		params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1$8._)`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
	};
	const def$12 = {
		keyword: "dependencies",
		type: "object",
		schemaType: "object",
		error: exports.error,
		code(cxt) {
			const [propDeps, schDeps] = splitDependencies(cxt);
			validatePropertyDeps(cxt, propDeps);
			validateSchemaDeps(cxt, schDeps);
		}
	};
	function splitDependencies({ schema: schema$1 }) {
		const propertyDeps = {};
		const schemaDeps = {};
		for (const key in schema$1) {
			if (key === "__proto__") continue;
			const deps = Array.isArray(schema$1[key]) ? propertyDeps : schemaDeps;
			deps[key] = schema$1[key];
		}
		return [propertyDeps, schemaDeps];
	}
	function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
		const { gen, data, it } = cxt;
		if (Object.keys(propertyDeps).length === 0) return;
		const missing = gen.let("missing");
		for (const prop in propertyDeps) {
			const deps = propertyDeps[prop];
			if (deps.length === 0) continue;
			const hasProperty = (0, code_1$3.propertyInData)(gen, data, prop, it.opts.ownProperties);
			cxt.setParams({
				property: prop,
				depsCount: deps.length,
				deps: deps.join(", ")
			});
			if (it.allErrors) gen.if(hasProperty, () => {
				for (const depProp of deps) (0, code_1$3.checkReportMissingProp)(cxt, depProp);
			});
			else {
				gen.if((0, codegen_1$8._)`${hasProperty} && (${(0, code_1$3.checkMissingProp)(cxt, deps, missing)})`);
				(0, code_1$3.reportMissingProp)(cxt, missing);
				gen.else();
			}
		}
	}
	exports.validatePropertyDeps = validatePropertyDeps;
	function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
		const { gen, data, keyword, it } = cxt;
		const valid = gen.name("valid");
		for (const prop in schemaDeps) {
			if ((0, util_1$10.alwaysValidSchema)(it, schemaDeps[prop])) continue;
			gen.if((0, code_1$3.propertyInData)(gen, data, prop, it.opts.ownProperties), () => {
				const schCxt = cxt.subschema({
					keyword,
					schemaProp: prop
				}, valid);
				cxt.mergeValidEvaluated(schCxt, valid);
			}, () => gen.var(valid, true));
			cxt.ok(valid);
		}
	}
	exports.validateSchemaDeps = validateSchemaDeps;
	exports.default = def$12;
}) });

//#endregion
//#region node_modules/ajv/dist/vocabularies/applicator/propertyNames.js
var require_propertyNames = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/vocabularies/applicator/propertyNames.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$7 = require_codegen();
	const util_1$9 = require_util();
	const def$11 = {
		keyword: "propertyNames",
		type: "object",
		schemaType: ["object", "boolean"],
		error: {
			message: "property name must be valid",
			params: ({ params }) => (0, codegen_1$7._)`{propertyName: ${params.propertyName}}`
		},
		code(cxt) {
			const { gen, schema: schema$1, data, it } = cxt;
			if ((0, util_1$9.alwaysValidSchema)(it, schema$1)) return;
			const valid = gen.name("valid");
			gen.forIn("key", data, (key) => {
				cxt.setParams({ propertyName: key });
				cxt.subschema({
					keyword: "propertyNames",
					data: key,
					dataTypes: ["string"],
					propertyName: key,
					compositeRule: true
				}, valid);
				gen.if((0, codegen_1$7.not)(valid), () => {
					cxt.error(true);
					if (!it.allErrors) gen.break();
				});
			});
			cxt.ok(valid);
		}
	};
	exports.default = def$11;
}) });

//#endregion
//#region node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js
var require_additionalProperties = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const code_1$2 = require_code();
	const codegen_1$6 = require_codegen();
	const names_1 = require_names();
	const util_1$8 = require_util();
	const def$10 = {
		keyword: "additionalProperties",
		type: ["object"],
		schemaType: ["boolean", "object"],
		allowUndefined: true,
		trackErrors: true,
		error: {
			message: "must NOT have additional properties",
			params: ({ params }) => (0, codegen_1$6._)`{additionalProperty: ${params.additionalProperty}}`
		},
		code(cxt) {
			const { gen, schema: schema$1, parentSchema, data, errsCount, it } = cxt;
			/* istanbul ignore if */
			if (!errsCount) throw new Error("ajv implementation error");
			const { allErrors, opts } = it;
			it.props = true;
			if (opts.removeAdditional !== "all" && (0, util_1$8.alwaysValidSchema)(it, schema$1)) return;
			const props = (0, code_1$2.allSchemaProperties)(parentSchema.properties);
			const patProps = (0, code_1$2.allSchemaProperties)(parentSchema.patternProperties);
			checkAdditionalProperties();
			cxt.ok((0, codegen_1$6._)`${errsCount} === ${names_1.default.errors}`);
			function checkAdditionalProperties() {
				gen.forIn("key", data, (key) => {
					if (!props.length && !patProps.length) additionalPropertyCode(key);
					else gen.if(isAdditional(key), () => additionalPropertyCode(key));
				});
			}
			function isAdditional(key) {
				let definedProp;
				if (props.length > 8) {
					const propsSchema = (0, util_1$8.schemaRefOrVal)(it, parentSchema.properties, "properties");
					definedProp = (0, code_1$2.isOwnProperty)(gen, propsSchema, key);
				} else if (props.length) definedProp = (0, codegen_1$6.or)(...props.map((p) => (0, codegen_1$6._)`${key} === ${p}`));
				else definedProp = codegen_1$6.nil;
				if (patProps.length) definedProp = (0, codegen_1$6.or)(definedProp, ...patProps.map((p) => (0, codegen_1$6._)`${(0, code_1$2.usePattern)(cxt, p)}.test(${key})`));
				return (0, codegen_1$6.not)(definedProp);
			}
			function deleteAdditional(key) {
				gen.code((0, codegen_1$6._)`delete ${data}[${key}]`);
			}
			function additionalPropertyCode(key) {
				if (opts.removeAdditional === "all" || opts.removeAdditional && schema$1 === false) {
					deleteAdditional(key);
					return;
				}
				if (schema$1 === false) {
					cxt.setParams({ additionalProperty: key });
					cxt.error();
					if (!allErrors) gen.break();
					return;
				}
				if (typeof schema$1 == "object" && !(0, util_1$8.alwaysValidSchema)(it, schema$1)) {
					const valid = gen.name("valid");
					if (opts.removeAdditional === "failing") {
						applyAdditionalSchema(key, valid, false);
						gen.if((0, codegen_1$6.not)(valid), () => {
							cxt.reset();
							deleteAdditional(key);
						});
					} else {
						applyAdditionalSchema(key, valid);
						if (!allErrors) gen.if((0, codegen_1$6.not)(valid), () => gen.break());
					}
				}
			}
			function applyAdditionalSchema(key, valid, errors$1) {
				const subschema = {
					keyword: "additionalProperties",
					dataProp: key,
					dataPropType: util_1$8.Type.Str
				};
				if (errors$1 === false) Object.assign(subschema, {
					compositeRule: true,
					createErrors: false,
					allErrors: false
				});
				cxt.subschema(subschema, valid);
			}
		}
	};
	exports.default = def$10;
}) });

//#endregion
//#region node_modules/ajv/dist/vocabularies/applicator/properties.js
var require_properties = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/vocabularies/applicator/properties.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const validate_1$1 = require_validate();
	const code_1$1 = require_code();
	const util_1$7 = require_util();
	const additionalProperties_1$1 = require_additionalProperties();
	const def$9 = {
		keyword: "properties",
		type: "object",
		schemaType: "object",
		code(cxt) {
			const { gen, schema: schema$1, parentSchema, data, it } = cxt;
			if (it.opts.removeAdditional === "all" && parentSchema.additionalProperties === void 0) additionalProperties_1$1.default.code(new validate_1$1.KeywordCxt(it, additionalProperties_1$1.default, "additionalProperties"));
			const allProps = (0, code_1$1.allSchemaProperties)(schema$1);
			for (const prop of allProps) it.definedProperties.add(prop);
			if (it.opts.unevaluated && allProps.length && it.props !== true) it.props = util_1$7.mergeEvaluated.props(gen, (0, util_1$7.toHash)(allProps), it.props);
			const properties = allProps.filter((p) => !(0, util_1$7.alwaysValidSchema)(it, schema$1[p]));
			if (properties.length === 0) return;
			const valid = gen.name("valid");
			for (const prop of properties) {
				if (hasDefault(prop)) applyPropertySchema(prop);
				else {
					gen.if((0, code_1$1.propertyInData)(gen, data, prop, it.opts.ownProperties));
					applyPropertySchema(prop);
					if (!it.allErrors) gen.else().var(valid, true);
					gen.endIf();
				}
				cxt.it.definedProperties.add(prop);
				cxt.ok(valid);
			}
			function hasDefault(prop) {
				return it.opts.useDefaults && !it.compositeRule && schema$1[prop].default !== void 0;
			}
			function applyPropertySchema(prop) {
				cxt.subschema({
					keyword: "properties",
					schemaProp: prop,
					dataProp: prop
				}, valid);
			}
		}
	};
	exports.default = def$9;
}) });

//#endregion
//#region node_modules/ajv/dist/vocabularies/applicator/patternProperties.js
var require_patternProperties = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/vocabularies/applicator/patternProperties.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const code_1 = require_code();
	const codegen_1$5 = require_codegen();
	const util_1$6 = require_util();
	const util_2 = require_util();
	const def$8 = {
		keyword: "patternProperties",
		type: "object",
		schemaType: "object",
		code(cxt) {
			const { gen, schema: schema$1, data, parentSchema, it } = cxt;
			const { opts } = it;
			const patterns = (0, code_1.allSchemaProperties)(schema$1);
			const alwaysValidPatterns = patterns.filter((p) => (0, util_1$6.alwaysValidSchema)(it, schema$1[p]));
			if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || it.props === true)) return;
			const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
			const valid = gen.name("valid");
			if (it.props !== true && !(it.props instanceof codegen_1$5.Name)) it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);
			const { props } = it;
			validatePatternProperties();
			function validatePatternProperties() {
				for (const pat of patterns) {
					if (checkProperties) checkMatchingProperties(pat);
					if (it.allErrors) validateProperties(pat);
					else {
						gen.var(valid, true);
						validateProperties(pat);
						gen.if(valid);
					}
				}
			}
			function checkMatchingProperties(pat) {
				for (const prop in checkProperties) if (new RegExp(pat).test(prop)) (0, util_1$6.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
			}
			function validateProperties(pat) {
				gen.forIn("key", data, (key) => {
					gen.if((0, codegen_1$5._)`${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {
						const alwaysValid = alwaysValidPatterns.includes(pat);
						if (!alwaysValid) cxt.subschema({
							keyword: "patternProperties",
							schemaProp: pat,
							dataProp: key,
							dataPropType: util_2.Type.Str
						}, valid);
						if (it.opts.unevaluated && props !== true) gen.assign((0, codegen_1$5._)`${props}[${key}]`, true);
						else if (!alwaysValid && !it.allErrors) gen.if((0, codegen_1$5.not)(valid), () => gen.break());
					});
				});
			}
		}
	};
	exports.default = def$8;
}) });

//#endregion
//#region node_modules/ajv/dist/vocabularies/applicator/not.js
var require_not = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/vocabularies/applicator/not.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const util_1$5 = require_util();
	const def$7 = {
		keyword: "not",
		schemaType: ["object", "boolean"],
		trackErrors: true,
		code(cxt) {
			const { gen, schema: schema$1, it } = cxt;
			if ((0, util_1$5.alwaysValidSchema)(it, schema$1)) {
				cxt.fail();
				return;
			}
			const valid = gen.name("valid");
			cxt.subschema({
				keyword: "not",
				compositeRule: true,
				createErrors: false,
				allErrors: false
			}, valid);
			cxt.failResult(valid, () => cxt.reset(), () => cxt.error());
		},
		error: { message: "must NOT be valid" }
	};
	exports.default = def$7;
}) });

//#endregion
//#region node_modules/ajv/dist/vocabularies/applicator/anyOf.js
var require_anyOf = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/vocabularies/applicator/anyOf.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const def$6 = {
		keyword: "anyOf",
		schemaType: "array",
		trackErrors: true,
		code: require_code().validateUnion,
		error: { message: "must match a schema in anyOf" }
	};
	exports.default = def$6;
}) });

//#endregion
//#region node_modules/ajv/dist/vocabularies/applicator/oneOf.js
var require_oneOf = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/vocabularies/applicator/oneOf.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$4 = require_codegen();
	const util_1$4 = require_util();
	const def$5 = {
		keyword: "oneOf",
		schemaType: "array",
		trackErrors: true,
		error: {
			message: "must match exactly one schema in oneOf",
			params: ({ params }) => (0, codegen_1$4._)`{passingSchemas: ${params.passing}}`
		},
		code(cxt) {
			const { gen, schema: schema$1, parentSchema, it } = cxt;
			/* istanbul ignore if */
			if (!Array.isArray(schema$1)) throw new Error("ajv implementation error");
			if (it.opts.discriminator && parentSchema.discriminator) return;
			const schArr = schema$1;
			const valid = gen.let("valid", false);
			const passing = gen.let("passing", null);
			const schValid = gen.name("_valid");
			cxt.setParams({ passing });
			gen.block(validateOneOf);
			cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
			function validateOneOf() {
				schArr.forEach((sch, i) => {
					let schCxt;
					if ((0, util_1$4.alwaysValidSchema)(it, sch)) gen.var(schValid, true);
					else schCxt = cxt.subschema({
						keyword: "oneOf",
						schemaProp: i,
						compositeRule: true
					}, schValid);
					if (i > 0) gen.if((0, codegen_1$4._)`${schValid} && ${valid}`).assign(valid, false).assign(passing, (0, codegen_1$4._)`[${passing}, ${i}]`).else();
					gen.if(schValid, () => {
						gen.assign(valid, true);
						gen.assign(passing, i);
						if (schCxt) cxt.mergeEvaluated(schCxt, codegen_1$4.Name);
					});
				});
			}
		}
	};
	exports.default = def$5;
}) });

//#endregion
//#region node_modules/ajv/dist/vocabularies/applicator/allOf.js
var require_allOf = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/vocabularies/applicator/allOf.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const util_1$3 = require_util();
	const def$4 = {
		keyword: "allOf",
		schemaType: "array",
		code(cxt) {
			const { gen, schema: schema$1, it } = cxt;
			/* istanbul ignore if */
			if (!Array.isArray(schema$1)) throw new Error("ajv implementation error");
			const valid = gen.name("valid");
			schema$1.forEach((sch, i) => {
				if ((0, util_1$3.alwaysValidSchema)(it, sch)) return;
				const schCxt = cxt.subschema({
					keyword: "allOf",
					schemaProp: i
				}, valid);
				cxt.ok(valid);
				cxt.mergeEvaluated(schCxt);
			});
		}
	};
	exports.default = def$4;
}) });

//#endregion
//#region node_modules/ajv/dist/vocabularies/applicator/if.js
var require_if = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/vocabularies/applicator/if.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$3 = require_codegen();
	const util_1$2 = require_util();
	const def$3 = {
		keyword: "if",
		schemaType: ["object", "boolean"],
		trackErrors: true,
		error: {
			message: ({ params }) => (0, codegen_1$3.str)`must match "${params.ifClause}" schema`,
			params: ({ params }) => (0, codegen_1$3._)`{failingKeyword: ${params.ifClause}}`
		},
		code(cxt) {
			const { gen, parentSchema, it } = cxt;
			if (parentSchema.then === void 0 && parentSchema.else === void 0) (0, util_1$2.checkStrictMode)(it, "\"if\" without \"then\" and \"else\" is ignored");
			const hasThen = hasSchema(it, "then");
			const hasElse = hasSchema(it, "else");
			if (!hasThen && !hasElse) return;
			const valid = gen.let("valid", true);
			const schValid = gen.name("_valid");
			validateIf();
			cxt.reset();
			if (hasThen && hasElse) {
				const ifClause = gen.let("ifClause");
				cxt.setParams({ ifClause });
				gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
			} else if (hasThen) gen.if(schValid, validateClause("then"));
			else gen.if((0, codegen_1$3.not)(schValid), validateClause("else"));
			cxt.pass(valid, () => cxt.error(true));
			function validateIf() {
				const schCxt = cxt.subschema({
					keyword: "if",
					compositeRule: true,
					createErrors: false,
					allErrors: false
				}, schValid);
				cxt.mergeEvaluated(schCxt);
			}
			function validateClause(keyword, ifClause) {
				return () => {
					const schCxt = cxt.subschema({ keyword }, schValid);
					gen.assign(valid, schValid);
					cxt.mergeValidEvaluated(schCxt, valid);
					if (ifClause) gen.assign(ifClause, (0, codegen_1$3._)`${keyword}`);
					else cxt.setParams({ ifClause: keyword });
				};
			}
		}
	};
	function hasSchema(it, keyword) {
		const schema$1 = it.schema[keyword];
		return schema$1 !== void 0 && !(0, util_1$2.alwaysValidSchema)(it, schema$1);
	}
	exports.default = def$3;
}) });

//#endregion
//#region node_modules/ajv/dist/vocabularies/applicator/thenElse.js
var require_thenElse = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/vocabularies/applicator/thenElse.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const util_1$1 = require_util();
	const def$2 = {
		keyword: ["then", "else"],
		schemaType: ["object", "boolean"],
		code({ keyword, parentSchema, it }) {
			if (parentSchema.if === void 0) (0, util_1$1.checkStrictMode)(it, `"${keyword}" without "if" is ignored`);
		}
	};
	exports.default = def$2;
}) });

//#endregion
//#region node_modules/ajv/dist/vocabularies/applicator/index.js
var require_applicator = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/vocabularies/applicator/index.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const additionalItems_1 = require_additionalItems();
	const prefixItems_1 = require_prefixItems();
	const items_1 = require_items();
	const items2020_1 = require_items2020();
	const contains_1 = require_contains();
	const dependencies_1 = require_dependencies();
	const propertyNames_1 = require_propertyNames();
	const additionalProperties_1 = require_additionalProperties();
	const properties_1 = require_properties();
	const patternProperties_1 = require_patternProperties();
	const not_1 = require_not();
	const anyOf_1 = require_anyOf();
	const oneOf_1 = require_oneOf();
	const allOf_1 = require_allOf();
	const if_1 = require_if();
	const thenElse_1 = require_thenElse();
	function getApplicator(draft2020 = false) {
		const applicator = [
			not_1.default,
			anyOf_1.default,
			oneOf_1.default,
			allOf_1.default,
			if_1.default,
			thenElse_1.default,
			propertyNames_1.default,
			additionalProperties_1.default,
			dependencies_1.default,
			properties_1.default,
			patternProperties_1.default
		];
		if (draft2020) applicator.push(prefixItems_1.default, items2020_1.default);
		else applicator.push(additionalItems_1.default, items_1.default);
		applicator.push(contains_1.default);
		return applicator;
	}
	exports.default = getApplicator;
}) });

//#endregion
//#region node_modules/ajv/dist/vocabularies/format/format.js
var require_format$1 = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/vocabularies/format/format.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$2 = require_codegen();
	const def$1 = {
		keyword: "format",
		type: ["number", "string"],
		schemaType: "string",
		$data: true,
		error: {
			message: ({ schemaCode }) => (0, codegen_1$2.str)`must match format "${schemaCode}"`,
			params: ({ schemaCode }) => (0, codegen_1$2._)`{format: ${schemaCode}}`
		},
		code(cxt, ruleType) {
			const { gen, data, $data, schema: schema$1, schemaCode, it } = cxt;
			const { opts, errSchemaPath, schemaEnv, self } = it;
			if (!opts.validateFormats) return;
			if ($data) validate$DataFormat();
			else validateFormat();
			function validate$DataFormat() {
				const fmts = gen.scopeValue("formats", {
					ref: self.formats,
					code: opts.code.formats
				});
				const fDef = gen.const("fDef", (0, codegen_1$2._)`${fmts}[${schemaCode}]`);
				const fType = gen.let("fType");
				const format$1 = gen.let("format");
				gen.if((0, codegen_1$2._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1$2._)`${fDef}.type || "string"`).assign(format$1, (0, codegen_1$2._)`${fDef}.validate`), () => gen.assign(fType, (0, codegen_1$2._)`"string"`).assign(format$1, fDef));
				cxt.fail$data((0, codegen_1$2.or)(unknownFmt(), invalidFmt()));
				function unknownFmt() {
					if (opts.strictSchema === false) return codegen_1$2.nil;
					return (0, codegen_1$2._)`${schemaCode} && !${format$1}`;
				}
				function invalidFmt() {
					const callFormat = schemaEnv.$async ? (0, codegen_1$2._)`(${fDef}.async ? await ${format$1}(${data}) : ${format$1}(${data}))` : (0, codegen_1$2._)`${format$1}(${data})`;
					const validData = (0, codegen_1$2._)`(typeof ${format$1} == "function" ? ${callFormat} : ${format$1}.test(${data}))`;
					return (0, codegen_1$2._)`${format$1} && ${format$1} !== true && ${fType} === ${ruleType} && !${validData}`;
				}
			}
			function validateFormat() {
				const formatDef = self.formats[schema$1];
				if (!formatDef) {
					unknownFormat();
					return;
				}
				if (formatDef === true) return;
				const [fmtType, format$1, fmtRef] = getFormat(formatDef);
				if (fmtType === ruleType) cxt.pass(validCondition());
				function unknownFormat() {
					if (opts.strictSchema === false) {
						self.logger.warn(unknownMsg());
						return;
					}
					throw new Error(unknownMsg());
					function unknownMsg() {
						return `unknown format "${schema$1}" ignored in schema at path "${errSchemaPath}"`;
					}
				}
				function getFormat(fmtDef) {
					const code = fmtDef instanceof RegExp ? (0, codegen_1$2.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1$2._)`${opts.code.formats}${(0, codegen_1$2.getProperty)(schema$1)}` : void 0;
					const fmt = gen.scopeValue("formats", {
						key: schema$1,
						ref: fmtDef,
						code
					});
					if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) return [
						fmtDef.type || "string",
						fmtDef.validate,
						(0, codegen_1$2._)`${fmt}.validate`
					];
					return [
						"string",
						fmtDef,
						fmt
					];
				}
				function validCondition() {
					if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
						if (!schemaEnv.$async) throw new Error("async format in sync schema");
						return (0, codegen_1$2._)`await ${fmtRef}(${data})`;
					}
					return typeof format$1 == "function" ? (0, codegen_1$2._)`${fmtRef}(${data})` : (0, codegen_1$2._)`${fmtRef}.test(${data})`;
				}
			}
		}
	};
	exports.default = def$1;
}) });

//#endregion
//#region node_modules/ajv/dist/vocabularies/format/index.js
var require_format = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/vocabularies/format/index.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const format = [require_format$1().default];
	exports.default = format;
}) });

//#endregion
//#region node_modules/ajv/dist/vocabularies/metadata.js
var require_metadata = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/vocabularies/metadata.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.metadataVocabulary = [
		"title",
		"description",
		"default",
		"deprecated",
		"readOnly",
		"writeOnly",
		"examples"
	];
	exports.contentVocabulary = [
		"contentMediaType",
		"contentEncoding",
		"contentSchema"
	];
}) });

//#endregion
//#region node_modules/ajv/dist/vocabularies/draft7.js
var require_draft7 = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/vocabularies/draft7.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const core_1$1 = require_core();
	const validation_1 = require_validation();
	const applicator_1 = require_applicator();
	const format_1 = require_format();
	const metadata_1 = require_metadata();
	const draft7Vocabularies = [
		core_1$1.default,
		validation_1.default,
		(0, applicator_1.default)(),
		format_1.default,
		metadata_1.metadataVocabulary,
		metadata_1.contentVocabulary
	];
	exports.default = draft7Vocabularies;
}) });

//#endregion
//#region node_modules/ajv/dist/vocabularies/discriminator/types.js
var require_types = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/vocabularies/discriminator/types.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var DiscrError;
	(function(DiscrError$1) {
		DiscrError$1["Tag"] = "tag";
		DiscrError$1["Mapping"] = "mapping";
	})(DiscrError || (exports.DiscrError = DiscrError = {}));
}) });

//#endregion
//#region node_modules/ajv/dist/vocabularies/discriminator/index.js
var require_discriminator = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/vocabularies/discriminator/index.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$1 = require_codegen();
	const types_1 = require_types();
	const compile_1 = require_compile();
	const ref_error_1$1 = require_ref_error();
	const util_1 = require_util();
	const def = {
		keyword: "discriminator",
		type: "object",
		schemaType: "object",
		error: {
			message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
			params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1$1._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
		},
		code(cxt) {
			const { gen, data, schema: schema$1, parentSchema, it } = cxt;
			const { oneOf } = parentSchema;
			if (!it.opts.discriminator) throw new Error("discriminator: requires discriminator option");
			const tagName = schema$1.propertyName;
			if (typeof tagName != "string") throw new Error("discriminator: requires propertyName");
			if (schema$1.mapping) throw new Error("discriminator: mapping is not supported");
			if (!oneOf) throw new Error("discriminator: requires oneOf keyword");
			const valid = gen.let("valid", false);
			const tag = gen.const("tag", (0, codegen_1$1._)`${data}${(0, codegen_1$1.getProperty)(tagName)}`);
			gen.if((0, codegen_1$1._)`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, {
				discrError: types_1.DiscrError.Tag,
				tag,
				tagName
			}));
			cxt.ok(valid);
			function validateMapping() {
				const mapping = getMapping();
				gen.if(false);
				for (const tagValue in mapping) {
					gen.elseIf((0, codegen_1$1._)`${tag} === ${tagValue}`);
					gen.assign(valid, applyTagSchema(mapping[tagValue]));
				}
				gen.else();
				cxt.error(false, {
					discrError: types_1.DiscrError.Mapping,
					tag,
					tagName
				});
				gen.endIf();
			}
			function applyTagSchema(schemaProp) {
				const _valid = gen.name("valid");
				const schCxt = cxt.subschema({
					keyword: "oneOf",
					schemaProp
				}, _valid);
				cxt.mergeEvaluated(schCxt, codegen_1$1.Name);
				return _valid;
			}
			function getMapping() {
				var _a$1;
				const oneOfMapping = {};
				const topRequired = hasRequired(parentSchema);
				let tagRequired = true;
				for (let i = 0; i < oneOf.length; i++) {
					let sch = oneOf[i];
					if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {
						const ref = sch.$ref;
						sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, ref);
						if (sch instanceof compile_1.SchemaEnv) sch = sch.schema;
						if (sch === void 0) throw new ref_error_1$1.default(it.opts.uriResolver, it.baseId, ref);
					}
					const propSch = (_a$1 = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a$1 === void 0 ? void 0 : _a$1[tagName];
					if (typeof propSch != "object") throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
					tagRequired = tagRequired && (topRequired || hasRequired(sch));
					addMappings(propSch, i);
				}
				if (!tagRequired) throw new Error(`discriminator: "${tagName}" must be required`);
				return oneOfMapping;
				function hasRequired({ required }) {
					return Array.isArray(required) && required.includes(tagName);
				}
				function addMappings(sch, i) {
					if (sch.const) addMapping(sch.const, i);
					else if (sch.enum) for (const tagValue of sch.enum) addMapping(tagValue, i);
					else throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
				}
				function addMapping(tagValue, i) {
					if (typeof tagValue != "string" || tagValue in oneOfMapping) throw new Error(`discriminator: "${tagName}" values must be unique strings`);
					oneOfMapping[tagValue] = i;
				}
			}
		}
	};
	exports.default = def;
}) });

//#endregion
//#region node_modules/ajv/dist/refs/json-schema-draft-07.json
var require_json_schema_draft_07 = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/refs/json-schema-draft-07.json": ((exports, module) => {
	module.exports = {
		"$schema": "http://json-schema.org/draft-07/schema#",
		"$id": "http://json-schema.org/draft-07/schema#",
		"title": "Core schema meta-schema",
		"definitions": {
			"schemaArray": {
				"type": "array",
				"minItems": 1,
				"items": { "$ref": "#" }
			},
			"nonNegativeInteger": {
				"type": "integer",
				"minimum": 0
			},
			"nonNegativeIntegerDefault0": { "allOf": [{ "$ref": "#/definitions/nonNegativeInteger" }, { "default": 0 }] },
			"simpleTypes": { "enum": [
				"array",
				"boolean",
				"integer",
				"null",
				"number",
				"object",
				"string"
			] },
			"stringArray": {
				"type": "array",
				"items": { "type": "string" },
				"uniqueItems": true,
				"default": []
			}
		},
		"type": ["object", "boolean"],
		"properties": {
			"$id": {
				"type": "string",
				"format": "uri-reference"
			},
			"$schema": {
				"type": "string",
				"format": "uri"
			},
			"$ref": {
				"type": "string",
				"format": "uri-reference"
			},
			"$comment": { "type": "string" },
			"title": { "type": "string" },
			"description": { "type": "string" },
			"default": true,
			"readOnly": {
				"type": "boolean",
				"default": false
			},
			"examples": {
				"type": "array",
				"items": true
			},
			"multipleOf": {
				"type": "number",
				"exclusiveMinimum": 0
			},
			"maximum": { "type": "number" },
			"exclusiveMaximum": { "type": "number" },
			"minimum": { "type": "number" },
			"exclusiveMinimum": { "type": "number" },
			"maxLength": { "$ref": "#/definitions/nonNegativeInteger" },
			"minLength": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },
			"pattern": {
				"type": "string",
				"format": "regex"
			},
			"additionalItems": { "$ref": "#" },
			"items": {
				"anyOf": [{ "$ref": "#" }, { "$ref": "#/definitions/schemaArray" }],
				"default": true
			},
			"maxItems": { "$ref": "#/definitions/nonNegativeInteger" },
			"minItems": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },
			"uniqueItems": {
				"type": "boolean",
				"default": false
			},
			"contains": { "$ref": "#" },
			"maxProperties": { "$ref": "#/definitions/nonNegativeInteger" },
			"minProperties": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },
			"required": { "$ref": "#/definitions/stringArray" },
			"additionalProperties": { "$ref": "#" },
			"definitions": {
				"type": "object",
				"additionalProperties": { "$ref": "#" },
				"default": {}
			},
			"properties": {
				"type": "object",
				"additionalProperties": { "$ref": "#" },
				"default": {}
			},
			"patternProperties": {
				"type": "object",
				"additionalProperties": { "$ref": "#" },
				"propertyNames": { "format": "regex" },
				"default": {}
			},
			"dependencies": {
				"type": "object",
				"additionalProperties": { "anyOf": [{ "$ref": "#" }, { "$ref": "#/definitions/stringArray" }] }
			},
			"propertyNames": { "$ref": "#" },
			"const": true,
			"enum": {
				"type": "array",
				"items": true,
				"minItems": 1,
				"uniqueItems": true
			},
			"type": { "anyOf": [{ "$ref": "#/definitions/simpleTypes" }, {
				"type": "array",
				"items": { "$ref": "#/definitions/simpleTypes" },
				"minItems": 1,
				"uniqueItems": true
			}] },
			"format": { "type": "string" },
			"contentMediaType": { "type": "string" },
			"contentEncoding": { "type": "string" },
			"if": { "$ref": "#" },
			"then": { "$ref": "#" },
			"else": { "$ref": "#" },
			"allOf": { "$ref": "#/definitions/schemaArray" },
			"anyOf": { "$ref": "#/definitions/schemaArray" },
			"oneOf": { "$ref": "#/definitions/schemaArray" },
			"not": { "$ref": "#" }
		},
		"default": true
	};
}) });

//#endregion
//#region node_modules/ajv/dist/ajv.js
var require_ajv = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/ajv.js": ((exports, module) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = exports.Ajv = void 0;
	const core_1 = require_core$1();
	const draft7_1 = require_draft7();
	const discriminator_1 = require_discriminator();
	const draft7MetaSchema = require_json_schema_draft_07();
	const META_SUPPORT_DATA = ["/properties"];
	const META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
	var Ajv$1 = class extends core_1.default {
		_addVocabularies() {
			super._addVocabularies();
			draft7_1.default.forEach((v) => this.addVocabulary(v));
			if (this.opts.discriminator) this.addKeyword(discriminator_1.default);
		}
		_addDefaultMetaSchema() {
			super._addDefaultMetaSchema();
			if (!this.opts.meta) return;
			const metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;
			this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
			this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
		}
		defaultMeta() {
			return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
		}
	};
	exports.Ajv = Ajv$1;
	module.exports = exports = Ajv$1;
	module.exports.Ajv = Ajv$1;
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Ajv$1;
	var validate_1 = require_validate();
	Object.defineProperty(exports, "KeywordCxt", {
		enumerable: true,
		get: function() {
			return validate_1.KeywordCxt;
		}
	});
	var codegen_1 = require_codegen();
	Object.defineProperty(exports, "_", {
		enumerable: true,
		get: function() {
			return codegen_1._;
		}
	});
	Object.defineProperty(exports, "str", {
		enumerable: true,
		get: function() {
			return codegen_1.str;
		}
	});
	Object.defineProperty(exports, "stringify", {
		enumerable: true,
		get: function() {
			return codegen_1.stringify;
		}
	});
	Object.defineProperty(exports, "nil", {
		enumerable: true,
		get: function() {
			return codegen_1.nil;
		}
	});
	Object.defineProperty(exports, "Name", {
		enumerable: true,
		get: function() {
			return codegen_1.Name;
		}
	});
	Object.defineProperty(exports, "CodeGen", {
		enumerable: true,
		get: function() {
			return codegen_1.CodeGen;
		}
	});
	var validation_error_1 = require_validation_error();
	Object.defineProperty(exports, "ValidationError", {
		enumerable: true,
		get: function() {
			return validation_error_1.default;
		}
	});
	var ref_error_1 = require_ref_error();
	Object.defineProperty(exports, "MissingRefError", {
		enumerable: true,
		get: function() {
			return ref_error_1.default;
		}
	});
}) });

//#endregion
//#region src/index.ts
var import_ajv = /* @__PURE__ */ __toESM$2(require_ajv());
const LLM_Results = table({
	name: "llm_result",
	public: true
}, {
	id: t.u128().autoInc().primaryKey(),
	prompt: t.string(),
	schema: t.string(),
	response: t.string(),
	provider: t.string(),
	model: t.string()
});
const spacetimedb = schema(LLM_Results);
spacetimedb.reducer("add_call", {
	prompt: t.string(),
	schema: t.string(),
	response: t.string(),
	provider: t.string(),
	model: t.string()
}, (ctx, { prompt, schema: schema$1, response, provider, model }) => {
	const validate = new import_ajv.Ajv().compile(JSON.parse(schema$1));
	if (!validate(JSON.parse(response))) {
		console.error("ERROR posting to database: ", validate.errors);
		throw new Error(validate.errors ? validate.errors.map((e) => e.message).join(", ") : "Invalid response");
	}
	ctx.db.llmResult.insert({
		id: 0n,
		prompt,
		schema: schema$1,
		response,
		provider,
		model
	});
});

//#endregion
export { spacetimedb };
//# debugId=50b81651-420c-4dac-a948-eb8f1af03d98
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnVuZGxlLmpzIiwibmFtZXMiOlsiX19jcmVhdGUiLCJfX2RlZlByb3AiLCJfX2dldE93blByb3BEZXNjIiwiX19nZXRPd25Qcm9wTmFtZXMiLCJfX2dldFByb3RvT2YiLCJfX2hhc093blByb3AiLCJfX2NvbW1vbkpTIiwiX19jb3B5UHJvcHMiLCJfX3RvRVNNIiwic3RyIiwicGFyc2UiLCJpbml0IiwiRSIsIl8iLCJleHBvcnRzIiwiI3ZpZXciLCIjb2Zmc2V0IiwiI2Vuc3VyZSIsIiNidWZmZXIiLCIjZXhwYW5kQnVmZmVyIiwic3RyIiwiYW5kIiwiI2Zyb20iLCIjdG8iLCIjYm9keSIsIiNpbm5lciIsInVyaSIsIiNpZGVudGl0eSIsIiNzZW5kZXJBdXRoIiwiI3V1aWRDb3VudGVyIiwiI2ZpbmFsaXphdGlvblJlZ2lzdHJ5IiwiI2lkIiwiI2RldGFjaCIsIl9hIiwibmFtZXMiLCJjb2RlXzEiLCJfYSIsIl9iIiwiZGVmIiwiY29kZV8xIiwibmFtZXMiLCJfYSIsIl9iIiwiY29kZWdlbl8xIiwiY29kZV8xIiwic2NoZW1hIiwic3RyIiwiY29kZWdlbl8xIiwiY29kZWdlbl8xIiwidXRpbF8xIiwibmFtZXNfMSIsImVycm9yc18xIiwiY29kZWdlbl8xIiwibmFtZXNfMSIsInNjaGVtYSIsInNjaGVtYSIsIl9hIiwicnVsZXNfMSIsImFwcGxpY2FiaWxpdHlfMSIsImVycm9yc18xIiwiY29kZWdlbl8xIiwidXRpbF8xIiwic2NoZW1hIiwidCIsImNvZGVnZW5fMSIsInV0aWxfMSIsImNvZGVnZW5fMSIsInV0aWxfMSIsIm5hbWVzXzEiLCJ1dGlsXzIiLCJzY2hlbWEiLCJjb2RlZ2VuXzEiLCJuYW1lc18xIiwiY29kZV8xIiwiZXJyb3JzXzEiLCJkZWYiLCJzY2hlbWEiLCJfYSIsImVycm9ycyIsImNvZGVnZW5fMSIsInV0aWxfMSIsInNjaGVtYSIsImVxdWFsIiwidHJhdmVyc2UiLCJzY2hlbWEiLCJzdHIiLCJ1dGlsXzEiLCJlcXVhbCIsInNjaGVtYSIsIm5vcm1hbGl6ZSIsImRhdGFUeXBlXzEiLCJjb2RlZ2VuXzEiLCJuYW1lc18xIiwicmVzb2x2ZV8xIiwidXRpbF8xIiwic2NoZW1hIiwiVmFsaWRhdGlvbkVycm9yIiwidCIsImRlZiIsImVycm9ycyIsInJlc29sdmVfMSIsImNvZGVnZW5fMSIsInZhbGlkYXRpb25fZXJyb3JfMSIsIm5hbWVzXzEiLCJyZXNvbHZlXzEiLCJ1dGlsXzEiLCJ2YWxpZGF0ZV8xIiwiX2EiLCJzY2hlbWEiLCJyZXNvbHZlIiwiaXNVVUlEIiwiaXNJUHY0Iiwibm9uU2ltcGxlRG9tYWluIiwibm9ybWFsaXplSVB2NiIsInN0ciIsInJlbW92ZURvdFNlZ21lbnRzIiwibm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmciLCJyZWNvbXBvc2VBdXRob3JpdHkiLCJnZXRTY2hlbWVIYW5kbGVyIiwiU0NIRU1FUyIsInVyaSIsImVxdWFsIiwidmFsaWRhdGVfMSIsImNvZGVnZW5fMSIsInZhbGlkYXRpb25fZXJyb3JfMSIsInJlZl9lcnJvcl8xIiwiY29tcGlsZV8xIiwiZGF0YVR5cGVfMSIsInV0aWxfMSIsInN0ciIsIl9hIiwiX2IiLCJfYyIsIm9wdGltaXplIiwiQWp2Iiwic2NoZW1hIiwiZGVmIiwidCIsImZvcm1hdCIsImVycm9ycyIsImRlZiIsInJlZl9lcnJvcl8xIiwiY29kZV8xIiwiY29kZWdlbl8xIiwibmFtZXNfMSIsImNvbXBpbGVfMSIsInV0aWxfMSIsImRlZiIsIl9hIiwiY29kZWdlbl8xIiwiZGVmIiwiY29kZWdlbl8xIiwiZGVmIiwic3RyIiwiY29kZWdlbl8xIiwidXRpbF8xIiwiZGVmIiwiY29kZV8xIiwiY29kZWdlbl8xIiwiZGVmIiwic2NoZW1hIiwiY29kZWdlbl8xIiwiZGVmIiwiY29kZV8xIiwiY29kZWdlbl8xIiwidXRpbF8xIiwiZGVmIiwic2NoZW1hIiwiY29kZWdlbl8xIiwiZGVmIiwiY29kZWdlbl8xIiwidXRpbF8xIiwiZXF1YWxfMSIsImRlZiIsInNjaGVtYSIsInQiLCJjb2RlZ2VuXzEiLCJ1dGlsXzEiLCJlcXVhbF8xIiwiZGVmIiwic2NoZW1hIiwiY29kZWdlbl8xIiwidXRpbF8xIiwiZGVmIiwic2NoZW1hIiwiY29kZWdlbl8xIiwidXRpbF8xIiwiZGVmIiwic2NoZW1hIiwiY29kZWdlbl8xIiwidXRpbF8xIiwiY29kZV8xIiwiZGVmIiwic2NoZW1hIiwiaXRlbXNfMSIsImRlZiIsImNvZGVnZW5fMSIsInV0aWxfMSIsImNvZGVfMSIsImFkZGl0aW9uYWxJdGVtc18xIiwiZGVmIiwic2NoZW1hIiwiY29kZWdlbl8xIiwidXRpbF8xIiwiZGVmIiwic2NoZW1hIiwiY29kZWdlbl8xIiwidXRpbF8xIiwiY29kZV8xIiwiZGVmIiwic2NoZW1hIiwiY29kZWdlbl8xIiwidXRpbF8xIiwiZGVmIiwic2NoZW1hIiwiY29kZV8xIiwiY29kZWdlbl8xIiwidXRpbF8xIiwiZGVmIiwic2NoZW1hIiwiZXJyb3JzIiwidmFsaWRhdGVfMSIsImNvZGVfMSIsInV0aWxfMSIsImFkZGl0aW9uYWxQcm9wZXJ0aWVzXzEiLCJkZWYiLCJzY2hlbWEiLCJjb2RlZ2VuXzEiLCJ1dGlsXzEiLCJkZWYiLCJzY2hlbWEiLCJ1dGlsXzEiLCJkZWYiLCJzY2hlbWEiLCJkZWYiLCJjb2RlZ2VuXzEiLCJ1dGlsXzEiLCJkZWYiLCJzY2hlbWEiLCJ1dGlsXzEiLCJkZWYiLCJzY2hlbWEiLCJjb2RlZ2VuXzEiLCJ1dGlsXzEiLCJkZWYiLCJzY2hlbWEiLCJ1dGlsXzEiLCJkZWYiLCJjb2RlZ2VuXzEiLCJkZWYiLCJmb3JtYXQiLCJzY2hlbWEiLCJjb3JlXzEiLCJjb2RlZ2VuXzEiLCJyZWZfZXJyb3JfMSIsInNjaGVtYSIsIl9hIiwiQWp2IiwiQWp2Iiwic2NoZW1hIl0sInNvdXJjZXMiOlsibm9kZV9tb2R1bGVzL2hlYWRlcnMtcG9seWZpbGwvbGliL2luZGV4Lm1qcyIsIm5vZGVfbW9kdWxlcy9zcGFjZXRpbWVkYi9kaXN0L3NlcnZlci9pbmRleC5tanMiLCJub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS9jb2RlZ2VuL2NvZGUuanMiLCJub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS9jb2RlZ2VuL3Njb3BlLmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvY29kZWdlbi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL3V0aWwuanMiLCJub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS9uYW1lcy5qcyIsIm5vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL2Vycm9ycy5qcyIsIm5vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL3ZhbGlkYXRlL2Jvb2xTY2hlbWEuanMiLCJub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS9ydWxlcy5qcyIsIm5vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL3ZhbGlkYXRlL2FwcGxpY2FiaWxpdHkuanMiLCJub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS92YWxpZGF0ZS9kYXRhVHlwZS5qcyIsIm5vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL3ZhbGlkYXRlL2RlZmF1bHRzLmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9jb2RlLmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvdmFsaWRhdGUva2V5d29yZC5qcyIsIm5vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL3ZhbGlkYXRlL3N1YnNjaGVtYS5qcyIsIm5vZGVfbW9kdWxlcy9mYXN0LWRlZXAtZXF1YWwvaW5kZXguanMiLCJub2RlX21vZHVsZXMvanNvbi1zY2hlbWEtdHJhdmVyc2UvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS9yZXNvbHZlLmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvdmFsaWRhdGUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYWp2L2Rpc3QvcnVudGltZS92YWxpZGF0aW9uX2Vycm9yLmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvcmVmX2Vycm9yLmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYWp2L2Rpc3QvcmVmcy9kYXRhLmpzb24iLCJub2RlX21vZHVsZXMvZmFzdC11cmkvbGliL3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL2Zhc3QtdXJpL2xpYi9zY2hlbWVzLmpzIiwibm9kZV9tb2R1bGVzL2Zhc3QtdXJpL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3J1bnRpbWUvdXJpLmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvcmUuanMiLCJub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2NvcmUvaWQuanMiLCJub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2NvcmUvcmVmLmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9jb3JlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL2xpbWl0TnVtYmVyLmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL211bHRpcGxlT2YuanMiLCJub2RlX21vZHVsZXMvYWp2L2Rpc3QvcnVudGltZS91Y3MybGVuZ3RoLmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL2xpbWl0TGVuZ3RoLmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL3BhdHRlcm4uanMiLCJub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL3ZhbGlkYXRpb24vbGltaXRQcm9wZXJ0aWVzLmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL3JlcXVpcmVkLmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL2xpbWl0SXRlbXMuanMiLCJub2RlX21vZHVsZXMvYWp2L2Rpc3QvcnVudGltZS9lcXVhbC5qcyIsIm5vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi91bmlxdWVJdGVtcy5qcyIsIm5vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9jb25zdC5qcyIsIm5vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9lbnVtLmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2FkZGl0aW9uYWxJdGVtcy5qcyIsIm5vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9pdGVtcy5qcyIsIm5vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9wcmVmaXhJdGVtcy5qcyIsIm5vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9pdGVtczIwMjAuanMiLCJub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvY29udGFpbnMuanMiLCJub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvZGVwZW5kZW5jaWVzLmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL3Byb3BlcnR5TmFtZXMuanMiLCJub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvYWRkaXRpb25hbFByb3BlcnRpZXMuanMiLCJub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvcHJvcGVydGllcy5qcyIsIm5vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9wYXR0ZXJuUHJvcGVydGllcy5qcyIsIm5vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9ub3QuanMiLCJub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvYW55T2YuanMiLCJub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3Ivb25lT2YuanMiLCJub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvYWxsT2YuanMiLCJub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvaWYuanMiLCJub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvdGhlbkVsc2UuanMiLCJub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2Zvcm1hdC9mb3JtYXQuanMiLCJub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2Zvcm1hdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvbWV0YWRhdGEuanMiLCJub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2RyYWZ0Ny5qcyIsIm5vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvZGlzY3JpbWluYXRvci90eXBlcy5qcyIsIm5vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvZGlzY3JpbWluYXRvci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9hanYvZGlzdC9yZWZzL2pzb24tc2NoZW1hLWRyYWZ0LTA3Lmpzb24iLCJub2RlX21vZHVsZXMvYWp2L2Rpc3QvYWp2LmpzIiwic3JjL2luZGV4LnRzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2NyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19nZXRQcm90b09mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19jb21tb25KUyA9IChjYiwgbW9kKSA9PiBmdW5jdGlvbiBfX3JlcXVpcmUoKSB7XG4gIHJldHVybiBtb2QgfHwgKDAsIGNiW19fZ2V0T3duUHJvcE5hbWVzKGNiKVswXV0pKChtb2QgPSB7IGV4cG9ydHM6IHt9IH0pLmV4cG9ydHMsIG1vZCksIG1vZC5leHBvcnRzO1xufTtcbnZhciBfX2NvcHlQcm9wcyA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG4gIGlmIChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMoZnJvbSkpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxuICAgICAgICBfX2RlZlByb3AodG8sIGtleSwgeyBnZXQ6ICgpID0+IGZyb21ba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRvO1xufTtcbnZhciBfX3RvRVNNID0gKG1vZCwgaXNOb2RlTW9kZSwgdGFyZ2V0KSA9PiAodGFyZ2V0ID0gbW9kICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kKSkgOiB7fSwgX19jb3B5UHJvcHMoXG4gIC8vIElmIHRoZSBpbXBvcnRlciBpcyBpbiBub2RlIGNvbXBhdGliaWxpdHkgbW9kZSBvciB0aGlzIGlzIG5vdCBhbiBFU01cbiAgLy8gZmlsZSB0aGF0IGhhcyBiZWVuIGNvbnZlcnRlZCB0byBhIENvbW1vbkpTIGZpbGUgdXNpbmcgYSBCYWJlbC1cbiAgLy8gY29tcGF0aWJsZSB0cmFuc2Zvcm0gKGkuZS4gXCJfX2VzTW9kdWxlXCIgaGFzIG5vdCBiZWVuIHNldCksIHRoZW4gc2V0XG4gIC8vIFwiZGVmYXVsdFwiIHRvIHRoZSBDb21tb25KUyBcIm1vZHVsZS5leHBvcnRzXCIgZm9yIG5vZGUgY29tcGF0aWJpbGl0eS5cbiAgaXNOb2RlTW9kZSB8fCAhbW9kIHx8ICFtb2QuX19lc01vZHVsZSA/IF9fZGVmUHJvcCh0YXJnZXQsIFwiZGVmYXVsdFwiLCB7IHZhbHVlOiBtb2QsIGVudW1lcmFibGU6IHRydWUgfSkgOiB0YXJnZXQsXG4gIG1vZFxuKSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9zZXQtY29va2llLXBhcnNlci9saWIvc2V0LWNvb2tpZS5qc1xudmFyIHJlcXVpcmVfc2V0X2Nvb2tpZSA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9zZXQtY29va2llLXBhcnNlci9saWIvc2V0LWNvb2tpZS5qc1wiKGV4cG9ydHMsIG1vZHVsZSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBkZWZhdWx0UGFyc2VPcHRpb25zID0ge1xuICAgICAgZGVjb2RlVmFsdWVzOiB0cnVlLFxuICAgICAgbWFwOiBmYWxzZSxcbiAgICAgIHNpbGVudDogZmFsc2VcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGlzTm9uRW1wdHlTdHJpbmcoc3RyKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHN0ciA9PT0gXCJzdHJpbmdcIiAmJiAhIXN0ci50cmltKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlU3RyaW5nKHNldENvb2tpZVZhbHVlLCBvcHRpb25zKSB7XG4gICAgICB2YXIgcGFydHMgPSBzZXRDb29raWVWYWx1ZS5zcGxpdChcIjtcIikuZmlsdGVyKGlzTm9uRW1wdHlTdHJpbmcpO1xuICAgICAgdmFyIG5hbWVWYWx1ZVBhaXJTdHIgPSBwYXJ0cy5zaGlmdCgpO1xuICAgICAgdmFyIHBhcnNlZCA9IHBhcnNlTmFtZVZhbHVlUGFpcihuYW1lVmFsdWVQYWlyU3RyKTtcbiAgICAgIHZhciBuYW1lID0gcGFyc2VkLm5hbWU7XG4gICAgICB2YXIgdmFsdWUgPSBwYXJzZWQudmFsdWU7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyA/IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRQYXJzZU9wdGlvbnMsIG9wdGlvbnMpIDogZGVmYXVsdFBhcnNlT3B0aW9ucztcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhbHVlID0gb3B0aW9ucy5kZWNvZGVWYWx1ZXMgPyBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpIDogdmFsdWU7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJzZXQtY29va2llLXBhcnNlciBlbmNvdW50ZXJlZCBhbiBlcnJvciB3aGlsZSBkZWNvZGluZyBhIGNvb2tpZSB3aXRoIHZhbHVlICdcIiArIHZhbHVlICsgXCInLiBTZXQgb3B0aW9ucy5kZWNvZGVWYWx1ZXMgdG8gZmFsc2UgdG8gZGlzYWJsZSB0aGlzIGZlYXR1cmUuXCIsXG4gICAgICAgICAgZVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdmFyIGNvb2tpZSA9IHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgdmFsdWVcbiAgICAgIH07XG4gICAgICBwYXJ0cy5mb3JFYWNoKGZ1bmN0aW9uKHBhcnQpIHtcbiAgICAgICAgdmFyIHNpZGVzID0gcGFydC5zcGxpdChcIj1cIik7XG4gICAgICAgIHZhciBrZXkgPSBzaWRlcy5zaGlmdCgpLnRyaW1MZWZ0KCkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdmFyIHZhbHVlMiA9IHNpZGVzLmpvaW4oXCI9XCIpO1xuICAgICAgICBpZiAoa2V5ID09PSBcImV4cGlyZXNcIikge1xuICAgICAgICAgIGNvb2tpZS5leHBpcmVzID0gbmV3IERhdGUodmFsdWUyKTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09IFwibWF4LWFnZVwiKSB7XG4gICAgICAgICAgY29va2llLm1heEFnZSA9IHBhcnNlSW50KHZhbHVlMiwgMTApO1xuICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJzZWN1cmVcIikge1xuICAgICAgICAgIGNvb2tpZS5zZWN1cmUgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJodHRwb25seVwiKSB7XG4gICAgICAgICAgY29va2llLmh0dHBPbmx5ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09IFwic2FtZXNpdGVcIikge1xuICAgICAgICAgIGNvb2tpZS5zYW1lU2l0ZSA9IHZhbHVlMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb29raWVba2V5XSA9IHZhbHVlMjtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gY29va2llO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZU5hbWVWYWx1ZVBhaXIobmFtZVZhbHVlUGFpclN0cikge1xuICAgICAgdmFyIG5hbWUgPSBcIlwiO1xuICAgICAgdmFyIHZhbHVlID0gXCJcIjtcbiAgICAgIHZhciBuYW1lVmFsdWVBcnIgPSBuYW1lVmFsdWVQYWlyU3RyLnNwbGl0KFwiPVwiKTtcbiAgICAgIGlmIChuYW1lVmFsdWVBcnIubGVuZ3RoID4gMSkge1xuICAgICAgICBuYW1lID0gbmFtZVZhbHVlQXJyLnNoaWZ0KCk7XG4gICAgICAgIHZhbHVlID0gbmFtZVZhbHVlQXJyLmpvaW4oXCI9XCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBuYW1lVmFsdWVQYWlyU3RyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgbmFtZSwgdmFsdWUgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2UoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zID8gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdFBhcnNlT3B0aW9ucywgb3B0aW9ucykgOiBkZWZhdWx0UGFyc2VPcHRpb25zO1xuICAgICAgaWYgKCFpbnB1dCkge1xuICAgICAgICBpZiAoIW9wdGlvbnMubWFwKSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlucHV0LmhlYWRlcnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dC5oZWFkZXJzLmdldFNldENvb2tpZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgaW5wdXQgPSBpbnB1dC5oZWFkZXJzLmdldFNldENvb2tpZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKGlucHV0LmhlYWRlcnNbXCJzZXQtY29va2llXCJdKSB7XG4gICAgICAgICAgaW5wdXQgPSBpbnB1dC5oZWFkZXJzW1wic2V0LWNvb2tpZVwiXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgc2NoID0gaW5wdXQuaGVhZGVyc1tPYmplY3Qua2V5cyhpbnB1dC5oZWFkZXJzKS5maW5kKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGtleS50b0xvd2VyQ2FzZSgpID09PSBcInNldC1jb29raWVcIjtcbiAgICAgICAgICB9KV07XG4gICAgICAgICAgaWYgKCFzY2ggJiYgaW5wdXQuaGVhZGVycy5jb29raWUgJiYgIW9wdGlvbnMuc2lsZW50KSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgIFwiV2FybmluZzogc2V0LWNvb2tpZS1wYXJzZXIgYXBwZWFycyB0byBoYXZlIGJlZW4gY2FsbGVkIG9uIGEgcmVxdWVzdCBvYmplY3QuIEl0IGlzIGRlc2lnbmVkIHRvIHBhcnNlIFNldC1Db29raWUgaGVhZGVycyBmcm9tIHJlc3BvbnNlcywgbm90IENvb2tpZSBoZWFkZXJzIGZyb20gcmVxdWVzdHMuIFNldCB0aGUgb3B0aW9uIHtzaWxlbnQ6IHRydWV9IHRvIHN1cHByZXNzIHRoaXMgd2FybmluZy5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW5wdXQgPSBzY2g7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgaW5wdXQgPSBbaW5wdXRdO1xuICAgICAgfVxuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0UGFyc2VPcHRpb25zLCBvcHRpb25zKSA6IGRlZmF1bHRQYXJzZU9wdGlvbnM7XG4gICAgICBpZiAoIW9wdGlvbnMubWFwKSB7XG4gICAgICAgIHJldHVybiBpbnB1dC5maWx0ZXIoaXNOb25FbXB0eVN0cmluZykubWFwKGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgIHJldHVybiBwYXJzZVN0cmluZyhzdHIsIG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBjb29raWVzID0ge307XG4gICAgICAgIHJldHVybiBpbnB1dC5maWx0ZXIoaXNOb25FbXB0eVN0cmluZykucmVkdWNlKGZ1bmN0aW9uKGNvb2tpZXMyLCBzdHIpIHtcbiAgICAgICAgICB2YXIgY29va2llID0gcGFyc2VTdHJpbmcoc3RyLCBvcHRpb25zKTtcbiAgICAgICAgICBjb29raWVzMltjb29raWUubmFtZV0gPSBjb29raWU7XG4gICAgICAgICAgcmV0dXJuIGNvb2tpZXMyO1xuICAgICAgICB9LCBjb29raWVzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc3BsaXRDb29raWVzU3RyaW5nMihjb29raWVzU3RyaW5nKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShjb29raWVzU3RyaW5nKSkge1xuICAgICAgICByZXR1cm4gY29va2llc1N0cmluZztcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgY29va2llc1N0cmluZyAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB2YXIgY29va2llc1N0cmluZ3MgPSBbXTtcbiAgICAgIHZhciBwb3MgPSAwO1xuICAgICAgdmFyIHN0YXJ0O1xuICAgICAgdmFyIGNoO1xuICAgICAgdmFyIGxhc3RDb21tYTtcbiAgICAgIHZhciBuZXh0U3RhcnQ7XG4gICAgICB2YXIgY29va2llc1NlcGFyYXRvckZvdW5kO1xuICAgICAgZnVuY3Rpb24gc2tpcFdoaXRlc3BhY2UoKSB7XG4gICAgICAgIHdoaWxlIChwb3MgPCBjb29raWVzU3RyaW5nLmxlbmd0aCAmJiAvXFxzLy50ZXN0KGNvb2tpZXNTdHJpbmcuY2hhckF0KHBvcykpKSB7XG4gICAgICAgICAgcG9zICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvcyA8IGNvb2tpZXNTdHJpbmcubGVuZ3RoO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gbm90U3BlY2lhbENoYXIoKSB7XG4gICAgICAgIGNoID0gY29va2llc1N0cmluZy5jaGFyQXQocG9zKTtcbiAgICAgICAgcmV0dXJuIGNoICE9PSBcIj1cIiAmJiBjaCAhPT0gXCI7XCIgJiYgY2ggIT09IFwiLFwiO1xuICAgICAgfVxuICAgICAgd2hpbGUgKHBvcyA8IGNvb2tpZXNTdHJpbmcubGVuZ3RoKSB7XG4gICAgICAgIHN0YXJ0ID0gcG9zO1xuICAgICAgICBjb29raWVzU2VwYXJhdG9yRm91bmQgPSBmYWxzZTtcbiAgICAgICAgd2hpbGUgKHNraXBXaGl0ZXNwYWNlKCkpIHtcbiAgICAgICAgICBjaCA9IGNvb2tpZXNTdHJpbmcuY2hhckF0KHBvcyk7XG4gICAgICAgICAgaWYgKGNoID09PSBcIixcIikge1xuICAgICAgICAgICAgbGFzdENvbW1hID0gcG9zO1xuICAgICAgICAgICAgcG9zICs9IDE7XG4gICAgICAgICAgICBza2lwV2hpdGVzcGFjZSgpO1xuICAgICAgICAgICAgbmV4dFN0YXJ0ID0gcG9zO1xuICAgICAgICAgICAgd2hpbGUgKHBvcyA8IGNvb2tpZXNTdHJpbmcubGVuZ3RoICYmIG5vdFNwZWNpYWxDaGFyKCkpIHtcbiAgICAgICAgICAgICAgcG9zICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocG9zIDwgY29va2llc1N0cmluZy5sZW5ndGggJiYgY29va2llc1N0cmluZy5jaGFyQXQocG9zKSA9PT0gXCI9XCIpIHtcbiAgICAgICAgICAgICAgY29va2llc1NlcGFyYXRvckZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgcG9zID0gbmV4dFN0YXJ0O1xuICAgICAgICAgICAgICBjb29raWVzU3RyaW5ncy5wdXNoKGNvb2tpZXNTdHJpbmcuc3Vic3RyaW5nKHN0YXJ0LCBsYXN0Q29tbWEpKTtcbiAgICAgICAgICAgICAgc3RhcnQgPSBwb3M7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwb3MgPSBsYXN0Q29tbWEgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb3MgKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb29raWVzU2VwYXJhdG9yRm91bmQgfHwgcG9zID49IGNvb2tpZXNTdHJpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgY29va2llc1N0cmluZ3MucHVzaChjb29raWVzU3RyaW5nLnN1YnN0cmluZyhzdGFydCwgY29va2llc1N0cmluZy5sZW5ndGgpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNvb2tpZXNTdHJpbmdzO1xuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHBhcnNlO1xuICAgIG1vZHVsZS5leHBvcnRzLnBhcnNlID0gcGFyc2U7XG4gICAgbW9kdWxlLmV4cG9ydHMucGFyc2VTdHJpbmcgPSBwYXJzZVN0cmluZztcbiAgICBtb2R1bGUuZXhwb3J0cy5zcGxpdENvb2tpZXNTdHJpbmcgPSBzcGxpdENvb2tpZXNTdHJpbmcyO1xuICB9XG59KTtcblxuLy8gc3JjL0hlYWRlcnMudHNcbnZhciBpbXBvcnRfc2V0X2Nvb2tpZV9wYXJzZXIgPSBfX3RvRVNNKHJlcXVpcmVfc2V0X2Nvb2tpZSgpKTtcblxuLy8gc3JjL3V0aWxzL25vcm1hbGl6ZUhlYWRlck5hbWUudHNcbnZhciBIRUFERVJTX0lOVkFMSURfQ0hBUkFDVEVSUyA9IC9bXmEtejAtOVxcLSMkJSYnKisuXl9gfH5dL2k7XG5mdW5jdGlvbiBub3JtYWxpemVIZWFkZXJOYW1lKG5hbWUpIHtcbiAgaWYgKEhFQURFUlNfSU5WQUxJRF9DSEFSQUNURVJTLnRlc3QobmFtZSkgfHwgbmFtZS50cmltKCkgPT09IFwiXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBjaGFyYWN0ZXIgaW4gaGVhZGVyIGZpZWxkIG5hbWVcIik7XG4gIH1cbiAgcmV0dXJuIG5hbWUudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG59XG5cbi8vIHNyYy91dGlscy9ub3JtYWxpemVIZWFkZXJWYWx1ZS50c1xudmFyIGNoYXJDb2Rlc1RvUmVtb3ZlID0gW1xuICBTdHJpbmcuZnJvbUNoYXJDb2RlKDEwKSxcbiAgU3RyaW5nLmZyb21DaGFyQ29kZSgxMyksXG4gIFN0cmluZy5mcm9tQ2hhckNvZGUoOSksXG4gIFN0cmluZy5mcm9tQ2hhckNvZGUoMzIpXG5dO1xudmFyIEhFQURFUl9WQUxVRV9SRU1PVkVfUkVHRVhQID0gbmV3IFJlZ0V4cChcbiAgYCheWyR7Y2hhckNvZGVzVG9SZW1vdmUuam9pbihcIlwiKX1dfCRbJHtjaGFyQ29kZXNUb1JlbW92ZS5qb2luKFwiXCIpfV0pYCxcbiAgXCJnXCJcbik7XG5mdW5jdGlvbiBub3JtYWxpemVIZWFkZXJWYWx1ZSh2YWx1ZSkge1xuICBjb25zdCBuZXh0VmFsdWUgPSB2YWx1ZS5yZXBsYWNlKEhFQURFUl9WQUxVRV9SRU1PVkVfUkVHRVhQLCBcIlwiKTtcbiAgcmV0dXJuIG5leHRWYWx1ZTtcbn1cblxuLy8gc3JjL3V0aWxzL2lzVmFsaWRIZWFkZXJOYW1lLnRzXG5mdW5jdGlvbiBpc1ZhbGlkSGVhZGVyTmFtZSh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNoYXJhY3RlciA9IHZhbHVlLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGNoYXJhY3RlciA+IDEyNyB8fCAhaXNUb2tlbihjaGFyYWN0ZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gaXNUb2tlbih2YWx1ZSkge1xuICByZXR1cm4gIVtcbiAgICAxMjcsXG4gICAgMzIsXG4gICAgXCIoXCIsXG4gICAgXCIpXCIsXG4gICAgXCI8XCIsXG4gICAgXCI+XCIsXG4gICAgXCJAXCIsXG4gICAgXCIsXCIsXG4gICAgXCI7XCIsXG4gICAgXCI6XCIsXG4gICAgXCJcXFxcXCIsXG4gICAgJ1wiJyxcbiAgICBcIi9cIixcbiAgICBcIltcIixcbiAgICBcIl1cIixcbiAgICBcIj9cIixcbiAgICBcIj1cIixcbiAgICBcIntcIixcbiAgICBcIn1cIlxuICBdLmluY2x1ZGVzKHZhbHVlKTtcbn1cblxuLy8gc3JjL3V0aWxzL2lzVmFsaWRIZWFkZXJWYWx1ZS50c1xuZnVuY3Rpb24gaXNWYWxpZEhlYWRlclZhbHVlKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHZhbHVlLnRyaW0oKSAhPT0gdmFsdWUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNoYXJhY3RlciA9IHZhbHVlLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKFxuICAgICAgLy8gTlVMLlxuICAgICAgY2hhcmFjdGVyID09PSAwIHx8IC8vIEhUVFAgbmV3bGluZSBieXRlcy5cbiAgICAgIGNoYXJhY3RlciA9PT0gMTAgfHwgY2hhcmFjdGVyID09PSAxM1xuICAgICkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gc3JjL0hlYWRlcnMudHNcbnZhciBOT1JNQUxJWkVEX0hFQURFUlMgPSBTeW1ib2woXCJub3JtYWxpemVkSGVhZGVyc1wiKTtcbnZhciBSQVdfSEVBREVSX05BTUVTID0gU3ltYm9sKFwicmF3SGVhZGVyTmFtZXNcIik7XG52YXIgSEVBREVSX1ZBTFVFX0RFTElNSVRFUiA9IFwiLCBcIjtcbnZhciBfYSwgX2IsIF9jO1xudmFyIEhlYWRlcnMgPSBjbGFzcyBfSGVhZGVycyB7XG4gIGNvbnN0cnVjdG9yKGluaXQpIHtcbiAgICAvLyBOb3JtYWxpemVkIGhlYWRlciB7XCJuYW1lXCI6XCJhLCBiXCJ9IHN0b3JhZ2UuXG4gICAgdGhpc1tfYV0gPSB7fTtcbiAgICAvLyBLZWVwcyB0aGUgbWFwcGluZyBiZXR3ZWVuIHRoZSByYXcgaGVhZGVyIG5hbWVcbiAgICAvLyBhbmQgdGhlIG5vcm1hbGl6ZWQgaGVhZGVyIG5hbWUgdG8gZWFzZSB0aGUgbG9va3VwLlxuICAgIHRoaXNbX2JdID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzW19jXSA9IFwiSGVhZGVyc1wiO1xuICAgIGlmIChbXCJIZWFkZXJzXCIsIFwiSGVhZGVyc1BvbHlmaWxsXCJdLmluY2x1ZGVzKGluaXQ/LmNvbnN0cnVjdG9yLm5hbWUpIHx8IGluaXQgaW5zdGFuY2VvZiBfSGVhZGVycyB8fCB0eXBlb2YgZ2xvYmFsVGhpcy5IZWFkZXJzICE9PSBcInVuZGVmaW5lZFwiICYmIGluaXQgaW5zdGFuY2VvZiBnbG9iYWxUaGlzLkhlYWRlcnMpIHtcbiAgICAgIGNvbnN0IGluaXRpYWxIZWFkZXJzID0gaW5pdDtcbiAgICAgIGluaXRpYWxIZWFkZXJzLmZvckVhY2goKHZhbHVlLCBuYW1lKSA9PiB7XG4gICAgICAgIHRoaXMuYXBwZW5kKG5hbWUsIHZhbHVlKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShpbml0KSkge1xuICAgICAgaW5pdC5mb3JFYWNoKChbbmFtZSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIHRoaXMuYXBwZW5kKFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5qb2luKEhFQURFUl9WQUxVRV9ERUxJTUlURVIpIDogdmFsdWVcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoaW5pdCkge1xuICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoaW5pdCkuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGluaXRbbmFtZV07XG4gICAgICAgIHRoaXMuYXBwZW5kKFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5qb2luKEhFQURFUl9WQUxVRV9ERUxJTUlURVIpIDogdmFsdWVcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBbKF9hID0gTk9STUFMSVpFRF9IRUFERVJTLCBfYiA9IFJBV19IRUFERVJfTkFNRVMsIF9jID0gU3ltYm9sLnRvU3RyaW5nVGFnLCBTeW1ib2wuaXRlcmF0b3IpXSgpIHtcbiAgICByZXR1cm4gdGhpcy5lbnRyaWVzKCk7XG4gIH1cbiAgKmtleXMoKSB7XG4gICAgZm9yIChjb25zdCBbbmFtZV0gb2YgdGhpcy5lbnRyaWVzKCkpIHtcbiAgICAgIHlpZWxkIG5hbWU7XG4gICAgfVxuICB9XG4gICp2YWx1ZXMoKSB7XG4gICAgZm9yIChjb25zdCBbLCB2YWx1ZV0gb2YgdGhpcy5lbnRyaWVzKCkpIHtcbiAgICAgIHlpZWxkIHZhbHVlO1xuICAgIH1cbiAgfVxuICAqZW50cmllcygpIHtcbiAgICBsZXQgc29ydGVkS2V5cyA9IE9iamVjdC5rZXlzKHRoaXNbTk9STUFMSVpFRF9IRUFERVJTXSkuc29ydChcbiAgICAgIChhLCBiKSA9PiBhLmxvY2FsZUNvbXBhcmUoYilcbiAgICApO1xuICAgIGZvciAoY29uc3QgbmFtZSBvZiBzb3J0ZWRLZXlzKSB7XG4gICAgICBpZiAobmFtZSA9PT0gXCJzZXQtY29va2llXCIpIHtcbiAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiB0aGlzLmdldFNldENvb2tpZSgpKSB7XG4gICAgICAgICAgeWllbGQgW25hbWUsIHZhbHVlXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeWllbGQgW25hbWUsIHRoaXMuZ2V0KG5hbWUpXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBib29sZWFuIHN0YXRpbmcgd2hldGhlciBhIGBIZWFkZXJzYCBvYmplY3QgY29udGFpbnMgYSBjZXJ0YWluIGhlYWRlci5cbiAgICovXG4gIGhhcyhuYW1lKSB7XG4gICAgaWYgKCFpc1ZhbGlkSGVhZGVyTmFtZShuYW1lKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBoZWFkZXIgbmFtZSBcIiR7bmFtZX1cImApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpc1tOT1JNQUxJWkVEX0hFQURFUlNdLmhhc093blByb3BlcnR5KG5vcm1hbGl6ZUhlYWRlck5hbWUobmFtZSkpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgYEJ5dGVTdHJpbmdgIHNlcXVlbmNlIG9mIGFsbCB0aGUgdmFsdWVzIG9mIGEgaGVhZGVyIHdpdGggYSBnaXZlbiBuYW1lLlxuICAgKi9cbiAgZ2V0KG5hbWUpIHtcbiAgICBpZiAoIWlzVmFsaWRIZWFkZXJOYW1lKG5hbWUpKSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoYEludmFsaWQgaGVhZGVyIG5hbWUgXCIke25hbWV9XCJgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNbTk9STUFMSVpFRF9IRUFERVJTXVtub3JtYWxpemVIZWFkZXJOYW1lKG5hbWUpXSA/PyBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIGEgbmV3IHZhbHVlIGZvciBhbiBleGlzdGluZyBoZWFkZXIgaW5zaWRlIGEgYEhlYWRlcnNgIG9iamVjdCwgb3IgYWRkcyB0aGUgaGVhZGVyIGlmIGl0IGRvZXMgbm90IGFscmVhZHkgZXhpc3QuXG4gICAqL1xuICBzZXQobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAoIWlzVmFsaWRIZWFkZXJOYW1lKG5hbWUpIHx8ICFpc1ZhbGlkSGVhZGVyVmFsdWUodmFsdWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5vcm1hbGl6ZWROYW1lID0gbm9ybWFsaXplSGVhZGVyTmFtZShuYW1lKTtcbiAgICBjb25zdCBub3JtYWxpemVkVmFsdWUgPSBub3JtYWxpemVIZWFkZXJWYWx1ZSh2YWx1ZSk7XG4gICAgdGhpc1tOT1JNQUxJWkVEX0hFQURFUlNdW25vcm1hbGl6ZWROYW1lXSA9IG5vcm1hbGl6ZUhlYWRlclZhbHVlKG5vcm1hbGl6ZWRWYWx1ZSk7XG4gICAgdGhpc1tSQVdfSEVBREVSX05BTUVTXS5zZXQobm9ybWFsaXplZE5hbWUsIG5hbWUpO1xuICB9XG4gIC8qKlxuICAgKiBBcHBlbmRzIGEgbmV3IHZhbHVlIG9udG8gYW4gZXhpc3RpbmcgaGVhZGVyIGluc2lkZSBhIGBIZWFkZXJzYCBvYmplY3QsIG9yIGFkZHMgdGhlIGhlYWRlciBpZiBpdCBkb2VzIG5vdCBhbHJlYWR5IGV4aXN0LlxuICAgKi9cbiAgYXBwZW5kKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKCFpc1ZhbGlkSGVhZGVyTmFtZShuYW1lKSB8fCAhaXNWYWxpZEhlYWRlclZhbHVlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBub3JtYWxpemVkTmFtZSA9IG5vcm1hbGl6ZUhlYWRlck5hbWUobmFtZSk7XG4gICAgY29uc3Qgbm9ybWFsaXplZFZhbHVlID0gbm9ybWFsaXplSGVhZGVyVmFsdWUodmFsdWUpO1xuICAgIGxldCByZXNvbHZlZFZhbHVlID0gdGhpcy5oYXMobm9ybWFsaXplZE5hbWUpID8gYCR7dGhpcy5nZXQobm9ybWFsaXplZE5hbWUpfSwgJHtub3JtYWxpemVkVmFsdWV9YCA6IG5vcm1hbGl6ZWRWYWx1ZTtcbiAgICB0aGlzLnNldChuYW1lLCByZXNvbHZlZFZhbHVlKTtcbiAgfVxuICAvKipcbiAgICogRGVsZXRlcyBhIGhlYWRlciBmcm9tIHRoZSBgSGVhZGVyc2Agb2JqZWN0LlxuICAgKi9cbiAgZGVsZXRlKG5hbWUpIHtcbiAgICBpZiAoIWlzVmFsaWRIZWFkZXJOYW1lKG5hbWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy5oYXMobmFtZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgbm9ybWFsaXplZE5hbWUgPSBub3JtYWxpemVIZWFkZXJOYW1lKG5hbWUpO1xuICAgIGRlbGV0ZSB0aGlzW05PUk1BTElaRURfSEVBREVSU11bbm9ybWFsaXplZE5hbWVdO1xuICAgIHRoaXNbUkFXX0hFQURFUl9OQU1FU10uZGVsZXRlKG5vcm1hbGl6ZWROYW1lKTtcbiAgfVxuICAvKipcbiAgICogVHJhdmVyc2VzIHRoZSBgSGVhZGVyc2Agb2JqZWN0LFxuICAgKiBjYWxsaW5nIHRoZSBnaXZlbiBjYWxsYmFjayBmb3IgZWFjaCBoZWFkZXIuXG4gICAqL1xuICBmb3JFYWNoKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgZm9yIChjb25zdCBbbmFtZSwgdmFsdWVdIG9mIHRoaXMuZW50cmllcygpKSB7XG4gICAgICBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHZhbHVlLCBuYW1lLCB0aGlzKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgdmFsdWVzXG4gICAqIG9mIGFsbCBTZXQtQ29va2llIGhlYWRlcnMgYXNzb2NpYXRlZFxuICAgKiB3aXRoIGEgcmVzcG9uc2VcbiAgICovXG4gIGdldFNldENvb2tpZSgpIHtcbiAgICBjb25zdCBzZXRDb29raWVIZWFkZXIgPSB0aGlzLmdldChcInNldC1jb29raWVcIik7XG4gICAgaWYgKHNldENvb2tpZUhlYWRlciA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBpZiAoc2V0Q29va2llSGVhZGVyID09PSBcIlwiKSB7XG4gICAgICByZXR1cm4gW1wiXCJdO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIGltcG9ydF9zZXRfY29va2llX3BhcnNlci5zcGxpdENvb2tpZXNTdHJpbmcpKHNldENvb2tpZUhlYWRlcik7XG4gIH1cbn07XG5cbi8vIHNyYy9nZXRSYXdIZWFkZXJzLnRzXG5mdW5jdGlvbiBnZXRSYXdIZWFkZXJzKGhlYWRlcnMpIHtcbiAgY29uc3QgcmF3SGVhZGVycyA9IHt9O1xuICBmb3IgKGNvbnN0IFtuYW1lLCB2YWx1ZV0gb2YgaGVhZGVycy5lbnRyaWVzKCkpIHtcbiAgICByYXdIZWFkZXJzW2hlYWRlcnNbUkFXX0hFQURFUl9OQU1FU10uZ2V0KG5hbWUpXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiByYXdIZWFkZXJzO1xufVxuXG4vLyBzcmMvdHJhbnNmb3JtZXJzL2hlYWRlcnNUb0xpc3QudHNcbmZ1bmN0aW9uIGhlYWRlcnNUb0xpc3QoaGVhZGVycykge1xuICBjb25zdCBoZWFkZXJzTGlzdCA9IFtdO1xuICBoZWFkZXJzLmZvckVhY2goKHZhbHVlLCBuYW1lKSA9PiB7XG4gICAgY29uc3QgcmVzb2x2ZWRWYWx1ZSA9IHZhbHVlLmluY2x1ZGVzKFwiLFwiKSA/IHZhbHVlLnNwbGl0KFwiLFwiKS5tYXAoKHZhbHVlMikgPT4gdmFsdWUyLnRyaW0oKSkgOiB2YWx1ZTtcbiAgICBoZWFkZXJzTGlzdC5wdXNoKFtuYW1lLCByZXNvbHZlZFZhbHVlXSk7XG4gIH0pO1xuICByZXR1cm4gaGVhZGVyc0xpc3Q7XG59XG5cbi8vIHNyYy90cmFuc2Zvcm1lcnMvaGVhZGVyc1RvU3RyaW5nLnRzXG5mdW5jdGlvbiBoZWFkZXJzVG9TdHJpbmcoaGVhZGVycykge1xuICBjb25zdCBsaXN0ID0gaGVhZGVyc1RvTGlzdChoZWFkZXJzKTtcbiAgY29uc3QgbGluZXMgPSBsaXN0Lm1hcCgoW25hbWUsIHZhbHVlXSkgPT4ge1xuICAgIGNvbnN0IHZhbHVlcyA9IFtdLmNvbmNhdCh2YWx1ZSk7XG4gICAgcmV0dXJuIGAke25hbWV9OiAke3ZhbHVlcy5qb2luKFwiLCBcIil9YDtcbiAgfSk7XG4gIHJldHVybiBsaW5lcy5qb2luKFwiXFxyXFxuXCIpO1xufVxuXG4vLyBzcmMvdHJhbnNmb3JtZXJzL2hlYWRlcnNUb09iamVjdC50c1xudmFyIHNpbmdsZVZhbHVlSGVhZGVycyA9IFtcInVzZXItYWdlbnRcIl07XG5mdW5jdGlvbiBoZWFkZXJzVG9PYmplY3QoaGVhZGVycykge1xuICBjb25zdCBoZWFkZXJzT2JqZWN0ID0ge307XG4gIGhlYWRlcnMuZm9yRWFjaCgodmFsdWUsIG5hbWUpID0+IHtcbiAgICBjb25zdCBpc011bHRpVmFsdWUgPSAhc2luZ2xlVmFsdWVIZWFkZXJzLmluY2x1ZGVzKG5hbWUudG9Mb3dlckNhc2UoKSkgJiYgdmFsdWUuaW5jbHVkZXMoXCIsXCIpO1xuICAgIGhlYWRlcnNPYmplY3RbbmFtZV0gPSBpc011bHRpVmFsdWUgPyB2YWx1ZS5zcGxpdChcIixcIikubWFwKChzKSA9PiBzLnRyaW0oKSkgOiB2YWx1ZTtcbiAgfSk7XG4gIHJldHVybiBoZWFkZXJzT2JqZWN0O1xufVxuXG4vLyBzcmMvdHJhbnNmb3JtZXJzL3N0cmluZ1RvSGVhZGVycy50c1xuZnVuY3Rpb24gc3RyaW5nVG9IZWFkZXJzKHN0cikge1xuICBjb25zdCBsaW5lcyA9IHN0ci50cmltKCkuc3BsaXQoL1tcXHJcXG5dKy8pO1xuICByZXR1cm4gbGluZXMucmVkdWNlKChoZWFkZXJzLCBsaW5lKSA9PiB7XG4gICAgaWYgKGxpbmUudHJpbSgpID09PSBcIlwiKSB7XG4gICAgICByZXR1cm4gaGVhZGVycztcbiAgICB9XG4gICAgY29uc3QgcGFydHMgPSBsaW5lLnNwbGl0KFwiOiBcIik7XG4gICAgY29uc3QgbmFtZSA9IHBhcnRzLnNoaWZ0KCk7XG4gICAgY29uc3QgdmFsdWUgPSBwYXJ0cy5qb2luKFwiOiBcIik7XG4gICAgaGVhZGVycy5hcHBlbmQobmFtZSwgdmFsdWUpO1xuICAgIHJldHVybiBoZWFkZXJzO1xuICB9LCBuZXcgSGVhZGVycygpKTtcbn1cblxuLy8gc3JjL3RyYW5zZm9ybWVycy9saXN0VG9IZWFkZXJzLnRzXG5mdW5jdGlvbiBsaXN0VG9IZWFkZXJzKGxpc3QpIHtcbiAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XG4gIGxpc3QuZm9yRWFjaCgoW25hbWUsIHZhbHVlXSkgPT4ge1xuICAgIGNvbnN0IHZhbHVlcyA9IFtdLmNvbmNhdCh2YWx1ZSk7XG4gICAgdmFsdWVzLmZvckVhY2goKHZhbHVlMikgPT4ge1xuICAgICAgaGVhZGVycy5hcHBlbmQobmFtZSwgdmFsdWUyKTtcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBoZWFkZXJzO1xufVxuXG4vLyBzcmMvdHJhbnNmb3JtZXJzL3JlZHVjZUhlYWRlcnNPYmplY3QudHNcbmZ1bmN0aW9uIHJlZHVjZUhlYWRlcnNPYmplY3QoaGVhZGVycywgcmVkdWNlciwgaW5pdGlhbFN0YXRlKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhoZWFkZXJzKS5yZWR1Y2UoKG5leHRIZWFkZXJzLCBuYW1lKSA9PiB7XG4gICAgcmV0dXJuIHJlZHVjZXIobmV4dEhlYWRlcnMsIG5hbWUsIGhlYWRlcnNbbmFtZV0pO1xuICB9LCBpbml0aWFsU3RhdGUpO1xufVxuXG4vLyBzcmMvdHJhbnNmb3JtZXJzL29iamVjdFRvSGVhZGVycy50c1xuZnVuY3Rpb24gb2JqZWN0VG9IZWFkZXJzKGhlYWRlcnNPYmplY3QpIHtcbiAgcmV0dXJuIHJlZHVjZUhlYWRlcnNPYmplY3QoXG4gICAgaGVhZGVyc09iamVjdCxcbiAgICAoaGVhZGVycywgbmFtZSwgdmFsdWUpID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlcyA9IFtdLmNvbmNhdCh2YWx1ZSkuZmlsdGVyKEJvb2xlYW4pO1xuICAgICAgdmFsdWVzLmZvckVhY2goKHZhbHVlMikgPT4ge1xuICAgICAgICBoZWFkZXJzLmFwcGVuZChuYW1lLCB2YWx1ZTIpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gaGVhZGVycztcbiAgICB9LFxuICAgIG5ldyBIZWFkZXJzKClcbiAgKTtcbn1cblxuLy8gc3JjL3RyYW5zZm9ybWVycy9mbGF0dGVuSGVhZGVyc0xpc3QudHNcbmZ1bmN0aW9uIGZsYXR0ZW5IZWFkZXJzTGlzdChsaXN0KSB7XG4gIHJldHVybiBsaXN0Lm1hcCgoW25hbWUsIHZhbHVlc10pID0+IHtcbiAgICByZXR1cm4gW25hbWUsIFtdLmNvbmNhdCh2YWx1ZXMpLmpvaW4oXCIsIFwiKV07XG4gIH0pO1xufVxuXG4vLyBzcmMvdHJhbnNmb3JtZXJzL2ZsYXR0ZW5IZWFkZXJzT2JqZWN0LnRzXG5mdW5jdGlvbiBmbGF0dGVuSGVhZGVyc09iamVjdChoZWFkZXJzT2JqZWN0KSB7XG4gIHJldHVybiByZWR1Y2VIZWFkZXJzT2JqZWN0KFxuICAgIGhlYWRlcnNPYmplY3QsXG4gICAgKGhlYWRlcnMsIG5hbWUsIHZhbHVlKSA9PiB7XG4gICAgICBoZWFkZXJzW25hbWVdID0gW10uY29uY2F0KHZhbHVlKS5qb2luKFwiLCBcIik7XG4gICAgICByZXR1cm4gaGVhZGVycztcbiAgICB9LFxuICAgIHt9XG4gICk7XG59XG5leHBvcnQge1xuICBIZWFkZXJzLFxuICBmbGF0dGVuSGVhZGVyc0xpc3QsXG4gIGZsYXR0ZW5IZWFkZXJzT2JqZWN0LFxuICBnZXRSYXdIZWFkZXJzLFxuICBoZWFkZXJzVG9MaXN0LFxuICBoZWFkZXJzVG9PYmplY3QsXG4gIGhlYWRlcnNUb1N0cmluZyxcbiAgbGlzdFRvSGVhZGVycyxcbiAgb2JqZWN0VG9IZWFkZXJzLFxuICByZWR1Y2VIZWFkZXJzT2JqZWN0LFxuICBzdHJpbmdUb0hlYWRlcnNcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwIiwiaW1wb3J0ICogYXMgX3N5c2NhbGxzMV8wIGZyb20gJ3NwYWNldGltZTpzeXNAMS4wJztcbmltcG9ydCB7IHJlZ2lzdGVyX2hvb2tzIH0gZnJvbSAnc3BhY2V0aW1lOnN5c0AxLjAnO1xuaW1wb3J0IHsgcmVnaXN0ZXJfaG9va3MgYXMgcmVnaXN0ZXJfaG9va3MkMSB9IGZyb20gJ3NwYWNldGltZTpzeXNAMS4xJztcbmltcG9ydCAqIGFzIF9zeXNjYWxsczFfMiBmcm9tICdzcGFjZXRpbWU6c3lzQDEuMic7XG5pbXBvcnQgeyByZWdpc3Rlcl9ob29rcyBhcyByZWdpc3Rlcl9ob29rcyQyIH0gZnJvbSAnc3BhY2V0aW1lOnN5c0AxLjInO1xuaW1wb3J0IHsgaGVhZGVyc1RvTGlzdCwgSGVhZGVycyB9IGZyb20gJ2hlYWRlcnMtcG9seWZpbGwnO1xuXG50eXBlb2YgZ2xvYmFsVGhpcyE9PVwidW5kZWZpbmVkXCImJigoZ2xvYmFsVGhpcy5nbG9iYWw9Z2xvYmFsVGhpcy5nbG9iYWx8fGdsb2JhbFRoaXMpLChnbG9iYWxUaGlzLndpbmRvdz1nbG9iYWxUaGlzLndpbmRvd3x8Z2xvYmFsVGhpcykpO1xudmFyIF9fY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2dldFByb3RvT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX2tub3duU3ltYm9sID0gKG5hbWUsIHN5bWJvbCkgPT4gKHN5bWJvbCA9IFN5bWJvbFtuYW1lXSkgPyBzeW1ib2wgOiBTeW1ib2wuZm9yKFwiU3ltYm9sLlwiICsgbmFtZSk7XG52YXIgX190eXBlRXJyb3IgPSAobXNnKSA9PiB7XG4gIHRocm93IFR5cGVFcnJvcihtc2cpO1xufTtcbnZhciBfX2NvbW1vbkpTID0gKGNiLCBtb2QpID0+IGZ1bmN0aW9uIF9fcmVxdWlyZSgpIHtcbiAgcmV0dXJuIG1vZCB8fCAoMCwgY2JbX19nZXRPd25Qcm9wTmFtZXMoY2IpWzBdXSkoKG1vZCA9IHsgZXhwb3J0czoge30gfSkuZXhwb3J0cywgbW9kKSwgbW9kLmV4cG9ydHM7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9FU00gPSAobW9kLCBpc05vZGVNb2RlLCB0YXJnZXQpID0+ICh0YXJnZXQgPSBtb2QgIT0gbnVsbCA/IF9fY3JlYXRlKF9fZ2V0UHJvdG9PZihtb2QpKSA6IHt9LCBfX2NvcHlQcm9wcyhcbiAgLy8gSWYgdGhlIGltcG9ydGVyIGlzIGluIG5vZGUgY29tcGF0aWJpbGl0eSBtb2RlIG9yIHRoaXMgaXMgbm90IGFuIEVTTVxuICAvLyBmaWxlIHRoYXQgaGFzIGJlZW4gY29udmVydGVkIHRvIGEgQ29tbW9uSlMgZmlsZSB1c2luZyBhIEJhYmVsLVxuICAvLyBjb21wYXRpYmxlIHRyYW5zZm9ybSAoaS5lLiBcIl9fZXNNb2R1bGVcIiBoYXMgbm90IGJlZW4gc2V0KSwgdGhlbiBzZXRcbiAgLy8gXCJkZWZhdWx0XCIgdG8gdGhlIENvbW1vbkpTIFwibW9kdWxlLmV4cG9ydHNcIiBmb3Igbm9kZSBjb21wYXRpYmlsaXR5LlxuICBfX2RlZlByb3AodGFyZ2V0LCBcImRlZmF1bHRcIiwgeyB2YWx1ZTogbW9kLCBlbnVtZXJhYmxlOiB0cnVlIH0pICxcbiAgbW9kXG4pKTtcbnZhciBfX3VzaW5nID0gKHN0YWNrLCB2YWx1ZSwgYXN5bmMpID0+IHtcbiAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiB2YWx1ZSAhPT0gXCJmdW5jdGlvblwiKSBfX3R5cGVFcnJvcihcIk9iamVjdCBleHBlY3RlZFwiKTtcbiAgICB2YXIgZGlzcG9zZSwgaW5uZXI7XG4gICAgaWYgKGRpc3Bvc2UgPT09IHZvaWQgMCkge1xuICAgICAgZGlzcG9zZSA9IHZhbHVlW19fa25vd25TeW1ib2woXCJkaXNwb3NlXCIpXTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBkaXNwb3NlICE9PSBcImZ1bmN0aW9uXCIpIF9fdHlwZUVycm9yKFwiT2JqZWN0IG5vdCBkaXNwb3NhYmxlXCIpO1xuICAgIGlmIChpbm5lcikgZGlzcG9zZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaW5uZXIuY2FsbCh0aGlzKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgc3RhY2sucHVzaChbYXN5bmMsIGRpc3Bvc2UsIHZhbHVlXSk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufTtcbnZhciBfX2NhbGxEaXNwb3NlID0gKHN0YWNrLCBlcnJvciwgaGFzRXJyb3IpID0+IHtcbiAgdmFyIEUgPSB0eXBlb2YgU3VwcHJlc3NlZEVycm9yID09PSBcImZ1bmN0aW9uXCIgPyBTdXBwcmVzc2VkRXJyb3IgOiBmdW5jdGlvbihlLCBzLCBtLCBfKSB7XG4gICAgcmV0dXJuIF8gPSBFcnJvcihtKSwgXy5uYW1lID0gXCJTdXBwcmVzc2VkRXJyb3JcIiwgXy5lcnJvciA9IGUsIF8uc3VwcHJlc3NlZCA9IHMsIF87XG4gIH07XG4gIHZhciBmYWlsID0gKGUpID0+IGVycm9yID0gaGFzRXJyb3IgPyBuZXcgRShlLCBlcnJvciwgXCJBbiBlcnJvciB3YXMgc3VwcHJlc3NlZCBkdXJpbmcgZGlzcG9zYWxcIikgOiAoaGFzRXJyb3IgPSB0cnVlLCBlKTtcbiAgdmFyIG5leHQgPSAoaXQpID0+IHtcbiAgICB3aGlsZSAoaXQgPSBzdGFjay5wb3AoKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGl0WzFdICYmIGl0WzFdLmNhbGwoaXRbMl0pO1xuICAgICAgICBpZiAoaXRbMF0pIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KS50aGVuKG5leHQsIChlKSA9PiAoZmFpbChlKSwgbmV4dCgpKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGZhaWwoZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChoYXNFcnJvcikgdGhyb3cgZXJyb3I7XG4gIH07XG4gIHJldHVybiBuZXh0KCk7XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vYmFzZTY0LWpzQDEuNS4xL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanNcbnZhciByZXF1aXJlX2Jhc2U2NF9qcyA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9iYXNlNjQtanNAMS41LjEvbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9pbmRleC5qc1wiKGV4cG9ydHMpIHtcbiAgICBleHBvcnRzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoO1xuICAgIGV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheTtcbiAgICBleHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5MjtcbiAgICB2YXIgbG9va3VwID0gW107XG4gICAgdmFyIHJldkxvb2t1cCA9IFtdO1xuICAgIHZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gXCJ1bmRlZmluZWRcIiA/IFVpbnQ4QXJyYXkgOiBBcnJheTtcbiAgICB2YXIgY29kZSA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiO1xuICAgIGZvciAoaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGxvb2t1cFtpXSA9IGNvZGVbaV07XG4gICAgICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGk7XG4gICAgfVxuICAgIHZhciBpO1xuICAgIHZhciBsZW47XG4gICAgcmV2TG9va3VwW1wiLVwiLmNoYXJDb2RlQXQoMCldID0gNjI7XG4gICAgcmV2TG9va3VwW1wiX1wiLmNoYXJDb2RlQXQoMCldID0gNjM7XG4gICAgZnVuY3Rpb24gZ2V0TGVucyhiNjQpIHtcbiAgICAgIHZhciBsZW4yID0gYjY0Lmxlbmd0aDtcbiAgICAgIGlmIChsZW4yICUgNCA+IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNFwiKTtcbiAgICAgIH1cbiAgICAgIHZhciB2YWxpZExlbiA9IGI2NC5pbmRleE9mKFwiPVwiKTtcbiAgICAgIGlmICh2YWxpZExlbiA9PT0gLTEpIHZhbGlkTGVuID0gbGVuMjtcbiAgICAgIHZhciBwbGFjZUhvbGRlcnNMZW4gPSB2YWxpZExlbiA9PT0gbGVuMiA/IDAgOiA0IC0gdmFsaWRMZW4gJSA0O1xuICAgICAgcmV0dXJuIFt2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYnl0ZUxlbmd0aChiNjQpIHtcbiAgICAgIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpO1xuICAgICAgdmFyIHZhbGlkTGVuID0gbGVuc1swXTtcbiAgICAgIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdO1xuICAgICAgcmV0dXJuICh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCAtIHBsYWNlSG9sZGVyc0xlbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gX2J5dGVMZW5ndGgoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSB7XG4gICAgICByZXR1cm4gKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzTGVuO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0b0J5dGVBcnJheShiNjQpIHtcbiAgICAgIHZhciB0bXA7XG4gICAgICB2YXIgbGVucyA9IGdldExlbnMoYjY0KTtcbiAgICAgIHZhciB2YWxpZExlbiA9IGxlbnNbMF07XG4gICAgICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXTtcbiAgICAgIHZhciBhcnIgPSBuZXcgQXJyKF9ieXRlTGVuZ3RoKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikpO1xuICAgICAgdmFyIGN1ckJ5dGUgPSAwO1xuICAgICAgdmFyIGxlbjIgPSBwbGFjZUhvbGRlcnNMZW4gPiAwID8gdmFsaWRMZW4gLSA0IDogdmFsaWRMZW47XG4gICAgICB2YXIgaTI7XG4gICAgICBmb3IgKGkyID0gMDsgaTIgPCBsZW4yOyBpMiArPSA0KSB7XG4gICAgICAgIHRtcCA9IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpMildIDw8IDE4IHwgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkyICsgMSldIDw8IDEyIHwgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkyICsgMildIDw8IDYgfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaTIgKyAzKV07XG4gICAgICAgIGFycltjdXJCeXRlKytdID0gdG1wID4+IDE2ICYgMjU1O1xuICAgICAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCA+PiA4ICYgMjU1O1xuICAgICAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDI1NTtcbiAgICAgIH1cbiAgICAgIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDIpIHtcbiAgICAgICAgdG1wID0gcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkyKV0gPDwgMiB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpMiArIDEpXSA+PiA0O1xuICAgICAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDI1NTtcbiAgICAgIH1cbiAgICAgIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDEpIHtcbiAgICAgICAgdG1wID0gcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkyKV0gPDwgMTAgfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaTIgKyAxKV0gPDwgNCB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpMiArIDIpXSA+PiAyO1xuICAgICAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCA+PiA4ICYgMjU1O1xuICAgICAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDI1NTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NChudW0pIHtcbiAgICAgIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgNjNdICsgbG9va3VwW251bSA+PiAxMiAmIDYzXSArIGxvb2t1cFtudW0gPj4gNiAmIDYzXSArIGxvb2t1cFtudW0gJiA2M107XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVuY29kZUNodW5rKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgdG1wO1xuICAgICAgdmFyIG91dHB1dCA9IFtdO1xuICAgICAgZm9yICh2YXIgaTIgPSBzdGFydDsgaTIgPCBlbmQ7IGkyICs9IDMpIHtcbiAgICAgICAgdG1wID0gKHVpbnQ4W2kyXSA8PCAxNiAmIDE2NzExNjgwKSArICh1aW50OFtpMiArIDFdIDw8IDggJiA2NTI4MCkgKyAodWludDhbaTIgKyAyXSAmIDI1NSk7XG4gICAgICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXRwdXQuam9pbihcIlwiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZnJvbUJ5dGVBcnJheTIodWludDgpIHtcbiAgICAgIHZhciB0bXA7XG4gICAgICB2YXIgbGVuMiA9IHVpbnQ4Lmxlbmd0aDtcbiAgICAgIHZhciBleHRyYUJ5dGVzID0gbGVuMiAlIDM7XG4gICAgICB2YXIgcGFydHMgPSBbXTtcbiAgICAgIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzO1xuICAgICAgZm9yICh2YXIgaTIgPSAwLCBsZW4yMiA9IGxlbjIgLSBleHRyYUJ5dGVzOyBpMiA8IGxlbjIyOyBpMiArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgICAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKHVpbnQ4LCBpMiwgaTIgKyBtYXhDaHVua0xlbmd0aCA+IGxlbjIyID8gbGVuMjIgOiBpMiArIG1heENodW5rTGVuZ3RoKSk7XG4gICAgICB9XG4gICAgICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgICAgICB0bXAgPSB1aW50OFtsZW4yIC0gMV07XG4gICAgICAgIHBhcnRzLnB1c2goXG4gICAgICAgICAgbG9va3VwW3RtcCA+PiAyXSArIGxvb2t1cFt0bXAgPDwgNCAmIDYzXSArIFwiPT1cIlxuICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgICAgIHRtcCA9ICh1aW50OFtsZW4yIC0gMl0gPDwgOCkgKyB1aW50OFtsZW4yIC0gMV07XG4gICAgICAgIHBhcnRzLnB1c2goXG4gICAgICAgICAgbG9va3VwW3RtcCA+PiAxMF0gKyBsb29rdXBbdG1wID4+IDQgJiA2M10gKyBsb29rdXBbdG1wIDw8IDIgJiA2M10gKyBcIj1cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcnRzLmpvaW4oXCJcIik7XG4gICAgfVxuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2Zhc3QtdGV4dC1lbmNvZGluZ0AxLjAuNi9ub2RlX21vZHVsZXMvZmFzdC10ZXh0LWVuY29kaW5nL3RleHQubWluLmpzXG52YXIgcmVxdWlyZV90ZXh0X21pbiA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9mYXN0LXRleHQtZW5jb2RpbmdAMS4wLjYvbm9kZV9tb2R1bGVzL2Zhc3QtdGV4dC1lbmNvZGluZy90ZXh0Lm1pbi5qc1wiKGV4cG9ydHMpIHtcbiAgICAoZnVuY3Rpb24oc2NvcGUpIHtcbiAgICAgIGZ1bmN0aW9uIEIociwgZSkge1xuICAgICAgICB2YXIgZjtcbiAgICAgICAgcmV0dXJuIHIgaW5zdGFuY2VvZiBCdWZmZXIgPyBmID0gciA6IGYgPSBCdWZmZXIuZnJvbShyLmJ1ZmZlciwgci5ieXRlT2Zmc2V0LCByLmJ5dGVMZW5ndGgpLCBmLnRvU3RyaW5nKGUpO1xuICAgICAgfVxuICAgICAgdmFyIHcgPSBmdW5jdGlvbihyKSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShyKTtcbiAgICAgIH07XG4gICAgICBmdW5jdGlvbiBoKHIpIHtcbiAgICAgICAgZm9yICh2YXIgZSA9IDAsIGYgPSBNYXRoLm1pbigyNTYgKiAyNTYsIHIubGVuZ3RoICsgMSksIG4gPSBuZXcgVWludDE2QXJyYXkoZiksIGkgPSBbXSwgbyA9IDA7IDsgKSB7XG4gICAgICAgICAgdmFyIHQyID0gZSA8IHIubGVuZ3RoO1xuICAgICAgICAgIGlmICghdDIgfHwgbyA+PSBmIC0gMSkge1xuICAgICAgICAgICAgdmFyIHMgPSBuLnN1YmFycmF5KDAsIG8pLCBtID0gcztcbiAgICAgICAgICAgIGlmIChpLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBtKSksICF0MikgcmV0dXJuIGkuam9pbihcIlwiKTtcbiAgICAgICAgICAgIHIgPSByLnN1YmFycmF5KGUpLCBlID0gMCwgbyA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBhID0gcltlKytdO1xuICAgICAgICAgIGlmICgoYSAmIDEyOCkgPT09IDApIG5bbysrXSA9IGE7XG4gICAgICAgICAgZWxzZSBpZiAoKGEgJiAyMjQpID09PSAxOTIpIHtcbiAgICAgICAgICAgIHZhciBkID0gcltlKytdICYgNjM7XG4gICAgICAgICAgICBuW28rK10gPSAoYSAmIDMxKSA8PCA2IHwgZDtcbiAgICAgICAgICB9IGVsc2UgaWYgKChhICYgMjQwKSA9PT0gMjI0KSB7XG4gICAgICAgICAgICB2YXIgZCA9IHJbZSsrXSAmIDYzLCBsID0gcltlKytdICYgNjM7XG4gICAgICAgICAgICBuW28rK10gPSAoYSAmIDMxKSA8PCAxMiB8IGQgPDwgNiB8IGw7XG4gICAgICAgICAgfSBlbHNlIGlmICgoYSAmIDI0OCkgPT09IDI0MCkge1xuICAgICAgICAgICAgdmFyIGQgPSByW2UrK10gJiA2MywgbCA9IHJbZSsrXSAmIDYzLCBSID0gcltlKytdICYgNjMsIGMgPSAoYSAmIDcpIDw8IDE4IHwgZCA8PCAxMiB8IGwgPDwgNiB8IFI7XG4gICAgICAgICAgICBjID4gNjU1MzUgJiYgKGMgLT0gNjU1MzYsIG5bbysrXSA9IGMgPj4+IDEwICYgMTAyMyB8IDU1Mjk2LCBjID0gNTYzMjAgfCBjICYgMTAyMyksIG5bbysrXSA9IGM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBGKHIpIHtcbiAgICAgICAgZm9yICh2YXIgZSA9IDAsIGYgPSByLmxlbmd0aCwgbiA9IDAsIGkgPSBNYXRoLm1heCgzMiwgZiArIChmID4+PiAxKSArIDcpLCBvID0gbmV3IFVpbnQ4QXJyYXkoaSA+Pj4gMyA8PCAzKTsgZSA8IGY7ICkge1xuICAgICAgICAgIHZhciB0MiA9IHIuY2hhckNvZGVBdChlKyspO1xuICAgICAgICAgIGlmICh0MiA+PSA1NTI5NiAmJiB0MiA8PSA1NjMxOSkge1xuICAgICAgICAgICAgaWYgKGUgPCBmKSB7XG4gICAgICAgICAgICAgIHZhciBzID0gci5jaGFyQ29kZUF0KGUpO1xuICAgICAgICAgICAgICAocyAmIDY0NTEyKSA9PT0gNTYzMjAgJiYgKCsrZSwgdDIgPSAoKHQyICYgMTAyMykgPDwgMTApICsgKHMgJiAxMDIzKSArIDY1NTM2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0MiA+PSA1NTI5NiAmJiB0MiA8PSA1NjMxOSkgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChuICsgNCA+IG8ubGVuZ3RoKSB7XG4gICAgICAgICAgICBpICs9IDgsIGkgKj0gMSArIGUgLyByLmxlbmd0aCAqIDIsIGkgPSBpID4+PiAzIDw8IDM7XG4gICAgICAgICAgICB2YXIgbSA9IG5ldyBVaW50OEFycmF5KGkpO1xuICAgICAgICAgICAgbS5zZXQobyksIG8gPSBtO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoKHQyICYgNDI5NDk2NzE2OCkgPT09IDApIHtcbiAgICAgICAgICAgIG9bbisrXSA9IHQyO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSBlbHNlIGlmICgodDIgJiA0Mjk0OTY1MjQ4KSA9PT0gMCkgb1tuKytdID0gdDIgPj4+IDYgJiAzMSB8IDE5MjtcbiAgICAgICAgICBlbHNlIGlmICgodDIgJiA0Mjk0OTAxNzYwKSA9PT0gMCkgb1tuKytdID0gdDIgPj4+IDEyICYgMTUgfCAyMjQsIG9bbisrXSA9IHQyID4+PiA2ICYgNjMgfCAxMjg7XG4gICAgICAgICAgZWxzZSBpZiAoKHQyICYgNDI5Mjg3MDE0NCkgPT09IDApIG9bbisrXSA9IHQyID4+PiAxOCAmIDcgfCAyNDAsIG9bbisrXSA9IHQyID4+PiAxMiAmIDYzIHwgMTI4LCBvW24rK10gPSB0MiA+Pj4gNiAmIDYzIHwgMTI4O1xuICAgICAgICAgIGVsc2UgY29udGludWU7XG4gICAgICAgICAgb1tuKytdID0gdDIgJiA2MyB8IDEyODtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gby5zbGljZSA/IG8uc2xpY2UoMCwgbikgOiBvLnN1YmFycmF5KDAsIG4pO1xuICAgICAgfVxuICAgICAgdmFyIHUgPSBcIkZhaWxlZCB0byBcIiwgcCA9IGZ1bmN0aW9uKHIsIGUsIGYpIHtcbiAgICAgICAgaWYgKHIpIHRocm93IG5ldyBFcnJvcihcIlwiLmNvbmNhdCh1KS5jb25jYXQoZSwgXCI6IHRoZSAnXCIpLmNvbmNhdChmLCBcIicgb3B0aW9uIGlzIHVuc3VwcG9ydGVkLlwiKSk7XG4gICAgICB9O1xuICAgICAgdmFyIHggPSB0eXBlb2YgQnVmZmVyID09IFwiZnVuY3Rpb25cIiAmJiBCdWZmZXIuZnJvbTtcbiAgICAgIHZhciBBID0geCA/IHcgOiBGO1xuICAgICAgZnVuY3Rpb24gdigpIHtcbiAgICAgICAgdGhpcy5lbmNvZGluZyA9IFwidXRmLThcIjtcbiAgICAgIH1cbiAgICAgIHYucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uKHIsIGUpIHtcbiAgICAgICAgcmV0dXJuIHAoZSAmJiBlLnN0cmVhbSwgXCJlbmNvZGVcIiwgXCJzdHJlYW1cIiksIEEocik7XG4gICAgICB9O1xuICAgICAgZnVuY3Rpb24gVShyKSB7XG4gICAgICAgIHZhciBlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBmID0gbmV3IEJsb2IoW3JdLCB7IHR5cGU6IFwidGV4dC9wbGFpbjtjaGFyc2V0PVVURi04XCIgfSk7XG4gICAgICAgICAgZSA9IFVSTC5jcmVhdGVPYmplY3RVUkwoZik7XG4gICAgICAgICAgdmFyIG4gPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICByZXR1cm4gbi5vcGVuKFwiR0VUXCIsIGUsIGZhbHNlKSwgbi5zZW5kKCksIG4ucmVzcG9uc2VUZXh0O1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGUgJiYgVVJMLnJldm9rZU9iamVjdFVSTChlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIE8gPSAheCAmJiB0eXBlb2YgQmxvYiA9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFVSTCA9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFVSTC5jcmVhdGVPYmplY3RVUkwgPT0gXCJmdW5jdGlvblwiLCBTID0gW1widXRmLThcIiwgXCJ1dGY4XCIsIFwidW5pY29kZS0xLTEtdXRmLThcIl0sIFQgPSBoO1xuICAgICAgeCA/IFQgPSBCIDogTyAmJiAoVCA9IGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gVShyKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJldHVybiBoKHIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHZhciB5ID0gXCJjb25zdHJ1Y3QgJ1RleHREZWNvZGVyJ1wiLCBFID0gXCJcIi5jb25jYXQodSwgXCIgXCIpLmNvbmNhdCh5LCBcIjogdGhlIFwiKTtcbiAgICAgIGZ1bmN0aW9uIGcociwgZSkge1xuICAgICAgICBwKGUgJiYgZS5mYXRhbCwgeSwgXCJmYXRhbFwiKSwgciA9IHIgfHwgXCJ1dGYtOFwiO1xuICAgICAgICB2YXIgZjtcbiAgICAgICAgaWYgKHggPyBmID0gQnVmZmVyLmlzRW5jb2RpbmcocikgOiBmID0gUy5pbmRleE9mKHIudG9Mb3dlckNhc2UoKSkgIT09IC0xLCAhZikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJcIi5jb25jYXQoRSwgXCIgZW5jb2RpbmcgbGFiZWwgcHJvdmlkZWQgKCdcIikuY29uY2F0KHIsIFwiJykgaXMgaW52YWxpZC5cIikpO1xuICAgICAgICB0aGlzLmVuY29kaW5nID0gciwgdGhpcy5mYXRhbCA9IGZhbHNlLCB0aGlzLmlnbm9yZUJPTSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgZy5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24ociwgZSkge1xuICAgICAgICBwKGUgJiYgZS5zdHJlYW0sIFwiZGVjb2RlXCIsIFwic3RyZWFtXCIpO1xuICAgICAgICB2YXIgZjtcbiAgICAgICAgcmV0dXJuIHIgaW5zdGFuY2VvZiBVaW50OEFycmF5ID8gZiA9IHIgOiByLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyID8gZiA9IG5ldyBVaW50OEFycmF5KHIuYnVmZmVyKSA6IGYgPSBuZXcgVWludDhBcnJheShyKSwgVChmLCB0aGlzLmVuY29kaW5nKTtcbiAgICAgIH07XG4gICAgICBzY29wZS5UZXh0RW5jb2RlciA9IHNjb3BlLlRleHRFbmNvZGVyIHx8IHY7XG4gICAgICBzY29wZS5UZXh0RGVjb2RlciA9IHNjb3BlLlRleHREZWNvZGVyIHx8IGc7XG4gICAgfSkodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiBleHBvcnRzKTtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9zdGF0dXNlc0AyLjAuMi9ub2RlX21vZHVsZXMvc3RhdHVzZXMvY29kZXMuanNvblxudmFyIHJlcXVpcmVfY29kZXMgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vc3RhdHVzZXNAMi4wLjIvbm9kZV9tb2R1bGVzL3N0YXR1c2VzL2NvZGVzLmpzb25cIihleHBvcnRzLCBtb2R1bGUpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgIFwiMTAwXCI6IFwiQ29udGludWVcIixcbiAgICAgIFwiMTAxXCI6IFwiU3dpdGNoaW5nIFByb3RvY29sc1wiLFxuICAgICAgXCIxMDJcIjogXCJQcm9jZXNzaW5nXCIsXG4gICAgICBcIjEwM1wiOiBcIkVhcmx5IEhpbnRzXCIsXG4gICAgICBcIjIwMFwiOiBcIk9LXCIsXG4gICAgICBcIjIwMVwiOiBcIkNyZWF0ZWRcIixcbiAgICAgIFwiMjAyXCI6IFwiQWNjZXB0ZWRcIixcbiAgICAgIFwiMjAzXCI6IFwiTm9uLUF1dGhvcml0YXRpdmUgSW5mb3JtYXRpb25cIixcbiAgICAgIFwiMjA0XCI6IFwiTm8gQ29udGVudFwiLFxuICAgICAgXCIyMDVcIjogXCJSZXNldCBDb250ZW50XCIsXG4gICAgICBcIjIwNlwiOiBcIlBhcnRpYWwgQ29udGVudFwiLFxuICAgICAgXCIyMDdcIjogXCJNdWx0aS1TdGF0dXNcIixcbiAgICAgIFwiMjA4XCI6IFwiQWxyZWFkeSBSZXBvcnRlZFwiLFxuICAgICAgXCIyMjZcIjogXCJJTSBVc2VkXCIsXG4gICAgICBcIjMwMFwiOiBcIk11bHRpcGxlIENob2ljZXNcIixcbiAgICAgIFwiMzAxXCI6IFwiTW92ZWQgUGVybWFuZW50bHlcIixcbiAgICAgIFwiMzAyXCI6IFwiRm91bmRcIixcbiAgICAgIFwiMzAzXCI6IFwiU2VlIE90aGVyXCIsXG4gICAgICBcIjMwNFwiOiBcIk5vdCBNb2RpZmllZFwiLFxuICAgICAgXCIzMDVcIjogXCJVc2UgUHJveHlcIixcbiAgICAgIFwiMzA3XCI6IFwiVGVtcG9yYXJ5IFJlZGlyZWN0XCIsXG4gICAgICBcIjMwOFwiOiBcIlBlcm1hbmVudCBSZWRpcmVjdFwiLFxuICAgICAgXCI0MDBcIjogXCJCYWQgUmVxdWVzdFwiLFxuICAgICAgXCI0MDFcIjogXCJVbmF1dGhvcml6ZWRcIixcbiAgICAgIFwiNDAyXCI6IFwiUGF5bWVudCBSZXF1aXJlZFwiLFxuICAgICAgXCI0MDNcIjogXCJGb3JiaWRkZW5cIixcbiAgICAgIFwiNDA0XCI6IFwiTm90IEZvdW5kXCIsXG4gICAgICBcIjQwNVwiOiBcIk1ldGhvZCBOb3QgQWxsb3dlZFwiLFxuICAgICAgXCI0MDZcIjogXCJOb3QgQWNjZXB0YWJsZVwiLFxuICAgICAgXCI0MDdcIjogXCJQcm94eSBBdXRoZW50aWNhdGlvbiBSZXF1aXJlZFwiLFxuICAgICAgXCI0MDhcIjogXCJSZXF1ZXN0IFRpbWVvdXRcIixcbiAgICAgIFwiNDA5XCI6IFwiQ29uZmxpY3RcIixcbiAgICAgIFwiNDEwXCI6IFwiR29uZVwiLFxuICAgICAgXCI0MTFcIjogXCJMZW5ndGggUmVxdWlyZWRcIixcbiAgICAgIFwiNDEyXCI6IFwiUHJlY29uZGl0aW9uIEZhaWxlZFwiLFxuICAgICAgXCI0MTNcIjogXCJQYXlsb2FkIFRvbyBMYXJnZVwiLFxuICAgICAgXCI0MTRcIjogXCJVUkkgVG9vIExvbmdcIixcbiAgICAgIFwiNDE1XCI6IFwiVW5zdXBwb3J0ZWQgTWVkaWEgVHlwZVwiLFxuICAgICAgXCI0MTZcIjogXCJSYW5nZSBOb3QgU2F0aXNmaWFibGVcIixcbiAgICAgIFwiNDE3XCI6IFwiRXhwZWN0YXRpb24gRmFpbGVkXCIsXG4gICAgICBcIjQxOFwiOiBcIkknbSBhIFRlYXBvdFwiLFxuICAgICAgXCI0MjFcIjogXCJNaXNkaXJlY3RlZCBSZXF1ZXN0XCIsXG4gICAgICBcIjQyMlwiOiBcIlVucHJvY2Vzc2FibGUgRW50aXR5XCIsXG4gICAgICBcIjQyM1wiOiBcIkxvY2tlZFwiLFxuICAgICAgXCI0MjRcIjogXCJGYWlsZWQgRGVwZW5kZW5jeVwiLFxuICAgICAgXCI0MjVcIjogXCJUb28gRWFybHlcIixcbiAgICAgIFwiNDI2XCI6IFwiVXBncmFkZSBSZXF1aXJlZFwiLFxuICAgICAgXCI0MjhcIjogXCJQcmVjb25kaXRpb24gUmVxdWlyZWRcIixcbiAgICAgIFwiNDI5XCI6IFwiVG9vIE1hbnkgUmVxdWVzdHNcIixcbiAgICAgIFwiNDMxXCI6IFwiUmVxdWVzdCBIZWFkZXIgRmllbGRzIFRvbyBMYXJnZVwiLFxuICAgICAgXCI0NTFcIjogXCJVbmF2YWlsYWJsZSBGb3IgTGVnYWwgUmVhc29uc1wiLFxuICAgICAgXCI1MDBcIjogXCJJbnRlcm5hbCBTZXJ2ZXIgRXJyb3JcIixcbiAgICAgIFwiNTAxXCI6IFwiTm90IEltcGxlbWVudGVkXCIsXG4gICAgICBcIjUwMlwiOiBcIkJhZCBHYXRld2F5XCIsXG4gICAgICBcIjUwM1wiOiBcIlNlcnZpY2UgVW5hdmFpbGFibGVcIixcbiAgICAgIFwiNTA0XCI6IFwiR2F0ZXdheSBUaW1lb3V0XCIsXG4gICAgICBcIjUwNVwiOiBcIkhUVFAgVmVyc2lvbiBOb3QgU3VwcG9ydGVkXCIsXG4gICAgICBcIjUwNlwiOiBcIlZhcmlhbnQgQWxzbyBOZWdvdGlhdGVzXCIsXG4gICAgICBcIjUwN1wiOiBcIkluc3VmZmljaWVudCBTdG9yYWdlXCIsXG4gICAgICBcIjUwOFwiOiBcIkxvb3AgRGV0ZWN0ZWRcIixcbiAgICAgIFwiNTA5XCI6IFwiQmFuZHdpZHRoIExpbWl0IEV4Y2VlZGVkXCIsXG4gICAgICBcIjUxMFwiOiBcIk5vdCBFeHRlbmRlZFwiLFxuICAgICAgXCI1MTFcIjogXCJOZXR3b3JrIEF1dGhlbnRpY2F0aW9uIFJlcXVpcmVkXCJcbiAgICB9O1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3N0YXR1c2VzQDIuMC4yL25vZGVfbW9kdWxlcy9zdGF0dXNlcy9pbmRleC5qc1xudmFyIHJlcXVpcmVfc3RhdHVzZXMgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vc3RhdHVzZXNAMi4wLjIvbm9kZV9tb2R1bGVzL3N0YXR1c2VzL2luZGV4LmpzXCIoZXhwb3J0cywgbW9kdWxlKSB7XG4gICAgdmFyIGNvZGVzID0gcmVxdWlyZV9jb2RlcygpO1xuICAgIG1vZHVsZS5leHBvcnRzID0gc3RhdHVzMjtcbiAgICBzdGF0dXMyLm1lc3NhZ2UgPSBjb2RlcztcbiAgICBzdGF0dXMyLmNvZGUgPSBjcmVhdGVNZXNzYWdlVG9TdGF0dXNDb2RlTWFwKGNvZGVzKTtcbiAgICBzdGF0dXMyLmNvZGVzID0gY3JlYXRlU3RhdHVzQ29kZUxpc3QoY29kZXMpO1xuICAgIHN0YXR1czIucmVkaXJlY3QgPSB7XG4gICAgICAzMDA6IHRydWUsXG4gICAgICAzMDE6IHRydWUsXG4gICAgICAzMDI6IHRydWUsXG4gICAgICAzMDM6IHRydWUsXG4gICAgICAzMDU6IHRydWUsXG4gICAgICAzMDc6IHRydWUsXG4gICAgICAzMDg6IHRydWVcbiAgICB9O1xuICAgIHN0YXR1czIuZW1wdHkgPSB7XG4gICAgICAyMDQ6IHRydWUsXG4gICAgICAyMDU6IHRydWUsXG4gICAgICAzMDQ6IHRydWVcbiAgICB9O1xuICAgIHN0YXR1czIucmV0cnkgPSB7XG4gICAgICA1MDI6IHRydWUsXG4gICAgICA1MDM6IHRydWUsXG4gICAgICA1MDQ6IHRydWVcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGNyZWF0ZU1lc3NhZ2VUb1N0YXR1c0NvZGVNYXAoY29kZXMyKSB7XG4gICAgICB2YXIgbWFwID0ge307XG4gICAgICBPYmplY3Qua2V5cyhjb2RlczIpLmZvckVhY2goZnVuY3Rpb24gZm9yRWFjaENvZGUoY29kZSkge1xuICAgICAgICB2YXIgbWVzc2FnZSA9IGNvZGVzMltjb2RlXTtcbiAgICAgICAgdmFyIHN0YXR1czMgPSBOdW1iZXIoY29kZSk7XG4gICAgICAgIG1hcFttZXNzYWdlLnRvTG93ZXJDYXNlKCldID0gc3RhdHVzMztcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG1hcDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlU3RhdHVzQ29kZUxpc3QoY29kZXMyKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXMoY29kZXMyKS5tYXAoZnVuY3Rpb24gbWFwQ29kZShjb2RlKSB7XG4gICAgICAgIHJldHVybiBOdW1iZXIoY29kZSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0U3RhdHVzQ29kZShtZXNzYWdlKSB7XG4gICAgICB2YXIgbXNnID0gbWVzc2FnZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc3RhdHVzMi5jb2RlLCBtc2cpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzdGF0dXMgbWVzc2FnZTogXCInICsgbWVzc2FnZSArICdcIicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0YXR1czIuY29kZVttc2ddO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRTdGF0dXNNZXNzYWdlKGNvZGUpIHtcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHN0YXR1czIubWVzc2FnZSwgY29kZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBzdGF0dXMgY29kZTogXCIgKyBjb2RlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdGF0dXMyLm1lc3NhZ2VbY29kZV07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0YXR1czIoY29kZSkge1xuICAgICAgaWYgKHR5cGVvZiBjb2RlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiBnZXRTdGF0dXNNZXNzYWdlKGNvZGUpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBjb2RlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJjb2RlIG11c3QgYmUgYSBudW1iZXIgb3Igc3RyaW5nXCIpO1xuICAgICAgfVxuICAgICAgdmFyIG4gPSBwYXJzZUludChjb2RlLCAxMCk7XG4gICAgICBpZiAoIWlzTmFOKG4pKSB7XG4gICAgICAgIHJldHVybiBnZXRTdGF0dXNNZXNzYWdlKG4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdldFN0YXR1c0NvZGUoY29kZSk7XG4gICAgfVxuICB9XG59KTtcblxuLy8gc3JjL2xpYi90aW1lX2R1cmF0aW9uLnRzXG52YXIgVGltZUR1cmF0aW9uID0gY2xhc3MgX1RpbWVEdXJhdGlvbiB7XG4gIF9fdGltZV9kdXJhdGlvbl9taWNyb3NfXztcbiAgc3RhdGljIE1JQ1JPU19QRVJfTUlMTElTID0gMTAwMG47XG4gIC8qKlxuICAgKiBHZXQgdGhlIGFsZ2VicmFpYyB0eXBlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB7QGxpbmsgVGltZUR1cmF0aW9ufSB0eXBlLlxuICAgKiBAcmV0dXJucyBUaGUgYWxnZWJyYWljIHR5cGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIHR5cGUuXG4gICAqL1xuICBzdGF0aWMgZ2V0QWxnZWJyYWljVHlwZSgpIHtcbiAgICByZXR1cm4gQWxnZWJyYWljVHlwZS5Qcm9kdWN0KHtcbiAgICAgIGVsZW1lbnRzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcIl9fdGltZV9kdXJhdGlvbl9taWNyb3NfX1wiLFxuICAgICAgICAgIGFsZ2VicmFpY1R5cGU6IEFsZ2VicmFpY1R5cGUuSTY0XG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgaXNUaW1lRHVyYXRpb24oYWxnZWJyYWljVHlwZSkge1xuICAgIGlmIChhbGdlYnJhaWNUeXBlLnRhZyAhPT0gXCJQcm9kdWN0XCIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgZWxlbWVudHMgPSBhbGdlYnJhaWNUeXBlLnZhbHVlLmVsZW1lbnRzO1xuICAgIGlmIChlbGVtZW50cy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgbWljcm9zRWxlbWVudCA9IGVsZW1lbnRzWzBdO1xuICAgIHJldHVybiBtaWNyb3NFbGVtZW50Lm5hbWUgPT09IFwiX190aW1lX2R1cmF0aW9uX21pY3Jvc19fXCIgJiYgbWljcm9zRWxlbWVudC5hbGdlYnJhaWNUeXBlLnRhZyA9PT0gXCJJNjRcIjtcbiAgfVxuICBnZXQgbWljcm9zKCkge1xuICAgIHJldHVybiB0aGlzLl9fdGltZV9kdXJhdGlvbl9taWNyb3NfXztcbiAgfVxuICBnZXQgbWlsbGlzKCkge1xuICAgIHJldHVybiBOdW1iZXIodGhpcy5taWNyb3MgLyBfVGltZUR1cmF0aW9uLk1JQ1JPU19QRVJfTUlMTElTKTtcbiAgfVxuICBjb25zdHJ1Y3RvcihtaWNyb3MpIHtcbiAgICB0aGlzLl9fdGltZV9kdXJhdGlvbl9taWNyb3NfXyA9IG1pY3JvcztcbiAgfVxuICBzdGF0aWMgZnJvbU1pbGxpcyhtaWxsaXMpIHtcbiAgICByZXR1cm4gbmV3IF9UaW1lRHVyYXRpb24oQmlnSW50KG1pbGxpcykgKiBfVGltZUR1cmF0aW9uLk1JQ1JPU19QRVJfTUlMTElTKTtcbiAgfVxuICAvKiogVGhpcyBvdXRwdXRzIHRoZSBzYW1lIHN0cmluZyBmb3JtYXQgdGhhdCB3ZSB1c2UgaW4gdGhlIGhvc3QgYW5kIGluIFJ1c3QgbW9kdWxlcyAqL1xuICB0b1N0cmluZygpIHtcbiAgICBjb25zdCBtaWNyb3MgPSB0aGlzLm1pY3JvcztcbiAgICBjb25zdCBzaWduID0gbWljcm9zIDwgMCA/IFwiLVwiIDogXCIrXCI7XG4gICAgY29uc3QgcG9zID0gbWljcm9zIDwgMCA/IC1taWNyb3MgOiBtaWNyb3M7XG4gICAgY29uc3Qgc2VjcyA9IHBvcyAvIDEwMDAwMDBuO1xuICAgIGNvbnN0IG1pY3Jvc19yZW1haW5pbmcgPSBwb3MgJSAxMDAwMDAwbjtcbiAgICByZXR1cm4gYCR7c2lnbn0ke3NlY3N9LiR7U3RyaW5nKG1pY3Jvc19yZW1haW5pbmcpLnBhZFN0YXJ0KDYsIFwiMFwiKX1gO1xuICB9XG59O1xuXG4vLyBzcmMvbGliL3RpbWVzdGFtcC50c1xudmFyIFRpbWVzdGFtcCA9IGNsYXNzIF9UaW1lc3RhbXAge1xuICBfX3RpbWVzdGFtcF9taWNyb3Nfc2luY2VfdW5peF9lcG9jaF9fO1xuICBzdGF0aWMgTUlDUk9TX1BFUl9NSUxMSVMgPSAxMDAwbjtcbiAgZ2V0IG1pY3Jvc1NpbmNlVW5peEVwb2NoKCkge1xuICAgIHJldHVybiB0aGlzLl9fdGltZXN0YW1wX21pY3Jvc19zaW5jZV91bml4X2Vwb2NoX187XG4gIH1cbiAgY29uc3RydWN0b3IobWljcm9zKSB7XG4gICAgdGhpcy5fX3RpbWVzdGFtcF9taWNyb3Nfc2luY2VfdW5peF9lcG9jaF9fID0gbWljcm9zO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGFsZ2VicmFpYyB0eXBlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB7QGxpbmsgVGltZXN0YW1wfSB0eXBlLlxuICAgKiBAcmV0dXJucyBUaGUgYWxnZWJyYWljIHR5cGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIHR5cGUuXG4gICAqL1xuICBzdGF0aWMgZ2V0QWxnZWJyYWljVHlwZSgpIHtcbiAgICByZXR1cm4gQWxnZWJyYWljVHlwZS5Qcm9kdWN0KHtcbiAgICAgIGVsZW1lbnRzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcIl9fdGltZXN0YW1wX21pY3Jvc19zaW5jZV91bml4X2Vwb2NoX19cIixcbiAgICAgICAgICBhbGdlYnJhaWNUeXBlOiBBbGdlYnJhaWNUeXBlLkk2NFxuICAgICAgICB9XG4gICAgICBdXG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGlzVGltZXN0YW1wKGFsZ2VicmFpY1R5cGUpIHtcbiAgICBpZiAoYWxnZWJyYWljVHlwZS50YWcgIT09IFwiUHJvZHVjdFwiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGVsZW1lbnRzID0gYWxnZWJyYWljVHlwZS52YWx1ZS5lbGVtZW50cztcbiAgICBpZiAoZWxlbWVudHMubGVuZ3RoICE9PSAxKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IG1pY3Jvc0VsZW1lbnQgPSBlbGVtZW50c1swXTtcbiAgICByZXR1cm4gbWljcm9zRWxlbWVudC5uYW1lID09PSBcIl9fdGltZXN0YW1wX21pY3Jvc19zaW5jZV91bml4X2Vwb2NoX19cIiAmJiBtaWNyb3NFbGVtZW50LmFsZ2VicmFpY1R5cGUudGFnID09PSBcIkk2NFwiO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgVW5peCBlcG9jaCwgdGhlIG1pZG5pZ2h0IGF0IHRoZSBiZWdpbm5pbmcgb2YgSmFudWFyeSAxLCAxOTcwLCBVVEMuXG4gICAqL1xuICBzdGF0aWMgVU5JWF9FUE9DSCA9IG5ldyBfVGltZXN0YW1wKDBuKTtcbiAgLyoqXG4gICAqIEdldCBhIGBUaW1lc3RhbXBgIHJlcHJlc2VudGluZyB0aGUgZXhlY3V0aW9uIGVudmlyb25tZW50J3MgYmVsaWVmIG9mIHRoZSBjdXJyZW50IG1vbWVudCBpbiB0aW1lLlxuICAgKi9cbiAgc3RhdGljIG5vdygpIHtcbiAgICByZXR1cm4gX1RpbWVzdGFtcC5mcm9tRGF0ZSgvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSk7XG4gIH1cbiAgLyoqIENvbnZlcnQgdG8gbWlsbGlzZWNvbmRzIHNpbmNlIFVuaXggZXBvY2guICovXG4gIHRvTWlsbGlzKCkge1xuICAgIHJldHVybiB0aGlzLm1pY3Jvc1NpbmNlVW5peEVwb2NoIC8gMTAwMG47XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhIGBUaW1lc3RhbXBgIHJlcHJlc2VudGluZyB0aGUgc2FtZSBwb2ludCBpbiB0aW1lIGFzIGBkYXRlYC5cbiAgICovXG4gIHN0YXRpYyBmcm9tRGF0ZShkYXRlKSB7XG4gICAgY29uc3QgbWlsbGlzID0gZGF0ZS5nZXRUaW1lKCk7XG4gICAgY29uc3QgbWljcm9zID0gQmlnSW50KG1pbGxpcykgKiBfVGltZXN0YW1wLk1JQ1JPU19QRVJfTUlMTElTO1xuICAgIHJldHVybiBuZXcgX1RpbWVzdGFtcChtaWNyb3MpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYSBgRGF0ZWAgcmVwcmVzZW50aW5nIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgcG9pbnQgaW4gdGltZSBhcyBgdGhpc2AuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIHRydW5jYXRlcyB0byBtaWxsaXNlY29uZCBwcmVjaXNpb24sXG4gICAqIGFuZCB0aHJvd3MgYFJhbmdlRXJyb3JgIGlmIHRoZSBgVGltZXN0YW1wYCBpcyBvdXRzaWRlIHRoZSByYW5nZSByZXByZXNlbnRhYmxlIGFzIGEgYERhdGVgLlxuICAgKi9cbiAgdG9EYXRlKCkge1xuICAgIGNvbnN0IG1pY3JvcyA9IHRoaXMuX190aW1lc3RhbXBfbWljcm9zX3NpbmNlX3VuaXhfZXBvY2hfXztcbiAgICBjb25zdCBtaWxsaXMgPSBtaWNyb3MgLyBfVGltZXN0YW1wLk1JQ1JPU19QRVJfTUlMTElTO1xuICAgIGlmIChtaWxsaXMgPiBCaWdJbnQoTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpIHx8IG1pbGxpcyA8IEJpZ0ludChOdW1iZXIuTUlOX1NBRkVfSU5URUdFUikpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFxuICAgICAgICBcIlRpbWVzdGFtcCBpcyBvdXRzaWRlIG9mIHRoZSByZXByZXNlbnRhYmxlIHJhbmdlIG9mIEpTJ3MgRGF0ZVwiXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IERhdGUoTnVtYmVyKG1pbGxpcykpO1xuICB9XG4gIHNpbmNlKG90aGVyKSB7XG4gICAgcmV0dXJuIG5ldyBUaW1lRHVyYXRpb24oXG4gICAgICB0aGlzLl9fdGltZXN0YW1wX21pY3Jvc19zaW5jZV91bml4X2Vwb2NoX18gLSBvdGhlci5fX3RpbWVzdGFtcF9taWNyb3Nfc2luY2VfdW5peF9lcG9jaF9fXG4gICAgKTtcbiAgfVxufTtcblxuLy8gc3JjL2xpYi91dWlkLnRzXG52YXIgVXVpZCA9IGNsYXNzIF9VdWlkIHtcbiAgX191dWlkX187XG4gIC8qKlxuICAgKiBUaGUgbmlsIFVVSUQgKGFsbCB6ZXJvcykuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzXG4gICAqIGNvbnN0IHV1aWQgPSBVdWlkLk5JTDtcbiAgICogY29uc29sZS5hc3NlcnQoXG4gICAqICAgdXVpZC50b1N0cmluZygpID09PSBcIjAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMFwiXG4gICAqICk7XG4gICAqIGBgYFxuICAgKi9cbiAgc3RhdGljIE5JTCA9IG5ldyBfVXVpZCgwbik7XG4gIHN0YXRpYyBNQVhfVVVJRF9CSUdJTlQgPSAweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmbjtcbiAgLyoqXG4gICAqIFRoZSBtYXggVVVJRCAoYWxsIG9uZXMpLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiBjb25zdCB1dWlkID0gVXVpZC5NQVg7XG4gICAqIGNvbnNvbGUuYXNzZXJ0KFxuICAgKiAgIHV1aWQudG9TdHJpbmcoKSA9PT0gXCJmZmZmZmZmZi1mZmZmLWZmZmYtZmZmZi1mZmZmZmZmZmZmZmZcIlxuICAgKiApO1xuICAgKiBgYGBcbiAgICovXG4gIHN0YXRpYyBNQVggPSBuZXcgX1V1aWQoX1V1aWQuTUFYX1VVSURfQklHSU5UKTtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIFVVSUQgZnJvbSBhIHJhdyAxMjgtYml0IHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0gdSAtIFVuc2lnbmVkIDEyOC1iaXQgaW50ZWdlclxuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHZhbHVlIGlzIG91dHNpZGUgdGhlIHZhbGlkIFVVSUQgcmFuZ2VcbiAgICovXG4gIGNvbnN0cnVjdG9yKHUpIHtcbiAgICBpZiAodSA8IDBuIHx8IHUgPiBfVXVpZC5NQVhfVVVJRF9CSUdJTlQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgVVVJRDogbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIGBNQVhfVVVJRF9CSUdJTlRgXCIpO1xuICAgIH1cbiAgICB0aGlzLl9fdXVpZF9fID0gdTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgVVVJRCBgdjRgIGZyb20gZXhwbGljaXQgcmFuZG9tIGJ5dGVzLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBhc3N1bWVzIHRoZSBieXRlcyBhcmUgYWxyZWFkeSBzdWZmaWNpZW50bHkgcmFuZG9tLlxuICAgKiBJdCBvbmx5IHNldHMgdGhlIGFwcHJvcHJpYXRlIGJpdHMgZm9yIHRoZSBVVUlEIHZlcnNpb24gYW5kIHZhcmlhbnQuXG4gICAqXG4gICAqIEBwYXJhbSBieXRlcyAtIEV4YWN0bHkgMTYgcmFuZG9tIGJ5dGVzXG4gICAqIEByZXR1cm5zIEEgVVVJRCBgdjRgXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBgYnl0ZXMubGVuZ3RoICE9PSAxNmBcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHNcbiAgICogY29uc3QgcmFuZG9tQnl0ZXMgPSBuZXcgVWludDhBcnJheSgxNik7XG4gICAqIGNvbnN0IHV1aWQgPSBVdWlkLmZyb21SYW5kb21CeXRlc1Y0KHJhbmRvbUJ5dGVzKTtcbiAgICpcbiAgICogY29uc29sZS5hc3NlcnQoXG4gICAqICAgdXVpZC50b1N0cmluZygpID09PSBcIjAwMDAwMDAwLTAwMDAtNDAwMC04MDAwLTAwMDAwMDAwMDAwMFwiXG4gICAqICk7XG4gICAqIGBgYFxuICAgKi9cbiAgc3RhdGljIGZyb21SYW5kb21CeXRlc1Y0KGJ5dGVzKSB7XG4gICAgaWYgKGJ5dGVzLmxlbmd0aCAhPT0gMTYpIHRocm93IG5ldyBFcnJvcihcIlVVSUQgdjQgcmVxdWlyZXMgMTYgYnl0ZXNcIik7XG4gICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMpO1xuICAgIGFycls2XSA9IGFycls2XSAmIDE1IHwgNjQ7XG4gICAgYXJyWzhdID0gYXJyWzhdICYgNjMgfCAxMjg7XG4gICAgcmV0dXJuIG5ldyBfVXVpZChfVXVpZC5ieXRlc1RvQmlnSW50KGFycikpO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIFVVSUQgYHY3YCB1c2luZyBhIG1vbm90b25pYyBjb3VudGVyIGZyb20gYDBgIHRvIGAyXjMxIC0gMWAsXG4gICAqIGEgdGltZXN0YW1wLCBhbmQgNCByYW5kb20gYnl0ZXMuXG4gICAqXG4gICAqIFRoZSBjb3VudGVyIHdyYXBzIGFyb3VuZCBvbiBvdmVyZmxvdy5cbiAgICpcbiAgICogVGhlIFVVSUQgYHY3YCBpcyBzdHJ1Y3R1cmVkIGFzIGZvbGxvd3M6XG4gICAqXG4gICAqIGBgYGFzY2lpXG4gICAqIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUrOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkFxuICAgKiB8IEIwICB8IEIxICB8IEIyICB8IEIzICB8IEI0ICB8IEI1ICAgICAgICAgICAgICB8ICAgICAgICAgQjYgICAgICAgIHxcbiAgICog4pSc4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSkXG4gICAqIHwgICAgICAgICAgICAgICAgIHVuaXhfdHNfbXMgICAgICAgICAgICAgICAgICAgIHwgICAgICB2ZXJzaW9uIDcgICAgfFxuICAgKiDilJTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilLTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJhcbiAgICog4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSs4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSs4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSs4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSQXG4gICAqIHwgQjcgICAgICAgICAgIHwgQjggICAgICB8IEI5ICB8IEIxMCB8IEIxMSAgfCBCMTIgfCBCMTMgfCBCMTQgfCBCMTUgfFxuICAgKiDilJzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilKRcbiAgICogfCBjb3VudGVyX2hpZ2ggfCB2YXJpYW50IHwgICAgY291bnRlcl9sb3cgICB8ICAgICAgICByYW5kb20gICAgICAgICB8XG4gICAqIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUtOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUtOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUtOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmFxuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIGNvdW50ZXIgLSBNdXRhYmxlIG1vbm90b25pYyBjb3VudGVyICgzMS1iaXQpXG4gICAqIEBwYXJhbSBub3cgLSBUaW1lc3RhbXAgc2luY2UgdGhlIFVuaXggZXBvY2hcbiAgICogQHBhcmFtIHJhbmRvbUJ5dGVzIC0gRXhhY3RseSA0IHJhbmRvbSBieXRlc1xuICAgKiBAcmV0dXJucyBBIFVVSUQgYHY3YFxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGBjb3VudGVyYCBpcyBuZWdhdGl2ZVxuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGB0aW1lc3RhbXBgIGlzIGJlZm9yZSB0aGUgVW5peCBlcG9jaFxuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgYHJhbmRvbUJ5dGVzLmxlbmd0aCAhPT0gNGBcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHNcbiAgICogY29uc3Qgbm93ID0gVGltZXN0YW1wLmZyb21NaWxsaXMoMV82ODZfMDAwXzAwMF8wMDBuKTtcbiAgICogY29uc3QgY291bnRlciA9IHsgdmFsdWU6IDEgfTtcbiAgICogY29uc3QgcmFuZG9tQnl0ZXMgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICpcbiAgICogY29uc3QgdXVpZCA9IFV1aWQuZnJvbUNvdW50ZXJWNyhjb3VudGVyLCBub3csIHJhbmRvbUJ5dGVzKTtcbiAgICpcbiAgICogY29uc29sZS5hc3NlcnQoXG4gICAqICAgdXVpZC50b1N0cmluZygpID09PSBcIjAwMDA2NDdlLTUxODAtNzAwMC04MDAwLTAwMDIwMDAwMDAwMFwiXG4gICAqICk7XG4gICAqIGBgYFxuICAgKi9cbiAgc3RhdGljIGZyb21Db3VudGVyVjcoY291bnRlciwgbm93LCByYW5kb21CeXRlcykge1xuICAgIGlmIChyYW5kb21CeXRlcy5sZW5ndGggIT09IDQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImBmcm9tQ291bnRlclY3YCByZXF1aXJlcyBgcmFuZG9tQnl0ZXMubGVuZ3RoID09IDRgXCIpO1xuICAgIH1cbiAgICBpZiAoY291bnRlci52YWx1ZSA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImBmcm9tQ291bnRlclY3YCB1dWlkIGBjb3VudGVyYCBtdXN0IGJlIG5vbi1uZWdhdGl2ZVwiKTtcbiAgICB9XG4gICAgaWYgKG5vdy5fX3RpbWVzdGFtcF9taWNyb3Nfc2luY2VfdW5peF9lcG9jaF9fIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYGZyb21Db3VudGVyVjdgIGB0aW1lc3RhbXBgIGJlZm9yZSB1bml4IGVwb2NoXCIpO1xuICAgIH1cbiAgICBjb25zdCBjb3VudGVyVmFsID0gY291bnRlci52YWx1ZTtcbiAgICBjb3VudGVyLnZhbHVlID0gY291bnRlclZhbCArIDEgJiAyMTQ3NDgzNjQ3O1xuICAgIGNvbnN0IHRzTXMgPSBub3cudG9NaWxsaXMoKSAmIDB4ZmZmZmZmZmZmZmZmbjtcbiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgICBieXRlc1swXSA9IE51bWJlcih0c01zID4+IDQwbiAmIDB4ZmZuKTtcbiAgICBieXRlc1sxXSA9IE51bWJlcih0c01zID4+IDMybiAmIDB4ZmZuKTtcbiAgICBieXRlc1syXSA9IE51bWJlcih0c01zID4+IDI0biAmIDB4ZmZuKTtcbiAgICBieXRlc1szXSA9IE51bWJlcih0c01zID4+IDE2biAmIDB4ZmZuKTtcbiAgICBieXRlc1s0XSA9IE51bWJlcih0c01zID4+IDhuICYgMHhmZm4pO1xuICAgIGJ5dGVzWzVdID0gTnVtYmVyKHRzTXMgJiAweGZmbik7XG4gICAgYnl0ZXNbN10gPSBjb3VudGVyVmFsID4+PiAyMyAmIDI1NTtcbiAgICBieXRlc1s5XSA9IGNvdW50ZXJWYWwgPj4+IDE1ICYgMjU1O1xuICAgIGJ5dGVzWzEwXSA9IGNvdW50ZXJWYWwgPj4+IDcgJiAyNTU7XG4gICAgYnl0ZXNbMTFdID0gKGNvdW50ZXJWYWwgJiAxMjcpIDw8IDEgJiAyNTU7XG4gICAgYnl0ZXNbMTJdIHw9IHJhbmRvbUJ5dGVzWzBdICYgMTI3O1xuICAgIGJ5dGVzWzEzXSA9IHJhbmRvbUJ5dGVzWzFdO1xuICAgIGJ5dGVzWzE0XSA9IHJhbmRvbUJ5dGVzWzJdO1xuICAgIGJ5dGVzWzE1XSA9IHJhbmRvbUJ5dGVzWzNdO1xuICAgIGJ5dGVzWzZdID0gYnl0ZXNbNl0gJiAxNSB8IDExMjtcbiAgICBieXRlc1s4XSA9IGJ5dGVzWzhdICYgNjMgfCAxMjg7XG4gICAgcmV0dXJuIG5ldyBfVXVpZChfVXVpZC5ieXRlc1RvQmlnSW50KGJ5dGVzKSk7XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlIGEgVVVJRCBmcm9tIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gcyAtIFVVSUQgc3RyaW5nXG4gICAqIEByZXR1cm5zIFBhcnNlZCBVVUlEXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgc3RyaW5nIGlzIG5vdCBhIHZhbGlkIFVVSURcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHNcbiAgICogY29uc3QgcyA9IFwiMDE4ODhkNmUtNWMwMC03MDAwLTgwMDAtMDAwMDAwMDAwMDAwXCI7XG4gICAqIGNvbnN0IHV1aWQgPSBVdWlkLnBhcnNlKHMpO1xuICAgKlxuICAgKiBjb25zb2xlLmFzc2VydCh1dWlkLnRvU3RyaW5nKCkgPT09IHMpO1xuICAgKiBgYGBcbiAgICovXG4gIHN0YXRpYyBwYXJzZShzKSB7XG4gICAgY29uc3QgaGV4ID0gcy5yZXBsYWNlKC8tL2csIFwiXCIpO1xuICAgIGlmIChoZXgubGVuZ3RoICE9PSAzMikgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBoZXggVVVJRFwiKTtcbiAgICBsZXQgdiA9IDBuO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzI7IGkgKz0gMikge1xuICAgICAgdiA9IHYgPDwgOG4gfCBCaWdJbnQocGFyc2VJbnQoaGV4LnNsaWNlKGksIGkgKyAyKSwgMTYpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBfVXVpZCh2KTtcbiAgfVxuICAvKiogQ29udmVydCB0byBzdHJpbmcgKGh5cGhlbmF0ZWQgZm9ybSkuICovXG4gIHRvU3RyaW5nKCkge1xuICAgIGNvbnN0IGJ5dGVzID0gX1V1aWQuYmlnSW50VG9CeXRlcyh0aGlzLl9fdXVpZF9fKTtcbiAgICBjb25zdCBoZXggPSBbLi4uYnl0ZXNdLm1hcCgoYikgPT4gYi50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpKS5qb2luKFwiXCIpO1xuICAgIHJldHVybiBoZXguc2xpY2UoMCwgOCkgKyBcIi1cIiArIGhleC5zbGljZSg4LCAxMikgKyBcIi1cIiArIGhleC5zbGljZSgxMiwgMTYpICsgXCItXCIgKyBoZXguc2xpY2UoMTYsIDIwKSArIFwiLVwiICsgaGV4LnNsaWNlKDIwKTtcbiAgfVxuICAvKiogQ29udmVydCB0byBiaWdpbnQgKHUxMjgpLiAqL1xuICBhc0JpZ0ludCgpIHtcbiAgICByZXR1cm4gdGhpcy5fX3V1aWRfXztcbiAgfVxuICAvKiogUmV0dXJuIGEgYFVpbnQ4QXJyYXlgIG9mIDE2IGJ5dGVzLiAqL1xuICB0b0J5dGVzKCkge1xuICAgIHJldHVybiBfVXVpZC5iaWdJbnRUb0J5dGVzKHRoaXMuX191dWlkX18pO1xuICB9XG4gIHN0YXRpYyBieXRlc1RvQmlnSW50KGJ5dGVzKSB7XG4gICAgbGV0IHJlc3VsdCA9IDBuO1xuICAgIGZvciAoY29uc3QgYiBvZiBieXRlcykgcmVzdWx0ID0gcmVzdWx0IDw8IDhuIHwgQmlnSW50KGIpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgc3RhdGljIGJpZ0ludFRvQnl0ZXModmFsdWUpIHtcbiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgICBmb3IgKGxldCBpID0gMTU7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBieXRlc1tpXSA9IE51bWJlcih2YWx1ZSAmIDB4ZmZuKTtcbiAgICAgIHZhbHVlID4+PSA4bjtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB2ZXJzaW9uIG9mIHRoaXMgVVVJRC5cbiAgICpcbiAgICogVGhpcyByZXByZXNlbnRzIHRoZSBhbGdvcml0aG0gdXNlZCB0byBnZW5lcmF0ZSB0aGUgdmFsdWUuXG4gICAqXG4gICAqIEByZXR1cm5zIEEgYFV1aWRWZXJzaW9uYFxuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHZlcnNpb24gZmllbGQgaXMgbm90IHJlY29nbml6ZWRcbiAgICovXG4gIGdldFZlcnNpb24oKSB7XG4gICAgY29uc3QgdmVyc2lvbiA9IHRoaXMudG9CeXRlcygpWzZdID4+IDQgJiAxNTtcbiAgICBzd2l0Y2ggKHZlcnNpb24pIHtcbiAgICAgIGNhc2UgNDpcbiAgICAgICAgcmV0dXJuIFwiVjRcIjtcbiAgICAgIGNhc2UgNzpcbiAgICAgICAgcmV0dXJuIFwiVjdcIjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmICh0aGlzID09IF9VdWlkLk5JTCkge1xuICAgICAgICAgIHJldHVybiBcIk5pbFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzID09IF9VdWlkLk1BWCkge1xuICAgICAgICAgIHJldHVybiBcIk1heFwiO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgVVVJRCB2ZXJzaW9uOiAke3ZlcnNpb259YCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBFeHRyYWN0IHRoZSBtb25vdG9uaWMgY291bnRlciBmcm9tIGEgVVVJRHY3LlxuICAgKlxuICAgKiBJbnRlbmRlZCBmb3IgdGVzdGluZyBhbmQgZGlhZ25vc3RpY3MuXG4gICAqIEJlaGF2aW9yIGlzIHVuZGVmaW5lZCBpZiBjYWxsZWQgb24gYSBub24tVjcgVVVJRC5cbiAgICpcbiAgICogQHJldHVybnMgMzEtYml0IGNvdW50ZXIgdmFsdWVcbiAgICovXG4gIGdldENvdW50ZXIoKSB7XG4gICAgY29uc3QgYnl0ZXMgPSB0aGlzLnRvQnl0ZXMoKTtcbiAgICBjb25zdCBoaWdoID0gYnl0ZXNbN107XG4gICAgY29uc3QgbWlkMSA9IGJ5dGVzWzldO1xuICAgIGNvbnN0IG1pZDIgPSBieXRlc1sxMF07XG4gICAgY29uc3QgbG93ID0gYnl0ZXNbMTFdID4+PiAxO1xuICAgIHJldHVybiBoaWdoIDw8IDIzIHwgbWlkMSA8PCAxNSB8IG1pZDIgPDwgNyB8IGxvdyB8IDA7XG4gIH1cbiAgY29tcGFyZVRvKG90aGVyKSB7XG4gICAgaWYgKHRoaXMuX191dWlkX18gPCBvdGhlci5fX3V1aWRfXykgcmV0dXJuIC0xO1xuICAgIGlmICh0aGlzLl9fdXVpZF9fID4gb3RoZXIuX191dWlkX18pIHJldHVybiAxO1xuICAgIHJldHVybiAwO1xuICB9XG4gIHN0YXRpYyBnZXRBbGdlYnJhaWNUeXBlKCkge1xuICAgIHJldHVybiBBbGdlYnJhaWNUeXBlLlByb2R1Y3Qoe1xuICAgICAgZWxlbWVudHM6IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwiX191dWlkX19cIixcbiAgICAgICAgICBhbGdlYnJhaWNUeXBlOiBBbGdlYnJhaWNUeXBlLlUxMjhcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0pO1xuICB9XG59O1xuXG4vLyBzcmMvbGliL2JpbmFyeV9yZWFkZXIudHNcbnZhciBCaW5hcnlSZWFkZXIgPSBjbGFzcyB7XG4gIC8qKlxuICAgKiBUaGUgRGF0YVZpZXcgdXNlZCB0byByZWFkIHZhbHVlcyBmcm9tIHRoZSBiaW5hcnkgZGF0YS5cbiAgICpcbiAgICogTm90ZTogVGhlIERhdGFWaWV3J3MgYGJ5dGVPZmZzZXRgIGlzIHJlbGF0aXZlIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlXG4gICAqIHVuZGVybHlpbmcgQXJyYXlCdWZmZXIsIG5vdCB0aGUgc3RhcnQgb2YgdGhlIHByb3ZpZGVkIFVpbnQ4QXJyYXkgaW5wdXQuXG4gICAqIFRoaXMgYEJpbmFyeVJlYWRlcmAncyBgI29mZnNldGAgZmllbGQgaXMgdXNlZCB0byB0cmFjayB0aGUgY3VycmVudCByZWFkIHBvc2l0aW9uXG4gICAqIHJlbGF0aXZlIHRvIHRoZSBzdGFydCBvZiB0aGUgcHJvdmlkZWQgVWludDhBcnJheSBpbnB1dC5cbiAgICovXG4gICN2aWV3O1xuICAvKipcbiAgICogUmVwcmVzZW50cyB0aGUgb2Zmc2V0IChpbiBieXRlcykgcmVsYXRpdmUgdG8gdGhlIHN0YXJ0IG9mIHRoZSBEYXRhVmlld1xuICAgKiBhbmQgcHJvdmlkZWQgVWludDhBcnJheSBpbnB1dC5cbiAgICpcbiAgICogTm90ZTogVGhpcyBpcyAqbm90KiB0aGUgYWJzb2x1dGUgYnl0ZSBvZmZzZXQgd2l0aGluIHRoZSB1bmRlcmx5aW5nIEFycmF5QnVmZmVyLlxuICAgKi9cbiAgI29mZnNldCA9IDA7XG4gIGNvbnN0cnVjdG9yKGlucHV0KSB7XG4gICAgdGhpcy4jdmlldyA9IG5ldyBEYXRhVmlldyhpbnB1dC5idWZmZXIsIGlucHV0LmJ5dGVPZmZzZXQsIGlucHV0LmJ5dGVMZW5ndGgpO1xuICAgIHRoaXMuI29mZnNldCA9IDA7XG4gIH1cbiAgZ2V0IG9mZnNldCgpIHtcbiAgICByZXR1cm4gdGhpcy4jb2Zmc2V0O1xuICB9XG4gIGdldCByZW1haW5pbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3ZpZXcuYnl0ZUxlbmd0aCAtIHRoaXMuI29mZnNldDtcbiAgfVxuICAvKiogRW5zdXJlIHdlIGhhdmUgYXQgbGVhc3QgYG5gIGJ5dGVzIGxlZnQgdG8gcmVhZCAqL1xuICAjZW5zdXJlKG4pIHtcbiAgICBpZiAodGhpcy4jb2Zmc2V0ICsgbiA+IHRoaXMuI3ZpZXcuYnl0ZUxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXG4gICAgICAgIGBUcmllZCB0byByZWFkICR7bn0gYnl0ZShzKSBhdCByZWxhdGl2ZSBvZmZzZXQgJHt0aGlzLiNvZmZzZXR9LCBidXQgb25seSAke3RoaXMucmVtYWluaW5nfSBieXRlKHMpIHJlbWFpbmBcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHJlYWRVSW50OEFycmF5KCkge1xuICAgIGNvbnN0IGxlbmd0aCA9IHRoaXMucmVhZFUzMigpO1xuICAgIHRoaXMuI2Vuc3VyZShsZW5ndGgpO1xuICAgIHJldHVybiB0aGlzLnJlYWRCeXRlcyhsZW5ndGgpO1xuICB9XG4gIHJlYWRCb29sKCkge1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jdmlldy5nZXRVaW50OCh0aGlzLiNvZmZzZXQpO1xuICAgIHRoaXMuI29mZnNldCArPSAxO1xuICAgIHJldHVybiB2YWx1ZSAhPT0gMDtcbiAgfVxuICByZWFkQnl0ZSgpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuI3ZpZXcuZ2V0VWludDgodGhpcy4jb2Zmc2V0KTtcbiAgICB0aGlzLiNvZmZzZXQgKz0gMTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmVhZEJ5dGVzKGxlbmd0aCkge1xuICAgIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoXG4gICAgICB0aGlzLiN2aWV3LmJ1ZmZlcixcbiAgICAgIHRoaXMuI3ZpZXcuYnl0ZU9mZnNldCArIHRoaXMuI29mZnNldCxcbiAgICAgIGxlbmd0aFxuICAgICk7XG4gICAgdGhpcy4jb2Zmc2V0ICs9IGxlbmd0aDtcbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cbiAgcmVhZEk4KCkge1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jdmlldy5nZXRJbnQ4KHRoaXMuI29mZnNldCk7XG4gICAgdGhpcy4jb2Zmc2V0ICs9IDE7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJlYWRVOCgpIHtcbiAgICByZXR1cm4gdGhpcy5yZWFkQnl0ZSgpO1xuICB9XG4gIHJlYWRJMTYoKSB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLiN2aWV3LmdldEludDE2KHRoaXMuI29mZnNldCwgdHJ1ZSk7XG4gICAgdGhpcy4jb2Zmc2V0ICs9IDI7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJlYWRVMTYoKSB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLiN2aWV3LmdldFVpbnQxNih0aGlzLiNvZmZzZXQsIHRydWUpO1xuICAgIHRoaXMuI29mZnNldCArPSAyO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZWFkSTMyKCkge1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jdmlldy5nZXRJbnQzMih0aGlzLiNvZmZzZXQsIHRydWUpO1xuICAgIHRoaXMuI29mZnNldCArPSA0O1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZWFkVTMyKCkge1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jdmlldy5nZXRVaW50MzIodGhpcy4jb2Zmc2V0LCB0cnVlKTtcbiAgICB0aGlzLiNvZmZzZXQgKz0gNDtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmVhZEk2NCgpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuI3ZpZXcuZ2V0QmlnSW50NjQodGhpcy4jb2Zmc2V0LCB0cnVlKTtcbiAgICB0aGlzLiNvZmZzZXQgKz0gODtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmVhZFU2NCgpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuI3ZpZXcuZ2V0QmlnVWludDY0KHRoaXMuI29mZnNldCwgdHJ1ZSk7XG4gICAgdGhpcy4jb2Zmc2V0ICs9IDg7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJlYWRVMTI4KCkge1xuICAgIGNvbnN0IGxvd2VyUGFydCA9IHRoaXMuI3ZpZXcuZ2V0QmlnVWludDY0KHRoaXMuI29mZnNldCwgdHJ1ZSk7XG4gICAgY29uc3QgdXBwZXJQYXJ0ID0gdGhpcy4jdmlldy5nZXRCaWdVaW50NjQodGhpcy4jb2Zmc2V0ICsgOCwgdHJ1ZSk7XG4gICAgdGhpcy4jb2Zmc2V0ICs9IDE2O1xuICAgIHJldHVybiAodXBwZXJQYXJ0IDw8IEJpZ0ludCg2NCkpICsgbG93ZXJQYXJ0O1xuICB9XG4gIHJlYWRJMTI4KCkge1xuICAgIGNvbnN0IGxvd2VyUGFydCA9IHRoaXMuI3ZpZXcuZ2V0QmlnVWludDY0KHRoaXMuI29mZnNldCwgdHJ1ZSk7XG4gICAgY29uc3QgdXBwZXJQYXJ0ID0gdGhpcy4jdmlldy5nZXRCaWdJbnQ2NCh0aGlzLiNvZmZzZXQgKyA4LCB0cnVlKTtcbiAgICB0aGlzLiNvZmZzZXQgKz0gMTY7XG4gICAgcmV0dXJuICh1cHBlclBhcnQgPDwgQmlnSW50KDY0KSkgKyBsb3dlclBhcnQ7XG4gIH1cbiAgcmVhZFUyNTYoKSB7XG4gICAgY29uc3QgcDAgPSB0aGlzLiN2aWV3LmdldEJpZ1VpbnQ2NCh0aGlzLiNvZmZzZXQsIHRydWUpO1xuICAgIGNvbnN0IHAxID0gdGhpcy4jdmlldy5nZXRCaWdVaW50NjQodGhpcy4jb2Zmc2V0ICsgOCwgdHJ1ZSk7XG4gICAgY29uc3QgcDIgPSB0aGlzLiN2aWV3LmdldEJpZ1VpbnQ2NCh0aGlzLiNvZmZzZXQgKyAxNiwgdHJ1ZSk7XG4gICAgY29uc3QgcDMgPSB0aGlzLiN2aWV3LmdldEJpZ1VpbnQ2NCh0aGlzLiNvZmZzZXQgKyAyNCwgdHJ1ZSk7XG4gICAgdGhpcy4jb2Zmc2V0ICs9IDMyO1xuICAgIHJldHVybiAocDMgPDwgQmlnSW50KDMgKiA2NCkpICsgKHAyIDw8IEJpZ0ludCgyICogNjQpKSArIChwMSA8PCBCaWdJbnQoMSAqIDY0KSkgKyBwMDtcbiAgfVxuICByZWFkSTI1NigpIHtcbiAgICBjb25zdCBwMCA9IHRoaXMuI3ZpZXcuZ2V0QmlnVWludDY0KHRoaXMuI29mZnNldCwgdHJ1ZSk7XG4gICAgY29uc3QgcDEgPSB0aGlzLiN2aWV3LmdldEJpZ1VpbnQ2NCh0aGlzLiNvZmZzZXQgKyA4LCB0cnVlKTtcbiAgICBjb25zdCBwMiA9IHRoaXMuI3ZpZXcuZ2V0QmlnVWludDY0KHRoaXMuI29mZnNldCArIDE2LCB0cnVlKTtcbiAgICBjb25zdCBwMyA9IHRoaXMuI3ZpZXcuZ2V0QmlnSW50NjQodGhpcy4jb2Zmc2V0ICsgMjQsIHRydWUpO1xuICAgIHRoaXMuI29mZnNldCArPSAzMjtcbiAgICByZXR1cm4gKHAzIDw8IEJpZ0ludCgzICogNjQpKSArIChwMiA8PCBCaWdJbnQoMiAqIDY0KSkgKyAocDEgPDwgQmlnSW50KDEgKiA2NCkpICsgcDA7XG4gIH1cbiAgcmVhZEYzMigpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuI3ZpZXcuZ2V0RmxvYXQzMih0aGlzLiNvZmZzZXQsIHRydWUpO1xuICAgIHRoaXMuI29mZnNldCArPSA0O1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZWFkRjY0KCkge1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jdmlldy5nZXRGbG9hdDY0KHRoaXMuI29mZnNldCwgdHJ1ZSk7XG4gICAgdGhpcy4jb2Zmc2V0ICs9IDg7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJlYWRTdHJpbmcoKSB7XG4gICAgY29uc3QgdWludDhBcnJheSA9IHRoaXMucmVhZFVJbnQ4QXJyYXkoKTtcbiAgICByZXR1cm4gbmV3IFRleHREZWNvZGVyKFwidXRmLThcIikuZGVjb2RlKHVpbnQ4QXJyYXkpO1xuICB9XG59O1xuXG4vLyBzcmMvbGliL2JpbmFyeV93cml0ZXIudHNcbnZhciBpbXBvcnRfYmFzZTY0X2pzID0gX190b0VTTShyZXF1aXJlX2Jhc2U2NF9qcygpKTtcbnZhciBCaW5hcnlXcml0ZXIgPSBjbGFzcyB7XG4gICNidWZmZXI7XG4gICN2aWV3O1xuICAjb2Zmc2V0ID0gMDtcbiAgY29uc3RydWN0b3Ioc2l6ZSkge1xuICAgIHRoaXMuI2J1ZmZlciA9IG5ldyBVaW50OEFycmF5KHNpemUpO1xuICAgIHRoaXMuI3ZpZXcgPSBuZXcgRGF0YVZpZXcodGhpcy4jYnVmZmVyLmJ1ZmZlcik7XG4gIH1cbiAgI2V4cGFuZEJ1ZmZlcihhZGRpdGlvbmFsQ2FwYWNpdHkpIHtcbiAgICBjb25zdCBtaW5DYXBhY2l0eSA9IHRoaXMuI29mZnNldCArIGFkZGl0aW9uYWxDYXBhY2l0eSArIDE7XG4gICAgaWYgKG1pbkNhcGFjaXR5IDw9IHRoaXMuI2J1ZmZlci5sZW5ndGgpIHJldHVybjtcbiAgICBsZXQgbmV3Q2FwYWNpdHkgPSB0aGlzLiNidWZmZXIubGVuZ3RoICogMjtcbiAgICBpZiAobmV3Q2FwYWNpdHkgPCBtaW5DYXBhY2l0eSkgbmV3Q2FwYWNpdHkgPSBtaW5DYXBhY2l0eTtcbiAgICBjb25zdCBuZXdCdWZmZXIgPSBuZXcgVWludDhBcnJheShuZXdDYXBhY2l0eSk7XG4gICAgbmV3QnVmZmVyLnNldCh0aGlzLiNidWZmZXIpO1xuICAgIHRoaXMuI2J1ZmZlciA9IG5ld0J1ZmZlcjtcbiAgICB0aGlzLiN2aWV3ID0gbmV3IERhdGFWaWV3KHRoaXMuI2J1ZmZlci5idWZmZXIpO1xuICB9XG4gIHRvQmFzZTY0KCkge1xuICAgIHJldHVybiAoMCwgaW1wb3J0X2Jhc2U2NF9qcy5mcm9tQnl0ZUFycmF5KSh0aGlzLiNidWZmZXIuc3ViYXJyYXkoMCwgdGhpcy4jb2Zmc2V0KSk7XG4gIH1cbiAgZ2V0QnVmZmVyKCkge1xuICAgIHJldHVybiB0aGlzLiNidWZmZXIuc2xpY2UoMCwgdGhpcy4jb2Zmc2V0KTtcbiAgfVxuICBnZXQgb2Zmc2V0KCkge1xuICAgIHJldHVybiB0aGlzLiNvZmZzZXQ7XG4gIH1cbiAgd3JpdGVVSW50OEFycmF5KHZhbHVlKSB7XG4gICAgY29uc3QgbGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuICAgIHRoaXMuI2V4cGFuZEJ1ZmZlcig0ICsgbGVuZ3RoKTtcbiAgICB0aGlzLndyaXRlVTMyKGxlbmd0aCk7XG4gICAgdGhpcy4jYnVmZmVyLnNldCh2YWx1ZSwgdGhpcy4jb2Zmc2V0KTtcbiAgICB0aGlzLiNvZmZzZXQgKz0gdmFsdWUubGVuZ3RoO1xuICB9XG4gIHdyaXRlQm9vbCh2YWx1ZSkge1xuICAgIHRoaXMuI2V4cGFuZEJ1ZmZlcigxKTtcbiAgICB0aGlzLiN2aWV3LnNldFVpbnQ4KHRoaXMuI29mZnNldCwgdmFsdWUgPyAxIDogMCk7XG4gICAgdGhpcy4jb2Zmc2V0ICs9IDE7XG4gIH1cbiAgd3JpdGVCeXRlKHZhbHVlKSB7XG4gICAgdGhpcy4jZXhwYW5kQnVmZmVyKDEpO1xuICAgIHRoaXMuI3ZpZXcuc2V0VWludDgodGhpcy4jb2Zmc2V0LCB2YWx1ZSk7XG4gICAgdGhpcy4jb2Zmc2V0ICs9IDE7XG4gIH1cbiAgd3JpdGVJOCh2YWx1ZSkge1xuICAgIHRoaXMuI2V4cGFuZEJ1ZmZlcigxKTtcbiAgICB0aGlzLiN2aWV3LnNldEludDgodGhpcy4jb2Zmc2V0LCB2YWx1ZSk7XG4gICAgdGhpcy4jb2Zmc2V0ICs9IDE7XG4gIH1cbiAgd3JpdGVVOCh2YWx1ZSkge1xuICAgIHRoaXMuI2V4cGFuZEJ1ZmZlcigxKTtcbiAgICB0aGlzLiN2aWV3LnNldFVpbnQ4KHRoaXMuI29mZnNldCwgdmFsdWUpO1xuICAgIHRoaXMuI29mZnNldCArPSAxO1xuICB9XG4gIHdyaXRlSTE2KHZhbHVlKSB7XG4gICAgdGhpcy4jZXhwYW5kQnVmZmVyKDIpO1xuICAgIHRoaXMuI3ZpZXcuc2V0SW50MTYodGhpcy4jb2Zmc2V0LCB2YWx1ZSwgdHJ1ZSk7XG4gICAgdGhpcy4jb2Zmc2V0ICs9IDI7XG4gIH1cbiAgd3JpdGVVMTYodmFsdWUpIHtcbiAgICB0aGlzLiNleHBhbmRCdWZmZXIoMik7XG4gICAgdGhpcy4jdmlldy5zZXRVaW50MTYodGhpcy4jb2Zmc2V0LCB2YWx1ZSwgdHJ1ZSk7XG4gICAgdGhpcy4jb2Zmc2V0ICs9IDI7XG4gIH1cbiAgd3JpdGVJMzIodmFsdWUpIHtcbiAgICB0aGlzLiNleHBhbmRCdWZmZXIoNCk7XG4gICAgdGhpcy4jdmlldy5zZXRJbnQzMih0aGlzLiNvZmZzZXQsIHZhbHVlLCB0cnVlKTtcbiAgICB0aGlzLiNvZmZzZXQgKz0gNDtcbiAgfVxuICB3cml0ZVUzMih2YWx1ZSkge1xuICAgIHRoaXMuI2V4cGFuZEJ1ZmZlcig0KTtcbiAgICB0aGlzLiN2aWV3LnNldFVpbnQzMih0aGlzLiNvZmZzZXQsIHZhbHVlLCB0cnVlKTtcbiAgICB0aGlzLiNvZmZzZXQgKz0gNDtcbiAgfVxuICB3cml0ZUk2NCh2YWx1ZSkge1xuICAgIHRoaXMuI2V4cGFuZEJ1ZmZlcig4KTtcbiAgICB0aGlzLiN2aWV3LnNldEJpZ0ludDY0KHRoaXMuI29mZnNldCwgdmFsdWUsIHRydWUpO1xuICAgIHRoaXMuI29mZnNldCArPSA4O1xuICB9XG4gIHdyaXRlVTY0KHZhbHVlKSB7XG4gICAgdGhpcy4jZXhwYW5kQnVmZmVyKDgpO1xuICAgIHRoaXMuI3ZpZXcuc2V0QmlnVWludDY0KHRoaXMuI29mZnNldCwgdmFsdWUsIHRydWUpO1xuICAgIHRoaXMuI29mZnNldCArPSA4O1xuICB9XG4gIHdyaXRlVTEyOCh2YWx1ZSkge1xuICAgIHRoaXMuI2V4cGFuZEJ1ZmZlcigxNik7XG4gICAgY29uc3QgbG93ZXJQYXJ0ID0gdmFsdWUgJiBCaWdJbnQoXCIweEZGRkZGRkZGRkZGRkZGRkZcIik7XG4gICAgY29uc3QgdXBwZXJQYXJ0ID0gdmFsdWUgPj4gQmlnSW50KDY0KTtcbiAgICB0aGlzLiN2aWV3LnNldEJpZ1VpbnQ2NCh0aGlzLiNvZmZzZXQsIGxvd2VyUGFydCwgdHJ1ZSk7XG4gICAgdGhpcy4jdmlldy5zZXRCaWdVaW50NjQodGhpcy4jb2Zmc2V0ICsgOCwgdXBwZXJQYXJ0LCB0cnVlKTtcbiAgICB0aGlzLiNvZmZzZXQgKz0gMTY7XG4gIH1cbiAgd3JpdGVJMTI4KHZhbHVlKSB7XG4gICAgdGhpcy4jZXhwYW5kQnVmZmVyKDE2KTtcbiAgICBjb25zdCBsb3dlclBhcnQgPSB2YWx1ZSAmIEJpZ0ludChcIjB4RkZGRkZGRkZGRkZGRkZGRlwiKTtcbiAgICBjb25zdCB1cHBlclBhcnQgPSB2YWx1ZSA+PiBCaWdJbnQoNjQpO1xuICAgIHRoaXMuI3ZpZXcuc2V0QmlnSW50NjQodGhpcy4jb2Zmc2V0LCBsb3dlclBhcnQsIHRydWUpO1xuICAgIHRoaXMuI3ZpZXcuc2V0QmlnSW50NjQodGhpcy4jb2Zmc2V0ICsgOCwgdXBwZXJQYXJ0LCB0cnVlKTtcbiAgICB0aGlzLiNvZmZzZXQgKz0gMTY7XG4gIH1cbiAgd3JpdGVVMjU2KHZhbHVlKSB7XG4gICAgdGhpcy4jZXhwYW5kQnVmZmVyKDMyKTtcbiAgICBjb25zdCBsb3dfNjRfbWFzayA9IEJpZ0ludChcIjB4RkZGRkZGRkZGRkZGRkZGRlwiKTtcbiAgICBjb25zdCBwMCA9IHZhbHVlICYgbG93XzY0X21hc2s7XG4gICAgY29uc3QgcDEgPSB2YWx1ZSA+PiBCaWdJbnQoNjQgKiAxKSAmIGxvd182NF9tYXNrO1xuICAgIGNvbnN0IHAyID0gdmFsdWUgPj4gQmlnSW50KDY0ICogMikgJiBsb3dfNjRfbWFzaztcbiAgICBjb25zdCBwMyA9IHZhbHVlID4+IEJpZ0ludCg2NCAqIDMpO1xuICAgIHRoaXMuI3ZpZXcuc2V0QmlnVWludDY0KHRoaXMuI29mZnNldCArIDggKiAwLCBwMCwgdHJ1ZSk7XG4gICAgdGhpcy4jdmlldy5zZXRCaWdVaW50NjQodGhpcy4jb2Zmc2V0ICsgOCAqIDEsIHAxLCB0cnVlKTtcbiAgICB0aGlzLiN2aWV3LnNldEJpZ1VpbnQ2NCh0aGlzLiNvZmZzZXQgKyA4ICogMiwgcDIsIHRydWUpO1xuICAgIHRoaXMuI3ZpZXcuc2V0QmlnVWludDY0KHRoaXMuI29mZnNldCArIDggKiAzLCBwMywgdHJ1ZSk7XG4gICAgdGhpcy4jb2Zmc2V0ICs9IDMyO1xuICB9XG4gIHdyaXRlSTI1Nih2YWx1ZSkge1xuICAgIHRoaXMuI2V4cGFuZEJ1ZmZlcigzMik7XG4gICAgY29uc3QgbG93XzY0X21hc2sgPSBCaWdJbnQoXCIweEZGRkZGRkZGRkZGRkZGRkZcIik7XG4gICAgY29uc3QgcDAgPSB2YWx1ZSAmIGxvd182NF9tYXNrO1xuICAgIGNvbnN0IHAxID0gdmFsdWUgPj4gQmlnSW50KDY0ICogMSkgJiBsb3dfNjRfbWFzaztcbiAgICBjb25zdCBwMiA9IHZhbHVlID4+IEJpZ0ludCg2NCAqIDIpICYgbG93XzY0X21hc2s7XG4gICAgY29uc3QgcDMgPSB2YWx1ZSA+PiBCaWdJbnQoNjQgKiAzKTtcbiAgICB0aGlzLiN2aWV3LnNldEJpZ1VpbnQ2NCh0aGlzLiNvZmZzZXQgKyA4ICogMCwgcDAsIHRydWUpO1xuICAgIHRoaXMuI3ZpZXcuc2V0QmlnVWludDY0KHRoaXMuI29mZnNldCArIDggKiAxLCBwMSwgdHJ1ZSk7XG4gICAgdGhpcy4jdmlldy5zZXRCaWdVaW50NjQodGhpcy4jb2Zmc2V0ICsgOCAqIDIsIHAyLCB0cnVlKTtcbiAgICB0aGlzLiN2aWV3LnNldEJpZ0ludDY0KHRoaXMuI29mZnNldCArIDggKiAzLCBwMywgdHJ1ZSk7XG4gICAgdGhpcy4jb2Zmc2V0ICs9IDMyO1xuICB9XG4gIHdyaXRlRjMyKHZhbHVlKSB7XG4gICAgdGhpcy4jZXhwYW5kQnVmZmVyKDQpO1xuICAgIHRoaXMuI3ZpZXcuc2V0RmxvYXQzMih0aGlzLiNvZmZzZXQsIHZhbHVlLCB0cnVlKTtcbiAgICB0aGlzLiNvZmZzZXQgKz0gNDtcbiAgfVxuICB3cml0ZUY2NCh2YWx1ZSkge1xuICAgIHRoaXMuI2V4cGFuZEJ1ZmZlcig4KTtcbiAgICB0aGlzLiN2aWV3LnNldEZsb2F0NjQodGhpcy4jb2Zmc2V0LCB2YWx1ZSwgdHJ1ZSk7XG4gICAgdGhpcy4jb2Zmc2V0ICs9IDg7XG4gIH1cbiAgd3JpdGVTdHJpbmcodmFsdWUpIHtcbiAgICBjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgY29uc3QgZW5jb2RlZFN0cmluZyA9IGVuY29kZXIuZW5jb2RlKHZhbHVlKTtcbiAgICB0aGlzLndyaXRlVTMyKGVuY29kZWRTdHJpbmcubGVuZ3RoKTtcbiAgICB0aGlzLiNleHBhbmRCdWZmZXIoZW5jb2RlZFN0cmluZy5sZW5ndGgpO1xuICAgIHRoaXMuI2J1ZmZlci5zZXQoZW5jb2RlZFN0cmluZywgdGhpcy4jb2Zmc2V0KTtcbiAgICB0aGlzLiNvZmZzZXQgKz0gZW5jb2RlZFN0cmluZy5sZW5ndGg7XG4gIH1cbn07XG5cbi8vIHNyYy9saWIvdXRpbC50c1xuZnVuY3Rpb24gdG9QYXNjYWxDYXNlKHMpIHtcbiAgY29uc3Qgc3RyID0gcy5yZXBsYWNlKC8oWy1fXVthLXpdKS9naSwgKCQxKSA9PiB7XG4gICAgcmV0dXJuICQxLnRvVXBwZXJDYXNlKCkucmVwbGFjZShcIi1cIiwgXCJcIikucmVwbGFjZShcIl9cIiwgXCJcIik7XG4gIH0pO1xuICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xufVxuZnVuY3Rpb24gdWludDhBcnJheVRvSGV4U3RyaW5nKGFycmF5KSB7XG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUubWFwLmNhbGwoYXJyYXkucmV2ZXJzZSgpLCAoeCkgPT4gKFwiMDBcIiArIHgudG9TdHJpbmcoMTYpKS5zbGljZSgtMikpLmpvaW4oXCJcIik7XG59XG5mdW5jdGlvbiB1aW50OEFycmF5VG9VMTI4KGFycmF5KSB7XG4gIGlmIChhcnJheS5sZW5ndGggIT0gMTYpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVpbnQ4QXJyYXkgaXMgbm90IDE2IGJ5dGVzIGxvbmc6ICR7YXJyYXl9YCk7XG4gIH1cbiAgcmV0dXJuIG5ldyBCaW5hcnlSZWFkZXIoYXJyYXkpLnJlYWRVMTI4KCk7XG59XG5mdW5jdGlvbiB1aW50OEFycmF5VG9VMjU2KGFycmF5KSB7XG4gIGlmIChhcnJheS5sZW5ndGggIT0gMzIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVpbnQ4QXJyYXkgaXMgbm90IDMyIGJ5dGVzIGxvbmc6IFske2FycmF5fV1gKTtcbiAgfVxuICByZXR1cm4gbmV3IEJpbmFyeVJlYWRlcihhcnJheSkucmVhZFUyNTYoKTtcbn1cbmZ1bmN0aW9uIGhleFN0cmluZ1RvVWludDhBcnJheShzdHIpIHtcbiAgaWYgKHN0ci5zdGFydHNXaXRoKFwiMHhcIikpIHtcbiAgICBzdHIgPSBzdHIuc2xpY2UoMik7XG4gIH1cbiAgY29uc3QgbWF0Y2hlcyA9IHN0ci5tYXRjaCgvLnsxLDJ9L2cpIHx8IFtdO1xuICBjb25zdCBkYXRhID0gVWludDhBcnJheS5mcm9tKFxuICAgIG1hdGNoZXMubWFwKChieXRlKSA9PiBwYXJzZUludChieXRlLCAxNikpXG4gICk7XG4gIHJldHVybiBkYXRhLnJldmVyc2UoKTtcbn1cbmZ1bmN0aW9uIGhleFN0cmluZ1RvVTEyOChzdHIpIHtcbiAgcmV0dXJuIHVpbnQ4QXJyYXlUb1UxMjgoaGV4U3RyaW5nVG9VaW50OEFycmF5KHN0cikpO1xufVxuZnVuY3Rpb24gaGV4U3RyaW5nVG9VMjU2KHN0cikge1xuICByZXR1cm4gdWludDhBcnJheVRvVTI1NihoZXhTdHJpbmdUb1VpbnQ4QXJyYXkoc3RyKSk7XG59XG5mdW5jdGlvbiB1MTI4VG9VaW50OEFycmF5KGRhdGEpIHtcbiAgY29uc3Qgd3JpdGVyID0gbmV3IEJpbmFyeVdyaXRlcigxNik7XG4gIHdyaXRlci53cml0ZVUxMjgoZGF0YSk7XG4gIHJldHVybiB3cml0ZXIuZ2V0QnVmZmVyKCk7XG59XG5mdW5jdGlvbiB1MTI4VG9IZXhTdHJpbmcoZGF0YSkge1xuICByZXR1cm4gdWludDhBcnJheVRvSGV4U3RyaW5nKHUxMjhUb1VpbnQ4QXJyYXkoZGF0YSkpO1xufVxuZnVuY3Rpb24gdTI1NlRvVWludDhBcnJheShkYXRhKSB7XG4gIGNvbnN0IHdyaXRlciA9IG5ldyBCaW5hcnlXcml0ZXIoMzIpO1xuICB3cml0ZXIud3JpdGVVMjU2KGRhdGEpO1xuICByZXR1cm4gd3JpdGVyLmdldEJ1ZmZlcigpO1xufVxuZnVuY3Rpb24gdTI1NlRvSGV4U3RyaW5nKGRhdGEpIHtcbiAgcmV0dXJuIHVpbnQ4QXJyYXlUb0hleFN0cmluZyh1MjU2VG9VaW50OEFycmF5KGRhdGEpKTtcbn1cbmZ1bmN0aW9uIHRvQ2FtZWxDYXNlKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL1stX10rL2csIFwiX1wiKS5yZXBsYWNlKC9fKFthLXpBLVowLTldKS9nLCAoXywgYykgPT4gYy50b1VwcGVyQ2FzZSgpKTtcbn1cbmZ1bmN0aW9uIGJzYXRuQmFzZVNpemUodHlwZXNwYWNlLCB0eSkge1xuICBjb25zdCBhc3N1bWVkQXJyYXlMZW5ndGggPSA0O1xuICB3aGlsZSAodHkudGFnID09PSBcIlJlZlwiKSB0eSA9IHR5cGVzcGFjZS50eXBlc1t0eS52YWx1ZV07XG4gIGlmICh0eS50YWcgPT09IFwiUHJvZHVjdFwiKSB7XG4gICAgbGV0IHN1bSA9IDA7XG4gICAgZm9yIChjb25zdCB7IGFsZ2VicmFpY1R5cGU6IGVsZW0gfSBvZiB0eS52YWx1ZS5lbGVtZW50cykge1xuICAgICAgc3VtICs9IGJzYXRuQmFzZVNpemUodHlwZXNwYWNlLCBlbGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1bTtcbiAgfSBlbHNlIGlmICh0eS50YWcgPT09IFwiU3VtXCIpIHtcbiAgICBsZXQgbWluID0gSW5maW5pdHk7XG4gICAgZm9yIChjb25zdCB7IGFsZ2VicmFpY1R5cGU6IHZhcmkgfSBvZiB0eS52YWx1ZS52YXJpYW50cykge1xuICAgICAgY29uc3QgdlNpemUgPSBic2F0bkJhc2VTaXplKHR5cGVzcGFjZSwgdmFyaSk7XG4gICAgICBpZiAodlNpemUgPCBtaW4pIG1pbiA9IHZTaXplO1xuICAgIH1cbiAgICBpZiAobWluID09PSBJbmZpbml0eSkgbWluID0gMDtcbiAgICByZXR1cm4gNCArIG1pbjtcbiAgfSBlbHNlIGlmICh0eS50YWcgPT0gXCJBcnJheVwiKSB7XG4gICAgcmV0dXJuIDQgKyBhc3N1bWVkQXJyYXlMZW5ndGggKiBic2F0bkJhc2VTaXplKHR5cGVzcGFjZSwgdHkudmFsdWUpO1xuICB9XG4gIHJldHVybiB7XG4gICAgU3RyaW5nOiA0ICsgYXNzdW1lZEFycmF5TGVuZ3RoLFxuICAgIFN1bTogMSxcbiAgICBCb29sOiAxLFxuICAgIEk4OiAxLFxuICAgIFU4OiAxLFxuICAgIEkxNjogMixcbiAgICBVMTY6IDIsXG4gICAgSTMyOiA0LFxuICAgIFUzMjogNCxcbiAgICBGMzI6IDQsXG4gICAgSTY0OiA4LFxuICAgIFU2NDogOCxcbiAgICBGNjQ6IDgsXG4gICAgSTEyODogMTYsXG4gICAgVTEyODogMTYsXG4gICAgSTI1NjogMzIsXG4gICAgVTI1NjogMzJcbiAgfVt0eS50YWddO1xufVxuXG4vLyBzcmMvbGliL2Nvbm5lY3Rpb25faWQudHNcbnZhciBDb25uZWN0aW9uSWQgPSBjbGFzcyBfQ29ubmVjdGlvbklkIHtcbiAgX19jb25uZWN0aW9uX2lkX187XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGBDb25uZWN0aW9uSWRgLlxuICAgKi9cbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHRoaXMuX19jb25uZWN0aW9uX2lkX18gPSBkYXRhO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGFsZ2VicmFpYyB0eXBlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB7QGxpbmsgQ29ubmVjdGlvbklkfSB0eXBlLlxuICAgKiBAcmV0dXJucyBUaGUgYWxnZWJyYWljIHR5cGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIHR5cGUuXG4gICAqL1xuICBzdGF0aWMgZ2V0QWxnZWJyYWljVHlwZSgpIHtcbiAgICByZXR1cm4gQWxnZWJyYWljVHlwZS5Qcm9kdWN0KHtcbiAgICAgIGVsZW1lbnRzOiBbXG4gICAgICAgIHsgbmFtZTogXCJfX2Nvbm5lY3Rpb25faWRfX1wiLCBhbGdlYnJhaWNUeXBlOiBBbGdlYnJhaWNUeXBlLlUxMjggfVxuICAgICAgXVxuICAgIH0pO1xuICB9XG4gIGlzWmVybygpIHtcbiAgICByZXR1cm4gdGhpcy5fX2Nvbm5lY3Rpb25faWRfXyA9PT0gQmlnSW50KDApO1xuICB9XG4gIHN0YXRpYyBudWxsSWZaZXJvKGFkZHIpIHtcbiAgICBpZiAoYWRkci5pc1plcm8oKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhZGRyO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgcmFuZG9tKCkge1xuICAgIGZ1bmN0aW9uIHJhbmRvbVU4KCkge1xuICAgICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDI1NSk7XG4gICAgfVxuICAgIGxldCByZXN1bHQgPSBCaWdJbnQoMCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgICByZXN1bHQgPSByZXN1bHQgPDwgQmlnSW50KDgpIHwgQmlnSW50KHJhbmRvbVU4KCkpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IF9Db25uZWN0aW9uSWQocmVzdWx0KTtcbiAgfVxuICAvKipcbiAgICogQ29tcGFyZSB0d28gY29ubmVjdGlvbiBJRHMgZm9yIGVxdWFsaXR5LlxuICAgKi9cbiAgaXNFcXVhbChvdGhlcikge1xuICAgIHJldHVybiB0aGlzLl9fY29ubmVjdGlvbl9pZF9fID09IG90aGVyLl9fY29ubmVjdGlvbl9pZF9fO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiB0d28gY29ubmVjdGlvbiBJRHMgYXJlIGVxdWFsLlxuICAgKi9cbiAgZXF1YWxzKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNFcXVhbChvdGhlcik7XG4gIH1cbiAgLyoqXG4gICAqIFByaW50IHRoZSBjb25uZWN0aW9uIElEIGFzIGEgaGV4YWRlY2ltYWwgc3RyaW5nLlxuICAgKi9cbiAgdG9IZXhTdHJpbmcoKSB7XG4gICAgcmV0dXJuIHUxMjhUb0hleFN0cmluZyh0aGlzLl9fY29ubmVjdGlvbl9pZF9fKTtcbiAgfVxuICAvKipcbiAgICogQ29udmVydCB0aGUgY29ubmVjdGlvbiBJRCB0byBhIFVpbnQ4QXJyYXkuXG4gICAqL1xuICB0b1VpbnQ4QXJyYXkoKSB7XG4gICAgcmV0dXJuIHUxMjhUb1VpbnQ4QXJyYXkodGhpcy5fX2Nvbm5lY3Rpb25faWRfXyk7XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlIGEgY29ubmVjdGlvbiBJRCBmcm9tIGEgaGV4YWRlY2ltYWwgc3RyaW5nLlxuICAgKi9cbiAgc3RhdGljIGZyb21TdHJpbmcoc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBfQ29ubmVjdGlvbklkKGhleFN0cmluZ1RvVTEyOChzdHIpKTtcbiAgfVxuICBzdGF0aWMgZnJvbVN0cmluZ09yTnVsbChzdHIpIHtcbiAgICBjb25zdCBhZGRyID0gX0Nvbm5lY3Rpb25JZC5mcm9tU3RyaW5nKHN0cik7XG4gICAgaWYgKGFkZHIuaXNaZXJvKCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYWRkcjtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9saWIvaWRlbnRpdHkudHNcbnZhciBJZGVudGl0eSA9IGNsYXNzIF9JZGVudGl0eSB7XG4gIF9faWRlbnRpdHlfXztcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgYElkZW50aXR5YC5cbiAgICpcbiAgICogYGRhdGFgIGNhbiBiZSBhIGhleGFkZWNpbWFsIHN0cmluZyBvciBhIGBiaWdpbnRgLlxuICAgKi9cbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHRoaXMuX19pZGVudGl0eV9fID0gdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgPyBoZXhTdHJpbmdUb1UyNTYoZGF0YSkgOiBkYXRhO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGFsZ2VicmFpYyB0eXBlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB7QGxpbmsgSWRlbnRpdHl9IHR5cGUuXG4gICAqIEByZXR1cm5zIFRoZSBhbGdlYnJhaWMgdHlwZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgdHlwZS5cbiAgICovXG4gIHN0YXRpYyBnZXRBbGdlYnJhaWNUeXBlKCkge1xuICAgIHJldHVybiBBbGdlYnJhaWNUeXBlLlByb2R1Y3Qoe1xuICAgICAgZWxlbWVudHM6IFt7IG5hbWU6IFwiX19pZGVudGl0eV9fXCIsIGFsZ2VicmFpY1R5cGU6IEFsZ2VicmFpY1R5cGUuVTI1NiB9XVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiB0d28gaWRlbnRpdGllcyBhcmUgZXF1YWwuXG4gICAqL1xuICBpc0VxdWFsKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMudG9IZXhTdHJpbmcoKSA9PT0gb3RoZXIudG9IZXhTdHJpbmcoKTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgdHdvIGlkZW50aXRpZXMgYXJlIGVxdWFsLlxuICAgKi9cbiAgZXF1YWxzKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNFcXVhbChvdGhlcik7XG4gIH1cbiAgLyoqXG4gICAqIFByaW50IHRoZSBpZGVudGl0eSBhcyBhIGhleGFkZWNpbWFsIHN0cmluZy5cbiAgICovXG4gIHRvSGV4U3RyaW5nKCkge1xuICAgIHJldHVybiB1MjU2VG9IZXhTdHJpbmcodGhpcy5fX2lkZW50aXR5X18pO1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0IHRoZSBhZGRyZXNzIHRvIGEgVWludDhBcnJheS5cbiAgICovXG4gIHRvVWludDhBcnJheSgpIHtcbiAgICByZXR1cm4gdTI1NlRvVWludDhBcnJheSh0aGlzLl9faWRlbnRpdHlfXyk7XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlIGFuIElkZW50aXR5IGZyb20gYSBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gICAqL1xuICBzdGF0aWMgZnJvbVN0cmluZyhzdHIpIHtcbiAgICByZXR1cm4gbmV3IF9JZGVudGl0eShzdHIpO1xuICB9XG4gIC8qKlxuICAgKiBaZXJvIGlkZW50aXR5ICgweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDApXG4gICAqL1xuICBzdGF0aWMgemVybygpIHtcbiAgICByZXR1cm4gbmV3IF9JZGVudGl0eSgwbik7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9IZXhTdHJpbmcoKTtcbiAgfVxufTtcblxuLy8gc3JjL2xpYi9hbGdlYnJhaWNfdHlwZS50c1xudmFyIEFsZ2VicmFpY1R5cGUgPSB7XG4gIFJlZjogKHZhbHVlKSA9PiAoeyB0YWc6IFwiUmVmXCIsIHZhbHVlIH0pLFxuICBTdW06ICh2YWx1ZSkgPT4gKHtcbiAgICB0YWc6IFwiU3VtXCIsXG4gICAgdmFsdWVcbiAgfSksXG4gIFByb2R1Y3Q6ICh2YWx1ZSkgPT4gKHtcbiAgICB0YWc6IFwiUHJvZHVjdFwiLFxuICAgIHZhbHVlXG4gIH0pLFxuICBBcnJheTogKHZhbHVlKSA9PiAoe1xuICAgIHRhZzogXCJBcnJheVwiLFxuICAgIHZhbHVlXG4gIH0pLFxuICBTdHJpbmc6IHsgdGFnOiBcIlN0cmluZ1wiIH0sXG4gIEJvb2w6IHsgdGFnOiBcIkJvb2xcIiB9LFxuICBJODogeyB0YWc6IFwiSThcIiB9LFxuICBVODogeyB0YWc6IFwiVThcIiB9LFxuICBJMTY6IHsgdGFnOiBcIkkxNlwiIH0sXG4gIFUxNjogeyB0YWc6IFwiVTE2XCIgfSxcbiAgSTMyOiB7IHRhZzogXCJJMzJcIiB9LFxuICBVMzI6IHsgdGFnOiBcIlUzMlwiIH0sXG4gIEk2NDogeyB0YWc6IFwiSTY0XCIgfSxcbiAgVTY0OiB7IHRhZzogXCJVNjRcIiB9LFxuICBJMTI4OiB7IHRhZzogXCJJMTI4XCIgfSxcbiAgVTEyODogeyB0YWc6IFwiVTEyOFwiIH0sXG4gIEkyNTY6IHsgdGFnOiBcIkkyNTZcIiB9LFxuICBVMjU2OiB7IHRhZzogXCJVMjU2XCIgfSxcbiAgRjMyOiB7IHRhZzogXCJGMzJcIiB9LFxuICBGNjQ6IHsgdGFnOiBcIkY2NFwiIH0sXG4gIHNlcmlhbGl6ZVZhbHVlKHdyaXRlciwgdHksIHZhbHVlLCB0eXBlc3BhY2UpIHtcbiAgICBpZiAodHkudGFnID09PSBcIlJlZlwiKSB7XG4gICAgICBpZiAoIXR5cGVzcGFjZSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IHNlcmlhbGl6ZSByZWZzIHdpdGhvdXQgYSB0eXBlc3BhY2VcIik7XG4gICAgICB3aGlsZSAodHkudGFnID09PSBcIlJlZlwiKSB0eSA9IHR5cGVzcGFjZS50eXBlc1t0eS52YWx1ZV07XG4gICAgfVxuICAgIHN3aXRjaCAodHkudGFnKSB7XG4gICAgICBjYXNlIFwiUHJvZHVjdFwiOlxuICAgICAgICBQcm9kdWN0VHlwZS5zZXJpYWxpemVWYWx1ZSh3cml0ZXIsIHR5LnZhbHVlLCB2YWx1ZSwgdHlwZXNwYWNlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiU3VtXCI6XG4gICAgICAgIFN1bVR5cGUuc2VyaWFsaXplVmFsdWUod3JpdGVyLCB0eS52YWx1ZSwgdmFsdWUsIHR5cGVzcGFjZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIkFycmF5XCI6XG4gICAgICAgIGlmICh0eS52YWx1ZS50YWcgPT09IFwiVThcIikge1xuICAgICAgICAgIHdyaXRlci53cml0ZVVJbnQ4QXJyYXkodmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGVsZW1UeXBlID0gdHkudmFsdWU7XG4gICAgICAgICAgd3JpdGVyLndyaXRlVTMyKHZhbHVlLmxlbmd0aCk7XG4gICAgICAgICAgZm9yIChjb25zdCBlbGVtIG9mIHZhbHVlKSB7XG4gICAgICAgICAgICBBbGdlYnJhaWNUeXBlLnNlcmlhbGl6ZVZhbHVlKHdyaXRlciwgZWxlbVR5cGUsIGVsZW0sIHR5cGVzcGFjZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIkJvb2xcIjpcbiAgICAgICAgd3JpdGVyLndyaXRlQm9vbCh2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIkk4XCI6XG4gICAgICAgIHdyaXRlci53cml0ZUk4KHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiVThcIjpcbiAgICAgICAgd3JpdGVyLndyaXRlVTgodmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJJMTZcIjpcbiAgICAgICAgd3JpdGVyLndyaXRlSTE2KHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiVTE2XCI6XG4gICAgICAgIHdyaXRlci53cml0ZVUxNih2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIkkzMlwiOlxuICAgICAgICB3cml0ZXIud3JpdGVJMzIodmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJVMzJcIjpcbiAgICAgICAgd3JpdGVyLndyaXRlVTMyKHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiSTY0XCI6XG4gICAgICAgIHdyaXRlci53cml0ZUk2NCh2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIlU2NFwiOlxuICAgICAgICB3cml0ZXIud3JpdGVVNjQodmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJJMTI4XCI6XG4gICAgICAgIHdyaXRlci53cml0ZUkxMjgodmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJVMTI4XCI6XG4gICAgICAgIHdyaXRlci53cml0ZVUxMjgodmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJJMjU2XCI6XG4gICAgICAgIHdyaXRlci53cml0ZUkyNTYodmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJVMjU2XCI6XG4gICAgICAgIHdyaXRlci53cml0ZVUyNTYodmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJGMzJcIjpcbiAgICAgICAgd3JpdGVyLndyaXRlRjMyKHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiRjY0XCI6XG4gICAgICAgIHdyaXRlci53cml0ZUY2NCh2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIlN0cmluZ1wiOlxuICAgICAgICB3cml0ZXIud3JpdGVTdHJpbmcodmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH0sXG4gIGRlc2VyaWFsaXplVmFsdWU6IGZ1bmN0aW9uKHJlYWRlciwgdHksIHR5cGVzcGFjZSkge1xuICAgIGlmICh0eS50YWcgPT09IFwiUmVmXCIpIHtcbiAgICAgIGlmICghdHlwZXNwYWNlKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZGVzZXJpYWxpemUgcmVmcyB3aXRob3V0IGEgdHlwZXNwYWNlXCIpO1xuICAgICAgd2hpbGUgKHR5LnRhZyA9PT0gXCJSZWZcIikgdHkgPSB0eXBlc3BhY2UudHlwZXNbdHkudmFsdWVdO1xuICAgIH1cbiAgICBzd2l0Y2ggKHR5LnRhZykge1xuICAgICAgY2FzZSBcIlByb2R1Y3RcIjpcbiAgICAgICAgcmV0dXJuIFByb2R1Y3RUeXBlLmRlc2VyaWFsaXplVmFsdWUocmVhZGVyLCB0eS52YWx1ZSwgdHlwZXNwYWNlKTtcbiAgICAgIGNhc2UgXCJTdW1cIjpcbiAgICAgICAgcmV0dXJuIFN1bVR5cGUuZGVzZXJpYWxpemVWYWx1ZShyZWFkZXIsIHR5LnZhbHVlLCB0eXBlc3BhY2UpO1xuICAgICAgY2FzZSBcIkFycmF5XCI6XG4gICAgICAgIGlmICh0eS52YWx1ZS50YWcgPT09IFwiVThcIikge1xuICAgICAgICAgIHJldHVybiByZWFkZXIucmVhZFVJbnQ4QXJyYXkoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBlbGVtVHlwZSA9IHR5LnZhbHVlO1xuICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IHJlYWRlci5yZWFkVTMyKCk7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goXG4gICAgICAgICAgICAgIEFsZ2VicmFpY1R5cGUuZGVzZXJpYWxpemVWYWx1ZShyZWFkZXIsIGVsZW1UeXBlLCB0eXBlc3BhY2UpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICBjYXNlIFwiQm9vbFwiOlxuICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWRCb29sKCk7XG4gICAgICBjYXNlIFwiSThcIjpcbiAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkSTgoKTtcbiAgICAgIGNhc2UgXCJVOFwiOlxuICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWRVOCgpO1xuICAgICAgY2FzZSBcIkkxNlwiOlxuICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWRJMTYoKTtcbiAgICAgIGNhc2UgXCJVMTZcIjpcbiAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkVTE2KCk7XG4gICAgICBjYXNlIFwiSTMyXCI6XG4gICAgICAgIHJldHVybiByZWFkZXIucmVhZEkzMigpO1xuICAgICAgY2FzZSBcIlUzMlwiOlxuICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWRVMzIoKTtcbiAgICAgIGNhc2UgXCJJNjRcIjpcbiAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkSTY0KCk7XG4gICAgICBjYXNlIFwiVTY0XCI6XG4gICAgICAgIHJldHVybiByZWFkZXIucmVhZFU2NCgpO1xuICAgICAgY2FzZSBcIkkxMjhcIjpcbiAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkSTEyOCgpO1xuICAgICAgY2FzZSBcIlUxMjhcIjpcbiAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkVTEyOCgpO1xuICAgICAgY2FzZSBcIkkyNTZcIjpcbiAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkSTI1NigpO1xuICAgICAgY2FzZSBcIlUyNTZcIjpcbiAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkVTI1NigpO1xuICAgICAgY2FzZSBcIkYzMlwiOlxuICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWRGMzIoKTtcbiAgICAgIGNhc2UgXCJGNjRcIjpcbiAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkRjY0KCk7XG4gICAgICBjYXNlIFwiU3RyaW5nXCI6XG4gICAgICAgIHJldHVybiByZWFkZXIucmVhZFN0cmluZygpO1xuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIENvbnZlcnQgYSB2YWx1ZSBvZiB0aGUgYWxnZWJyYWljIHR5cGUgaW50byBzb21ldGhpbmcgdGhhdCBjYW4gYmUgdXNlZCBhcyBhIGtleSBpbiBhIG1hcC5cbiAgICogVGhlcmUgYXJlIG5vIGd1YXJhbnRlZXMgYWJvdXQgYmVpbmcgYWJsZSB0byBvcmRlciBpdC5cbiAgICogVGhpcyBpcyBvbmx5IGd1YXJhbnRlZWQgdG8gYmUgY29tcGFyYWJsZSB0byBvdGhlciB2YWx1ZXMgb2YgdGhlIHNhbWUgdHlwZS5cbiAgICogQHBhcmFtIHZhbHVlIEEgdmFsdWUgb2YgdGhlIGFsZ2VicmFpYyB0eXBlXG4gICAqIEByZXR1cm5zIFNvbWV0aGluZyB0aGF0IGNhbiBiZSB1c2VkIGFzIGEga2V5IGluIGEgbWFwLlxuICAgKi9cbiAgaW50b01hcEtleTogZnVuY3Rpb24odHksIHZhbHVlKSB7XG4gICAgc3dpdGNoICh0eS50YWcpIHtcbiAgICAgIGNhc2UgXCJVOFwiOlxuICAgICAgY2FzZSBcIlUxNlwiOlxuICAgICAgY2FzZSBcIlUzMlwiOlxuICAgICAgY2FzZSBcIlU2NFwiOlxuICAgICAgY2FzZSBcIlUxMjhcIjpcbiAgICAgIGNhc2UgXCJVMjU2XCI6XG4gICAgICBjYXNlIFwiSThcIjpcbiAgICAgIGNhc2UgXCJJMTZcIjpcbiAgICAgIGNhc2UgXCJJMzJcIjpcbiAgICAgIGNhc2UgXCJJNjRcIjpcbiAgICAgIGNhc2UgXCJJMTI4XCI6XG4gICAgICBjYXNlIFwiSTI1NlwiOlxuICAgICAgY2FzZSBcIkYzMlwiOlxuICAgICAgY2FzZSBcIkY2NFwiOlxuICAgICAgY2FzZSBcIlN0cmluZ1wiOlxuICAgICAgY2FzZSBcIkJvb2xcIjpcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgY2FzZSBcIlByb2R1Y3RcIjpcbiAgICAgICAgcmV0dXJuIFByb2R1Y3RUeXBlLmludG9NYXBLZXkodHkudmFsdWUsIHZhbHVlKTtcbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgY29uc3Qgd3JpdGVyID0gbmV3IEJpbmFyeVdyaXRlcigxMCk7XG4gICAgICAgIEFsZ2VicmFpY1R5cGUuc2VyaWFsaXplVmFsdWUod3JpdGVyLCB0eSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gd3JpdGVyLnRvQmFzZTY0KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xudmFyIFByb2R1Y3RUeXBlID0ge1xuICBzZXJpYWxpemVWYWx1ZSh3cml0ZXIsIHR5LCB2YWx1ZSwgdHlwZXNwYWNlKSB7XG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHR5LmVsZW1lbnRzKSB7XG4gICAgICBBbGdlYnJhaWNUeXBlLnNlcmlhbGl6ZVZhbHVlKFxuICAgICAgICB3cml0ZXIsXG4gICAgICAgIGVsZW1lbnQuYWxnZWJyYWljVHlwZSxcbiAgICAgICAgdmFsdWVbZWxlbWVudC5uYW1lXSxcbiAgICAgICAgdHlwZXNwYWNlXG4gICAgICApO1xuICAgIH1cbiAgfSxcbiAgZGVzZXJpYWxpemVWYWx1ZShyZWFkZXIsIHR5LCB0eXBlc3BhY2UpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBpZiAodHkuZWxlbWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICBpZiAodHkuZWxlbWVudHNbMF0ubmFtZSA9PT0gXCJfX3RpbWVfZHVyYXRpb25fbWljcm9zX19cIikge1xuICAgICAgICByZXR1cm4gbmV3IFRpbWVEdXJhdGlvbihyZWFkZXIucmVhZEk2NCgpKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eS5lbGVtZW50c1swXS5uYW1lID09PSBcIl9fdGltZXN0YW1wX21pY3Jvc19zaW5jZV91bml4X2Vwb2NoX19cIikge1xuICAgICAgICByZXR1cm4gbmV3IFRpbWVzdGFtcChyZWFkZXIucmVhZEk2NCgpKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eS5lbGVtZW50c1swXS5uYW1lID09PSBcIl9faWRlbnRpdHlfX1wiKSB7XG4gICAgICAgIHJldHVybiBuZXcgSWRlbnRpdHkocmVhZGVyLnJlYWRVMjU2KCkpO1xuICAgICAgfVxuICAgICAgaWYgKHR5LmVsZW1lbnRzWzBdLm5hbWUgPT09IFwiX19jb25uZWN0aW9uX2lkX19cIikge1xuICAgICAgICByZXR1cm4gbmV3IENvbm5lY3Rpb25JZChyZWFkZXIucmVhZFUxMjgoKSk7XG4gICAgICB9XG4gICAgICBpZiAodHkuZWxlbWVudHNbMF0ubmFtZSA9PT0gXCJfX3V1aWRfX1wiKSB7XG4gICAgICAgIHJldHVybiBuZXcgVXVpZChyZWFkZXIucmVhZFUxMjgoKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiB0eS5lbGVtZW50cykge1xuICAgICAgcmVzdWx0W2VsZW1lbnQubmFtZV0gPSBBbGdlYnJhaWNUeXBlLmRlc2VyaWFsaXplVmFsdWUoXG4gICAgICAgIHJlYWRlcixcbiAgICAgICAgZWxlbWVudC5hbGdlYnJhaWNUeXBlLFxuICAgICAgICB0eXBlc3BhY2VcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG4gIGludG9NYXBLZXkodHksIHZhbHVlKSB7XG4gICAgaWYgKHR5LmVsZW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgaWYgKHR5LmVsZW1lbnRzWzBdLm5hbWUgPT09IFwiX190aW1lX2R1cmF0aW9uX21pY3Jvc19fXCIpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLl9fdGltZV9kdXJhdGlvbl9taWNyb3NfXztcbiAgICAgIH1cbiAgICAgIGlmICh0eS5lbGVtZW50c1swXS5uYW1lID09PSBcIl9fdGltZXN0YW1wX21pY3Jvc19zaW5jZV91bml4X2Vwb2NoX19cIikge1xuICAgICAgICByZXR1cm4gdmFsdWUuX190aW1lc3RhbXBfbWljcm9zX3NpbmNlX3VuaXhfZXBvY2hfXztcbiAgICAgIH1cbiAgICAgIGlmICh0eS5lbGVtZW50c1swXS5uYW1lID09PSBcIl9faWRlbnRpdHlfX1wiKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5fX2lkZW50aXR5X187XG4gICAgICB9XG4gICAgICBpZiAodHkuZWxlbWVudHNbMF0ubmFtZSA9PT0gXCJfX2Nvbm5lY3Rpb25faWRfX1wiKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5fX2Nvbm5lY3Rpb25faWRfXztcbiAgICAgIH1cbiAgICAgIGlmICh0eS5lbGVtZW50c1swXS5uYW1lID09PSBcIl9fdXVpZF9fXCIpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLl9fdXVpZF9fO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB3cml0ZXIgPSBuZXcgQmluYXJ5V3JpdGVyKDEwKTtcbiAgICBBbGdlYnJhaWNUeXBlLnNlcmlhbGl6ZVZhbHVlKHdyaXRlciwgQWxnZWJyYWljVHlwZS5Qcm9kdWN0KHR5KSwgdmFsdWUpO1xuICAgIHJldHVybiB3cml0ZXIudG9CYXNlNjQoKTtcbiAgfVxufTtcbnZhciBTdW1UeXBlID0ge1xuICBzZXJpYWxpemVWYWx1ZTogZnVuY3Rpb24od3JpdGVyLCB0eSwgdmFsdWUsIHR5cGVzcGFjZSkge1xuICAgIGlmICh0eS52YXJpYW50cy5sZW5ndGggPT0gMiAmJiB0eS52YXJpYW50c1swXS5uYW1lID09PSBcInNvbWVcIiAmJiB0eS52YXJpYW50c1sxXS5uYW1lID09PSBcIm5vbmVcIikge1xuICAgICAgaWYgKHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgICAgd3JpdGVyLndyaXRlQnl0ZSgwKTtcbiAgICAgICAgQWxnZWJyYWljVHlwZS5zZXJpYWxpemVWYWx1ZShcbiAgICAgICAgICB3cml0ZXIsXG4gICAgICAgICAgdHkudmFyaWFudHNbMF0uYWxnZWJyYWljVHlwZSxcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICB0eXBlc3BhY2VcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdyaXRlci53cml0ZUJ5dGUoMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eS52YXJpYW50cy5sZW5ndGggPT0gMiAmJiB0eS52YXJpYW50c1swXS5uYW1lID09PSBcIm9rXCIgJiYgdHkudmFyaWFudHNbMV0ubmFtZSA9PT0gXCJlcnJcIikge1xuICAgICAgbGV0IHZhcmlhbnROYW1lO1xuICAgICAgbGV0IGlubmVyVmFsdWU7XG4gICAgICBsZXQgaW5kZXg7XG4gICAgICBpZiAoXCJva1wiIGluIHZhbHVlKSB7XG4gICAgICAgIHZhcmlhbnROYW1lID0gXCJva1wiO1xuICAgICAgICBpbm5lclZhbHVlID0gdmFsdWUub2s7XG4gICAgICAgIGluZGV4ID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhcmlhbnROYW1lID0gXCJlcnJcIjtcbiAgICAgICAgaW5uZXJWYWx1ZSA9IHZhbHVlLmVycjtcbiAgICAgICAgaW5kZXggPSAxO1xuICAgICAgfVxuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICB0aHJvdyBgUmVzdWx0IHNlcmlhbGl6YXRpb24gZXJyb3I6IHZhcmlhbnQgJyR7dmFyaWFudE5hbWV9JyBub3QgZm91bmQgaW4gJHtKU09OLnN0cmluZ2lmeSh0eSl9YDtcbiAgICAgIH1cbiAgICAgIHdyaXRlci53cml0ZVU4KGluZGV4KTtcbiAgICAgIEFsZ2VicmFpY1R5cGUuc2VyaWFsaXplVmFsdWUoXG4gICAgICAgIHdyaXRlcixcbiAgICAgICAgdHkudmFyaWFudHNbaW5kZXhdLmFsZ2VicmFpY1R5cGUsXG4gICAgICAgIGlubmVyVmFsdWUsXG4gICAgICAgIHR5cGVzcGFjZVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdmFyaWFudCA9IHZhbHVlW1widGFnXCJdO1xuICAgICAgY29uc3QgaW5kZXggPSB0eS52YXJpYW50cy5maW5kSW5kZXgoKHYpID0+IHYubmFtZSA9PT0gdmFyaWFudCk7XG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIHRocm93IGBDYW4ndCBzZXJpYWxpemUgYSBzdW0gdHlwZSwgY291bGRuJ3QgZmluZCAke3ZhbHVlLnRhZ30gdGFnICR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfSBpbiB2YXJpYW50cyAke0pTT04uc3RyaW5naWZ5KHR5KX1gO1xuICAgICAgfVxuICAgICAgd3JpdGVyLndyaXRlVTgoaW5kZXgpO1xuICAgICAgQWxnZWJyYWljVHlwZS5zZXJpYWxpemVWYWx1ZShcbiAgICAgICAgd3JpdGVyLFxuICAgICAgICB0eS52YXJpYW50c1tpbmRleF0uYWxnZWJyYWljVHlwZSxcbiAgICAgICAgdmFsdWVbXCJ2YWx1ZVwiXSxcbiAgICAgICAgdHlwZXNwYWNlXG4gICAgICApO1xuICAgIH1cbiAgfSxcbiAgZGVzZXJpYWxpemVWYWx1ZTogZnVuY3Rpb24ocmVhZGVyLCB0eSwgdHlwZXNwYWNlKSB7XG4gICAgY29uc3QgdGFnID0gcmVhZGVyLnJlYWRVOCgpO1xuICAgIGlmICh0eS52YXJpYW50cy5sZW5ndGggPT0gMiAmJiB0eS52YXJpYW50c1swXS5uYW1lID09PSBcInNvbWVcIiAmJiB0eS52YXJpYW50c1sxXS5uYW1lID09PSBcIm5vbmVcIikge1xuICAgICAgaWYgKHRhZyA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQWxnZWJyYWljVHlwZS5kZXNlcmlhbGl6ZVZhbHVlKFxuICAgICAgICAgIHJlYWRlcixcbiAgICAgICAgICB0eS52YXJpYW50c1swXS5hbGdlYnJhaWNUeXBlLFxuICAgICAgICAgIHR5cGVzcGFjZVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmICh0YWcgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGBDYW4ndCBkZXNlcmlhbGl6ZSBhbiBvcHRpb24gdHlwZSwgY291bGRuJ3QgZmluZCAke3RhZ30gdGFnYDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5LnZhcmlhbnRzLmxlbmd0aCA9PSAyICYmIHR5LnZhcmlhbnRzWzBdLm5hbWUgPT09IFwib2tcIiAmJiB0eS52YXJpYW50c1sxXS5uYW1lID09PSBcImVyclwiKSB7XG4gICAgICBpZiAodGFnID09PSAwKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gQWxnZWJyYWljVHlwZS5kZXNlcmlhbGl6ZVZhbHVlKFxuICAgICAgICAgIHJlYWRlcixcbiAgICAgICAgICB0eS52YXJpYW50c1swXS5hbGdlYnJhaWNUeXBlLFxuICAgICAgICAgIHR5cGVzcGFjZVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4geyBvazogdmFsdWUgfTtcbiAgICAgIH0gZWxzZSBpZiAodGFnID09PSAxKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gQWxnZWJyYWljVHlwZS5kZXNlcmlhbGl6ZVZhbHVlKFxuICAgICAgICAgIHJlYWRlcixcbiAgICAgICAgICB0eS52YXJpYW50c1sxXS5hbGdlYnJhaWNUeXBlLFxuICAgICAgICAgIHR5cGVzcGFjZVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4geyBlcnI6IHZhbHVlIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBgQ2FuJ3QgZGVzZXJpYWxpemUgYSByZXN1bHQgdHlwZSwgY291bGRuJ3QgZmluZCAke3RhZ30gdGFnYDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdmFyaWFudCA9IHR5LnZhcmlhbnRzW3RhZ107XG4gICAgICBjb25zdCB2YWx1ZSA9IEFsZ2VicmFpY1R5cGUuZGVzZXJpYWxpemVWYWx1ZShcbiAgICAgICAgcmVhZGVyLFxuICAgICAgICB2YXJpYW50LmFsZ2VicmFpY1R5cGUsXG4gICAgICAgIHR5cGVzcGFjZVxuICAgICAgKTtcbiAgICAgIHJldHVybiB7IHRhZzogdmFyaWFudC5uYW1lLCB2YWx1ZSB9O1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL2xpYi9vcHRpb24udHNcbnZhciBPcHRpb24gPSB7XG4gIGdldEFsZ2VicmFpY1R5cGUoaW5uZXJUeXBlKSB7XG4gICAgcmV0dXJuIEFsZ2VicmFpY1R5cGUuU3VtKHtcbiAgICAgIHZhcmlhbnRzOiBbXG4gICAgICAgIHsgbmFtZTogXCJzb21lXCIsIGFsZ2VicmFpY1R5cGU6IGlubmVyVHlwZSB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJub25lXCIsXG4gICAgICAgICAgYWxnZWJyYWljVHlwZTogQWxnZWJyYWljVHlwZS5Qcm9kdWN0KHsgZWxlbWVudHM6IFtdIH0pXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9KTtcbiAgfVxufTtcblxuLy8gc3JjL2xpYi9yZXN1bHQudHNcbnZhciBSZXN1bHQgPSB7XG4gIGdldEFsZ2VicmFpY1R5cGUob2tUeXBlLCBlcnJUeXBlKSB7XG4gICAgcmV0dXJuIEFsZ2VicmFpY1R5cGUuU3VtKHtcbiAgICAgIHZhcmlhbnRzOiBbXG4gICAgICAgIHsgbmFtZTogXCJva1wiLCBhbGdlYnJhaWNUeXBlOiBva1R5cGUgfSxcbiAgICAgICAgeyBuYW1lOiBcImVyclwiLCBhbGdlYnJhaWNUeXBlOiBlcnJUeXBlIH1cbiAgICAgIF1cbiAgICB9KTtcbiAgfVxufTtcblxuLy8gc3JjL2xpYi9zY2hlZHVsZV9hdC50c1xudmFyIFNjaGVkdWxlQXQgPSB7XG4gIGludGVydmFsKHZhbHVlKSB7XG4gICAgcmV0dXJuIEludGVydmFsKHZhbHVlKTtcbiAgfSxcbiAgdGltZSh2YWx1ZSkge1xuICAgIHJldHVybiBUaW1lKHZhbHVlKTtcbiAgfSxcbiAgZ2V0QWxnZWJyYWljVHlwZSgpIHtcbiAgICByZXR1cm4gQWxnZWJyYWljVHlwZS5TdW0oe1xuICAgICAgdmFyaWFudHM6IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwiSW50ZXJ2YWxcIixcbiAgICAgICAgICBhbGdlYnJhaWNUeXBlOiBUaW1lRHVyYXRpb24uZ2V0QWxnZWJyYWljVHlwZSgpXG4gICAgICAgIH0sXG4gICAgICAgIHsgbmFtZTogXCJUaW1lXCIsIGFsZ2VicmFpY1R5cGU6IFRpbWVzdGFtcC5nZXRBbGdlYnJhaWNUeXBlKCkgfVxuICAgICAgXVxuICAgIH0pO1xuICB9LFxuICBpc1NjaGVkdWxlQXQoYWxnZWJyYWljVHlwZSkge1xuICAgIGlmIChhbGdlYnJhaWNUeXBlLnRhZyAhPT0gXCJTdW1cIikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCB2YXJpYW50cyA9IGFsZ2VicmFpY1R5cGUudmFsdWUudmFyaWFudHM7XG4gICAgaWYgKHZhcmlhbnRzLmxlbmd0aCAhPT0gMikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBpbnRlcnZhbFZhcmlhbnQgPSB2YXJpYW50cy5maW5kKCh2KSA9PiB2Lm5hbWUgPT09IFwiSW50ZXJ2YWxcIik7XG4gICAgY29uc3QgdGltZVZhcmlhbnQgPSB2YXJpYW50cy5maW5kKCh2KSA9PiB2Lm5hbWUgPT09IFwiVGltZVwiKTtcbiAgICBpZiAoIWludGVydmFsVmFyaWFudCB8fCAhdGltZVZhcmlhbnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIFRpbWVEdXJhdGlvbi5pc1RpbWVEdXJhdGlvbihpbnRlcnZhbFZhcmlhbnQuYWxnZWJyYWljVHlwZSkgJiYgVGltZXN0YW1wLmlzVGltZXN0YW1wKHRpbWVWYXJpYW50LmFsZ2VicmFpY1R5cGUpO1xuICB9XG59O1xudmFyIEludGVydmFsID0gKG1pY3JvcykgPT4gKHtcbiAgdGFnOiBcIkludGVydmFsXCIsXG4gIHZhbHVlOiBuZXcgVGltZUR1cmF0aW9uKG1pY3Jvcylcbn0pO1xudmFyIFRpbWUgPSAobWljcm9zU2luY2VVbml4RXBvY2gpID0+ICh7XG4gIHRhZzogXCJUaW1lXCIsXG4gIHZhbHVlOiBuZXcgVGltZXN0YW1wKG1pY3Jvc1NpbmNlVW5peEVwb2NoKVxufSk7XG52YXIgc2NoZWR1bGVfYXRfZGVmYXVsdCA9IFNjaGVkdWxlQXQ7XG5cbi8vIHNyYy9saWIvdHlwZV91dGlsLnRzXG5mdW5jdGlvbiBzZXQoeCwgdDIpIHtcbiAgcmV0dXJuIHsgLi4ueCwgLi4udDIgfTtcbn1cblxuLy8gc3JjL2xpYi90eXBlX2J1aWxkZXJzLnRzXG52YXIgVHlwZUJ1aWxkZXIgPSBjbGFzcyB7XG4gIC8qKlxuICAgKiBUaGUgVHlwZVNjcmlwdCBwaGFudG9tIHR5cGUuIFRoaXMgaXMgbm90IHN0b3JlZCBhdCBydW50aW1lLFxuICAgKiBidXQgaXMgdmlzaWJsZSB0byB0aGUgY29tcGlsZXJcbiAgICovXG4gIHR5cGU7XG4gIC8qKlxuICAgKiBUaGUgU3BhY2V0aW1lREIgYWxnZWJyYWljIHR5cGUgKHJ1buKAkXRpbWUgdmFsdWUpLiBJbiBhZGRpdGlvbiB0byBzdG9yaW5nXG4gICAqIHRoZSBydW50aW1lIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBgQWxnZWJyYWljVHlwZWAsIGl0IGFsc28gY2FwdHVyZXNcbiAgICogdGhlIFR5cGVTY3JpcHQgdHlwZSBpbmZvcm1hdGlvbiBvZiB0aGUgYEFsZ2VicmFpY1R5cGVgLiBUaGF0IGlzIHRvIHNheVxuICAgKiB0aGUgdmFsdWUgaXMgbm90IG1lcmVseSBhbiBgQWxnZWJyYWljVHlwZWAsIGJ1dCBpcyBjb25zdHJ1Y3RlZCB0byBiZVxuICAgKiB0aGUgY29ycmVzcG9uZGluZyBjb25jcmV0ZSBgQWxnZWJyYWljVHlwZWAgZm9yIHRoZSBUeXBlU2NyaXB0IHR5cGUgYFR5cGVgLlxuICAgKlxuICAgKiBlLmcuIGBzdHJpbmdgIGNvcnJlc3BvbmRzIHRvIGBBbGdlYnJhaWNUeXBlLlN0cmluZ2BcbiAgICovXG4gIGFsZ2VicmFpY1R5cGU7XG4gIGNvbnN0cnVjdG9yKGFsZ2VicmFpY1R5cGUpIHtcbiAgICB0aGlzLmFsZ2VicmFpY1R5cGUgPSBhbGdlYnJhaWNUeXBlO1xuICB9XG4gIG9wdGlvbmFsKCkge1xuICAgIHJldHVybiBuZXcgT3B0aW9uQnVpbGRlcih0aGlzKTtcbiAgfVxuICBzZXJpYWxpemUod3JpdGVyLCB2YWx1ZSkge1xuICAgIEFsZ2VicmFpY1R5cGUuc2VyaWFsaXplVmFsdWUod3JpdGVyLCB0aGlzLmFsZ2VicmFpY1R5cGUsIHZhbHVlKTtcbiAgfVxuICBkZXNlcmlhbGl6ZShyZWFkZXIpIHtcbiAgICByZXR1cm4gQWxnZWJyYWljVHlwZS5kZXNlcmlhbGl6ZVZhbHVlKHJlYWRlciwgdGhpcy5hbGdlYnJhaWNUeXBlKTtcbiAgfVxufTtcbnZhciBVOEJ1aWxkZXIgPSBjbGFzcyBleHRlbmRzIFR5cGVCdWlsZGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoQWxnZWJyYWljVHlwZS5VOCk7XG4gIH1cbiAgaW5kZXgoYWxnb3JpdGhtID0gXCJidHJlZVwiKSB7XG4gICAgcmV0dXJuIG5ldyBVOENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpbmRleFR5cGU6IGFsZ29yaXRobSB9KVxuICAgICk7XG4gIH1cbiAgdW5pcXVlKCkge1xuICAgIHJldHVybiBuZXcgVThDb2x1bW5CdWlsZGVyKHRoaXMsIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNVbmlxdWU6IHRydWUgfSkpO1xuICB9XG4gIHByaW1hcnlLZXkoKSB7XG4gICAgcmV0dXJuIG5ldyBVOENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpc1ByaW1hcnlLZXk6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGF1dG9JbmMoKSB7XG4gICAgcmV0dXJuIG5ldyBVOENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpc0F1dG9JbmNyZW1lbnQ6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGRlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IFU4Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGRlZmF1bHRWYWx1ZTogdmFsdWUgfSlcbiAgICApO1xuICB9XG4gIG5hbWUobmFtZSkge1xuICAgIHJldHVybiBuZXcgVThDb2x1bW5CdWlsZGVyKHRoaXMsIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgbmFtZSB9KSk7XG4gIH1cbn07XG52YXIgVTE2QnVpbGRlciA9IGNsYXNzIGV4dGVuZHMgVHlwZUJ1aWxkZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihBbGdlYnJhaWNUeXBlLlUxNik7XG4gIH1cbiAgaW5kZXgoYWxnb3JpdGhtID0gXCJidHJlZVwiKSB7XG4gICAgcmV0dXJuIG5ldyBVMTZDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaW5kZXhUeXBlOiBhbGdvcml0aG0gfSlcbiAgICApO1xuICB9XG4gIHVuaXF1ZSgpIHtcbiAgICByZXR1cm4gbmV3IFUxNkNvbHVtbkJ1aWxkZXIodGhpcywgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpc1VuaXF1ZTogdHJ1ZSB9KSk7XG4gIH1cbiAgcHJpbWFyeUtleSgpIHtcbiAgICByZXR1cm4gbmV3IFUxNkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpc1ByaW1hcnlLZXk6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGF1dG9JbmMoKSB7XG4gICAgcmV0dXJuIG5ldyBVMTZDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNBdXRvSW5jcmVtZW50OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBVMTZDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgZGVmYXVsdFZhbHVlOiB2YWx1ZSB9KVxuICAgICk7XG4gIH1cbiAgbmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBVMTZDb2x1bW5CdWlsZGVyKHRoaXMsIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgbmFtZSB9KSk7XG4gIH1cbn07XG52YXIgVTMyQnVpbGRlciA9IGNsYXNzIGV4dGVuZHMgVHlwZUJ1aWxkZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihBbGdlYnJhaWNUeXBlLlUzMik7XG4gIH1cbiAgaW5kZXgoYWxnb3JpdGhtID0gXCJidHJlZVwiKSB7XG4gICAgcmV0dXJuIG5ldyBVMzJDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaW5kZXhUeXBlOiBhbGdvcml0aG0gfSlcbiAgICApO1xuICB9XG4gIHVuaXF1ZSgpIHtcbiAgICByZXR1cm4gbmV3IFUzMkNvbHVtbkJ1aWxkZXIodGhpcywgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpc1VuaXF1ZTogdHJ1ZSB9KSk7XG4gIH1cbiAgcHJpbWFyeUtleSgpIHtcbiAgICByZXR1cm4gbmV3IFUzMkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpc1ByaW1hcnlLZXk6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGF1dG9JbmMoKSB7XG4gICAgcmV0dXJuIG5ldyBVMzJDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNBdXRvSW5jcmVtZW50OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBVMzJDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgZGVmYXVsdFZhbHVlOiB2YWx1ZSB9KVxuICAgICk7XG4gIH1cbiAgbmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBVMzJDb2x1bW5CdWlsZGVyKHRoaXMsIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgbmFtZSB9KSk7XG4gIH1cbn07XG52YXIgVTY0QnVpbGRlciA9IGNsYXNzIGV4dGVuZHMgVHlwZUJ1aWxkZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihBbGdlYnJhaWNUeXBlLlU2NCk7XG4gIH1cbiAgaW5kZXgoYWxnb3JpdGhtID0gXCJidHJlZVwiKSB7XG4gICAgcmV0dXJuIG5ldyBVNjRDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaW5kZXhUeXBlOiBhbGdvcml0aG0gfSlcbiAgICApO1xuICB9XG4gIHVuaXF1ZSgpIHtcbiAgICByZXR1cm4gbmV3IFU2NENvbHVtbkJ1aWxkZXIodGhpcywgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpc1VuaXF1ZTogdHJ1ZSB9KSk7XG4gIH1cbiAgcHJpbWFyeUtleSgpIHtcbiAgICByZXR1cm4gbmV3IFU2NENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpc1ByaW1hcnlLZXk6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGF1dG9JbmMoKSB7XG4gICAgcmV0dXJuIG5ldyBVNjRDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNBdXRvSW5jcmVtZW50OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBVNjRDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgZGVmYXVsdFZhbHVlOiB2YWx1ZSB9KVxuICAgICk7XG4gIH1cbiAgbmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBVNjRDb2x1bW5CdWlsZGVyKHRoaXMsIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgbmFtZSB9KSk7XG4gIH1cbn07XG52YXIgVTEyOEJ1aWxkZXIgPSBjbGFzcyBleHRlbmRzIFR5cGVCdWlsZGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoQWxnZWJyYWljVHlwZS5VMTI4KTtcbiAgfVxuICBpbmRleChhbGdvcml0aG0gPSBcImJ0cmVlXCIpIHtcbiAgICByZXR1cm4gbmV3IFUxMjhDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaW5kZXhUeXBlOiBhbGdvcml0aG0gfSlcbiAgICApO1xuICB9XG4gIHVuaXF1ZSgpIHtcbiAgICByZXR1cm4gbmV3IFUxMjhDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNVbmlxdWU6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIHByaW1hcnlLZXkoKSB7XG4gICAgcmV0dXJuIG5ldyBVMTI4Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGlzUHJpbWFyeUtleTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgYXV0b0luYygpIHtcbiAgICByZXR1cm4gbmV3IFUxMjhDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNBdXRvSW5jcmVtZW50OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBVMTI4Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGRlZmF1bHRWYWx1ZTogdmFsdWUgfSlcbiAgICApO1xuICB9XG4gIG5hbWUobmFtZSkge1xuICAgIHJldHVybiBuZXcgVTEyOENvbHVtbkJ1aWxkZXIodGhpcywgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBuYW1lIH0pKTtcbiAgfVxufTtcbnZhciBVMjU2QnVpbGRlciA9IGNsYXNzIGV4dGVuZHMgVHlwZUJ1aWxkZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihBbGdlYnJhaWNUeXBlLlUyNTYpO1xuICB9XG4gIGluZGV4KGFsZ29yaXRobSA9IFwiYnRyZWVcIikge1xuICAgIHJldHVybiBuZXcgVTI1NkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpbmRleFR5cGU6IGFsZ29yaXRobSB9KVxuICAgICk7XG4gIH1cbiAgdW5pcXVlKCkge1xuICAgIHJldHVybiBuZXcgVTI1NkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpc1VuaXF1ZTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgcHJpbWFyeUtleSgpIHtcbiAgICByZXR1cm4gbmV3IFUyNTZDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNQcmltYXJ5S2V5OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBhdXRvSW5jKCkge1xuICAgIHJldHVybiBuZXcgVTI1NkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpc0F1dG9JbmNyZW1lbnQ6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGRlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IFUyNTZDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgZGVmYXVsdFZhbHVlOiB2YWx1ZSB9KVxuICAgICk7XG4gIH1cbiAgbmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBVMjU2Q29sdW1uQnVpbGRlcih0aGlzLCBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IG5hbWUgfSkpO1xuICB9XG59O1xudmFyIEk4QnVpbGRlciA9IGNsYXNzIGV4dGVuZHMgVHlwZUJ1aWxkZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihBbGdlYnJhaWNUeXBlLkk4KTtcbiAgfVxuICBpbmRleChhbGdvcml0aG0gPSBcImJ0cmVlXCIpIHtcbiAgICByZXR1cm4gbmV3IEk4Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGluZGV4VHlwZTogYWxnb3JpdGhtIH0pXG4gICAgKTtcbiAgfVxuICB1bmlxdWUoKSB7XG4gICAgcmV0dXJuIG5ldyBJOENvbHVtbkJ1aWxkZXIodGhpcywgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpc1VuaXF1ZTogdHJ1ZSB9KSk7XG4gIH1cbiAgcHJpbWFyeUtleSgpIHtcbiAgICByZXR1cm4gbmV3IEk4Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGlzUHJpbWFyeUtleTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgYXV0b0luYygpIHtcbiAgICByZXR1cm4gbmV3IEk4Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGlzQXV0b0luY3JlbWVudDogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgZGVmYXVsdCh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgSThDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgZGVmYXVsdFZhbHVlOiB2YWx1ZSB9KVxuICAgICk7XG4gIH1cbiAgbmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBJOENvbHVtbkJ1aWxkZXIodGhpcywgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBuYW1lIH0pKTtcbiAgfVxufTtcbnZhciBJMTZCdWlsZGVyID0gY2xhc3MgZXh0ZW5kcyBUeXBlQnVpbGRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKEFsZ2VicmFpY1R5cGUuSTE2KTtcbiAgfVxuICBpbmRleChhbGdvcml0aG0gPSBcImJ0cmVlXCIpIHtcbiAgICByZXR1cm4gbmV3IEkxNkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpbmRleFR5cGU6IGFsZ29yaXRobSB9KVxuICAgICk7XG4gIH1cbiAgdW5pcXVlKCkge1xuICAgIHJldHVybiBuZXcgSTE2Q29sdW1uQnVpbGRlcih0aGlzLCBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGlzVW5pcXVlOiB0cnVlIH0pKTtcbiAgfVxuICBwcmltYXJ5S2V5KCkge1xuICAgIHJldHVybiBuZXcgSTE2Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGlzUHJpbWFyeUtleTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgYXV0b0luYygpIHtcbiAgICByZXR1cm4gbmV3IEkxNkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpc0F1dG9JbmNyZW1lbnQ6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGRlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IEkxNkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBkZWZhdWx0VmFsdWU6IHZhbHVlIH0pXG4gICAgKTtcbiAgfVxuICBuYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IEkxNkNvbHVtbkJ1aWxkZXIodGhpcywgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBuYW1lIH0pKTtcbiAgfVxufTtcbnZhciBJMzJCdWlsZGVyID0gY2xhc3MgZXh0ZW5kcyBUeXBlQnVpbGRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKEFsZ2VicmFpY1R5cGUuSTMyKTtcbiAgfVxuICBpbmRleChhbGdvcml0aG0gPSBcImJ0cmVlXCIpIHtcbiAgICByZXR1cm4gbmV3IEkzMkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpbmRleFR5cGU6IGFsZ29yaXRobSB9KVxuICAgICk7XG4gIH1cbiAgdW5pcXVlKCkge1xuICAgIHJldHVybiBuZXcgSTMyQ29sdW1uQnVpbGRlcih0aGlzLCBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGlzVW5pcXVlOiB0cnVlIH0pKTtcbiAgfVxuICBwcmltYXJ5S2V5KCkge1xuICAgIHJldHVybiBuZXcgSTMyQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGlzUHJpbWFyeUtleTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgYXV0b0luYygpIHtcbiAgICByZXR1cm4gbmV3IEkzMkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpc0F1dG9JbmNyZW1lbnQ6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGRlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IEkzMkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBkZWZhdWx0VmFsdWU6IHZhbHVlIH0pXG4gICAgKTtcbiAgfVxuICBuYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IEkzMkNvbHVtbkJ1aWxkZXIodGhpcywgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBuYW1lIH0pKTtcbiAgfVxufTtcbnZhciBJNjRCdWlsZGVyID0gY2xhc3MgZXh0ZW5kcyBUeXBlQnVpbGRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKEFsZ2VicmFpY1R5cGUuSTY0KTtcbiAgfVxuICBpbmRleChhbGdvcml0aG0gPSBcImJ0cmVlXCIpIHtcbiAgICByZXR1cm4gbmV3IEk2NENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpbmRleFR5cGU6IGFsZ29yaXRobSB9KVxuICAgICk7XG4gIH1cbiAgdW5pcXVlKCkge1xuICAgIHJldHVybiBuZXcgSTY0Q29sdW1uQnVpbGRlcih0aGlzLCBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGlzVW5pcXVlOiB0cnVlIH0pKTtcbiAgfVxuICBwcmltYXJ5S2V5KCkge1xuICAgIHJldHVybiBuZXcgSTY0Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGlzUHJpbWFyeUtleTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgYXV0b0luYygpIHtcbiAgICByZXR1cm4gbmV3IEk2NENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpc0F1dG9JbmNyZW1lbnQ6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGRlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IEk2NENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBkZWZhdWx0VmFsdWU6IHZhbHVlIH0pXG4gICAgKTtcbiAgfVxuICBuYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IEk2NENvbHVtbkJ1aWxkZXIodGhpcywgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBuYW1lIH0pKTtcbiAgfVxufTtcbnZhciBJMTI4QnVpbGRlciA9IGNsYXNzIGV4dGVuZHMgVHlwZUJ1aWxkZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihBbGdlYnJhaWNUeXBlLkkxMjgpO1xuICB9XG4gIGluZGV4KGFsZ29yaXRobSA9IFwiYnRyZWVcIikge1xuICAgIHJldHVybiBuZXcgSTEyOENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpbmRleFR5cGU6IGFsZ29yaXRobSB9KVxuICAgICk7XG4gIH1cbiAgdW5pcXVlKCkge1xuICAgIHJldHVybiBuZXcgSTEyOENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpc1VuaXF1ZTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgcHJpbWFyeUtleSgpIHtcbiAgICByZXR1cm4gbmV3IEkxMjhDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNQcmltYXJ5S2V5OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBhdXRvSW5jKCkge1xuICAgIHJldHVybiBuZXcgSTEyOENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpc0F1dG9JbmNyZW1lbnQ6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGRlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IEkxMjhDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgZGVmYXVsdFZhbHVlOiB2YWx1ZSB9KVxuICAgICk7XG4gIH1cbiAgbmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBJMTI4Q29sdW1uQnVpbGRlcih0aGlzLCBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IG5hbWUgfSkpO1xuICB9XG59O1xudmFyIEkyNTZCdWlsZGVyID0gY2xhc3MgZXh0ZW5kcyBUeXBlQnVpbGRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKEFsZ2VicmFpY1R5cGUuSTI1Nik7XG4gIH1cbiAgaW5kZXgoYWxnb3JpdGhtID0gXCJidHJlZVwiKSB7XG4gICAgcmV0dXJuIG5ldyBJMjU2Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGluZGV4VHlwZTogYWxnb3JpdGhtIH0pXG4gICAgKTtcbiAgfVxuICB1bmlxdWUoKSB7XG4gICAgcmV0dXJuIG5ldyBJMjU2Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGlzVW5pcXVlOiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBwcmltYXJ5S2V5KCkge1xuICAgIHJldHVybiBuZXcgSTI1NkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpc1ByaW1hcnlLZXk6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGF1dG9JbmMoKSB7XG4gICAgcmV0dXJuIG5ldyBJMjU2Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGlzQXV0b0luY3JlbWVudDogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgZGVmYXVsdCh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgSTI1NkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBkZWZhdWx0VmFsdWU6IHZhbHVlIH0pXG4gICAgKTtcbiAgfVxuICBuYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IEkyNTZDb2x1bW5CdWlsZGVyKHRoaXMsIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgbmFtZSB9KSk7XG4gIH1cbn07XG52YXIgRjMyQnVpbGRlciA9IGNsYXNzIGV4dGVuZHMgVHlwZUJ1aWxkZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihBbGdlYnJhaWNUeXBlLkYzMik7XG4gIH1cbiAgZGVmYXVsdCh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgRjMyQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGRlZmF1bHRWYWx1ZTogdmFsdWUgfSlcbiAgICApO1xuICB9XG4gIG5hbWUobmFtZSkge1xuICAgIHJldHVybiBuZXcgRjMyQ29sdW1uQnVpbGRlcih0aGlzLCBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IG5hbWUgfSkpO1xuICB9XG59O1xudmFyIEY2NEJ1aWxkZXIgPSBjbGFzcyBleHRlbmRzIFR5cGVCdWlsZGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoQWxnZWJyYWljVHlwZS5GNjQpO1xuICB9XG4gIGRlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IEY2NENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBkZWZhdWx0VmFsdWU6IHZhbHVlIH0pXG4gICAgKTtcbiAgfVxuICBuYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IEY2NENvbHVtbkJ1aWxkZXIodGhpcywgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBuYW1lIH0pKTtcbiAgfVxufTtcbnZhciBCb29sQnVpbGRlciA9IGNsYXNzIGV4dGVuZHMgVHlwZUJ1aWxkZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihBbGdlYnJhaWNUeXBlLkJvb2wpO1xuICB9XG4gIGluZGV4KGFsZ29yaXRobSA9IFwiYnRyZWVcIikge1xuICAgIHJldHVybiBuZXcgQm9vbENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpbmRleFR5cGU6IGFsZ29yaXRobSB9KVxuICAgICk7XG4gIH1cbiAgdW5pcXVlKCkge1xuICAgIHJldHVybiBuZXcgQm9vbENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpc1VuaXF1ZTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgcHJpbWFyeUtleSgpIHtcbiAgICByZXR1cm4gbmV3IEJvb2xDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNQcmltYXJ5S2V5OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBCb29sQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGRlZmF1bHRWYWx1ZTogdmFsdWUgfSlcbiAgICApO1xuICB9XG4gIG5hbWUobmFtZSkge1xuICAgIHJldHVybiBuZXcgQm9vbENvbHVtbkJ1aWxkZXIodGhpcywgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBuYW1lIH0pKTtcbiAgfVxufTtcbnZhciBTdHJpbmdCdWlsZGVyID0gY2xhc3MgZXh0ZW5kcyBUeXBlQnVpbGRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKEFsZ2VicmFpY1R5cGUuU3RyaW5nKTtcbiAgfVxuICBpbmRleChhbGdvcml0aG0gPSBcImJ0cmVlXCIpIHtcbiAgICByZXR1cm4gbmV3IFN0cmluZ0NvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpbmRleFR5cGU6IGFsZ29yaXRobSB9KVxuICAgICk7XG4gIH1cbiAgdW5pcXVlKCkge1xuICAgIHJldHVybiBuZXcgU3RyaW5nQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGlzVW5pcXVlOiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBwcmltYXJ5S2V5KCkge1xuICAgIHJldHVybiBuZXcgU3RyaW5nQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGlzUHJpbWFyeUtleTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgZGVmYXVsdCh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgU3RyaW5nQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGRlZmF1bHRWYWx1ZTogdmFsdWUgfSlcbiAgICApO1xuICB9XG4gIG5hbWUobmFtZSkge1xuICAgIHJldHVybiBuZXcgU3RyaW5nQ29sdW1uQnVpbGRlcih0aGlzLCBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IG5hbWUgfSkpO1xuICB9XG59O1xudmFyIEFycmF5QnVpbGRlciA9IGNsYXNzIGV4dGVuZHMgVHlwZUJ1aWxkZXIge1xuICBlbGVtZW50O1xuICBjb25zdHJ1Y3RvcihlbGVtZW50KSB7XG4gICAgc3VwZXIoQWxnZWJyYWljVHlwZS5BcnJheShlbGVtZW50LmFsZ2VicmFpY1R5cGUpKTtcbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICB9XG4gIGRlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IEFycmF5Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMuZWxlbWVudCxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgZGVmYXVsdFZhbHVlOiB2YWx1ZSB9KVxuICAgICk7XG4gIH1cbiAgbmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBBcnJheUNvbHVtbkJ1aWxkZXIodGhpcy5lbGVtZW50LCBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IG5hbWUgfSkpO1xuICB9XG59O1xudmFyIEJ5dGVBcnJheUJ1aWxkZXIgPSBjbGFzcyBleHRlbmRzIFR5cGVCdWlsZGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoQWxnZWJyYWljVHlwZS5BcnJheShBbGdlYnJhaWNUeXBlLlU4KSk7XG4gIH1cbiAgZGVmYXVsdCh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgQnl0ZUFycmF5Q29sdW1uQnVpbGRlcihcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgZGVmYXVsdFZhbHVlOiB2YWx1ZSB9KVxuICAgICk7XG4gIH1cbiAgbmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBCeXRlQXJyYXlDb2x1bW5CdWlsZGVyKHNldChkZWZhdWx0TWV0YWRhdGEsIHsgbmFtZSB9KSk7XG4gIH1cbn07XG52YXIgT3B0aW9uQnVpbGRlciA9IGNsYXNzIGV4dGVuZHMgVHlwZUJ1aWxkZXIge1xuICB2YWx1ZTtcbiAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICBzdXBlcihPcHRpb24uZ2V0QWxnZWJyYWljVHlwZSh2YWx1ZS5hbGdlYnJhaWNUeXBlKSk7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIGRlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IE9wdGlvbkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBkZWZhdWx0VmFsdWU6IHZhbHVlIH0pXG4gICAgKTtcbiAgfVxuICBuYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IE9wdGlvbkNvbHVtbkJ1aWxkZXIodGhpcywgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBuYW1lIH0pKTtcbiAgfVxufTtcbnZhciBQcm9kdWN0QnVpbGRlciA9IGNsYXNzIGV4dGVuZHMgVHlwZUJ1aWxkZXIge1xuICB0eXBlTmFtZTtcbiAgZWxlbWVudHM7XG4gIGNvbnN0cnVjdG9yKGVsZW1lbnRzLCBuYW1lKSB7XG4gICAgZnVuY3Rpb24gZWxlbWVudHNBcnJheUZyb21FbGVtZW50c09iaihvYmopIHtcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopLm1hcCgoa2V5KSA9PiAoe1xuICAgICAgICBuYW1lOiBrZXksXG4gICAgICAgIC8vIExhemlseSByZXNvbHZlIHRoZSB1bmRlcmx5aW5nIG9iamVjdCdzIGFsZ2VicmFpY1R5cGUuXG4gICAgICAgIC8vIFRoaXMgd2lsbCBjYWxsIG9ialtrZXldLmFsZ2VicmFpY1R5cGUgb25seSB3aGVuIHNvbWVvbmVcbiAgICAgICAgLy8gYWN0dWFsbHkgcmVhZHMgdGhpcyBwcm9wZXJ0eS5cbiAgICAgICAgZ2V0IGFsZ2VicmFpY1R5cGUoKSB7XG4gICAgICAgICAgcmV0dXJuIG9ialtrZXldLmFsZ2VicmFpY1R5cGU7XG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICB9XG4gICAgc3VwZXIoXG4gICAgICBBbGdlYnJhaWNUeXBlLlByb2R1Y3Qoe1xuICAgICAgICBlbGVtZW50czogZWxlbWVudHNBcnJheUZyb21FbGVtZW50c09iaihlbGVtZW50cylcbiAgICAgIH0pXG4gICAgKTtcbiAgICB0aGlzLnR5cGVOYW1lID0gbmFtZTtcbiAgICB0aGlzLmVsZW1lbnRzID0gZWxlbWVudHM7XG4gIH1cbiAgZGVmYXVsdCh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgUHJvZHVjdENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBkZWZhdWx0VmFsdWU6IHZhbHVlIH0pXG4gICAgKTtcbiAgfVxuICBuYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IFByb2R1Y3RDb2x1bW5CdWlsZGVyKHRoaXMsIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgbmFtZSB9KSk7XG4gIH1cbn07XG52YXIgUmVzdWx0QnVpbGRlciA9IGNsYXNzIGV4dGVuZHMgVHlwZUJ1aWxkZXIge1xuICBvaztcbiAgZXJyO1xuICBjb25zdHJ1Y3RvcihvaywgZXJyKSB7XG4gICAgc3VwZXIoUmVzdWx0LmdldEFsZ2VicmFpY1R5cGUob2suYWxnZWJyYWljVHlwZSwgZXJyLmFsZ2VicmFpY1R5cGUpKTtcbiAgICB0aGlzLm9rID0gb2s7XG4gICAgdGhpcy5lcnIgPSBlcnI7XG4gIH1cbiAgZGVmYXVsdCh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgUmVzdWx0Q29sdW1uQnVpbGRlcih0aGlzLCBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGRlZmF1bHRWYWx1ZTogdmFsdWUgfSkpO1xuICB9XG59O1xudmFyIFVuaXRCdWlsZGVyID0gY2xhc3MgZXh0ZW5kcyBUeXBlQnVpbGRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKHsgdGFnOiBcIlByb2R1Y3RcIiwgdmFsdWU6IHsgZWxlbWVudHM6IFtdIH0gfSk7XG4gIH1cbn07XG52YXIgUm93QnVpbGRlciA9IGNsYXNzIGV4dGVuZHMgVHlwZUJ1aWxkZXIge1xuICByb3c7XG4gIHR5cGVOYW1lO1xuICBjb25zdHJ1Y3Rvcihyb3csIG5hbWUpIHtcbiAgICBjb25zdCBtYXBwZWRSb3cgPSBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICBPYmplY3QuZW50cmllcyhyb3cpLm1hcCgoW2NvbE5hbWUsIGJ1aWxkZXJdKSA9PiBbXG4gICAgICAgIGNvbE5hbWUsXG4gICAgICAgIGJ1aWxkZXIgaW5zdGFuY2VvZiBDb2x1bW5CdWlsZGVyID8gYnVpbGRlciA6IG5ldyBDb2x1bW5CdWlsZGVyKGJ1aWxkZXIsIHt9KVxuICAgICAgXSlcbiAgICApO1xuICAgIGNvbnN0IGVsZW1lbnRzID0gT2JqZWN0LmtleXMobWFwcGVkUm93KS5tYXAoKG5hbWUyKSA9PiAoe1xuICAgICAgbmFtZTogbmFtZTIsXG4gICAgICBnZXQgYWxnZWJyYWljVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIG1hcHBlZFJvd1tuYW1lMl0udHlwZUJ1aWxkZXIuYWxnZWJyYWljVHlwZTtcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgc3VwZXIoQWxnZWJyYWljVHlwZS5Qcm9kdWN0KHsgZWxlbWVudHMgfSkpO1xuICAgIHRoaXMucm93ID0gbWFwcGVkUm93O1xuICAgIHRoaXMudHlwZU5hbWUgPSBuYW1lO1xuICB9XG59O1xudmFyIFN1bUJ1aWxkZXJJbXBsID0gY2xhc3MgZXh0ZW5kcyBUeXBlQnVpbGRlciB7XG4gIHZhcmlhbnRzO1xuICB0eXBlTmFtZTtcbiAgY29uc3RydWN0b3IodmFyaWFudHMsIG5hbWUpIHtcbiAgICBmdW5jdGlvbiB2YXJpYW50c0FycmF5RnJvbVZhcmlhbnRzT2JqKHZhcmlhbnRzMikge1xuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHZhcmlhbnRzMikubWFwKChrZXkpID0+ICh7XG4gICAgICAgIG5hbWU6IGtleSxcbiAgICAgICAgLy8gTGF6aWx5IHJlc29sdmUgdGhlIHVuZGVybHlpbmcgb2JqZWN0J3MgYWxnZWJyYWljVHlwZS5cbiAgICAgICAgLy8gVGhpcyB3aWxsIGNhbGwgb2JqW2tleV0uYWxnZWJyYWljVHlwZSBvbmx5IHdoZW4gc29tZW9uZVxuICAgICAgICAvLyBhY3R1YWxseSByZWFkcyB0aGlzIHByb3BlcnR5LlxuICAgICAgICBnZXQgYWxnZWJyYWljVHlwZSgpIHtcbiAgICAgICAgICByZXR1cm4gdmFyaWFudHMyW2tleV0uYWxnZWJyYWljVHlwZTtcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgIH1cbiAgICBzdXBlcihcbiAgICAgIEFsZ2VicmFpY1R5cGUuU3VtKHtcbiAgICAgICAgdmFyaWFudHM6IHZhcmlhbnRzQXJyYXlGcm9tVmFyaWFudHNPYmoodmFyaWFudHMpXG4gICAgICB9KVxuICAgICk7XG4gICAgdGhpcy52YXJpYW50cyA9IHZhcmlhbnRzO1xuICAgIHRoaXMudHlwZU5hbWUgPSBuYW1lO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHZhcmlhbnRzKSkge1xuICAgICAgY29uc3QgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFyaWFudHMsIGtleSk7XG4gICAgICBjb25zdCBpc0FjY2Vzc29yID0gISFkZXNjICYmICh0eXBlb2YgZGVzYy5nZXQgPT09IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2YgZGVzYy5zZXQgPT09IFwiZnVuY3Rpb25cIik7XG4gICAgICBsZXQgaXNVbml0MiA9IGZhbHNlO1xuICAgICAgaWYgKCFpc0FjY2Vzc29yKSB7XG4gICAgICAgIGNvbnN0IHZhcmlhbnQgPSB2YXJpYW50c1trZXldO1xuICAgICAgICBpc1VuaXQyID0gdmFyaWFudCBpbnN0YW5jZW9mIFVuaXRCdWlsZGVyO1xuICAgICAgfVxuICAgICAgaWYgKGlzVW5pdDIpIHtcbiAgICAgICAgY29uc3QgY29uc3RhbnQgPSB0aGlzLmNyZWF0ZShrZXkpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywga2V5LCB7XG4gICAgICAgICAgdmFsdWU6IGNvbnN0YW50LFxuICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBmbiA9ICgodmFsdWUpID0+IHRoaXMuY3JlYXRlKGtleSwgdmFsdWUpKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGtleSwge1xuICAgICAgICAgIHZhbHVlOiBmbixcbiAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjcmVhdGUodGFnLCB2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdm9pZCAwID8geyB0YWcgfSA6IHsgdGFnLCB2YWx1ZSB9O1xuICB9XG4gIGRlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IFN1bUNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBkZWZhdWx0VmFsdWU6IHZhbHVlIH0pXG4gICAgKTtcbiAgfVxuICBuYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IFN1bUNvbHVtbkJ1aWxkZXIodGhpcywgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBuYW1lIH0pKTtcbiAgfVxufTtcbnZhciBTdW1CdWlsZGVyID0gU3VtQnVpbGRlckltcGw7XG52YXIgU2ltcGxlU3VtQnVpbGRlckltcGwgPSBjbGFzcyBleHRlbmRzIFN1bUJ1aWxkZXJJbXBsIHtcbiAgaW5kZXgoYWxnb3JpdGhtID0gXCJidHJlZVwiKSB7XG4gICAgcmV0dXJuIG5ldyBTaW1wbGVTdW1Db2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaW5kZXhUeXBlOiBhbGdvcml0aG0gfSlcbiAgICApO1xuICB9XG4gIHByaW1hcnlLZXkoKSB7XG4gICAgcmV0dXJuIG5ldyBTaW1wbGVTdW1Db2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNQcmltYXJ5S2V5OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxufTtcbnZhciBTaW1wbGVTdW1CdWlsZGVyID0gU2ltcGxlU3VtQnVpbGRlckltcGw7XG52YXIgU2NoZWR1bGVBdEJ1aWxkZXIgPSBjbGFzcyBleHRlbmRzIFR5cGVCdWlsZGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoc2NoZWR1bGVfYXRfZGVmYXVsdC5nZXRBbGdlYnJhaWNUeXBlKCkpO1xuICB9XG4gIGRlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IFNjaGVkdWxlQXRDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgZGVmYXVsdFZhbHVlOiB2YWx1ZSB9KVxuICAgICk7XG4gIH1cbiAgbmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBTY2hlZHVsZUF0Q29sdW1uQnVpbGRlcih0aGlzLCBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IG5hbWUgfSkpO1xuICB9XG59O1xudmFyIElkZW50aXR5QnVpbGRlciA9IGNsYXNzIGV4dGVuZHMgVHlwZUJ1aWxkZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihJZGVudGl0eS5nZXRBbGdlYnJhaWNUeXBlKCkpO1xuICB9XG4gIGluZGV4KGFsZ29yaXRobSA9IFwiYnRyZWVcIikge1xuICAgIHJldHVybiBuZXcgSWRlbnRpdHlDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaW5kZXhUeXBlOiBhbGdvcml0aG0gfSlcbiAgICApO1xuICB9XG4gIHVuaXF1ZSgpIHtcbiAgICByZXR1cm4gbmV3IElkZW50aXR5Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGlzVW5pcXVlOiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBwcmltYXJ5S2V5KCkge1xuICAgIHJldHVybiBuZXcgSWRlbnRpdHlDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNQcmltYXJ5S2V5OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBhdXRvSW5jKCkge1xuICAgIHJldHVybiBuZXcgSWRlbnRpdHlDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNBdXRvSW5jcmVtZW50OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBJZGVudGl0eUNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBkZWZhdWx0VmFsdWU6IHZhbHVlIH0pXG4gICAgKTtcbiAgfVxuICBuYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IElkZW50aXR5Q29sdW1uQnVpbGRlcih0aGlzLCBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IG5hbWUgfSkpO1xuICB9XG59O1xudmFyIENvbm5lY3Rpb25JZEJ1aWxkZXIgPSBjbGFzcyBleHRlbmRzIFR5cGVCdWlsZGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoQ29ubmVjdGlvbklkLmdldEFsZ2VicmFpY1R5cGUoKSk7XG4gIH1cbiAgaW5kZXgoYWxnb3JpdGhtID0gXCJidHJlZVwiKSB7XG4gICAgcmV0dXJuIG5ldyBDb25uZWN0aW9uSWRDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaW5kZXhUeXBlOiBhbGdvcml0aG0gfSlcbiAgICApO1xuICB9XG4gIHVuaXF1ZSgpIHtcbiAgICByZXR1cm4gbmV3IENvbm5lY3Rpb25JZENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpc1VuaXF1ZTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgcHJpbWFyeUtleSgpIHtcbiAgICByZXR1cm4gbmV3IENvbm5lY3Rpb25JZENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpc1ByaW1hcnlLZXk6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGF1dG9JbmMoKSB7XG4gICAgcmV0dXJuIG5ldyBDb25uZWN0aW9uSWRDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNBdXRvSW5jcmVtZW50OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBDb25uZWN0aW9uSWRDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgZGVmYXVsdFZhbHVlOiB2YWx1ZSB9KVxuICAgICk7XG4gIH1cbiAgbmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBDb25uZWN0aW9uSWRDb2x1bW5CdWlsZGVyKHRoaXMsIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgbmFtZSB9KSk7XG4gIH1cbn07XG52YXIgVGltZXN0YW1wQnVpbGRlciA9IGNsYXNzIGV4dGVuZHMgVHlwZUJ1aWxkZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihUaW1lc3RhbXAuZ2V0QWxnZWJyYWljVHlwZSgpKTtcbiAgfVxuICBpbmRleChhbGdvcml0aG0gPSBcImJ0cmVlXCIpIHtcbiAgICByZXR1cm4gbmV3IFRpbWVzdGFtcENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpbmRleFR5cGU6IGFsZ29yaXRobSB9KVxuICAgICk7XG4gIH1cbiAgdW5pcXVlKCkge1xuICAgIHJldHVybiBuZXcgVGltZXN0YW1wQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGlzVW5pcXVlOiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBwcmltYXJ5S2V5KCkge1xuICAgIHJldHVybiBuZXcgVGltZXN0YW1wQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGlzUHJpbWFyeUtleTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgYXV0b0luYygpIHtcbiAgICByZXR1cm4gbmV3IFRpbWVzdGFtcENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpc0F1dG9JbmNyZW1lbnQ6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGRlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IFRpbWVzdGFtcENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBkZWZhdWx0VmFsdWU6IHZhbHVlIH0pXG4gICAgKTtcbiAgfVxuICBuYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IFRpbWVzdGFtcENvbHVtbkJ1aWxkZXIodGhpcywgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBuYW1lIH0pKTtcbiAgfVxufTtcbnZhciBUaW1lRHVyYXRpb25CdWlsZGVyID0gY2xhc3MgZXh0ZW5kcyBUeXBlQnVpbGRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFRpbWVEdXJhdGlvbi5nZXRBbGdlYnJhaWNUeXBlKCkpO1xuICB9XG4gIGluZGV4KGFsZ29yaXRobSA9IFwiYnRyZWVcIikge1xuICAgIHJldHVybiBuZXcgVGltZUR1cmF0aW9uQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGluZGV4VHlwZTogYWxnb3JpdGhtIH0pXG4gICAgKTtcbiAgfVxuICB1bmlxdWUoKSB7XG4gICAgcmV0dXJuIG5ldyBUaW1lRHVyYXRpb25Db2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNVbmlxdWU6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIHByaW1hcnlLZXkoKSB7XG4gICAgcmV0dXJuIG5ldyBUaW1lRHVyYXRpb25Db2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNQcmltYXJ5S2V5OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBhdXRvSW5jKCkge1xuICAgIHJldHVybiBuZXcgVGltZUR1cmF0aW9uQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGlzQXV0b0luY3JlbWVudDogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgZGVmYXVsdCh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgVGltZUR1cmF0aW9uQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGRlZmF1bHRWYWx1ZTogdmFsdWUgfSlcbiAgICApO1xuICB9XG4gIG5hbWUobmFtZSkge1xuICAgIHJldHVybiBuZXcgVGltZUR1cmF0aW9uQ29sdW1uQnVpbGRlcih0aGlzLCBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IG5hbWUgfSkpO1xuICB9XG59O1xudmFyIFV1aWRCdWlsZGVyID0gY2xhc3MgZXh0ZW5kcyBUeXBlQnVpbGRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFV1aWQuZ2V0QWxnZWJyYWljVHlwZSgpKTtcbiAgfVxuICBpbmRleChhbGdvcml0aG0gPSBcImJ0cmVlXCIpIHtcbiAgICByZXR1cm4gbmV3IFV1aWRDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaW5kZXhUeXBlOiBhbGdvcml0aG0gfSlcbiAgICApO1xuICB9XG4gIHVuaXF1ZSgpIHtcbiAgICByZXR1cm4gbmV3IFV1aWRDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNVbmlxdWU6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIHByaW1hcnlLZXkoKSB7XG4gICAgcmV0dXJuIG5ldyBVdWlkQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGlzUHJpbWFyeUtleTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgYXV0b0luYygpIHtcbiAgICByZXR1cm4gbmV3IFV1aWRDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNBdXRvSW5jcmVtZW50OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBVdWlkQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGRlZmF1bHRWYWx1ZTogdmFsdWUgfSlcbiAgICApO1xuICB9XG59O1xudmFyIGRlZmF1bHRNZXRhZGF0YSA9IHt9O1xudmFyIENvbHVtbkJ1aWxkZXIgPSBjbGFzcyB7XG4gIHR5cGVCdWlsZGVyO1xuICBjb2x1bW5NZXRhZGF0YTtcbiAgY29uc3RydWN0b3IodHlwZUJ1aWxkZXIsIG1ldGFkYXRhKSB7XG4gICAgdGhpcy50eXBlQnVpbGRlciA9IHR5cGVCdWlsZGVyO1xuICAgIHRoaXMuY29sdW1uTWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgfVxuICBzZXJpYWxpemUod3JpdGVyLCB2YWx1ZSkge1xuICAgIEFsZ2VicmFpY1R5cGUuc2VyaWFsaXplVmFsdWUod3JpdGVyLCB0aGlzLnR5cGVCdWlsZGVyLmFsZ2VicmFpY1R5cGUsIHZhbHVlKTtcbiAgfVxuICBkZXNlcmlhbGl6ZShyZWFkZXIpIHtcbiAgICByZXR1cm4gQWxnZWJyYWljVHlwZS5kZXNlcmlhbGl6ZVZhbHVlKFxuICAgICAgcmVhZGVyLFxuICAgICAgdGhpcy50eXBlQnVpbGRlci5hbGdlYnJhaWNUeXBlXG4gICAgKTtcbiAgfVxufTtcbnZhciBVOENvbHVtbkJ1aWxkZXIgPSBjbGFzcyBfVThDb2x1bW5CdWlsZGVyIGV4dGVuZHMgQ29sdW1uQnVpbGRlciB7XG4gIGluZGV4KGFsZ29yaXRobSA9IFwiYnRyZWVcIikge1xuICAgIHJldHVybiBuZXcgX1U4Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpbmRleFR5cGU6IGFsZ29yaXRobSB9KVxuICAgICk7XG4gIH1cbiAgdW5pcXVlKCkge1xuICAgIHJldHVybiBuZXcgX1U4Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpc1VuaXF1ZTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgcHJpbWFyeUtleSgpIHtcbiAgICByZXR1cm4gbmV3IF9VOENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaXNQcmltYXJ5S2V5OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBhdXRvSW5jKCkge1xuICAgIHJldHVybiBuZXcgX1U4Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpc0F1dG9JbmNyZW1lbnQ6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGRlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IF9VOENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHtcbiAgICAgICAgZGVmYXVsdFZhbHVlOiB2YWx1ZVxuICAgICAgfSlcbiAgICApO1xuICB9XG4gIG5hbWUobmFtZSkge1xuICAgIHJldHVybiBuZXcgX1U4Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBuYW1lIH0pXG4gICAgKTtcbiAgfVxufTtcbnZhciBVMTZDb2x1bW5CdWlsZGVyID0gY2xhc3MgX1UxNkNvbHVtbkJ1aWxkZXIgZXh0ZW5kcyBDb2x1bW5CdWlsZGVyIHtcbiAgaW5kZXgoYWxnb3JpdGhtID0gXCJidHJlZVwiKSB7XG4gICAgcmV0dXJuIG5ldyBfVTE2Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpbmRleFR5cGU6IGFsZ29yaXRobSB9KVxuICAgICk7XG4gIH1cbiAgdW5pcXVlKCkge1xuICAgIHJldHVybiBuZXcgX1UxNkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaXNVbmlxdWU6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIHByaW1hcnlLZXkoKSB7XG4gICAgcmV0dXJuIG5ldyBfVTE2Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpc1ByaW1hcnlLZXk6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGF1dG9JbmMoKSB7XG4gICAgcmV0dXJuIG5ldyBfVTE2Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpc0F1dG9JbmNyZW1lbnQ6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGRlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IF9VMTZDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7XG4gICAgICAgIGRlZmF1bHRWYWx1ZTogdmFsdWVcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICBuYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IF9VMTZDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IG5hbWUgfSlcbiAgICApO1xuICB9XG59O1xudmFyIFUzMkNvbHVtbkJ1aWxkZXIgPSBjbGFzcyBfVTMyQ29sdW1uQnVpbGRlciBleHRlbmRzIENvbHVtbkJ1aWxkZXIge1xuICBpbmRleChhbGdvcml0aG0gPSBcImJ0cmVlXCIpIHtcbiAgICByZXR1cm4gbmV3IF9VMzJDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGluZGV4VHlwZTogYWxnb3JpdGhtIH0pXG4gICAgKTtcbiAgfVxuICB1bmlxdWUoKSB7XG4gICAgcmV0dXJuIG5ldyBfVTMyQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpc1VuaXF1ZTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgcHJpbWFyeUtleSgpIHtcbiAgICByZXR1cm4gbmV3IF9VMzJDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGlzUHJpbWFyeUtleTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgYXV0b0luYygpIHtcbiAgICByZXR1cm4gbmV3IF9VMzJDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGlzQXV0b0luY3JlbWVudDogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgZGVmYXVsdCh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgX1UzMkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHtcbiAgICAgICAgZGVmYXVsdFZhbHVlOiB2YWx1ZVxuICAgICAgfSlcbiAgICApO1xuICB9XG4gIG5hbWUobmFtZSkge1xuICAgIHJldHVybiBuZXcgX1UzMkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgbmFtZSB9KVxuICAgICk7XG4gIH1cbn07XG52YXIgVTY0Q29sdW1uQnVpbGRlciA9IGNsYXNzIF9VNjRDb2x1bW5CdWlsZGVyIGV4dGVuZHMgQ29sdW1uQnVpbGRlciB7XG4gIGluZGV4KGFsZ29yaXRobSA9IFwiYnRyZWVcIikge1xuICAgIHJldHVybiBuZXcgX1U2NENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaW5kZXhUeXBlOiBhbGdvcml0aG0gfSlcbiAgICApO1xuICB9XG4gIHVuaXF1ZSgpIHtcbiAgICByZXR1cm4gbmV3IF9VNjRDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGlzVW5pcXVlOiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBwcmltYXJ5S2V5KCkge1xuICAgIHJldHVybiBuZXcgX1U2NENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaXNQcmltYXJ5S2V5OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBhdXRvSW5jKCkge1xuICAgIHJldHVybiBuZXcgX1U2NENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaXNBdXRvSW5jcmVtZW50OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBfVTY0Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwge1xuICAgICAgICBkZWZhdWx0VmFsdWU6IHZhbHVlXG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgbmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBfVTY0Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBuYW1lIH0pXG4gICAgKTtcbiAgfVxufTtcbnZhciBVMTI4Q29sdW1uQnVpbGRlciA9IGNsYXNzIF9VMTI4Q29sdW1uQnVpbGRlciBleHRlbmRzIENvbHVtbkJ1aWxkZXIge1xuICBpbmRleChhbGdvcml0aG0gPSBcImJ0cmVlXCIpIHtcbiAgICByZXR1cm4gbmV3IF9VMTI4Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpbmRleFR5cGU6IGFsZ29yaXRobSB9KVxuICAgICk7XG4gIH1cbiAgdW5pcXVlKCkge1xuICAgIHJldHVybiBuZXcgX1UxMjhDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGlzVW5pcXVlOiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBwcmltYXJ5S2V5KCkge1xuICAgIHJldHVybiBuZXcgX1UxMjhDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGlzUHJpbWFyeUtleTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgYXV0b0luYygpIHtcbiAgICByZXR1cm4gbmV3IF9VMTI4Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpc0F1dG9JbmNyZW1lbnQ6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGRlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IF9VMTI4Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwge1xuICAgICAgICBkZWZhdWx0VmFsdWU6IHZhbHVlXG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgbmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBfVTEyOENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgbmFtZSB9KVxuICAgICk7XG4gIH1cbn07XG52YXIgVTI1NkNvbHVtbkJ1aWxkZXIgPSBjbGFzcyBfVTI1NkNvbHVtbkJ1aWxkZXIgZXh0ZW5kcyBDb2x1bW5CdWlsZGVyIHtcbiAgaW5kZXgoYWxnb3JpdGhtID0gXCJidHJlZVwiKSB7XG4gICAgcmV0dXJuIG5ldyBfVTI1NkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaW5kZXhUeXBlOiBhbGdvcml0aG0gfSlcbiAgICApO1xuICB9XG4gIHVuaXF1ZSgpIHtcbiAgICByZXR1cm4gbmV3IF9VMjU2Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpc1VuaXF1ZTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgcHJpbWFyeUtleSgpIHtcbiAgICByZXR1cm4gbmV3IF9VMjU2Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpc1ByaW1hcnlLZXk6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGF1dG9JbmMoKSB7XG4gICAgcmV0dXJuIG5ldyBfVTI1NkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaXNBdXRvSW5jcmVtZW50OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBfVTI1NkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHtcbiAgICAgICAgZGVmYXVsdFZhbHVlOiB2YWx1ZVxuICAgICAgfSlcbiAgICApO1xuICB9XG4gIG5hbWUobmFtZSkge1xuICAgIHJldHVybiBuZXcgX1UyNTZDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IG5hbWUgfSlcbiAgICApO1xuICB9XG59O1xudmFyIEk4Q29sdW1uQnVpbGRlciA9IGNsYXNzIF9JOENvbHVtbkJ1aWxkZXIgZXh0ZW5kcyBDb2x1bW5CdWlsZGVyIHtcbiAgaW5kZXgoYWxnb3JpdGhtID0gXCJidHJlZVwiKSB7XG4gICAgcmV0dXJuIG5ldyBfSThDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGluZGV4VHlwZTogYWxnb3JpdGhtIH0pXG4gICAgKTtcbiAgfVxuICB1bmlxdWUoKSB7XG4gICAgcmV0dXJuIG5ldyBfSThDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGlzVW5pcXVlOiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBwcmltYXJ5S2V5KCkge1xuICAgIHJldHVybiBuZXcgX0k4Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpc1ByaW1hcnlLZXk6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGF1dG9JbmMoKSB7XG4gICAgcmV0dXJuIG5ldyBfSThDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGlzQXV0b0luY3JlbWVudDogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgZGVmYXVsdCh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgX0k4Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwge1xuICAgICAgICBkZWZhdWx0VmFsdWU6IHZhbHVlXG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgbmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBfSThDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IG5hbWUgfSlcbiAgICApO1xuICB9XG59O1xudmFyIEkxNkNvbHVtbkJ1aWxkZXIgPSBjbGFzcyBfSTE2Q29sdW1uQnVpbGRlciBleHRlbmRzIENvbHVtbkJ1aWxkZXIge1xuICBpbmRleChhbGdvcml0aG0gPSBcImJ0cmVlXCIpIHtcbiAgICByZXR1cm4gbmV3IF9JMTZDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGluZGV4VHlwZTogYWxnb3JpdGhtIH0pXG4gICAgKTtcbiAgfVxuICB1bmlxdWUoKSB7XG4gICAgcmV0dXJuIG5ldyBfSTE2Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpc1VuaXF1ZTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgcHJpbWFyeUtleSgpIHtcbiAgICByZXR1cm4gbmV3IF9JMTZDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGlzUHJpbWFyeUtleTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgYXV0b0luYygpIHtcbiAgICByZXR1cm4gbmV3IF9JMTZDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGlzQXV0b0luY3JlbWVudDogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgZGVmYXVsdCh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgX0kxNkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHtcbiAgICAgICAgZGVmYXVsdFZhbHVlOiB2YWx1ZVxuICAgICAgfSlcbiAgICApO1xuICB9XG4gIG5hbWUobmFtZSkge1xuICAgIHJldHVybiBuZXcgX0kxNkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgbmFtZSB9KVxuICAgICk7XG4gIH1cbn07XG52YXIgSTMyQ29sdW1uQnVpbGRlciA9IGNsYXNzIF9JMzJDb2x1bW5CdWlsZGVyIGV4dGVuZHMgQ29sdW1uQnVpbGRlciB7XG4gIGluZGV4KGFsZ29yaXRobSA9IFwiYnRyZWVcIikge1xuICAgIHJldHVybiBuZXcgX0kzMkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaW5kZXhUeXBlOiBhbGdvcml0aG0gfSlcbiAgICApO1xuICB9XG4gIHVuaXF1ZSgpIHtcbiAgICByZXR1cm4gbmV3IF9JMzJDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGlzVW5pcXVlOiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBwcmltYXJ5S2V5KCkge1xuICAgIHJldHVybiBuZXcgX0kzMkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaXNQcmltYXJ5S2V5OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBhdXRvSW5jKCkge1xuICAgIHJldHVybiBuZXcgX0kzMkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaXNBdXRvSW5jcmVtZW50OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBfSTMyQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwge1xuICAgICAgICBkZWZhdWx0VmFsdWU6IHZhbHVlXG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgbmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBfSTMyQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBuYW1lIH0pXG4gICAgKTtcbiAgfVxufTtcbnZhciBJNjRDb2x1bW5CdWlsZGVyID0gY2xhc3MgX0k2NENvbHVtbkJ1aWxkZXIgZXh0ZW5kcyBDb2x1bW5CdWlsZGVyIHtcbiAgaW5kZXgoYWxnb3JpdGhtID0gXCJidHJlZVwiKSB7XG4gICAgcmV0dXJuIG5ldyBfSTY0Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpbmRleFR5cGU6IGFsZ29yaXRobSB9KVxuICAgICk7XG4gIH1cbiAgdW5pcXVlKCkge1xuICAgIHJldHVybiBuZXcgX0k2NENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaXNVbmlxdWU6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIHByaW1hcnlLZXkoKSB7XG4gICAgcmV0dXJuIG5ldyBfSTY0Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpc1ByaW1hcnlLZXk6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGF1dG9JbmMoKSB7XG4gICAgcmV0dXJuIG5ldyBfSTY0Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpc0F1dG9JbmNyZW1lbnQ6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGRlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IF9JNjRDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7XG4gICAgICAgIGRlZmF1bHRWYWx1ZTogdmFsdWVcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICBuYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IF9JNjRDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IG5hbWUgfSlcbiAgICApO1xuICB9XG59O1xudmFyIEkxMjhDb2x1bW5CdWlsZGVyID0gY2xhc3MgX0kxMjhDb2x1bW5CdWlsZGVyIGV4dGVuZHMgQ29sdW1uQnVpbGRlciB7XG4gIGluZGV4KGFsZ29yaXRobSA9IFwiYnRyZWVcIikge1xuICAgIHJldHVybiBuZXcgX0kxMjhDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGluZGV4VHlwZTogYWxnb3JpdGhtIH0pXG4gICAgKTtcbiAgfVxuICB1bmlxdWUoKSB7XG4gICAgcmV0dXJuIG5ldyBfSTEyOENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaXNVbmlxdWU6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIHByaW1hcnlLZXkoKSB7XG4gICAgcmV0dXJuIG5ldyBfSTEyOENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaXNQcmltYXJ5S2V5OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBhdXRvSW5jKCkge1xuICAgIHJldHVybiBuZXcgX0kxMjhDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGlzQXV0b0luY3JlbWVudDogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgZGVmYXVsdCh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgX0kxMjhDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7XG4gICAgICAgIGRlZmF1bHRWYWx1ZTogdmFsdWVcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICBuYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IF9JMTI4Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBuYW1lIH0pXG4gICAgKTtcbiAgfVxufTtcbnZhciBJMjU2Q29sdW1uQnVpbGRlciA9IGNsYXNzIF9JMjU2Q29sdW1uQnVpbGRlciBleHRlbmRzIENvbHVtbkJ1aWxkZXIge1xuICBpbmRleChhbGdvcml0aG0gPSBcImJ0cmVlXCIpIHtcbiAgICByZXR1cm4gbmV3IF9JMjU2Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpbmRleFR5cGU6IGFsZ29yaXRobSB9KVxuICAgICk7XG4gIH1cbiAgdW5pcXVlKCkge1xuICAgIHJldHVybiBuZXcgX0kyNTZDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGlzVW5pcXVlOiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBwcmltYXJ5S2V5KCkge1xuICAgIHJldHVybiBuZXcgX0kyNTZDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGlzUHJpbWFyeUtleTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgYXV0b0luYygpIHtcbiAgICByZXR1cm4gbmV3IF9JMjU2Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpc0F1dG9JbmNyZW1lbnQ6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGRlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IF9JMjU2Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwge1xuICAgICAgICBkZWZhdWx0VmFsdWU6IHZhbHVlXG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgbmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBfSTI1NkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgbmFtZSB9KVxuICAgICk7XG4gIH1cbn07XG52YXIgRjMyQ29sdW1uQnVpbGRlciA9IGNsYXNzIF9GMzJDb2x1bW5CdWlsZGVyIGV4dGVuZHMgQ29sdW1uQnVpbGRlciB7XG4gIGRlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IF9GMzJDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7XG4gICAgICAgIGRlZmF1bHRWYWx1ZTogdmFsdWVcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICBuYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IF9GMzJDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IG5hbWUgfSlcbiAgICApO1xuICB9XG59O1xudmFyIEY2NENvbHVtbkJ1aWxkZXIgPSBjbGFzcyBfRjY0Q29sdW1uQnVpbGRlciBleHRlbmRzIENvbHVtbkJ1aWxkZXIge1xuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBfRjY0Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwge1xuICAgICAgICBkZWZhdWx0VmFsdWU6IHZhbHVlXG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgbmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBfRjY0Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBuYW1lIH0pXG4gICAgKTtcbiAgfVxufTtcbnZhciBCb29sQ29sdW1uQnVpbGRlciA9IGNsYXNzIF9Cb29sQ29sdW1uQnVpbGRlciBleHRlbmRzIENvbHVtbkJ1aWxkZXIge1xuICBpbmRleChhbGdvcml0aG0gPSBcImJ0cmVlXCIpIHtcbiAgICByZXR1cm4gbmV3IF9Cb29sQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpbmRleFR5cGU6IGFsZ29yaXRobSB9KVxuICAgICk7XG4gIH1cbiAgdW5pcXVlKCkge1xuICAgIHJldHVybiBuZXcgX0Jvb2xDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGlzVW5pcXVlOiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBwcmltYXJ5S2V5KCkge1xuICAgIHJldHVybiBuZXcgX0Jvb2xDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGlzUHJpbWFyeUtleTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgZGVmYXVsdCh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgX0Jvb2xDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7XG4gICAgICAgIGRlZmF1bHRWYWx1ZTogdmFsdWVcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICBuYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IF9Cb29sQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBuYW1lIH0pXG4gICAgKTtcbiAgfVxufTtcbnZhciBTdHJpbmdDb2x1bW5CdWlsZGVyID0gY2xhc3MgX1N0cmluZ0NvbHVtbkJ1aWxkZXIgZXh0ZW5kcyBDb2x1bW5CdWlsZGVyIHtcbiAgaW5kZXgoYWxnb3JpdGhtID0gXCJidHJlZVwiKSB7XG4gICAgcmV0dXJuIG5ldyBfU3RyaW5nQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpbmRleFR5cGU6IGFsZ29yaXRobSB9KVxuICAgICk7XG4gIH1cbiAgdW5pcXVlKCkge1xuICAgIHJldHVybiBuZXcgX1N0cmluZ0NvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaXNVbmlxdWU6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIHByaW1hcnlLZXkoKSB7XG4gICAgcmV0dXJuIG5ldyBfU3RyaW5nQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpc1ByaW1hcnlLZXk6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGRlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IF9TdHJpbmdDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7XG4gICAgICAgIGRlZmF1bHRWYWx1ZTogdmFsdWVcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICBuYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IF9TdHJpbmdDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IG5hbWUgfSlcbiAgICApO1xuICB9XG59O1xudmFyIEFycmF5Q29sdW1uQnVpbGRlciA9IGNsYXNzIF9BcnJheUNvbHVtbkJ1aWxkZXIgZXh0ZW5kcyBDb2x1bW5CdWlsZGVyIHtcbiAgZGVmYXVsdCh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgX0FycmF5Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwge1xuICAgICAgICBkZWZhdWx0VmFsdWU6IHZhbHVlXG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgbmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBfQXJyYXlDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IG5hbWUgfSlcbiAgICApO1xuICB9XG59O1xudmFyIEJ5dGVBcnJheUNvbHVtbkJ1aWxkZXIgPSBjbGFzcyBfQnl0ZUFycmF5Q29sdW1uQnVpbGRlciBleHRlbmRzIENvbHVtbkJ1aWxkZXIge1xuICBjb25zdHJ1Y3RvcihtZXRhZGF0YSkge1xuICAgIHN1cGVyKG5ldyBUeXBlQnVpbGRlcihBbGdlYnJhaWNUeXBlLkFycmF5KEFsZ2VicmFpY1R5cGUuVTgpKSwgbWV0YWRhdGEpO1xuICB9XG4gIGRlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IF9CeXRlQXJyYXlDb2x1bW5CdWlsZGVyKFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgZGVmYXVsdFZhbHVlOiB2YWx1ZSB9KVxuICAgICk7XG4gIH1cbiAgbmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBfQnl0ZUFycmF5Q29sdW1uQnVpbGRlcihzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBuYW1lIH0pKTtcbiAgfVxufTtcbnZhciBPcHRpb25Db2x1bW5CdWlsZGVyID0gY2xhc3MgX09wdGlvbkNvbHVtbkJ1aWxkZXIgZXh0ZW5kcyBDb2x1bW5CdWlsZGVyIHtcbiAgZGVmYXVsdCh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgX09wdGlvbkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHtcbiAgICAgICAgZGVmYXVsdFZhbHVlOiB2YWx1ZVxuICAgICAgfSlcbiAgICApO1xuICB9XG4gIG5hbWUobmFtZSkge1xuICAgIHJldHVybiBuZXcgX09wdGlvbkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgbmFtZSB9KVxuICAgICk7XG4gIH1cbn07XG52YXIgUmVzdWx0Q29sdW1uQnVpbGRlciA9IGNsYXNzIF9SZXN1bHRDb2x1bW5CdWlsZGVyIGV4dGVuZHMgQ29sdW1uQnVpbGRlciB7XG4gIGNvbnN0cnVjdG9yKHR5cGVCdWlsZGVyLCBtZXRhZGF0YSkge1xuICAgIHN1cGVyKHR5cGVCdWlsZGVyLCBtZXRhZGF0YSk7XG4gIH1cbiAgZGVmYXVsdCh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgX1Jlc3VsdENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHtcbiAgICAgICAgZGVmYXVsdFZhbHVlOiB2YWx1ZVxuICAgICAgfSlcbiAgICApO1xuICB9XG59O1xudmFyIFByb2R1Y3RDb2x1bW5CdWlsZGVyID0gY2xhc3MgX1Byb2R1Y3RDb2x1bW5CdWlsZGVyIGV4dGVuZHMgQ29sdW1uQnVpbGRlciB7XG4gIGRlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IF9Qcm9kdWN0Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBkZWZhdWx0VmFsdWU6IHZhbHVlIH0pXG4gICAgKTtcbiAgfVxuICBuYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IF9Qcm9kdWN0Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBuYW1lIH0pXG4gICAgKTtcbiAgfVxufTtcbnZhciBTdW1Db2x1bW5CdWlsZGVyID0gY2xhc3MgX1N1bUNvbHVtbkJ1aWxkZXIgZXh0ZW5kcyBDb2x1bW5CdWlsZGVyIHtcbiAgZGVmYXVsdCh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgX1N1bUNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgZGVmYXVsdFZhbHVlOiB2YWx1ZSB9KVxuICAgICk7XG4gIH1cbiAgbmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBfU3VtQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBuYW1lIH0pXG4gICAgKTtcbiAgfVxufTtcbnZhciBTaW1wbGVTdW1Db2x1bW5CdWlsZGVyID0gY2xhc3MgX1NpbXBsZVN1bUNvbHVtbkJ1aWxkZXIgZXh0ZW5kcyBTdW1Db2x1bW5CdWlsZGVyIHtcbiAgaW5kZXgoYWxnb3JpdGhtID0gXCJidHJlZVwiKSB7XG4gICAgcmV0dXJuIG5ldyBfU2ltcGxlU3VtQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpbmRleFR5cGU6IGFsZ29yaXRobSB9KVxuICAgICk7XG4gIH1cbiAgcHJpbWFyeUtleSgpIHtcbiAgICByZXR1cm4gbmV3IF9TaW1wbGVTdW1Db2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGlzUHJpbWFyeUtleTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbn07XG52YXIgU2NoZWR1bGVBdENvbHVtbkJ1aWxkZXIgPSBjbGFzcyBfU2NoZWR1bGVBdENvbHVtbkJ1aWxkZXIgZXh0ZW5kcyBDb2x1bW5CdWlsZGVyIHtcbiAgZGVmYXVsdCh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgX1NjaGVkdWxlQXRDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGRlZmF1bHRWYWx1ZTogdmFsdWUgfSlcbiAgICApO1xuICB9XG4gIG5hbWUobmFtZSkge1xuICAgIHJldHVybiBuZXcgX1NjaGVkdWxlQXRDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IG5hbWUgfSlcbiAgICApO1xuICB9XG59O1xudmFyIElkZW50aXR5Q29sdW1uQnVpbGRlciA9IGNsYXNzIF9JZGVudGl0eUNvbHVtbkJ1aWxkZXIgZXh0ZW5kcyBDb2x1bW5CdWlsZGVyIHtcbiAgaW5kZXgoYWxnb3JpdGhtID0gXCJidHJlZVwiKSB7XG4gICAgcmV0dXJuIG5ldyBfSWRlbnRpdHlDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGluZGV4VHlwZTogYWxnb3JpdGhtIH0pXG4gICAgKTtcbiAgfVxuICB1bmlxdWUoKSB7XG4gICAgcmV0dXJuIG5ldyBfSWRlbnRpdHlDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGlzVW5pcXVlOiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBwcmltYXJ5S2V5KCkge1xuICAgIHJldHVybiBuZXcgX0lkZW50aXR5Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpc1ByaW1hcnlLZXk6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGRlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IF9JZGVudGl0eUNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgZGVmYXVsdFZhbHVlOiB2YWx1ZSB9KVxuICAgICk7XG4gIH1cbiAgbmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBfSWRlbnRpdHlDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IG5hbWUgfSlcbiAgICApO1xuICB9XG59O1xudmFyIENvbm5lY3Rpb25JZENvbHVtbkJ1aWxkZXIgPSBjbGFzcyBfQ29ubmVjdGlvbklkQ29sdW1uQnVpbGRlciBleHRlbmRzIENvbHVtbkJ1aWxkZXIge1xuICBpbmRleChhbGdvcml0aG0gPSBcImJ0cmVlXCIpIHtcbiAgICByZXR1cm4gbmV3IF9Db25uZWN0aW9uSWRDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGluZGV4VHlwZTogYWxnb3JpdGhtIH0pXG4gICAgKTtcbiAgfVxuICB1bmlxdWUoKSB7XG4gICAgcmV0dXJuIG5ldyBfQ29ubmVjdGlvbklkQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpc1VuaXF1ZTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgcHJpbWFyeUtleSgpIHtcbiAgICByZXR1cm4gbmV3IF9Db25uZWN0aW9uSWRDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGlzUHJpbWFyeUtleTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgZGVmYXVsdCh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgX0Nvbm5lY3Rpb25JZENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgZGVmYXVsdFZhbHVlOiB2YWx1ZSB9KVxuICAgICk7XG4gIH1cbiAgbmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBfQ29ubmVjdGlvbklkQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBuYW1lIH0pXG4gICAgKTtcbiAgfVxufTtcbnZhciBUaW1lc3RhbXBDb2x1bW5CdWlsZGVyID0gY2xhc3MgX1RpbWVzdGFtcENvbHVtbkJ1aWxkZXIgZXh0ZW5kcyBDb2x1bW5CdWlsZGVyIHtcbiAgaW5kZXgoYWxnb3JpdGhtID0gXCJidHJlZVwiKSB7XG4gICAgcmV0dXJuIG5ldyBfVGltZXN0YW1wQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpbmRleFR5cGU6IGFsZ29yaXRobSB9KVxuICAgICk7XG4gIH1cbiAgdW5pcXVlKCkge1xuICAgIHJldHVybiBuZXcgX1RpbWVzdGFtcENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaXNVbmlxdWU6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIHByaW1hcnlLZXkoKSB7XG4gICAgcmV0dXJuIG5ldyBfVGltZXN0YW1wQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpc1ByaW1hcnlLZXk6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGRlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IF9UaW1lc3RhbXBDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGRlZmF1bHRWYWx1ZTogdmFsdWUgfSlcbiAgICApO1xuICB9XG4gIG5hbWUobmFtZSkge1xuICAgIHJldHVybiBuZXcgX1RpbWVzdGFtcENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgbmFtZSB9KVxuICAgICk7XG4gIH1cbn07XG52YXIgVGltZUR1cmF0aW9uQ29sdW1uQnVpbGRlciA9IGNsYXNzIF9UaW1lRHVyYXRpb25Db2x1bW5CdWlsZGVyIGV4dGVuZHMgQ29sdW1uQnVpbGRlciB7XG4gIGluZGV4KGFsZ29yaXRobSA9IFwiYnRyZWVcIikge1xuICAgIHJldHVybiBuZXcgX1RpbWVEdXJhdGlvbkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaW5kZXhUeXBlOiBhbGdvcml0aG0gfSlcbiAgICApO1xuICB9XG4gIHVuaXF1ZSgpIHtcbiAgICByZXR1cm4gbmV3IF9UaW1lRHVyYXRpb25Db2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGlzVW5pcXVlOiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBwcmltYXJ5S2V5KCkge1xuICAgIHJldHVybiBuZXcgX1RpbWVEdXJhdGlvbkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaXNQcmltYXJ5S2V5OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBfVGltZUR1cmF0aW9uQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBkZWZhdWx0VmFsdWU6IHZhbHVlIH0pXG4gICAgKTtcbiAgfVxuICBuYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IF9UaW1lRHVyYXRpb25Db2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IG5hbWUgfSlcbiAgICApO1xuICB9XG59O1xudmFyIFV1aWRDb2x1bW5CdWlsZGVyID0gY2xhc3MgX1V1aWRDb2x1bW5CdWlsZGVyIGV4dGVuZHMgQ29sdW1uQnVpbGRlciB7XG4gIGluZGV4KGFsZ29yaXRobSA9IFwiYnRyZWVcIikge1xuICAgIHJldHVybiBuZXcgX1V1aWRDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGluZGV4VHlwZTogYWxnb3JpdGhtIH0pXG4gICAgKTtcbiAgfVxuICB1bmlxdWUoKSB7XG4gICAgcmV0dXJuIG5ldyBfVXVpZENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaXNVbmlxdWU6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIHByaW1hcnlLZXkoKSB7XG4gICAgcmV0dXJuIG5ldyBfVXVpZENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaXNQcmltYXJ5S2V5OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBfVXVpZENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgZGVmYXVsdFZhbHVlOiB2YWx1ZSB9KVxuICAgICk7XG4gIH1cbn07XG52YXIgUmVmQnVpbGRlciA9IGNsYXNzIGV4dGVuZHMgVHlwZUJ1aWxkZXIge1xuICByZWY7XG4gIC8qKiBUaGUgcGhhbnRvbSB0eXBlIG9mIHRoZSBwb2ludGVlIG9mIHRoaXMgcmVmLiAqL1xuICBfX3NwYWNldGltZVR5cGU7XG4gIGNvbnN0cnVjdG9yKHJlZikge1xuICAgIHN1cGVyKEFsZ2VicmFpY1R5cGUuUmVmKHJlZikpO1xuICAgIHRoaXMucmVmID0gcmVmO1xuICB9XG59O1xudmFyIGVudW1JbXBsID0gKChuYW1lT3JPYmosIG1heWJlT2JqKSA9PiB7XG4gIGxldCBvYmogPSBuYW1lT3JPYmo7XG4gIGxldCBuYW1lID0gdm9pZCAwO1xuICBpZiAodHlwZW9mIG5hbWVPck9iaiA9PT0gXCJzdHJpbmdcIikge1xuICAgIGlmICghbWF5YmVPYmopIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgIFwiV2hlbiBwcm92aWRpbmcgYSBuYW1lLCB5b3UgbXVzdCBhbHNvIHByb3ZpZGUgdGhlIHZhcmlhbnRzIG9iamVjdCBvciBhcnJheS5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgb2JqID0gbWF5YmVPYmo7XG4gICAgbmFtZSA9IG5hbWVPck9iajtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgY29uc3Qgc2ltcGxlVmFyaWFudHNPYmogPSB7fTtcbiAgICBmb3IgKGNvbnN0IHZhcmlhbnQgb2Ygb2JqKSB7XG4gICAgICBzaW1wbGVWYXJpYW50c09ialt2YXJpYW50XSA9IG5ldyBVbml0QnVpbGRlcigpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFNpbXBsZVN1bUJ1aWxkZXJJbXBsKHNpbXBsZVZhcmlhbnRzT2JqLCBuYW1lKTtcbiAgfVxuICByZXR1cm4gbmV3IFN1bUJ1aWxkZXIob2JqLCBuYW1lKTtcbn0pO1xudmFyIHQgPSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGBCb29sYCB7QGxpbmsgQWxnZWJyYWljVHlwZX0gdG8gYmUgdXNlZCBpbiB0YWJsZSBkZWZpbml0aW9uc1xuICAgKiBSZXByZXNlbnRlZCBhcyBgYm9vbGVhbmAgaW4gVHlwZVNjcmlwdC5cbiAgICogQHJldHVybnMgQSBuZXcge0BsaW5rIEJvb2xCdWlsZGVyfSBpbnN0YW5jZVxuICAgKi9cbiAgYm9vbDogKCkgPT4gbmV3IEJvb2xCdWlsZGVyKCksXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGBTdHJpbmdgIHtAbGluayBBbGdlYnJhaWNUeXBlfSB0byBiZSB1c2VkIGluIHRhYmxlIGRlZmluaXRpb25zXG4gICAqIFJlcHJlc2VudGVkIGFzIGBzdHJpbmdgIGluIFR5cGVTY3JpcHQuXG4gICAqIEByZXR1cm5zIEEgbmV3IHtAbGluayBTdHJpbmdCdWlsZGVyfSBpbnN0YW5jZVxuICAgKi9cbiAgc3RyaW5nOiAoKSA9PiBuZXcgU3RyaW5nQnVpbGRlcigpLFxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBgRjY0YCB7QGxpbmsgQWxnZWJyYWljVHlwZX0gdG8gYmUgdXNlZCBpbiB0YWJsZSBkZWZpbml0aW9uc1xuICAgKiBSZXByZXNlbnRlZCBhcyBgbnVtYmVyYCBpbiBUeXBlU2NyaXB0LlxuICAgKiBAcmV0dXJucyBBIG5ldyB7QGxpbmsgRjY0QnVpbGRlcn0gaW5zdGFuY2VcbiAgICovXG4gIG51bWJlcjogKCkgPT4gbmV3IEY2NEJ1aWxkZXIoKSxcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgYEk4YCB7QGxpbmsgQWxnZWJyYWljVHlwZX0gdG8gYmUgdXNlZCBpbiB0YWJsZSBkZWZpbml0aW9uc1xuICAgKiBSZXByZXNlbnRlZCBhcyBgbnVtYmVyYCBpbiBUeXBlU2NyaXB0LlxuICAgKiBAcmV0dXJucyBBIG5ldyB7QGxpbmsgSThCdWlsZGVyfSBpbnN0YW5jZVxuICAgKi9cbiAgaTg6ICgpID0+IG5ldyBJOEJ1aWxkZXIoKSxcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgYFU4YCB7QGxpbmsgQWxnZWJyYWljVHlwZX0gdG8gYmUgdXNlZCBpbiB0YWJsZSBkZWZpbml0aW9uc1xuICAgKiBSZXByZXNlbnRlZCBhcyBgbnVtYmVyYCBpbiBUeXBlU2NyaXB0LlxuICAgKiBAcmV0dXJucyBBIG5ldyB7QGxpbmsgVThCdWlsZGVyfSBpbnN0YW5jZVxuICAgKi9cbiAgdTg6ICgpID0+IG5ldyBVOEJ1aWxkZXIoKSxcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgYEkxNmAge0BsaW5rIEFsZ2VicmFpY1R5cGV9IHRvIGJlIHVzZWQgaW4gdGFibGUgZGVmaW5pdGlvbnNcbiAgICogUmVwcmVzZW50ZWQgYXMgYG51bWJlcmAgaW4gVHlwZVNjcmlwdC5cbiAgICogQHJldHVybnMgQSBuZXcge0BsaW5rIEkxNkJ1aWxkZXJ9IGluc3RhbmNlXG4gICAqL1xuICBpMTY6ICgpID0+IG5ldyBJMTZCdWlsZGVyKCksXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGBVMTZgIHtAbGluayBBbGdlYnJhaWNUeXBlfSB0byBiZSB1c2VkIGluIHRhYmxlIGRlZmluaXRpb25zXG4gICAqIFJlcHJlc2VudGVkIGFzIGBudW1iZXJgIGluIFR5cGVTY3JpcHQuXG4gICAqIEByZXR1cm5zIEEgbmV3IHtAbGluayBVMTZCdWlsZGVyfSBpbnN0YW5jZVxuICAgKi9cbiAgdTE2OiAoKSA9PiBuZXcgVTE2QnVpbGRlcigpLFxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBgSTMyYCB7QGxpbmsgQWxnZWJyYWljVHlwZX0gdG8gYmUgdXNlZCBpbiB0YWJsZSBkZWZpbml0aW9uc1xuICAgKiBSZXByZXNlbnRlZCBhcyBgbnVtYmVyYCBpbiBUeXBlU2NyaXB0LlxuICAgKiBAcmV0dXJucyBBIG5ldyB7QGxpbmsgSTMyQnVpbGRlcn0gaW5zdGFuY2VcbiAgICovXG4gIGkzMjogKCkgPT4gbmV3IEkzMkJ1aWxkZXIoKSxcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgYFUzMmAge0BsaW5rIEFsZ2VicmFpY1R5cGV9IHRvIGJlIHVzZWQgaW4gdGFibGUgZGVmaW5pdGlvbnNcbiAgICogUmVwcmVzZW50ZWQgYXMgYG51bWJlcmAgaW4gVHlwZVNjcmlwdC5cbiAgICogQHJldHVybnMgQSBuZXcge0BsaW5rIFUzMkJ1aWxkZXJ9IGluc3RhbmNlXG4gICAqL1xuICB1MzI6ICgpID0+IG5ldyBVMzJCdWlsZGVyKCksXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGBJNjRgIHtAbGluayBBbGdlYnJhaWNUeXBlfSB0byBiZSB1c2VkIGluIHRhYmxlIGRlZmluaXRpb25zXG4gICAqIFJlcHJlc2VudGVkIGFzIGBiaWdpbnRgIGluIFR5cGVTY3JpcHQuXG4gICAqIEByZXR1cm5zIEEgbmV3IHtAbGluayBJNjRCdWlsZGVyfSBpbnN0YW5jZVxuICAgKi9cbiAgaTY0OiAoKSA9PiBuZXcgSTY0QnVpbGRlcigpLFxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBgVTY0YCB7QGxpbmsgQWxnZWJyYWljVHlwZX0gdG8gYmUgdXNlZCBpbiB0YWJsZSBkZWZpbml0aW9uc1xuICAgKiBSZXByZXNlbnRlZCBhcyBgYmlnaW50YCBpbiBUeXBlU2NyaXB0LlxuICAgKiBAcmV0dXJucyBBIG5ldyB7QGxpbmsgVTY0QnVpbGRlcn0gaW5zdGFuY2VcbiAgICovXG4gIHU2NDogKCkgPT4gbmV3IFU2NEJ1aWxkZXIoKSxcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgYEkxMjhgIHtAbGluayBBbGdlYnJhaWNUeXBlfSB0byBiZSB1c2VkIGluIHRhYmxlIGRlZmluaXRpb25zXG4gICAqIFJlcHJlc2VudGVkIGFzIGBiaWdpbnRgIGluIFR5cGVTY3JpcHQuXG4gICAqIEByZXR1cm5zIEEgbmV3IHtAbGluayBJMTI4QnVpbGRlcn0gaW5zdGFuY2VcbiAgICovXG4gIGkxMjg6ICgpID0+IG5ldyBJMTI4QnVpbGRlcigpLFxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBgVTEyOGAge0BsaW5rIEFsZ2VicmFpY1R5cGV9IHRvIGJlIHVzZWQgaW4gdGFibGUgZGVmaW5pdGlvbnNcbiAgICogUmVwcmVzZW50ZWQgYXMgYGJpZ2ludGAgaW4gVHlwZVNjcmlwdC5cbiAgICogQHJldHVybnMgQSBuZXcge0BsaW5rIFUxMjhCdWlsZGVyfSBpbnN0YW5jZVxuICAgKi9cbiAgdTEyODogKCkgPT4gbmV3IFUxMjhCdWlsZGVyKCksXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGBJMjU2YCB7QGxpbmsgQWxnZWJyYWljVHlwZX0gdG8gYmUgdXNlZCBpbiB0YWJsZSBkZWZpbml0aW9uc1xuICAgKiBSZXByZXNlbnRlZCBhcyBgYmlnaW50YCBpbiBUeXBlU2NyaXB0LlxuICAgKiBAcmV0dXJucyBBIG5ldyB7QGxpbmsgSTI1NkJ1aWxkZXJ9IGluc3RhbmNlXG4gICAqL1xuICBpMjU2OiAoKSA9PiBuZXcgSTI1NkJ1aWxkZXIoKSxcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgYFUyNTZgIHtAbGluayBBbGdlYnJhaWNUeXBlfSB0byBiZSB1c2VkIGluIHRhYmxlIGRlZmluaXRpb25zXG4gICAqIFJlcHJlc2VudGVkIGFzIGBiaWdpbnRgIGluIFR5cGVTY3JpcHQuXG4gICAqIEByZXR1cm5zIEEgbmV3IHtAbGluayBVMjU2QnVpbGRlcn0gaW5zdGFuY2VcbiAgICovXG4gIHUyNTY6ICgpID0+IG5ldyBVMjU2QnVpbGRlcigpLFxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBgRjMyYCB7QGxpbmsgQWxnZWJyYWljVHlwZX0gdG8gYmUgdXNlZCBpbiB0YWJsZSBkZWZpbml0aW9uc1xuICAgKiBSZXByZXNlbnRlZCBhcyBgbnVtYmVyYCBpbiBUeXBlU2NyaXB0LlxuICAgKiBAcmV0dXJucyBBIG5ldyB7QGxpbmsgRjMyQnVpbGRlcn0gaW5zdGFuY2VcbiAgICovXG4gIGYzMjogKCkgPT4gbmV3IEYzMkJ1aWxkZXIoKSxcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgYEY2NGAge0BsaW5rIEFsZ2VicmFpY1R5cGV9IHRvIGJlIHVzZWQgaW4gdGFibGUgZGVmaW5pdGlvbnNcbiAgICogUmVwcmVzZW50ZWQgYXMgYG51bWJlcmAgaW4gVHlwZVNjcmlwdC5cbiAgICogQHJldHVybnMgQSBuZXcge0BsaW5rIEY2NEJ1aWxkZXJ9IGluc3RhbmNlXG4gICAqL1xuICBmNjQ6ICgpID0+IG5ldyBGNjRCdWlsZGVyKCksXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGBQcm9kdWN0YCB7QGxpbmsgQWxnZWJyYWljVHlwZX0gdG8gYmUgdXNlZCBpbiB0YWJsZSBkZWZpbml0aW9ucy4gUHJvZHVjdCB0eXBlcyBpbiBTcGFjZXRpbWVEQlxuICAgKiBhcmUgZXNzZW50aWFsbHkgdGhlIHNhbWUgYXMgb2JqZWN0cyBpbiBKYXZhU2NyaXB0L1R5cGVTY3JpcHQuXG4gICAqIFByb3BlcnRpZXMgb2YgdGhlIG9iamVjdCBtdXN0IGFsc28gYmUge0BsaW5rIFR5cGVCdWlsZGVyfXMuXG4gICAqIFJlcHJlc2VudGVkIGFzIGFuIG9iamVjdCB3aXRoIHNwZWNpZmljIHByb3BlcnRpZXMgaW4gVHlwZVNjcmlwdC5cbiAgICpcbiAgICogQHBhcmFtIG5hbWUgKG9wdGlvbmFsKSBBIGRpc3BsYXkgbmFtZSBmb3IgdGhlIHByb2R1Y3QgdHlwZS4gSWYgb21pdHRlZCwgYW4gYW5vbnltb3VzIHByb2R1Y3QgdHlwZSBpcyBjcmVhdGVkLlxuICAgKiBAcGFyYW0gb2JqIFRoZSBvYmplY3QgZGVmaW5pbmcgdGhlIHByb3BlcnRpZXMgb2YgdGhlIHR5cGUsIHdob3NlIHByb3BlcnR5XG4gICAqIHZhbHVlcyBtdXN0IGJlIHtAbGluayBUeXBlQnVpbGRlcn1zLlxuICAgKiBAcmV0dXJucyBBIG5ldyB7QGxpbmsgUHJvZHVjdEJ1aWxkZXJ9IGluc3RhbmNlLlxuICAgKi9cbiAgb2JqZWN0OiAoKG5hbWVPck9iaiwgbWF5YmVPYmopID0+IHtcbiAgICBpZiAodHlwZW9mIG5hbWVPck9iaiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgaWYgKCFtYXliZU9iaikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIFwiV2hlbiBwcm92aWRpbmcgYSBuYW1lLCB5b3UgbXVzdCBhbHNvIHByb3ZpZGUgdGhlIG9iamVjdC5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBQcm9kdWN0QnVpbGRlcihtYXliZU9iaiwgbmFtZU9yT2JqKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQcm9kdWN0QnVpbGRlcihuYW1lT3JPYmosIHZvaWQgMCk7XG4gIH0pLFxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBgUm93YCB7QGxpbmsgQWxnZWJyYWljVHlwZX0gdG8gYmUgdXNlZCBpbiB0YWJsZSBkZWZpbml0aW9ucy4gUm93IHR5cGVzIGluIFNwYWNldGltZURCXG4gICAqIGFyZSBzaW1pbGFyIHRvIGBQcm9kdWN0YCB0eXBlcywgYnV0IGFyZSBzcGVjaWZpY2FsbHkgdXNlZCB0byBkZWZpbmUgdGhlIHNjaGVtYSBvZiBhIHRhYmxlIHJvdy5cbiAgICogUHJvcGVydGllcyBvZiB0aGUgb2JqZWN0IG11c3QgYWxzbyBiZSB7QGxpbmsgVHlwZUJ1aWxkZXJ9IG9yIHtAbGluayBDb2x1bW5CdWlsZGVyfXMuXG4gICAqXG4gICAqIFlvdSBjYW4gcmVwcmVzZW50IGEgYFJvd2AgYXMgZWl0aGVyIGEge0BsaW5rIFJvd09ian0gb3IgYW4ge0BsaW5rIFJvd0J1aWxkZXJ9IHR5cGUgd2hlblxuICAgKiBkZWZpbmluZyBhIHRhYmxlIHNjaGVtYS5cbiAgICpcbiAgICogVGhlIHtAbGluayBSb3dCdWlsZGVyfSB0eXBlIGlzIHVzZWZ1bCB3aGVuIHlvdSB3YW50IHRvIGNyZWF0ZSBhIHR5cGUgd2hpY2ggY2FuIGJlIHVzZWQgYW55d2hlcmVcbiAgICogYSB7QGxpbmsgVHlwZUJ1aWxkZXJ9IGlzIGFjY2VwdGVkLCBzdWNoIGFzIGluIG5lc3RlZCBvYmplY3RzIG9yIGFycmF5cywgb3IgYXMgdGhlIGFyZ3VtZW50XG4gICAqIHRvIGEgc2NoZWR1bGVkIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gb2JqIFRoZSBvYmplY3QgZGVmaW5pbmcgdGhlIHByb3BlcnRpZXMgb2YgdGhlIHJvdywgd2hvc2UgcHJvcGVydHlcbiAgICogdmFsdWVzIG11c3QgYmUge0BsaW5rIFR5cGVCdWlsZGVyfXMgb3Ige0BsaW5rIENvbHVtbkJ1aWxkZXJ9cy5cbiAgICogQHJldHVybnMgQSBuZXcge0BsaW5rIFJvd0J1aWxkZXJ9IGluc3RhbmNlXG4gICAqL1xuICByb3c6ICgobmFtZU9yT2JqLCBtYXliZU9iaikgPT4ge1xuICAgIGNvbnN0IFtvYmosIG5hbWVdID0gdHlwZW9mIG5hbWVPck9iaiA9PT0gXCJzdHJpbmdcIiA/IFttYXliZU9iaiwgbmFtZU9yT2JqXSA6IFtuYW1lT3JPYmosIHZvaWQgMF07XG4gICAgcmV0dXJuIG5ldyBSb3dCdWlsZGVyKG9iaiwgbmFtZSk7XG4gIH0pLFxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBgQXJyYXlgIHtAbGluayBBbGdlYnJhaWNUeXBlfSB0byBiZSB1c2VkIGluIHRhYmxlIGRlZmluaXRpb25zLlxuICAgKiBSZXByZXNlbnRlZCBhcyBhbiBhcnJheSBpbiBUeXBlU2NyaXB0LlxuICAgKiBAcGFyYW0gZWxlbWVudCBUaGUgZWxlbWVudCB0eXBlIG9mIHRoZSBhcnJheSwgd2hpY2ggbXVzdCBiZSBhIGBUeXBlQnVpbGRlcmAuXG4gICAqIEByZXR1cm5zIEEgbmV3IHtAbGluayBBcnJheUJ1aWxkZXJ9IGluc3RhbmNlXG4gICAqL1xuICBhcnJheShlKSB7XG4gICAgcmV0dXJuIG5ldyBBcnJheUJ1aWxkZXIoZSk7XG4gIH0sXG4gIGVudW06IGVudW1JbXBsLFxuICAvKipcbiAgICogVGhpcyBpcyBhIHNwZWNpYWwgaGVscGVyIGZ1bmN0aW9uIGZvciBjb252ZW5pZW50bHkgY3JlYXRpbmcge0BsaW5rIFByb2R1Y3R9IHR5cGUgY29sdW1ucyB3aXRoIG5vIGZpZWxkcy5cbiAgICpcbiAgICogQHJldHVybnMgQSBuZXcge0BsaW5rIFByb2R1Y3RCdWlsZGVyfSBpbnN0YW5jZSB3aXRoIG5vIGZpZWxkcy5cbiAgICovXG4gIHVuaXQoKSB7XG4gICAgcmV0dXJuIG5ldyBVbml0QnVpbGRlcigpO1xuICB9LFxuICAvKipcbiAgICogQ3JlYXRlcyBhIGxhemlseS1ldmFsdWF0ZWQge0BsaW5rIFR5cGVCdWlsZGVyfS4gVGhpcyBpcyB1c2VmdWwgZm9yIGNyZWF0aW5nXG4gICAqIHJlY3Vyc2l2ZSB0eXBlcywgc3VjaCBhcyBhIHRyZWUgb3IgbGlua2VkIGxpc3QuXG4gICAqIEBwYXJhbSB0aHVuayBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHtAbGluayBUeXBlQnVpbGRlcn0uXG4gICAqIEByZXR1cm5zIEEgcHJveHkge0BsaW5rIFR5cGVCdWlsZGVyfSB0aGF0IGV2YWx1YXRlcyB0aGUgdGh1bmsgb24gZmlyc3QgYWNjZXNzLlxuICAgKi9cbiAgbGF6eSh0aHVuaykge1xuICAgIGxldCBjYWNoZWQgPSBudWxsO1xuICAgIGNvbnN0IGdldCA9ICgpID0+IGNhY2hlZCA/Pz0gdGh1bmsoKTtcbiAgICBjb25zdCBwcm94eSA9IG5ldyBQcm94eSh7fSwge1xuICAgICAgZ2V0KF90LCBwcm9wLCByZWN2KSB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGdldCgpO1xuICAgICAgICBjb25zdCB2YWwgPSBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3AsIHJlY3YpO1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gXCJmdW5jdGlvblwiID8gdmFsLmJpbmQodGFyZ2V0KSA6IHZhbDtcbiAgICAgIH0sXG4gICAgICBzZXQoX3QsIHByb3AsIHZhbHVlLCByZWN2KSB7XG4gICAgICAgIHJldHVybiBSZWZsZWN0LnNldChnZXQoKSwgcHJvcCwgdmFsdWUsIHJlY3YpO1xuICAgICAgfSxcbiAgICAgIGhhcyhfdCwgcHJvcCkge1xuICAgICAgICByZXR1cm4gcHJvcCBpbiBnZXQoKTtcbiAgICAgIH0sXG4gICAgICBvd25LZXlzKCkge1xuICAgICAgICByZXR1cm4gUmVmbGVjdC5vd25LZXlzKGdldCgpKTtcbiAgICAgIH0sXG4gICAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoX3QsIHByb3ApIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZ2V0KCksIHByb3ApO1xuICAgICAgfSxcbiAgICAgIGdldFByb3RvdHlwZU9mKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKGdldCgpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcHJveHk7XG4gIH0sXG4gIC8qKlxuICAgKiBUaGlzIGlzIGEgc3BlY2lhbCBoZWxwZXIgZnVuY3Rpb24gZm9yIGNvbnZlbmllbnRseSBjcmVhdGluZyB7QGxpbmsgU2NoZWR1bGVBdH0gdHlwZSBjb2x1bW5zLlxuICAgKiBAcmV0dXJucyBBIG5ldyBDb2x1bW5CdWlsZGVyIGluc3RhbmNlIHdpdGggdGhlIHtAbGluayBTY2hlZHVsZUF0fSB0eXBlLlxuICAgKi9cbiAgc2NoZWR1bGVBdDogKCkgPT4ge1xuICAgIHJldHVybiBuZXcgU2NoZWR1bGVBdEJ1aWxkZXIoKTtcbiAgfSxcbiAgLyoqXG4gICAqIFRoaXMgaXMgYSBjb252ZW5pZW5jZSBtZXRob2QgZm9yIGNyZWF0aW5nIGEgY29sdW1uIHdpdGggdGhlIHtAbGluayBPcHRpb259IHR5cGUuXG4gICAqIFlvdSBjYW4gY3JlYXRlIGEgY29sdW1uIG9mIHRoZSBzYW1lIHR5cGUgYnkgY29uc3RydWN0aW5nIGFuIGVudW0gd2l0aCBhIGBzb21lYCBhbmQgYG5vbmVgIHZhcmlhbnQuXG4gICAqIEBwYXJhbSB2YWx1ZSBUaGUgdHlwZSBvZiB0aGUgdmFsdWUgY29udGFpbmVkIGluIHRoZSBgc29tZWAgdmFyaWFudCBvZiB0aGUgYE9wdGlvbmAuXG4gICAqIEByZXR1cm5zIEEgbmV3IHtAbGluayBPcHRpb25CdWlsZGVyfSBpbnN0YW5jZSB3aXRoIHRoZSB7QGxpbmsgT3B0aW9ufSB0eXBlLlxuICAgKi9cbiAgb3B0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBPcHRpb25CdWlsZGVyKHZhbHVlKTtcbiAgfSxcbiAgLyoqXG4gICAqIFRoaXMgaXMgYSBjb252ZW5pZW5jZSBtZXRob2QgZm9yIGNyZWF0aW5nIGEgY29sdW1uIHdpdGggdGhlIHtAbGluayBSZXN1bHR9IHR5cGUuXG4gICAqIFlvdSBjYW4gY3JlYXRlIGEgY29sdW1uIG9mIHRoZSBzYW1lIHR5cGUgYnkgY29uc3RydWN0aW5nIGFuIGVudW0gd2l0aCBhbiBgb2tgIGFuZCBgZXJyYCB2YXJpYW50LlxuICAgKiBAcGFyYW0gb2sgVGhlIHR5cGUgb2YgdGhlIHZhbHVlIGNvbnRhaW5lZCBpbiB0aGUgYG9rYCB2YXJpYW50IG9mIHRoZSBgUmVzdWx0YC5cbiAgICogQHBhcmFtIGVyciBUaGUgdHlwZSBvZiB0aGUgdmFsdWUgY29udGFpbmVkIGluIHRoZSBgZXJyYCB2YXJpYW50IG9mIHRoZSBgUmVzdWx0YC5cbiAgICogQHJldHVybnMgQSBuZXcge0BsaW5rIFJlc3VsdEJ1aWxkZXJ9IGluc3RhbmNlIHdpdGggdGhlIHtAbGluayBSZXN1bHR9IHR5cGUuXG4gICAqL1xuICByZXN1bHQob2ssIGVycikge1xuICAgIHJldHVybiBuZXcgUmVzdWx0QnVpbGRlcihvaywgZXJyKTtcbiAgfSxcbiAgLyoqXG4gICAqIFRoaXMgaXMgYSBjb252ZW5pZW5jZSBtZXRob2QgZm9yIGNyZWF0aW5nIGEgY29sdW1uIHdpdGggdGhlIHtAbGluayBJZGVudGl0eX0gdHlwZS5cbiAgICogWW91IGNhbiBjcmVhdGUgYSBjb2x1bW4gb2YgdGhlIHNhbWUgdHlwZSBieSBjb25zdHJ1Y3RpbmcgYW4gYG9iamVjdGAgd2l0aCBhIHNpbmdsZSBgX19pZGVudGl0eV9fYCBlbGVtZW50LlxuICAgKiBAcmV0dXJucyBBIG5ldyB7QGxpbmsgVHlwZUJ1aWxkZXJ9IGluc3RhbmNlIHdpdGggdGhlIHtAbGluayBJZGVudGl0eX0gdHlwZS5cbiAgICovXG4gIGlkZW50aXR5OiAoKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBJZGVudGl0eUJ1aWxkZXIoKTtcbiAgfSxcbiAgLyoqXG4gICAqIFRoaXMgaXMgYSBjb252ZW5pZW5jZSBtZXRob2QgZm9yIGNyZWF0aW5nIGEgY29sdW1uIHdpdGggdGhlIHtAbGluayBDb25uZWN0aW9uSWR9IHR5cGUuXG4gICAqIFlvdSBjYW4gY3JlYXRlIGEgY29sdW1uIG9mIHRoZSBzYW1lIHR5cGUgYnkgY29uc3RydWN0aW5nIGFuIGBvYmplY3RgIHdpdGggYSBzaW5nbGUgYF9fY29ubmVjdGlvbl9pZF9fYCBlbGVtZW50LlxuICAgKiBAcmV0dXJucyBBIG5ldyB7QGxpbmsgVHlwZUJ1aWxkZXJ9IGluc3RhbmNlIHdpdGggdGhlIHtAbGluayBDb25uZWN0aW9uSWR9IHR5cGUuXG4gICAqL1xuICBjb25uZWN0aW9uSWQ6ICgpID0+IHtcbiAgICByZXR1cm4gbmV3IENvbm5lY3Rpb25JZEJ1aWxkZXIoKTtcbiAgfSxcbiAgLyoqXG4gICAqIFRoaXMgaXMgYSBjb252ZW5pZW5jZSBtZXRob2QgZm9yIGNyZWF0aW5nIGEgY29sdW1uIHdpdGggdGhlIHtAbGluayBUaW1lc3RhbXB9IHR5cGUuXG4gICAqIFlvdSBjYW4gY3JlYXRlIGEgY29sdW1uIG9mIHRoZSBzYW1lIHR5cGUgYnkgY29uc3RydWN0aW5nIGFuIGBvYmplY3RgIHdpdGggYSBzaW5nbGUgYF9fdGltZXN0YW1wX21pY3Jvc19zaW5jZV91bml4X2Vwb2NoX19gIGVsZW1lbnQuXG4gICAqIEByZXR1cm5zIEEgbmV3IHtAbGluayBUeXBlQnVpbGRlcn0gaW5zdGFuY2Ugd2l0aCB0aGUge0BsaW5rIFRpbWVzdGFtcH0gdHlwZS5cbiAgICovXG4gIHRpbWVzdGFtcDogKCkgPT4ge1xuICAgIHJldHVybiBuZXcgVGltZXN0YW1wQnVpbGRlcigpO1xuICB9LFxuICAvKipcbiAgICogVGhpcyBpcyBhIGNvbnZlbmllbmNlIG1ldGhvZCBmb3IgY3JlYXRpbmcgYSBjb2x1bW4gd2l0aCB0aGUge0BsaW5rIFRpbWVEdXJhdGlvbn0gdHlwZS5cbiAgICogWW91IGNhbiBjcmVhdGUgYSBjb2x1bW4gb2YgdGhlIHNhbWUgdHlwZSBieSBjb25zdHJ1Y3RpbmcgYW4gYG9iamVjdGAgd2l0aCBhIHNpbmdsZSBgX190aW1lX2R1cmF0aW9uX21pY3Jvc19fYCBlbGVtZW50LlxuICAgKiBAcmV0dXJucyBBIG5ldyB7QGxpbmsgVHlwZUJ1aWxkZXJ9IGluc3RhbmNlIHdpdGggdGhlIHtAbGluayBUaW1lRHVyYXRpb259IHR5cGUuXG4gICAqL1xuICB0aW1lRHVyYXRpb246ICgpID0+IHtcbiAgICByZXR1cm4gbmV3IFRpbWVEdXJhdGlvbkJ1aWxkZXIoKTtcbiAgfSxcbiAgLyoqXG4gICAqIFRoaXMgaXMgYSBjb252ZW5pZW5jZSBtZXRob2QgZm9yIGNyZWF0aW5nIGEgY29sdW1uIHdpdGggdGhlIHtAbGluayBVdWlkfSB0eXBlLlxuICAgKiBZb3UgY2FuIGNyZWF0ZSBhIGNvbHVtbiBvZiB0aGUgc2FtZSB0eXBlIGJ5IGNvbnN0cnVjdGluZyBhbiBgb2JqZWN0YCB3aXRoIGEgc2luZ2xlIGBfX3V1aWRfX2AgZWxlbWVudC5cbiAgICogQHJldHVybnMgQSBuZXcge0BsaW5rIFR5cGVCdWlsZGVyfSBpbnN0YW5jZSB3aXRoIHRoZSB7QGxpbmsgVXVpZH0gdHlwZS5cbiAgICovXG4gIHV1aWQ6ICgpID0+IHtcbiAgICByZXR1cm4gbmV3IFV1aWRCdWlsZGVyKCk7XG4gIH0sXG4gIC8qKlxuICAgKiBUaGlzIGlzIGEgY29udmVuaWVuY2UgbWV0aG9kIGZvciBjcmVhdGluZyBhIGNvbHVtbiB3aXRoIHRoZSB7QGxpbmsgQnl0ZUFycmF5fSB0eXBlLlxuICAgKiBZb3UgY2FuIGNyZWF0ZSBhIGNvbHVtbiBvZiB0aGUgc2FtZSB0eXBlIGJ5IGNvbnN0cnVjdGluZyBhbiBgYXJyYXlgIG9mIGB1OGAuXG4gICAqIFRoZSBUeXBlU2NyaXB0IHJlcHJlc2VudGF0aW9uIGlzIHtAbGluayBVaW50OEFycmF5fS5cbiAgICogQHJldHVybnMgQSBuZXcge0BsaW5rIEJ5dGVBcnJheUJ1aWxkZXJ9IGluc3RhbmNlIHdpdGggdGhlIHtAbGluayBCeXRlQXJyYXl9IHR5cGUuXG4gICAqL1xuICBieXRlQXJyYXk6ICgpID0+IHtcbiAgICByZXR1cm4gbmV3IEJ5dGVBcnJheUJ1aWxkZXIoKTtcbiAgfVxufTtcblxuLy8gc3JjL2xpYi9hdXRvZ2VuL2xpZmVjeWNsZV90eXBlLnRzXG52YXIgTGlmZWN5Y2xlID0gdC5lbnVtKFwiTGlmZWN5Y2xlXCIsIHtcbiAgSW5pdDogdC51bml0KCksXG4gIE9uQ29ubmVjdDogdC51bml0KCksXG4gIE9uRGlzY29ubmVjdDogdC51bml0KClcbn0pO1xudmFyIGxpZmVjeWNsZV90eXBlX2RlZmF1bHQgPSBMaWZlY3ljbGU7XG5cbi8vIHNyYy9saWIvcmVkdWNlcnMudHNcbmZ1bmN0aW9uIHB1c2hSZWR1Y2VyKG5hbWUsIHBhcmFtcywgZm4sIGxpZmVjeWNsZSkge1xuICBpZiAoZXhpc3RpbmdSZWR1Y2Vycy5oYXMobmFtZSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGVyZSBpcyBhbHJlYWR5IGEgcmVkdWNlciB3aXRoIHRoZSBuYW1lICcke25hbWV9J2ApO1xuICB9XG4gIGV4aXN0aW5nUmVkdWNlcnMuYWRkKG5hbWUpO1xuICBpZiAoIShwYXJhbXMgaW5zdGFuY2VvZiBSb3dCdWlsZGVyKSkge1xuICAgIHBhcmFtcyA9IG5ldyBSb3dCdWlsZGVyKHBhcmFtcyk7XG4gIH1cbiAgaWYgKHBhcmFtcy50eXBlTmFtZSA9PT0gdm9pZCAwKSB7XG4gICAgcGFyYW1zLnR5cGVOYW1lID0gdG9QYXNjYWxDYXNlKG5hbWUpO1xuICB9XG4gIGNvbnN0IHJlZiA9IHJlZ2lzdGVyVHlwZXNSZWN1cnNpdmVseShwYXJhbXMpO1xuICBjb25zdCBwYXJhbXNUeXBlID0gcmVzb2x2ZVR5cGUoTU9EVUxFX0RFRi50eXBlc3BhY2UsIHJlZikudmFsdWU7XG4gIE1PRFVMRV9ERUYucmVkdWNlcnMucHVzaCh7XG4gICAgbmFtZSxcbiAgICBwYXJhbXM6IHBhcmFtc1R5cGUsXG4gICAgbGlmZWN5Y2xlXG4gICAgLy8gPC0gbGlmZWN5Y2xlIGZsYWcgbGFuZHMgaGVyZVxuICB9KTtcbiAgaWYgKCFmbi5uYW1lKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCBcIm5hbWVcIiwgeyB2YWx1ZTogbmFtZSwgd3JpdGFibGU6IGZhbHNlIH0pO1xuICB9XG4gIFJFRFVDRVJTLnB1c2goZm4pO1xufVxudmFyIGV4aXN0aW5nUmVkdWNlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xudmFyIFJFRFVDRVJTID0gW107XG5mdW5jdGlvbiByZWR1Y2VyKG5hbWUsIHBhcmFtcywgZm4pIHtcbiAgcHVzaFJlZHVjZXIobmFtZSwgcGFyYW1zLCBmbik7XG59XG5mdW5jdGlvbiBpbml0KG5hbWUsIHBhcmFtcywgZm4pIHtcbiAgcHVzaFJlZHVjZXIobmFtZSwgcGFyYW1zLCBmbiwgbGlmZWN5Y2xlX3R5cGVfZGVmYXVsdC5Jbml0KTtcbn1cbmZ1bmN0aW9uIGNsaWVudENvbm5lY3RlZChuYW1lLCBwYXJhbXMsIGZuKSB7XG4gIHB1c2hSZWR1Y2VyKG5hbWUsIHBhcmFtcywgZm4sIGxpZmVjeWNsZV90eXBlX2RlZmF1bHQuT25Db25uZWN0KTtcbn1cbmZ1bmN0aW9uIGNsaWVudERpc2Nvbm5lY3RlZChuYW1lLCBwYXJhbXMsIGZuKSB7XG4gIHB1c2hSZWR1Y2VyKG5hbWUsIHBhcmFtcywgZm4sIGxpZmVjeWNsZV90eXBlX2RlZmF1bHQuT25EaXNjb25uZWN0KTtcbn1cbnZhciBSZWR1Y2VycyA9IGNsYXNzIHtcbiAgcmVkdWNlcnNUeXBlO1xuICBjb25zdHJ1Y3RvcihoYW5kbGVzKSB7XG4gICAgdGhpcy5yZWR1Y2Vyc1R5cGUgPSByZWR1Y2Vyc1RvU2NoZW1hKGhhbmRsZXMpO1xuICB9XG59O1xuZnVuY3Rpb24gcmVkdWNlcnNUb1NjaGVtYShyZWR1Y2VyczIpIHtcbiAgY29uc3QgbWFwcGVkID0gcmVkdWNlcnMyLm1hcCgocikgPT4ge1xuICAgIGNvbnN0IHBhcmFtc1JvdyA9IHIucGFyYW1zLnJvdztcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogci5yZWR1Y2VyTmFtZSxcbiAgICAgIC8vIFByZWZlciB0aGUgc2NoZW1hJ3Mgb3duIGFjY2Vzc29yTmFtZSBpZiBwcmVzZW50IGF0IHJ1bnRpbWU7IG90aGVyd2lzZSBkZXJpdmUgaXQuXG4gICAgICBhY2Nlc3Nvck5hbWU6IHIuYWNjZXNzb3JOYW1lLFxuICAgICAgcGFyYW1zOiBwYXJhbXNSb3csXG4gICAgICBwYXJhbXNUeXBlOiByLnBhcmFtc1NwYWNldGltZVR5cGVcbiAgICB9O1xuICB9KTtcbiAgY29uc3QgcmVzdWx0ID0geyByZWR1Y2VyczogbWFwcGVkIH07XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiByZWR1Y2VycyguLi5hcmdzKSB7XG4gIGNvbnN0IGhhbmRsZXMgPSBhcmdzLmxlbmd0aCA9PT0gMSAmJiBBcnJheS5pc0FycmF5KGFyZ3NbMF0pID8gYXJnc1swXSA6IGFyZ3M7XG4gIHJldHVybiBuZXcgUmVkdWNlcnMoaGFuZGxlcyk7XG59XG5cbi8vIHNyYy9zZXJ2ZXIvcXVlcnkudHNcbnZhciBRdWVyeUJyYW5kID0gU3ltYm9sKFwiUXVlcnlCcmFuZFwiKTtcbnZhciBpc1Jvd1R5cGVkUXVlcnkgPSAodmFsKSA9PiAhIXZhbCAmJiB0eXBlb2YgdmFsID09PSBcIm9iamVjdFwiICYmIFF1ZXJ5QnJhbmQgaW4gdmFsO1xuZnVuY3Rpb24gdG9TcWwocSkge1xuICByZXR1cm4gcS50b1NxbCgpO1xufVxudmFyIFNlbWlqb2luSW1wbCA9IGNsYXNzIF9TZW1pam9pbkltcGwge1xuICBjb25zdHJ1Y3Rvcihzb3VyY2VRdWVyeSwgZmlsdGVyUXVlcnksIGpvaW5Db25kaXRpb24pIHtcbiAgICB0aGlzLnNvdXJjZVF1ZXJ5ID0gc291cmNlUXVlcnk7XG4gICAgdGhpcy5maWx0ZXJRdWVyeSA9IGZpbHRlclF1ZXJ5O1xuICAgIHRoaXMuam9pbkNvbmRpdGlvbiA9IGpvaW5Db25kaXRpb247XG4gICAgaWYgKHNvdXJjZVF1ZXJ5LnRhYmxlLm5hbWUgPT09IGZpbHRlclF1ZXJ5LnRhYmxlLm5hbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZW1pam9pbiBhIHRhYmxlIHRvIGl0c2VsZlwiKTtcbiAgICB9XG4gIH1cbiAgW1F1ZXJ5QnJhbmRdID0gdHJ1ZTtcbiAgdHlwZSA9IFwic2VtaWpvaW5cIjtcbiAgYnVpbGQoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgd2hlcmUocHJlZGljYXRlKSB7XG4gICAgY29uc3QgbmV4dFNvdXJjZVF1ZXJ5ID0gdGhpcy5zb3VyY2VRdWVyeS53aGVyZShwcmVkaWNhdGUpO1xuICAgIHJldHVybiBuZXcgX1NlbWlqb2luSW1wbChcbiAgICAgIG5leHRTb3VyY2VRdWVyeSxcbiAgICAgIHRoaXMuZmlsdGVyUXVlcnksXG4gICAgICB0aGlzLmpvaW5Db25kaXRpb25cbiAgICApO1xuICB9XG4gIHRvU3FsKCkge1xuICAgIGNvbnN0IGxlZnQgPSB0aGlzLmZpbHRlclF1ZXJ5O1xuICAgIGNvbnN0IHJpZ2h0ID0gdGhpcy5zb3VyY2VRdWVyeTtcbiAgICBjb25zdCBsZWZ0VGFibGUgPSBxdW90ZUlkZW50aWZpZXIobGVmdC50YWJsZS5uYW1lKTtcbiAgICBjb25zdCByaWdodFRhYmxlID0gcXVvdGVJZGVudGlmaWVyKHJpZ2h0LnRhYmxlLm5hbWUpO1xuICAgIGxldCBzcWwgPSBgU0VMRUNUICR7cmlnaHRUYWJsZX0uKiBGUk9NICR7bGVmdFRhYmxlfSBKT0lOICR7cmlnaHRUYWJsZX0gT04gJHtib29sZWFuRXhwclRvU3FsKHRoaXMuam9pbkNvbmRpdGlvbil9YDtcbiAgICBjb25zdCBjbGF1c2VzID0gW107XG4gICAgaWYgKGxlZnQud2hlcmVDbGF1c2UpIHtcbiAgICAgIGNsYXVzZXMucHVzaChib29sZWFuRXhwclRvU3FsKGxlZnQud2hlcmVDbGF1c2UpKTtcbiAgICB9XG4gICAgaWYgKHJpZ2h0LndoZXJlQ2xhdXNlKSB7XG4gICAgICBjbGF1c2VzLnB1c2goYm9vbGVhbkV4cHJUb1NxbChyaWdodC53aGVyZUNsYXVzZSkpO1xuICAgIH1cbiAgICBpZiAoY2xhdXNlcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCB3aGVyZVNxbCA9IGNsYXVzZXMubGVuZ3RoID09PSAxID8gY2xhdXNlc1swXSA6IGNsYXVzZXMubWFwKHdyYXBJblBhcmVucykuam9pbihcIiBBTkQgXCIpO1xuICAgICAgc3FsICs9IGAgV0hFUkUgJHt3aGVyZVNxbH1gO1xuICAgIH1cbiAgICByZXR1cm4gc3FsO1xuICB9XG59O1xudmFyIEZyb21CdWlsZGVyID0gY2xhc3MgX0Zyb21CdWlsZGVyIHtcbiAgY29uc3RydWN0b3IodGFibGUyLCB3aGVyZUNsYXVzZSkge1xuICAgIHRoaXMudGFibGUgPSB0YWJsZTI7XG4gICAgdGhpcy53aGVyZUNsYXVzZSA9IHdoZXJlQ2xhdXNlO1xuICB9XG4gIFtRdWVyeUJyYW5kXSA9IHRydWU7XG4gIHdoZXJlKHByZWRpY2F0ZSkge1xuICAgIGNvbnN0IG5ld0NvbmRpdGlvbiA9IHByZWRpY2F0ZSh0aGlzLnRhYmxlLmNvbHMpO1xuICAgIGNvbnN0IG5leHRXaGVyZSA9IHRoaXMud2hlcmVDbGF1c2UgPyBhbmQodGhpcy53aGVyZUNsYXVzZSwgbmV3Q29uZGl0aW9uKSA6IG5ld0NvbmRpdGlvbjtcbiAgICByZXR1cm4gbmV3IF9Gcm9tQnVpbGRlcih0aGlzLnRhYmxlLCBuZXh0V2hlcmUpO1xuICB9XG4gIHJpZ2h0U2VtaWpvaW4ocmlnaHQsIG9uKSB7XG4gICAgY29uc3Qgc291cmNlUXVlcnkgPSBuZXcgX0Zyb21CdWlsZGVyKHJpZ2h0KTtcbiAgICBjb25zdCBqb2luQ29uZGl0aW9uID0gb24oXG4gICAgICB0aGlzLnRhYmxlLmluZGV4ZWRDb2xzLFxuICAgICAgcmlnaHQuaW5kZXhlZENvbHNcbiAgICApO1xuICAgIHJldHVybiBuZXcgU2VtaWpvaW5JbXBsKHNvdXJjZVF1ZXJ5LCB0aGlzLCBqb2luQ29uZGl0aW9uKTtcbiAgfVxuICBsZWZ0U2VtaWpvaW4ocmlnaHQsIG9uKSB7XG4gICAgY29uc3QgZmlsdGVyUXVlcnkgPSBuZXcgX0Zyb21CdWlsZGVyKHJpZ2h0KTtcbiAgICBjb25zdCBqb2luQ29uZGl0aW9uID0gb24oXG4gICAgICB0aGlzLnRhYmxlLmluZGV4ZWRDb2xzLFxuICAgICAgcmlnaHQuaW5kZXhlZENvbHNcbiAgICApO1xuICAgIHJldHVybiBuZXcgU2VtaWpvaW5JbXBsKHRoaXMsIGZpbHRlclF1ZXJ5LCBqb2luQ29uZGl0aW9uKTtcbiAgfVxuICB0b1NxbCgpIHtcbiAgICByZXR1cm4gcmVuZGVyU2VsZWN0U3FsV2l0aEpvaW5zKHRoaXMudGFibGUsIHRoaXMud2hlcmVDbGF1c2UpO1xuICB9XG4gIGJ1aWxkKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59O1xudmFyIFRhYmxlUmVmSW1wbCA9IGNsYXNzIHtcbiAgdHlwZSA9IFwidGFibGVcIjtcbiAgbmFtZTtcbiAgY29scztcbiAgaW5kZXhlZENvbHM7XG4gIHRhYmxlRGVmO1xuICBjb25zdHJ1Y3Rvcih0YWJsZURlZikge1xuICAgIHRoaXMubmFtZSA9IHRhYmxlRGVmLm5hbWU7XG4gICAgdGhpcy5jb2xzID0gY3JlYXRlUm93RXhwcih0YWJsZURlZik7XG4gICAgdGhpcy5pbmRleGVkQ29scyA9IHRoaXMuY29scztcbiAgICB0aGlzLnRhYmxlRGVmID0gdGFibGVEZWY7XG4gICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgfVxuICBhc0Zyb20oKSB7XG4gICAgcmV0dXJuIG5ldyBGcm9tQnVpbGRlcih0aGlzKTtcbiAgfVxuICByaWdodFNlbWlqb2luKG90aGVyLCBvbikge1xuICAgIHJldHVybiB0aGlzLmFzRnJvbSgpLnJpZ2h0U2VtaWpvaW4ob3RoZXIsIG9uKTtcbiAgfVxuICBsZWZ0U2VtaWpvaW4ob3RoZXIsIG9uKSB7XG4gICAgcmV0dXJuIHRoaXMuYXNGcm9tKCkubGVmdFNlbWlqb2luKG90aGVyLCBvbik7XG4gIH1cbiAgYnVpbGQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXNGcm9tKCkuYnVpbGQoKTtcbiAgfVxuICB0b1NxbCgpIHtcbiAgICByZXR1cm4gdGhpcy5hc0Zyb20oKS50b1NxbCgpO1xuICB9XG4gIHdoZXJlKHByZWRpY2F0ZSkge1xuICAgIHJldHVybiB0aGlzLmFzRnJvbSgpLndoZXJlKHByZWRpY2F0ZSk7XG4gIH1cbn07XG5mdW5jdGlvbiBjcmVhdGVUYWJsZVJlZkZyb21EZWYodGFibGVEZWYpIHtcbiAgcmV0dXJuIG5ldyBUYWJsZVJlZkltcGwodGFibGVEZWYpO1xufVxuZnVuY3Rpb24gbWFrZVF1ZXJ5QnVpbGRlcihzY2hlbWEyKSB7XG4gIGNvbnN0IHFiID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGZvciAoY29uc3QgdGFibGUyIG9mIHNjaGVtYTIudGFibGVzKSB7XG4gICAgY29uc3QgcmVmID0gY3JlYXRlVGFibGVSZWZGcm9tRGVmKFxuICAgICAgdGFibGUyXG4gICAgKTtcbiAgICBxYlt0YWJsZTIubmFtZV0gPSByZWY7XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5mcmVlemUocWIpO1xufVxuZnVuY3Rpb24gY3JlYXRlUm93RXhwcih0YWJsZURlZikge1xuICBjb25zdCByb3cgPSB7fTtcbiAgZm9yIChjb25zdCBjb2x1bW5OYW1lIG9mIE9iamVjdC5rZXlzKHRhYmxlRGVmLmNvbHVtbnMpKSB7XG4gICAgY29uc3QgY29sdW1uQnVpbGRlciA9IHRhYmxlRGVmLmNvbHVtbnNbY29sdW1uTmFtZV07XG4gICAgY29uc3QgY29sdW1uID0gbmV3IENvbHVtbkV4cHJlc3Npb24oXG4gICAgICB0YWJsZURlZi5uYW1lLFxuICAgICAgY29sdW1uTmFtZSxcbiAgICAgIGNvbHVtbkJ1aWxkZXIudHlwZUJ1aWxkZXIuYWxnZWJyYWljVHlwZVxuICAgICk7XG4gICAgcm93W2NvbHVtbk5hbWVdID0gT2JqZWN0LmZyZWV6ZShjb2x1bW4pO1xuICB9XG4gIHJldHVybiBPYmplY3QuZnJlZXplKHJvdyk7XG59XG5mdW5jdGlvbiByZW5kZXJTZWxlY3RTcWxXaXRoSm9pbnModGFibGUyLCB3aGVyZSwgZXh0cmFDbGF1c2VzID0gW10pIHtcbiAgY29uc3QgcXVvdGVkVGFibGUgPSBxdW90ZUlkZW50aWZpZXIodGFibGUyLm5hbWUpO1xuICBjb25zdCBzcWwgPSBgU0VMRUNUICogRlJPTSAke3F1b3RlZFRhYmxlfWA7XG4gIGNvbnN0IGNsYXVzZXMgPSBbXTtcbiAgaWYgKHdoZXJlKSBjbGF1c2VzLnB1c2goYm9vbGVhbkV4cHJUb1NxbCh3aGVyZSkpO1xuICBjbGF1c2VzLnB1c2goLi4uZXh0cmFDbGF1c2VzKTtcbiAgaWYgKGNsYXVzZXMubGVuZ3RoID09PSAwKSByZXR1cm4gc3FsO1xuICBjb25zdCB3aGVyZVNxbCA9IGNsYXVzZXMubGVuZ3RoID09PSAxID8gY2xhdXNlc1swXSA6IGNsYXVzZXMubWFwKHdyYXBJblBhcmVucykuam9pbihcIiBBTkQgXCIpO1xuICByZXR1cm4gYCR7c3FsfSBXSEVSRSAke3doZXJlU3FsfWA7XG59XG52YXIgQ29sdW1uRXhwcmVzc2lvbiA9IGNsYXNzIHtcbiAgdHlwZSA9IFwiY29sdW1uXCI7XG4gIGNvbHVtbjtcbiAgdGFibGU7XG4gIC8vIHBoYW50b206IGFjdHVhbCBydW50aW1lIHZhbHVlIGlzIHVuZGVmaW5lZFxuICB0c1ZhbHVlVHlwZTtcbiAgc3BhY2V0aW1lVHlwZTtcbiAgY29uc3RydWN0b3IodGFibGUyLCBjb2x1bW4sIHNwYWNldGltZVR5cGUpIHtcbiAgICB0aGlzLnRhYmxlID0gdGFibGUyO1xuICAgIHRoaXMuY29sdW1uID0gY29sdW1uO1xuICAgIHRoaXMuc3BhY2V0aW1lVHlwZSA9IHNwYWNldGltZVR5cGU7XG4gIH1cbiAgLy8gVGhlc2UgdHlwZXMgY291bGQgYmUgdGlnaHRlZCwgYnV0IHNpbmNlIHdlIGRlY2xhcmUgdGhlIG92ZXJsb2FkcyBhYm92ZSwgaXQgZG9lc24ndCB3ZWFrZW4gdGhlIEFQSSBzdXJmYWNlLlxuICBlcSh4KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZXFcIixcbiAgICAgIGxlZnQ6IHRoaXMsXG4gICAgICByaWdodDogbm9ybWFsaXplVmFsdWUoeClcbiAgICB9O1xuICB9XG4gIC8vIFRoZXNlIHR5cGVzIGNvdWxkIGJlIHRpZ2h0ZWQsIGJ1dCBzaW5jZSB3ZSBkZWNsYXJlIHRoZSBvdmVybG9hZHMgYWJvdmUsIGl0IGRvZXNuJ3Qgd2Vha2VuIHRoZSBBUEkgc3VyZmFjZS5cbiAgbHQoeCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImx0XCIsXG4gICAgICBsZWZ0OiB0aGlzLFxuICAgICAgcmlnaHQ6IG5vcm1hbGl6ZVZhbHVlKHgpXG4gICAgfTtcbiAgfVxuICAvLyBUaGVzZSB0eXBlcyBjb3VsZCBiZSB0aWdodGVkLCBidXQgc2luY2Ugd2UgZGVjbGFyZSB0aGUgb3ZlcmxvYWRzIGFib3ZlLCBpdCBkb2Vzbid0IHdlYWtlbiB0aGUgQVBJIHN1cmZhY2UuXG4gIGx0ZSh4KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwibHRlXCIsXG4gICAgICBsZWZ0OiB0aGlzLFxuICAgICAgcmlnaHQ6IG5vcm1hbGl6ZVZhbHVlKHgpXG4gICAgfTtcbiAgfVxuICAvLyBUaGVzZSB0eXBlcyBjb3VsZCBiZSB0aWdodGVkLCBidXQgc2luY2Ugd2UgZGVjbGFyZSB0aGUgb3ZlcmxvYWRzIGFib3ZlLCBpdCBkb2Vzbid0IHdlYWtlbiB0aGUgQVBJIHN1cmZhY2UuXG4gIGd0KHgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJndFwiLFxuICAgICAgbGVmdDogdGhpcyxcbiAgICAgIHJpZ2h0OiBub3JtYWxpemVWYWx1ZSh4KVxuICAgIH07XG4gIH1cbiAgLy8gVGhlc2UgdHlwZXMgY291bGQgYmUgdGlnaHRlZCwgYnV0IHNpbmNlIHdlIGRlY2xhcmUgdGhlIG92ZXJsb2FkcyBhYm92ZSwgaXQgZG9lc24ndCB3ZWFrZW4gdGhlIEFQSSBzdXJmYWNlLlxuICBndGUoeCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImd0ZVwiLFxuICAgICAgbGVmdDogdGhpcyxcbiAgICAgIHJpZ2h0OiBub3JtYWxpemVWYWx1ZSh4KVxuICAgIH07XG4gIH1cbn07XG5mdW5jdGlvbiBsaXRlcmFsKHZhbHVlKSB7XG4gIHJldHVybiB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZSB9O1xufVxuZnVuY3Rpb24gbm9ybWFsaXplVmFsdWUodmFsKSB7XG4gIGlmICh2YWwudHlwZSA9PT0gXCJsaXRlcmFsXCIpXG4gICAgcmV0dXJuIHZhbDtcbiAgaWYgKHR5cGVvZiB2YWwgPT09IFwib2JqZWN0XCIgJiYgdmFsICE9IG51bGwgJiYgXCJ0eXBlXCIgaW4gdmFsICYmIHZhbC50eXBlID09PSBcImNvbHVtblwiKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICByZXR1cm4gbGl0ZXJhbCh2YWwpO1xufVxuZnVuY3Rpb24gbm90KGNsYXVzZSkge1xuICByZXR1cm4geyB0eXBlOiBcIm5vdFwiLCBjbGF1c2UgfTtcbn1cbmZ1bmN0aW9uIGFuZCguLi5jbGF1c2VzKSB7XG4gIHJldHVybiB7IHR5cGU6IFwiYW5kXCIsIGNsYXVzZXMgfTtcbn1cbmZ1bmN0aW9uIG9yKC4uLmNsYXVzZXMpIHtcbiAgcmV0dXJuIHsgdHlwZTogXCJvclwiLCBjbGF1c2VzIH07XG59XG5mdW5jdGlvbiBib29sZWFuRXhwclRvU3FsKGV4cHIsIHRhYmxlQWxpYXMpIHtcbiAgc3dpdGNoIChleHByLnR5cGUpIHtcbiAgICBjYXNlIFwiZXFcIjpcbiAgICAgIHJldHVybiBgJHt2YWx1ZUV4cHJUb1NxbChleHByLmxlZnQpfSA9ICR7dmFsdWVFeHByVG9TcWwoZXhwci5yaWdodCl9YDtcbiAgICBjYXNlIFwibmVcIjpcbiAgICAgIHJldHVybiBgJHt2YWx1ZUV4cHJUb1NxbChleHByLmxlZnQpfSA8PiAke3ZhbHVlRXhwclRvU3FsKGV4cHIucmlnaHQpfWA7XG4gICAgY2FzZSBcImd0XCI6XG4gICAgICByZXR1cm4gYCR7dmFsdWVFeHByVG9TcWwoZXhwci5sZWZ0KX0gPiAke3ZhbHVlRXhwclRvU3FsKGV4cHIucmlnaHQpfWA7XG4gICAgY2FzZSBcImd0ZVwiOlxuICAgICAgcmV0dXJuIGAke3ZhbHVlRXhwclRvU3FsKGV4cHIubGVmdCl9ID49ICR7dmFsdWVFeHByVG9TcWwoZXhwci5yaWdodCl9YDtcbiAgICBjYXNlIFwibHRcIjpcbiAgICAgIHJldHVybiBgJHt2YWx1ZUV4cHJUb1NxbChleHByLmxlZnQpfSA8ICR7dmFsdWVFeHByVG9TcWwoZXhwci5yaWdodCl9YDtcbiAgICBjYXNlIFwibHRlXCI6XG4gICAgICByZXR1cm4gYCR7dmFsdWVFeHByVG9TcWwoZXhwci5sZWZ0KX0gPD0gJHt2YWx1ZUV4cHJUb1NxbChleHByLnJpZ2h0KX1gO1xuICAgIGNhc2UgXCJhbmRcIjpcbiAgICAgIHJldHVybiBleHByLmNsYXVzZXMubWFwKChjKSA9PiBib29sZWFuRXhwclRvU3FsKGMpKS5tYXAod3JhcEluUGFyZW5zKS5qb2luKFwiIEFORCBcIik7XG4gICAgY2FzZSBcIm9yXCI6XG4gICAgICByZXR1cm4gZXhwci5jbGF1c2VzLm1hcCgoYykgPT4gYm9vbGVhbkV4cHJUb1NxbChjKSkubWFwKHdyYXBJblBhcmVucykuam9pbihcIiBPUiBcIik7XG4gICAgY2FzZSBcIm5vdFwiOlxuICAgICAgcmV0dXJuIGBOT1QgJHt3cmFwSW5QYXJlbnMoYm9vbGVhbkV4cHJUb1NxbChleHByLmNsYXVzZSkpfWA7XG4gIH1cbn1cbmZ1bmN0aW9uIHdyYXBJblBhcmVucyhzcWwpIHtcbiAgcmV0dXJuIGAoJHtzcWx9KWA7XG59XG5mdW5jdGlvbiB2YWx1ZUV4cHJUb1NxbChleHByLCB0YWJsZUFsaWFzKSB7XG4gIGlmIChpc0xpdGVyYWxFeHByKGV4cHIpKSB7XG4gICAgcmV0dXJuIGxpdGVyYWxWYWx1ZVRvU3FsKGV4cHIudmFsdWUpO1xuICB9XG4gIGNvbnN0IHRhYmxlMiA9IGV4cHIudGFibGU7XG4gIHJldHVybiBgJHtxdW90ZUlkZW50aWZpZXIodGFibGUyKX0uJHtxdW90ZUlkZW50aWZpZXIoZXhwci5jb2x1bW4pfWA7XG59XG5mdW5jdGlvbiBsaXRlcmFsVmFsdWVUb1NxbCh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHZvaWQgMCkge1xuICAgIHJldHVybiBcIk5VTExcIjtcbiAgfVxuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBJZGVudGl0eSB8fCB2YWx1ZSBpbnN0YW5jZW9mIENvbm5lY3Rpb25JZCkge1xuICAgIHJldHVybiBgMHgke3ZhbHVlLnRvSGV4U3RyaW5nKCl9YDtcbiAgfVxuICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICBjYXNlIFwiYmlnaW50XCI6XG4gICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbiAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgcmV0dXJuIHZhbHVlID8gXCJUUlVFXCIgOiBcIkZBTFNFXCI7XG4gICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgcmV0dXJuIGAnJHt2YWx1ZS5yZXBsYWNlKC8nL2csIFwiJydcIil9J2A7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBgJyR7SlNPTi5zdHJpbmdpZnkodmFsdWUpLnJlcGxhY2UoLycvZywgXCInJ1wiKX0nYDtcbiAgfVxufVxuZnVuY3Rpb24gcXVvdGVJZGVudGlmaWVyKG5hbWUpIHtcbiAgcmV0dXJuIGBcIiR7bmFtZS5yZXBsYWNlKC9cIi9nLCAnXCJcIicpfVwiYDtcbn1cbmZ1bmN0aW9uIGlzTGl0ZXJhbEV4cHIoZXhwcikge1xuICByZXR1cm4gZXhwci50eXBlID09PSBcImxpdGVyYWxcIjtcbn1cblxuLy8gc3JjL2xpYi92aWV3cy50c1xuZnVuY3Rpb24gZGVmaW5lVmlldyhvcHRzLCBhbm9uLCBwYXJhbXMsIHJldCwgZm4pIHtcbiAgY29uc3QgcGFyYW1zQnVpbGRlciA9IG5ldyBSb3dCdWlsZGVyKHBhcmFtcywgdG9QYXNjYWxDYXNlKG9wdHMubmFtZSkpO1xuICBsZXQgcmV0dXJuVHlwZSA9IHJlZ2lzdGVyVHlwZXNSZWN1cnNpdmVseShyZXQpLmFsZ2VicmFpY1R5cGU7XG4gIGNvbnN0IHsgdmFsdWU6IHBhcmFtVHlwZSB9ID0gcmVzb2x2ZVR5cGUoXG4gICAgTU9EVUxFX0RFRi50eXBlc3BhY2UsXG4gICAgcmVnaXN0ZXJUeXBlc1JlY3Vyc2l2ZWx5KHBhcmFtc0J1aWxkZXIpXG4gICk7XG4gIE1PRFVMRV9ERUYubWlzY0V4cG9ydHMucHVzaCh7XG4gICAgdGFnOiBcIlZpZXdcIixcbiAgICB2YWx1ZToge1xuICAgICAgbmFtZTogb3B0cy5uYW1lLFxuICAgICAgaW5kZXg6IChhbm9uID8gQU5PTl9WSUVXUyA6IFZJRVdTKS5sZW5ndGgsXG4gICAgICBpc1B1YmxpYzogb3B0cy5wdWJsaWMsXG4gICAgICBpc0Fub255bW91czogYW5vbixcbiAgICAgIHBhcmFtczogcGFyYW1UeXBlLFxuICAgICAgcmV0dXJuVHlwZVxuICAgIH1cbiAgfSk7XG4gIGlmIChyZXR1cm5UeXBlLnRhZyA9PSBcIlN1bVwiKSB7XG4gICAgY29uc3Qgb3JpZ2luYWxGbiA9IGZuO1xuICAgIGZuID0gKChjdHgsIGFyZ3MpID0+IHtcbiAgICAgIGNvbnN0IHJldDIgPSBvcmlnaW5hbEZuKGN0eCwgYXJncyk7XG4gICAgICByZXR1cm4gcmV0MiA9PSBudWxsID8gW10gOiBbcmV0Ml07XG4gICAgfSk7XG4gICAgcmV0dXJuVHlwZSA9IEFsZ2VicmFpY1R5cGUuQXJyYXkoXG4gICAgICByZXR1cm5UeXBlLnZhbHVlLnZhcmlhbnRzWzBdLmFsZ2VicmFpY1R5cGVcbiAgICApO1xuICB9XG4gIChhbm9uID8gQU5PTl9WSUVXUyA6IFZJRVdTKS5wdXNoKHtcbiAgICBmbixcbiAgICBwYXJhbXM6IHBhcmFtVHlwZSxcbiAgICByZXR1cm5UeXBlLFxuICAgIHJldHVyblR5cGVCYXNlU2l6ZTogYnNhdG5CYXNlU2l6ZShNT0RVTEVfREVGLnR5cGVzcGFjZSwgcmV0dXJuVHlwZSlcbiAgfSk7XG59XG52YXIgVklFV1MgPSBbXTtcbnZhciBBTk9OX1ZJRVdTID0gW107XG5cbi8vIHNyYy9saWIvcHJvY2VkdXJlcy50c1xuZnVuY3Rpb24gcHJvY2VkdXJlKG5hbWUsIHBhcmFtcywgcmV0LCBmbikge1xuICBjb25zdCBwYXJhbXNUeXBlID0ge1xuICAgIGVsZW1lbnRzOiBPYmplY3QuZW50cmllcyhwYXJhbXMpLm1hcCgoW24sIGNdKSA9PiAoe1xuICAgICAgbmFtZTogbixcbiAgICAgIGFsZ2VicmFpY1R5cGU6IHJlZ2lzdGVyVHlwZXNSZWN1cnNpdmVseShcbiAgICAgICAgXCJ0eXBlQnVpbGRlclwiIGluIGMgPyBjLnR5cGVCdWlsZGVyIDogY1xuICAgICAgKS5hbGdlYnJhaWNUeXBlXG4gICAgfSkpXG4gIH07XG4gIGNvbnN0IHJldHVyblR5cGUgPSByZWdpc3RlclR5cGVzUmVjdXJzaXZlbHkocmV0KS5hbGdlYnJhaWNUeXBlO1xuICBNT0RVTEVfREVGLm1pc2NFeHBvcnRzLnB1c2goe1xuICAgIHRhZzogXCJQcm9jZWR1cmVcIixcbiAgICB2YWx1ZToge1xuICAgICAgbmFtZSxcbiAgICAgIHBhcmFtczogcGFyYW1zVHlwZSxcbiAgICAgIHJldHVyblR5cGVcbiAgICB9XG4gIH0pO1xuICBQUk9DRURVUkVTLnB1c2goe1xuICAgIGZuLFxuICAgIHBhcmFtc1R5cGUsXG4gICAgcmV0dXJuVHlwZSxcbiAgICByZXR1cm5UeXBlQmFzZVNpemU6IGJzYXRuQmFzZVNpemUoTU9EVUxFX0RFRi50eXBlc3BhY2UsIHJldHVyblR5cGUpXG4gIH0pO1xufVxudmFyIFBST0NFRFVSRVMgPSBbXTtcblxuLy8gc3JjL2xpYi9zY2hlbWEudHNcbnZhciBSRUdJU1RFUkVEX1NDSEVNQSA9IG51bGw7XG5mdW5jdGlvbiBnZXRSZWdpc3RlcmVkU2NoZW1hKCkge1xuICBpZiAoUkVHSVNURVJFRF9TQ0hFTUEgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlNjaGVtYSBoYXMgbm90IGJlZW4gcmVnaXN0ZXJlZCB5ZXQuIENhbGwgc2NoZW1hKCkgZmlyc3QuXCIpO1xuICB9XG4gIHJldHVybiBSRUdJU1RFUkVEX1NDSEVNQTtcbn1cbmZ1bmN0aW9uIHRhYmxlc1RvU2NoZW1hKHRhYmxlcykge1xuICByZXR1cm4geyB0YWJsZXM6IHRhYmxlcy5tYXAodGFibGVUb1NjaGVtYSkgfTtcbn1cbmZ1bmN0aW9uIHRhYmxlVG9TY2hlbWEoc2NoZW1hMikge1xuICBjb25zdCBnZXRDb2xOYW1lID0gKGkpID0+IHNjaGVtYTIucm93VHlwZS5hbGdlYnJhaWNUeXBlLnZhbHVlLmVsZW1lbnRzW2ldLm5hbWU7XG4gIHJldHVybiB7XG4gICAgbmFtZTogc2NoZW1hMi50YWJsZU5hbWUsXG4gICAgYWNjZXNzb3JOYW1lOiB0b0NhbWVsQ2FzZShzY2hlbWEyLnRhYmxlTmFtZSksXG4gICAgY29sdW1uczogc2NoZW1hMi5yb3dUeXBlLnJvdyxcbiAgICAvLyB0eXBlZCBhcyBUW2ldWydyb3dUeXBlJ11bJ3JvdyddIHVuZGVyIFRhYmxlc1RvU2NoZW1hPFQ+XG4gICAgcm93VHlwZTogc2NoZW1hMi5yb3dTcGFjZXRpbWVUeXBlLFxuICAgIGNvbnN0cmFpbnRzOiBzY2hlbWEyLnRhYmxlRGVmLmNvbnN0cmFpbnRzLm1hcCgoYykgPT4gKHtcbiAgICAgIG5hbWU6IGMubmFtZSxcbiAgICAgIGNvbnN0cmFpbnQ6IFwidW5pcXVlXCIsXG4gICAgICBjb2x1bW5zOiBjLmRhdGEudmFsdWUuY29sdW1ucy5tYXAoZ2V0Q29sTmFtZSlcbiAgICB9KSksXG4gICAgLy8gVE9ETzogaG9ycmlibGUgaG9ycmlibGUgaG9ycmlibGUuIHdlIHNtdWdnbGUgdGhpcyBgQXJyYXk8VW50eXBlZEluZGV4PmBcbiAgICAvLyBieSBjYXN0aW5nIGl0IHRvIGFuIGBBcnJheTxJbmRleE9wdHM+YCBhcyBgVGFibGVUb1NjaGVtYWAgZXhwZWN0cy5cbiAgICAvLyBUaGlzIGlzIHRoZW4gdXNlZCBpbiBgVGFibGVDYWNoZUltcGwuY29uc3RydWN0b3JgIGFuZCB3aG8ga25vd3Mgd2hlcmUgZWxzZS5cbiAgICAvLyBXZSBzaG91bGQgc3RvcCBseWluZyBhYm91dCBvdXIgdHlwZXMuXG4gICAgaW5kZXhlczogc2NoZW1hMi50YWJsZURlZi5pbmRleGVzLm1hcCgoaWR4KSA9PiB7XG4gICAgICBjb25zdCBjb2x1bW5JZHMgPSBpZHguYWxnb3JpdGhtLnRhZyA9PT0gXCJEaXJlY3RcIiA/IFtpZHguYWxnb3JpdGhtLnZhbHVlXSA6IGlkeC5hbGdvcml0aG0udmFsdWU7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBpZHguYWNjZXNzb3JOYW1lLFxuICAgICAgICB1bmlxdWU6IHNjaGVtYTIudGFibGVEZWYuY29uc3RyYWludHMuc29tZShcbiAgICAgICAgICAoYykgPT4gYy5kYXRhLnZhbHVlLmNvbHVtbnMuZXZlcnkoKGNvbCkgPT4gY29sdW1uSWRzLmluY2x1ZGVzKGNvbCkpXG4gICAgICAgICksXG4gICAgICAgIGFsZ29yaXRobTogaWR4LmFsZ29yaXRobS50YWcudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgY29sdW1uczogY29sdW1uSWRzLm1hcChnZXRDb2xOYW1lKVxuICAgICAgfTtcbiAgICB9KVxuICB9O1xufVxudmFyIE1PRFVMRV9ERUYgPSB7XG4gIHR5cGVzcGFjZTogeyB0eXBlczogW10gfSxcbiAgdGFibGVzOiBbXSxcbiAgcmVkdWNlcnM6IFtdLFxuICB0eXBlczogW10sXG4gIG1pc2NFeHBvcnRzOiBbXSxcbiAgcm93TGV2ZWxTZWN1cml0eTogW11cbn07XG52YXIgQ09NUE9VTkRfVFlQRVMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuZnVuY3Rpb24gcmVzb2x2ZVR5cGUodHlwZXNwYWNlLCB0eXBlQnVpbGRlcikge1xuICBsZXQgdHkgPSB0eXBlQnVpbGRlci5hbGdlYnJhaWNUeXBlO1xuICB3aGlsZSAodHkudGFnID09PSBcIlJlZlwiKSB7XG4gICAgdHkgPSB0eXBlc3BhY2UudHlwZXNbdHkudmFsdWVdO1xuICB9XG4gIHJldHVybiB0eTtcbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyVHlwZXNSZWN1cnNpdmVseSh0eXBlQnVpbGRlcikge1xuICBpZiAodHlwZUJ1aWxkZXIgaW5zdGFuY2VvZiBQcm9kdWN0QnVpbGRlciAmJiAhaXNVbml0KHR5cGVCdWlsZGVyKSB8fCB0eXBlQnVpbGRlciBpbnN0YW5jZW9mIFN1bUJ1aWxkZXIgfHwgdHlwZUJ1aWxkZXIgaW5zdGFuY2VvZiBSb3dCdWlsZGVyKSB7XG4gICAgcmV0dXJuIHJlZ2lzdGVyQ29tcG91bmRUeXBlUmVjdXJzaXZlbHkodHlwZUJ1aWxkZXIpO1xuICB9IGVsc2UgaWYgKHR5cGVCdWlsZGVyIGluc3RhbmNlb2YgT3B0aW9uQnVpbGRlcikge1xuICAgIHJldHVybiBuZXcgT3B0aW9uQnVpbGRlcihcbiAgICAgIHJlZ2lzdGVyVHlwZXNSZWN1cnNpdmVseSh0eXBlQnVpbGRlci52YWx1ZSlcbiAgICApO1xuICB9IGVsc2UgaWYgKHR5cGVCdWlsZGVyIGluc3RhbmNlb2YgUmVzdWx0QnVpbGRlcikge1xuICAgIHJldHVybiBuZXcgUmVzdWx0QnVpbGRlcihcbiAgICAgIHJlZ2lzdGVyVHlwZXNSZWN1cnNpdmVseSh0eXBlQnVpbGRlci5vayksXG4gICAgICByZWdpc3RlclR5cGVzUmVjdXJzaXZlbHkodHlwZUJ1aWxkZXIuZXJyKVxuICAgICk7XG4gIH0gZWxzZSBpZiAodHlwZUJ1aWxkZXIgaW5zdGFuY2VvZiBBcnJheUJ1aWxkZXIpIHtcbiAgICByZXR1cm4gbmV3IEFycmF5QnVpbGRlcihcbiAgICAgIHJlZ2lzdGVyVHlwZXNSZWN1cnNpdmVseSh0eXBlQnVpbGRlci5lbGVtZW50KVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHR5cGVCdWlsZGVyO1xuICB9XG59XG5mdW5jdGlvbiByZWdpc3RlckNvbXBvdW5kVHlwZVJlY3Vyc2l2ZWx5KHR5cGVCdWlsZGVyKSB7XG4gIGNvbnN0IHR5ID0gdHlwZUJ1aWxkZXIuYWxnZWJyYWljVHlwZTtcbiAgY29uc3QgbmFtZSA9IHR5cGVCdWlsZGVyLnR5cGVOYW1lO1xuICBpZiAobmFtZSA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYE1pc3NpbmcgdHlwZSBuYW1lIGZvciAke3R5cGVCdWlsZGVyLmNvbnN0cnVjdG9yLm5hbWUgPz8gXCJUeXBlQnVpbGRlclwifSAke0pTT04uc3RyaW5naWZ5KHR5cGVCdWlsZGVyKX1gXG4gICAgKTtcbiAgfVxuICBsZXQgciA9IENPTVBPVU5EX1RZUEVTLmdldCh0eSk7XG4gIGlmIChyICE9IG51bGwpIHtcbiAgICByZXR1cm4gcjtcbiAgfVxuICBjb25zdCBuZXdUeSA9IHR5cGVCdWlsZGVyIGluc3RhbmNlb2YgUm93QnVpbGRlciB8fCB0eXBlQnVpbGRlciBpbnN0YW5jZW9mIFByb2R1Y3RCdWlsZGVyID8ge1xuICAgIHRhZzogXCJQcm9kdWN0XCIsXG4gICAgdmFsdWU6IHsgZWxlbWVudHM6IFtdIH1cbiAgfSA6IHsgdGFnOiBcIlN1bVwiLCB2YWx1ZTogeyB2YXJpYW50czogW10gfSB9O1xuICByID0gbmV3IFJlZkJ1aWxkZXIoTU9EVUxFX0RFRi50eXBlc3BhY2UudHlwZXMubGVuZ3RoKTtcbiAgTU9EVUxFX0RFRi50eXBlc3BhY2UudHlwZXMucHVzaChuZXdUeSk7XG4gIENPTVBPVU5EX1RZUEVTLnNldCh0eSwgcik7XG4gIGlmICh0eXBlQnVpbGRlciBpbnN0YW5jZW9mIFJvd0J1aWxkZXIpIHtcbiAgICBmb3IgKGNvbnN0IFtuYW1lMiwgZWxlbV0gb2YgT2JqZWN0LmVudHJpZXModHlwZUJ1aWxkZXIucm93KSkge1xuICAgICAgbmV3VHkudmFsdWUuZWxlbWVudHMucHVzaCh7XG4gICAgICAgIG5hbWU6IG5hbWUyLFxuICAgICAgICBhbGdlYnJhaWNUeXBlOiByZWdpc3RlclR5cGVzUmVjdXJzaXZlbHkoZWxlbS50eXBlQnVpbGRlcikuYWxnZWJyYWljVHlwZVxuICAgICAgfSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVCdWlsZGVyIGluc3RhbmNlb2YgUHJvZHVjdEJ1aWxkZXIpIHtcbiAgICBmb3IgKGNvbnN0IFtuYW1lMiwgZWxlbV0gb2YgT2JqZWN0LmVudHJpZXModHlwZUJ1aWxkZXIuZWxlbWVudHMpKSB7XG4gICAgICBuZXdUeS52YWx1ZS5lbGVtZW50cy5wdXNoKHtcbiAgICAgICAgbmFtZTogbmFtZTIsXG4gICAgICAgIGFsZ2VicmFpY1R5cGU6IHJlZ2lzdGVyVHlwZXNSZWN1cnNpdmVseShlbGVtKS5hbGdlYnJhaWNUeXBlXG4gICAgICB9KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZUJ1aWxkZXIgaW5zdGFuY2VvZiBTdW1CdWlsZGVyKSB7XG4gICAgZm9yIChjb25zdCBbbmFtZTIsIHZhcmlhbnRdIG9mIE9iamVjdC5lbnRyaWVzKHR5cGVCdWlsZGVyLnZhcmlhbnRzKSkge1xuICAgICAgbmV3VHkudmFsdWUudmFyaWFudHMucHVzaCh7XG4gICAgICAgIG5hbWU6IG5hbWUyLFxuICAgICAgICBhbGdlYnJhaWNUeXBlOiByZWdpc3RlclR5cGVzUmVjdXJzaXZlbHkodmFyaWFudCkuYWxnZWJyYWljVHlwZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIE1PRFVMRV9ERUYudHlwZXMucHVzaCh7XG4gICAgbmFtZTogc3BsaXROYW1lKG5hbWUpLFxuICAgIHR5OiByLnJlZixcbiAgICBjdXN0b21PcmRlcmluZzogdHJ1ZVxuICB9KTtcbiAgcmV0dXJuIHI7XG59XG5mdW5jdGlvbiBpc1VuaXQodHlwZUJ1aWxkZXIpIHtcbiAgcmV0dXJuIHR5cGVCdWlsZGVyLnR5cGVOYW1lID09IG51bGwgJiYgdHlwZUJ1aWxkZXIuYWxnZWJyYWljVHlwZS52YWx1ZS5lbGVtZW50cy5sZW5ndGggPT09IDA7XG59XG5mdW5jdGlvbiBzcGxpdE5hbWUobmFtZSkge1xuICBjb25zdCBzY29wZSA9IG5hbWUuc3BsaXQoXCIuXCIpO1xuICByZXR1cm4geyBuYW1lOiBzY29wZS5wb3AoKSwgc2NvcGUgfTtcbn1cbnZhciBTY2hlbWEgPSBjbGFzcyB7XG4gIHRhYmxlc0RlZjtcbiAgdHlwZXNwYWNlO1xuICBzY2hlbWFUeXBlO1xuICBjb25zdHJ1Y3Rvcih0YWJsZXMsIHR5cGVzcGFjZSwgaGFuZGxlcykge1xuICAgIHRoaXMudGFibGVzRGVmID0geyB0YWJsZXMgfTtcbiAgICB0aGlzLnR5cGVzcGFjZSA9IHR5cGVzcGFjZTtcbiAgICB0aGlzLnNjaGVtYVR5cGUgPSB0YWJsZXNUb1NjaGVtYShoYW5kbGVzKTtcbiAgfVxuICByZWR1Y2VyKG5hbWUsIHBhcmFtc09yRm4sIGZuKSB7XG4gICAgaWYgKHR5cGVvZiBwYXJhbXNPckZuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHJlZHVjZXIobmFtZSwge30sIHBhcmFtc09yRm4pO1xuICAgICAgcmV0dXJuIHBhcmFtc09yRm47XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZHVjZXIobmFtZSwgcGFyYW1zT3JGbiwgZm4pO1xuICAgICAgcmV0dXJuIGZuO1xuICAgIH1cbiAgfVxuICBpbml0KG5hbWVPckZuLCBtYXliZUZuKSB7XG4gICAgY29uc3QgW25hbWUsIGZuXSA9IHR5cGVvZiBuYW1lT3JGbiA9PT0gXCJzdHJpbmdcIiA/IFtuYW1lT3JGbiwgbWF5YmVGbl0gOiBbXCJpbml0XCIsIG5hbWVPckZuXTtcbiAgICBpbml0KG5hbWUsIHt9LCBmbik7XG4gIH1cbiAgY2xpZW50Q29ubmVjdGVkKG5hbWVPckZuLCBtYXliZUZuKSB7XG4gICAgY29uc3QgW25hbWUsIGZuXSA9IHR5cGVvZiBuYW1lT3JGbiA9PT0gXCJzdHJpbmdcIiA/IFtuYW1lT3JGbiwgbWF5YmVGbl0gOiBbXCJvbl9jb25uZWN0XCIsIG5hbWVPckZuXTtcbiAgICBjbGllbnRDb25uZWN0ZWQobmFtZSwge30sIGZuKTtcbiAgfVxuICBjbGllbnREaXNjb25uZWN0ZWQobmFtZU9yRm4sIG1heWJlRm4pIHtcbiAgICBjb25zdCBbbmFtZSwgZm5dID0gdHlwZW9mIG5hbWVPckZuID09PSBcInN0cmluZ1wiID8gW25hbWVPckZuLCBtYXliZUZuXSA6IFtcIm9uX2Rpc2Nvbm5lY3RcIiwgbmFtZU9yRm5dO1xuICAgIGNsaWVudERpc2Nvbm5lY3RlZChuYW1lLCB7fSwgZm4pO1xuICB9XG4gIHZpZXcob3B0cywgcmV0LCBmbikge1xuICAgIGRlZmluZVZpZXcob3B0cywgZmFsc2UsIHt9LCByZXQsIGZuKTtcbiAgfVxuICAvLyBUT0RPOiByZS1lbmFibGUgb25jZSBwYXJhbWV0ZXJpemVkIHZpZXdzIGFyZSBzdXBwb3J0ZWQgaW4gU1FMXG4gIC8vIHZpZXc8UmV0IGV4dGVuZHMgVmlld1JldHVyblR5cGVCdWlsZGVyPihcbiAgLy8gICBvcHRzOiBWaWV3T3B0cyxcbiAgLy8gICByZXQ6IFJldCxcbiAgLy8gICBmbjogVmlld0ZuPFMsIHt9LCBSZXQ+XG4gIC8vICk6IHZvaWQ7XG4gIC8vIHZpZXc8UGFyYW1zIGV4dGVuZHMgUGFyYW1zT2JqLCBSZXQgZXh0ZW5kcyBWaWV3UmV0dXJuVHlwZUJ1aWxkZXI+KFxuICAvLyAgIG9wdHM6IFZpZXdPcHRzLFxuICAvLyAgIHBhcmFtczogUGFyYW1zLFxuICAvLyAgIHJldDogUmV0LFxuICAvLyAgIGZuOiBWaWV3Rm48Uywge30sIFJldD5cbiAgLy8gKTogdm9pZDtcbiAgLy8gdmlldzxQYXJhbXMgZXh0ZW5kcyBQYXJhbXNPYmosIFJldCBleHRlbmRzIFZpZXdSZXR1cm5UeXBlQnVpbGRlcj4oXG4gIC8vICAgb3B0czogVmlld09wdHMsXG4gIC8vICAgcGFyYW1zT3JSZXQ6IFJldCB8IFBhcmFtcyxcbiAgLy8gICByZXRPckZuOiBWaWV3Rm48Uywge30sIFJldD4gfCBSZXQsXG4gIC8vICAgbWF5YmVGbj86IFZpZXdGbjxTLCBQYXJhbXMsIFJldD5cbiAgLy8gKTogdm9pZCB7XG4gIC8vICAgaWYgKHR5cGVvZiByZXRPckZuID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vICAgICBkZWZpbmVWaWV3KG5hbWUsIGZhbHNlLCB7fSwgcGFyYW1zT3JSZXQgYXMgUmV0LCByZXRPckZuKTtcbiAgLy8gICB9IGVsc2Uge1xuICAvLyAgICAgZGVmaW5lVmlldyhuYW1lLCBmYWxzZSwgcGFyYW1zT3JSZXQgYXMgUGFyYW1zLCByZXRPckZuLCBtYXliZUZuISk7XG4gIC8vICAgfVxuICAvLyB9XG4gIGFub255bW91c1ZpZXcob3B0cywgcmV0LCBmbikge1xuICAgIGRlZmluZVZpZXcob3B0cywgdHJ1ZSwge30sIHJldCwgZm4pO1xuICB9XG4gIHByb2NlZHVyZShuYW1lLCBwYXJhbXNPclJldCwgcmV0T3JGbiwgbWF5YmVGbikge1xuICAgIGlmICh0eXBlb2YgcmV0T3JGbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBwcm9jZWR1cmUobmFtZSwge30sIHBhcmFtc09yUmV0LCByZXRPckZuKTtcbiAgICAgIHJldHVybiByZXRPckZuO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9jZWR1cmUobmFtZSwgcGFyYW1zT3JSZXQsIHJldE9yRm4sIG1heWJlRm4pO1xuICAgICAgcmV0dXJuIG1heWJlRm47XG4gICAgfVxuICB9XG4gIGNsaWVudFZpc2liaWxpdHlGaWx0ZXIgPSB7XG4gICAgc3FsKGZpbHRlcikge1xuICAgICAgTU9EVUxFX0RFRi5yb3dMZXZlbFNlY3VyaXR5LnB1c2goeyBzcWw6IGZpbHRlciB9KTtcbiAgICB9XG4gIH07XG59O1xuZnVuY3Rpb24gc2NoZW1hKC4uLmFyZ3MpIHtcbiAgY29uc3QgaGFuZGxlcyA9IGFyZ3MubGVuZ3RoID09PSAxICYmIEFycmF5LmlzQXJyYXkoYXJnc1swXSkgPyBhcmdzWzBdIDogYXJncztcbiAgY29uc3QgdGFibGVEZWZzID0gaGFuZGxlcy5tYXAoKGgpID0+IGgudGFibGVEZWYpO1xuICBNT0RVTEVfREVGLnRhYmxlcy5wdXNoKC4uLnRhYmxlRGVmcyk7XG4gIFJFR0lTVEVSRURfU0NIRU1BID0ge1xuICAgIHRhYmxlczogaGFuZGxlcy5tYXAoKGhhbmRsZSkgPT4gKHtcbiAgICAgIG5hbWU6IGhhbmRsZS50YWJsZU5hbWUsXG4gICAgICBhY2Nlc3Nvck5hbWU6IGhhbmRsZS50YWJsZU5hbWUsXG4gICAgICBjb2x1bW5zOiBoYW5kbGUucm93VHlwZS5yb3csXG4gICAgICByb3dUeXBlOiBoYW5kbGUucm93U3BhY2V0aW1lVHlwZSxcbiAgICAgIGluZGV4ZXM6IGhhbmRsZS5pZHhzLFxuICAgICAgY29uc3RyYWludHM6IGhhbmRsZS5jb25zdHJhaW50c1xuICAgIH0pKVxuICB9O1xuICByZXR1cm4gbmV3IFNjaGVtYSh0YWJsZURlZnMsIE1PRFVMRV9ERUYudHlwZXNwYWNlLCBoYW5kbGVzKTtcbn1cblxuLy8gc3JjL2xpYi9hdXRvZ2VuL3Jhd19pbmRleF9hbGdvcml0aG1fdHlwZS50c1xudmFyIFJhd0luZGV4QWxnb3JpdGhtID0gdC5lbnVtKFwiUmF3SW5kZXhBbGdvcml0aG1cIiwge1xuICBCVHJlZTogdC5hcnJheSh0LnUxNigpKSxcbiAgSGFzaDogdC5hcnJheSh0LnUxNigpKSxcbiAgRGlyZWN0OiB0LnUxNigpXG59KTtcbnZhciByYXdfaW5kZXhfYWxnb3JpdGhtX3R5cGVfZGVmYXVsdCA9IFJhd0luZGV4QWxnb3JpdGhtO1xuXG4vLyBzcmMvbGliL3RhYmxlLnRzXG5mdW5jdGlvbiB0YWJsZShvcHRzLCByb3cpIHtcbiAgY29uc3Qge1xuICAgIG5hbWUsXG4gICAgcHVibGljOiBpc1B1YmxpYyA9IGZhbHNlLFxuICAgIGluZGV4ZXM6IHVzZXJJbmRleGVzID0gW10sXG4gICAgc2NoZWR1bGVkXG4gIH0gPSBvcHRzO1xuICBjb25zdCBjb2xJZHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCBjb2xOYW1lTGlzdCA9IFtdO1xuICBpZiAoIShyb3cgaW5zdGFuY2VvZiBSb3dCdWlsZGVyKSkge1xuICAgIHJvdyA9IG5ldyBSb3dCdWlsZGVyKHJvdyk7XG4gIH1cbiAgaWYgKHJvdy50eXBlTmFtZSA9PT0gdm9pZCAwKSB7XG4gICAgcm93LnR5cGVOYW1lID0gdG9QYXNjYWxDYXNlKG5hbWUpO1xuICB9XG4gIGNvbnN0IHJvd1R5cGVSZWYgPSByZWdpc3RlclR5cGVzUmVjdXJzaXZlbHkocm93KTtcbiAgcm93LmFsZ2VicmFpY1R5cGUudmFsdWUuZWxlbWVudHMuZm9yRWFjaCgoZWxlbSwgaSkgPT4ge1xuICAgIGNvbElkcy5zZXQoZWxlbS5uYW1lLCBpKTtcbiAgICBjb2xOYW1lTGlzdC5wdXNoKGVsZW0ubmFtZSk7XG4gIH0pO1xuICBjb25zdCBwayA9IFtdO1xuICBjb25zdCBpbmRleGVzID0gW107XG4gIGNvbnN0IGNvbnN0cmFpbnRzID0gW107XG4gIGNvbnN0IHNlcXVlbmNlcyA9IFtdO1xuICBsZXQgc2NoZWR1bGVBdENvbDtcbiAgZm9yIChjb25zdCBbbmFtZTIsIGJ1aWxkZXJdIG9mIE9iamVjdC5lbnRyaWVzKHJvdy5yb3cpKSB7XG4gICAgY29uc3QgbWV0YSA9IGJ1aWxkZXIuY29sdW1uTWV0YWRhdGE7XG4gICAgaWYgKG1ldGEuaXNQcmltYXJ5S2V5KSB7XG4gICAgICBway5wdXNoKGNvbElkcy5nZXQobmFtZTIpKTtcbiAgICB9XG4gICAgY29uc3QgaXNVbmlxdWUgPSBtZXRhLmlzVW5pcXVlIHx8IG1ldGEuaXNQcmltYXJ5S2V5O1xuICAgIGlmIChtZXRhLmluZGV4VHlwZSB8fCBpc1VuaXF1ZSkge1xuICAgICAgY29uc3QgYWxnbyA9IG1ldGEuaW5kZXhUeXBlID8/IFwiYnRyZWVcIjtcbiAgICAgIGNvbnN0IGlkID0gY29sSWRzLmdldChuYW1lMik7XG4gICAgICBsZXQgYWxnb3JpdGhtO1xuICAgICAgc3dpdGNoIChhbGdvKSB7XG4gICAgICAgIGNhc2UgXCJidHJlZVwiOlxuICAgICAgICAgIGFsZ29yaXRobSA9IHJhd19pbmRleF9hbGdvcml0aG1fdHlwZV9kZWZhdWx0LkJUcmVlKFtpZF0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZGlyZWN0XCI6XG4gICAgICAgICAgYWxnb3JpdGhtID0gcmF3X2luZGV4X2FsZ29yaXRobV90eXBlX2RlZmF1bHQuRGlyZWN0KGlkKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGluZGV4ZXMucHVzaCh7XG4gICAgICAgIG5hbWU6IHZvaWQgMCxcbiAgICAgICAgLy8gVW5uYW1lZCBpbmRleGVzIHdpbGwgYmUgYXNzaWduZWQgYSBnbG9iYWxseSB1bmlxdWUgbmFtZVxuICAgICAgICBhY2Nlc3Nvck5hbWU6IG5hbWUyLFxuICAgICAgICAvLyBUaGUgbmFtZSBvZiB0aGlzIGNvbHVtbiB3aWxsIGJlIHVzZWQgYXMgdGhlIGFjY2Vzc29yIG5hbWVcbiAgICAgICAgYWxnb3JpdGhtXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGlzVW5pcXVlKSB7XG4gICAgICBjb25zdHJhaW50cy5wdXNoKHtcbiAgICAgICAgbmFtZTogdm9pZCAwLFxuICAgICAgICBkYXRhOiB7IHRhZzogXCJVbmlxdWVcIiwgdmFsdWU6IHsgY29sdW1uczogW2NvbElkcy5nZXQobmFtZTIpXSB9IH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAobWV0YS5pc0F1dG9JbmNyZW1lbnQpIHtcbiAgICAgIHNlcXVlbmNlcy5wdXNoKHtcbiAgICAgICAgbmFtZTogdm9pZCAwLFxuICAgICAgICBzdGFydDogdm9pZCAwLFxuICAgICAgICBtaW5WYWx1ZTogdm9pZCAwLFxuICAgICAgICBtYXhWYWx1ZTogdm9pZCAwLFxuICAgICAgICBjb2x1bW46IGNvbElkcy5nZXQobmFtZTIpLFxuICAgICAgICBpbmNyZW1lbnQ6IDFuXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHNjaGVkdWxlZCkge1xuICAgICAgY29uc3QgYWxnZWJyYWljVHlwZSA9IGJ1aWxkZXIudHlwZUJ1aWxkZXIuYWxnZWJyYWljVHlwZTtcbiAgICAgIGlmIChzY2hlZHVsZV9hdF9kZWZhdWx0LmlzU2NoZWR1bGVBdChhbGdlYnJhaWNUeXBlKSkge1xuICAgICAgICBzY2hlZHVsZUF0Q29sID0gY29sSWRzLmdldChuYW1lMik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZvciAoY29uc3QgaW5kZXhPcHRzIG9mIHVzZXJJbmRleGVzID8/IFtdKSB7XG4gICAgbGV0IGFsZ29yaXRobTtcbiAgICBzd2l0Y2ggKGluZGV4T3B0cy5hbGdvcml0aG0pIHtcbiAgICAgIGNhc2UgXCJidHJlZVwiOlxuICAgICAgICBhbGdvcml0aG0gPSB7XG4gICAgICAgICAgdGFnOiBcIkJUcmVlXCIsXG4gICAgICAgICAgdmFsdWU6IGluZGV4T3B0cy5jb2x1bW5zLm1hcCgoYykgPT4gY29sSWRzLmdldChjKSlcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZGlyZWN0XCI6XG4gICAgICAgIGFsZ29yaXRobSA9IHsgdGFnOiBcIkRpcmVjdFwiLCB2YWx1ZTogY29sSWRzLmdldChpbmRleE9wdHMuY29sdW1uKSB9O1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgaW5kZXhlcy5wdXNoKHsgbmFtZTogdm9pZCAwLCBhY2Nlc3Nvck5hbWU6IGluZGV4T3B0cy5uYW1lLCBhbGdvcml0aG0gfSk7XG4gIH1cbiAgZm9yIChjb25zdCBjb25zdHJhaW50T3B0cyBvZiBvcHRzLmNvbnN0cmFpbnRzID8/IFtdKSB7XG4gICAgaWYgKGNvbnN0cmFpbnRPcHRzLmNvbnN0cmFpbnQgPT09IFwidW5pcXVlXCIpIHtcbiAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgIHRhZzogXCJVbmlxdWVcIixcbiAgICAgICAgdmFsdWU6IHsgY29sdW1uczogY29uc3RyYWludE9wdHMuY29sdW1ucy5tYXAoKGMpID0+IGNvbElkcy5nZXQoYykpIH1cbiAgICAgIH07XG4gICAgICBjb25zdHJhaW50cy5wdXNoKHsgbmFtZTogY29uc3RyYWludE9wdHMubmFtZSwgZGF0YSB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IGluZGV4IG9mIGluZGV4ZXMpIHtcbiAgICBjb25zdCBjb2xzID0gaW5kZXguYWxnb3JpdGhtLnRhZyA9PT0gXCJEaXJlY3RcIiA/IFtpbmRleC5hbGdvcml0aG0udmFsdWVdIDogaW5kZXguYWxnb3JpdGhtLnZhbHVlO1xuICAgIGNvbnN0IGNvbFMgPSBjb2xzLm1hcCgoaSkgPT4gY29sTmFtZUxpc3RbaV0pLmpvaW4oXCJfXCIpO1xuICAgIGluZGV4Lm5hbWUgPSBgJHtuYW1lfV8ke2NvbFN9X2lkeF8ke2luZGV4LmFsZ29yaXRobS50YWcudG9Mb3dlckNhc2UoKX1gO1xuICB9XG4gIGNvbnN0IHRhYmxlRGVmID0ge1xuICAgIG5hbWUsXG4gICAgcHJvZHVjdFR5cGVSZWY6IHJvd1R5cGVSZWYucmVmLFxuICAgIHByaW1hcnlLZXk6IHBrLFxuICAgIGluZGV4ZXMsXG4gICAgY29uc3RyYWludHMsXG4gICAgc2VxdWVuY2VzLFxuICAgIHNjaGVkdWxlOiBzY2hlZHVsZWQgJiYgc2NoZWR1bGVBdENvbCAhPT0gdm9pZCAwID8ge1xuICAgICAgbmFtZTogdm9pZCAwLFxuICAgICAgcmVkdWNlck5hbWU6IHNjaGVkdWxlZCxcbiAgICAgIHNjaGVkdWxlZEF0Q29sdW1uOiBzY2hlZHVsZUF0Q29sXG4gICAgfSA6IHZvaWQgMCxcbiAgICB0YWJsZVR5cGU6IHsgdGFnOiBcIlVzZXJcIiB9LFxuICAgIHRhYmxlQWNjZXNzOiB7IHRhZzogaXNQdWJsaWMgPyBcIlB1YmxpY1wiIDogXCJQcml2YXRlXCIgfVxuICB9O1xuICBjb25zdCBwcm9kdWN0VHlwZSA9IHJvdy5hbGdlYnJhaWNUeXBlLnZhbHVlO1xuICByZXR1cm4ge1xuICAgIHJvd1R5cGU6IHJvdyxcbiAgICB0YWJsZU5hbWU6IG5hbWUsXG4gICAgcm93U3BhY2V0aW1lVHlwZTogcHJvZHVjdFR5cGUsXG4gICAgdGFibGVEZWYsXG4gICAgaWR4czoge30sXG4gICAgY29uc3RyYWludHNcbiAgfTtcbn1cblxuLy8gc3JjL3NlcnZlci9lcnJvcnMudHNcbnZhciBTcGFjZXRpbWVIb3N0RXJyb3IgPSBjbGFzcyBfU3BhY2V0aW1lSG9zdEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb2RlO1xuICBtZXNzYWdlO1xuICBjb25zdHJ1Y3Rvcihjb2RlLCBtZXNzYWdlKSB7XG4gICAgc3VwZXIoKTtcbiAgICBjb25zdCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKTtcbiAgICBsZXQgY2xzO1xuICAgIGlmIChlcnJvclByb3RveXBlcy5oYXMocHJvdG8pKSB7XG4gICAgICBjbHMgPSBwcm90by5jb25zdHJ1Y3RvcjtcbiAgICAgIGlmIChjb2RlICE9PSBjbHMuQ09ERSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgaW52YWxpZCBlcnJvciBjb2RlIGZvciAke2Nscy5uYW1lfWApO1xuICAgIH0gZWxzZSBpZiAocHJvdG8gPT09IF9TcGFjZXRpbWVIb3N0RXJyb3IucHJvdG90eXBlKSB7XG4gICAgICBjbHMgPSBlcnJub1RvQ2xhc3MuZ2V0KGNvZGUpO1xuICAgICAgaWYgKCFjbHMpIHRocm93IG5ldyBSYW5nZUVycm9yKGB1bmtub3duIGVycm9yIGNvZGUgJHtjb2RlfWApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2Fubm90IHN1YmNsYXNzIFNwYWNldGltZUVycm9yXCIpO1xuICAgIH1cbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgY2xzLnByb3RvdHlwZSk7XG4gICAgdGhpcy5jb2RlID0gY2xzLkNPREU7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSA/PyBjbHMuTUVTU0FHRTtcbiAgfVxuICBnZXQgbmFtZSgpIHtcbiAgICByZXR1cm4gZXJybm9Ub0NsYXNzLmdldCh0aGlzLmNvZGUpPy5uYW1lID8/IFwiU3BhY2V0aW1lSG9zdEVycm9yXCI7XG4gIH1cbn07XG52YXIgU2VuZGVyRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICB9XG4gIGdldCBuYW1lKCkge1xuICAgIHJldHVybiBcIlNlbmRlckVycm9yXCI7XG4gIH1cbn07XG52YXIgZXJyb3JEYXRhID0ge1xuICAvKipcbiAgICogQSBnZW5lcmljIGVycm9yIGNsYXNzIGZvciB1bmtub3duIGVycm9yIGNvZGVzLlxuICAgKi9cbiAgSG9zdENhbGxGYWlsdXJlOiBbMSwgXCJBQkkgY2FsbGVkIGJ5IGhvc3QgcmV0dXJuZWQgYW4gZXJyb3JcIl0sXG4gIC8qKlxuICAgKiBFcnJvciBpbmRpY2F0aW5nIHRoYXQgYW4gQUJJIGNhbGwgd2FzIG1hZGUgb3V0c2lkZSBvZiBhIHRyYW5zYWN0aW9uLlxuICAgKi9cbiAgTm90SW5UcmFuc2FjdGlvbjogWzIsIFwiQUJJIGNhbGwgY2FuIG9ubHkgYmUgbWFkZSB3aGlsZSBpbiBhIHRyYW5zYWN0aW9uXCJdLFxuICAvKipcbiAgICogRXJyb3IgaW5kaWNhdGluZyB0aGF0IEJTQVROIGRlY29kaW5nIGZhaWxlZC5cbiAgICogVGhpcyB0eXBpY2FsbHkgbWVhbnMgdGhhdCB0aGUgZGF0YSBjb3VsZCBub3QgYmUgZGVjb2RlZCB0byB0aGUgZXhwZWN0ZWQgdHlwZS5cbiAgICovXG4gIEJzYXRuRGVjb2RlRXJyb3I6IFszLCBcIkNvdWxkbid0IGRlY29kZSB0aGUgQlNBVE4gdG8gdGhlIGV4cGVjdGVkIHR5cGVcIl0sXG4gIC8qKlxuICAgKiBFcnJvciBpbmRpY2F0aW5nIHRoYXQgYSBzcGVjaWZpZWQgdGFibGUgZG9lcyBub3QgZXhpc3QuXG4gICAqL1xuICBOb1N1Y2hUYWJsZTogWzQsIFwiTm8gc3VjaCB0YWJsZVwiXSxcbiAgLyoqXG4gICAqIEVycm9yIGluZGljYXRpbmcgdGhhdCBhIHNwZWNpZmllZCBpbmRleCBkb2VzIG5vdCBleGlzdC5cbiAgICovXG4gIE5vU3VjaEluZGV4OiBbNSwgXCJObyBzdWNoIGluZGV4XCJdLFxuICAvKipcbiAgICogRXJyb3IgaW5kaWNhdGluZyB0aGF0IGEgc3BlY2lmaWVkIHJvdyBpdGVyYXRvciBpcyBub3QgdmFsaWQuXG4gICAqL1xuICBOb1N1Y2hJdGVyOiBbNiwgXCJUaGUgcHJvdmlkZWQgcm93IGl0ZXJhdG9yIGlzIG5vdCB2YWxpZFwiXSxcbiAgLyoqXG4gICAqIEVycm9yIGluZGljYXRpbmcgdGhhdCBhIHNwZWNpZmllZCBjb25zb2xlIHRpbWVyIGRvZXMgbm90IGV4aXN0LlxuICAgKi9cbiAgTm9TdWNoQ29uc29sZVRpbWVyOiBbNywgXCJUaGUgcHJvdmlkZWQgY29uc29sZSB0aW1lciBkb2VzIG5vdCBleGlzdFwiXSxcbiAgLyoqXG4gICAqIEVycm9yIGluZGljYXRpbmcgdGhhdCBhIHNwZWNpZmllZCBieXRlcyBzb3VyY2Ugb3Igc2luayBpcyBub3QgdmFsaWQuXG4gICAqL1xuICBOb1N1Y2hCeXRlczogWzgsIFwiVGhlIHByb3ZpZGVkIGJ5dGVzIHNvdXJjZSBvciBzaW5rIGlzIG5vdCB2YWxpZFwiXSxcbiAgLyoqXG4gICAqIEVycm9yIGluZGljYXRpbmcgdGhhdCBhIHByb3ZpZGVkIHNpbmsgaGFzIG5vIG1vcmUgc3BhY2UgbGVmdC5cbiAgICovXG4gIE5vU3BhY2U6IFs5LCBcIlRoZSBwcm92aWRlZCBzaW5rIGhhcyBubyBtb3JlIHNwYWNlIGxlZnRcIl0sXG4gIC8qKlxuICAgKiBFcnJvciBpbmRpY2F0aW5nIHRoYXQgdGhlcmUgaXMgbm8gbW9yZSBzcGFjZSBpbiB0aGUgZGF0YWJhc2UuXG4gICAqL1xuICBCdWZmZXJUb29TbWFsbDogW1xuICAgIDExLFxuICAgIFwiVGhlIHByb3ZpZGVkIGJ1ZmZlciBpcyBub3QgbGFyZ2UgZW5vdWdoIHRvIHN0b3JlIHRoZSBkYXRhXCJcbiAgXSxcbiAgLyoqXG4gICAqIEVycm9yIGluZGljYXRpbmcgdGhhdCBhIHZhbHVlIHdpdGggYSBnaXZlbiB1bmlxdWUgaWRlbnRpZmllciBhbHJlYWR5IGV4aXN0cy5cbiAgICovXG4gIFVuaXF1ZUFscmVhZHlFeGlzdHM6IFtcbiAgICAxMixcbiAgICBcIlZhbHVlIHdpdGggZ2l2ZW4gdW5pcXVlIGlkZW50aWZpZXIgYWxyZWFkeSBleGlzdHNcIlxuICBdLFxuICAvKipcbiAgICogRXJyb3IgaW5kaWNhdGluZyB0aGF0IHRoZSBzcGVjaWZpZWQgZGVsYXkgaW4gc2NoZWR1bGluZyBhIHJvdyB3YXMgdG9vIGxvbmcuXG4gICAqL1xuICBTY2hlZHVsZUF0RGVsYXlUb29Mb25nOiBbXG4gICAgMTMsXG4gICAgXCJTcGVjaWZpZWQgZGVsYXkgaW4gc2NoZWR1bGluZyByb3cgd2FzIHRvbyBsb25nXCJcbiAgXSxcbiAgLyoqXG4gICAqIEVycm9yIGluZGljYXRpbmcgdGhhdCBhbiBpbmRleCB3YXMgbm90IHVuaXF1ZSB3aGVuIGl0IHdhcyBleHBlY3RlZCB0byBiZS5cbiAgICovXG4gIEluZGV4Tm90VW5pcXVlOiBbMTQsIFwiVGhlIGluZGV4IHdhcyBub3QgdW5pcXVlXCJdLFxuICAvKipcbiAgICogRXJyb3IgaW5kaWNhdGluZyB0aGF0IGFuIGluZGV4IHdhcyBub3QgdW5pcXVlIHdoZW4gaXQgd2FzIGV4cGVjdGVkIHRvIGJlLlxuICAgKi9cbiAgTm9TdWNoUm93OiBbMTUsIFwiVGhlIHJvdyB3YXMgbm90IGZvdW5kLCBlLmcuLCBpbiBhbiB1cGRhdGUgY2FsbFwiXSxcbiAgLyoqXG4gICAqIEVycm9yIGluZGljYXRpbmcgdGhhdCBhbiBhdXRvLWluY3JlbWVudCBzZXF1ZW5jZSBoYXMgb3ZlcmZsb3dlZC5cbiAgICovXG4gIEF1dG9JbmNPdmVyZmxvdzogWzE2LCBcIlRoZSBhdXRvLWluY3JlbWVudCBzZXF1ZW5jZSBvdmVyZmxvd2VkXCJdLFxuICBXb3VsZEJsb2NrVHJhbnNhY3Rpb246IFtcbiAgICAxNyxcbiAgICBcIkF0dGVtcHRlZCBhc3luYyBvciBibG9ja2luZyBvcCB3aGlsZSBob2xkaW5nIG9wZW4gYSB0cmFuc2FjdGlvblwiXG4gIF0sXG4gIFRyYW5zYWN0aW9uTm90QW5vbnltb3VzOiBbXG4gICAgMTgsXG4gICAgXCJOb3QgaW4gYW4gYW5vbnltb3VzIHRyYW5zYWN0aW9uLiBDYWxsZWQgYnkgYSByZWR1Y2VyP1wiXG4gIF0sXG4gIFRyYW5zYWN0aW9uSXNSZWFkT25seTogW1xuICAgIDE5LFxuICAgIFwiQUJJIGNhbGwgY2FuIG9ubHkgYmUgbWFkZSB3aGlsZSB3aXRoaW4gYSBtdXRhYmxlIHRyYW5zYWN0aW9uXCJcbiAgXSxcbiAgVHJhbnNhY3Rpb25Jc011dDogW1xuICAgIDIwLFxuICAgIFwiQUJJIGNhbGwgY2FuIG9ubHkgYmUgbWFkZSB3aGlsZSB3aXRoaW4gYSByZWFkLW9ubHkgdHJhbnNhY3Rpb25cIlxuICBdLFxuICBIdHRwRXJyb3I6IFsyMSwgXCJUaGUgSFRUUCByZXF1ZXN0IGZhaWxlZFwiXVxufTtcbmZ1bmN0aW9uIG1hcEVudHJpZXMoeCwgZikge1xuICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgIE9iamVjdC5lbnRyaWVzKHgpLm1hcCgoW2ssIHZdKSA9PiBbaywgZihrLCB2KV0pXG4gICk7XG59XG52YXIgZXJyb3JzID0gT2JqZWN0LmZyZWV6ZShcbiAgbWFwRW50cmllcyhcbiAgICBlcnJvckRhdGEsXG4gICAgKG5hbWUsIFtjb2RlLCBtZXNzYWdlXSkgPT4gT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgICAgY2xhc3MgZXh0ZW5kcyBTcGFjZXRpbWVIb3N0RXJyb3Ige1xuICAgICAgICBzdGF0aWMgQ09ERSA9IGNvZGU7XG4gICAgICAgIHN0YXRpYyBNRVNTQUdFID0gbWVzc2FnZTtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgc3VwZXIoY29kZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcIm5hbWVcIixcbiAgICAgIHsgdmFsdWU6IG5hbWUsIHdyaXRhYmxlOiBmYWxzZSB9XG4gICAgKVxuICApXG4pO1xudmFyIGVycm9yUHJvdG95cGVzID0gbmV3IFNldChPYmplY3QudmFsdWVzKGVycm9ycykubWFwKChjbHMpID0+IGNscy5wcm90b3R5cGUpKTtcbnZhciBlcnJub1RvQ2xhc3MgPSBuZXcgTWFwKFxuICBPYmplY3QudmFsdWVzKGVycm9ycykubWFwKChjbHMpID0+IFtjbHMuQ09ERSwgY2xzXSlcbik7XG5cbi8vIHNyYy9zZXJ2ZXIvcG9seWZpbGxzLnRzXG5fX3RvRVNNKHJlcXVpcmVfdGV4dF9taW4oKSk7XG5cbi8vIHNyYy9saWIvYXV0b2dlbi9zdW1fdHlwZV92YXJpYW50X3R5cGUudHNcbnZhciBzdW1fdHlwZV92YXJpYW50X3R5cGVfZGVmYXVsdCA9IHQub2JqZWN0KFwiU3VtVHlwZVZhcmlhbnRcIiwge1xuICBuYW1lOiB0Lm9wdGlvbih0LnN0cmluZygpKSxcbiAgZ2V0IGFsZ2VicmFpY1R5cGUoKSB7XG4gICAgcmV0dXJuIGFsZ2VicmFpY190eXBlX3R5cGVfZGVmYXVsdDtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvYXV0b2dlbi9zdW1fdHlwZV90eXBlLnRzXG52YXIgc3VtX3R5cGVfdHlwZV9kZWZhdWx0ID0gdC5vYmplY3QoXCJTdW1UeXBlXCIsIHtcbiAgZ2V0IHZhcmlhbnRzKCkge1xuICAgIHJldHVybiB0LmFycmF5KHN1bV90eXBlX3ZhcmlhbnRfdHlwZV9kZWZhdWx0KTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvYXV0b2dlbi9wcm9kdWN0X3R5cGVfZWxlbWVudF90eXBlLnRzXG52YXIgcHJvZHVjdF90eXBlX2VsZW1lbnRfdHlwZV9kZWZhdWx0ID0gdC5vYmplY3QoXCJQcm9kdWN0VHlwZUVsZW1lbnRcIiwge1xuICBuYW1lOiB0Lm9wdGlvbih0LnN0cmluZygpKSxcbiAgZ2V0IGFsZ2VicmFpY1R5cGUoKSB7XG4gICAgcmV0dXJuIGFsZ2VicmFpY190eXBlX3R5cGVfZGVmYXVsdDtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvYXV0b2dlbi9wcm9kdWN0X3R5cGVfdHlwZS50c1xudmFyIHByb2R1Y3RfdHlwZV90eXBlX2RlZmF1bHQgPSB0Lm9iamVjdChcIlByb2R1Y3RUeXBlXCIsIHtcbiAgZ2V0IGVsZW1lbnRzKCkge1xuICAgIHJldHVybiB0LmFycmF5KHByb2R1Y3RfdHlwZV9lbGVtZW50X3R5cGVfZGVmYXVsdCk7XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL2F1dG9nZW4vYWxnZWJyYWljX3R5cGVfdHlwZS50c1xudmFyIEFsZ2VicmFpY1R5cGUyID0gdC5lbnVtKFwiQWxnZWJyYWljVHlwZVwiLCB7XG4gIFJlZjogdC51MzIoKSxcbiAgZ2V0IFN1bSgpIHtcbiAgICByZXR1cm4gc3VtX3R5cGVfdHlwZV9kZWZhdWx0O1xuICB9LFxuICBnZXQgUHJvZHVjdCgpIHtcbiAgICByZXR1cm4gcHJvZHVjdF90eXBlX3R5cGVfZGVmYXVsdDtcbiAgfSxcbiAgZ2V0IEFycmF5KCkge1xuICAgIHJldHVybiBBbGdlYnJhaWNUeXBlMjtcbiAgfSxcbiAgU3RyaW5nOiB0LnVuaXQoKSxcbiAgQm9vbDogdC51bml0KCksXG4gIEk4OiB0LnVuaXQoKSxcbiAgVTg6IHQudW5pdCgpLFxuICBJMTY6IHQudW5pdCgpLFxuICBVMTY6IHQudW5pdCgpLFxuICBJMzI6IHQudW5pdCgpLFxuICBVMzI6IHQudW5pdCgpLFxuICBJNjQ6IHQudW5pdCgpLFxuICBVNjQ6IHQudW5pdCgpLFxuICBJMTI4OiB0LnVuaXQoKSxcbiAgVTEyODogdC51bml0KCksXG4gIEkyNTY6IHQudW5pdCgpLFxuICBVMjU2OiB0LnVuaXQoKSxcbiAgRjMyOiB0LnVuaXQoKSxcbiAgRjY0OiB0LnVuaXQoKVxufSk7XG52YXIgYWxnZWJyYWljX3R5cGVfdHlwZV9kZWZhdWx0ID0gQWxnZWJyYWljVHlwZTI7XG5cbi8vIHNyYy9saWIvYXV0b2dlbi90eXBlc3BhY2VfdHlwZS50c1xudmFyIHR5cGVzcGFjZV90eXBlX2RlZmF1bHQgPSB0Lm9iamVjdChcIlR5cGVzcGFjZVwiLCB7XG4gIGdldCB0eXBlcygpIHtcbiAgICByZXR1cm4gdC5hcnJheShhbGdlYnJhaWNfdHlwZV90eXBlX2RlZmF1bHQpO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi9hdXRvZ2VuL3Jhd19jb2x1bW5fZGVmX3ZfOF90eXBlLnRzXG52YXIgcmF3X2NvbHVtbl9kZWZfdl84X3R5cGVfZGVmYXVsdCA9IHQub2JqZWN0KFwiUmF3Q29sdW1uRGVmVjhcIiwge1xuICBjb2xOYW1lOiB0LnN0cmluZygpLFxuICBnZXQgY29sVHlwZSgpIHtcbiAgICByZXR1cm4gYWxnZWJyYWljX3R5cGVfdHlwZV9kZWZhdWx0O1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi9hdXRvZ2VuL2luZGV4X3R5cGVfdHlwZS50c1xudmFyIEluZGV4VHlwZSA9IHQuZW51bShcIkluZGV4VHlwZVwiLCB7XG4gIEJUcmVlOiB0LnVuaXQoKSxcbiAgSGFzaDogdC51bml0KClcbn0pO1xudmFyIGluZGV4X3R5cGVfdHlwZV9kZWZhdWx0ID0gSW5kZXhUeXBlO1xuXG4vLyBzcmMvbGliL2F1dG9nZW4vcmF3X2luZGV4X2RlZl92XzhfdHlwZS50c1xudmFyIHJhd19pbmRleF9kZWZfdl84X3R5cGVfZGVmYXVsdCA9IHQub2JqZWN0KFwiUmF3SW5kZXhEZWZWOFwiLCB7XG4gIGluZGV4TmFtZTogdC5zdHJpbmcoKSxcbiAgaXNVbmlxdWU6IHQuYm9vbCgpLFxuICBnZXQgaW5kZXhUeXBlKCkge1xuICAgIHJldHVybiBpbmRleF90eXBlX3R5cGVfZGVmYXVsdDtcbiAgfSxcbiAgY29sdW1uczogdC5hcnJheSh0LnUxNigpKVxufSk7XG5cbi8vIHNyYy9saWIvYXV0b2dlbi9yYXdfY29uc3RyYWludF9kZWZfdl84X3R5cGUudHNcbnZhciByYXdfY29uc3RyYWludF9kZWZfdl84X3R5cGVfZGVmYXVsdCA9IHQub2JqZWN0KFwiUmF3Q29uc3RyYWludERlZlY4XCIsIHtcbiAgY29uc3RyYWludE5hbWU6IHQuc3RyaW5nKCksXG4gIGNvbnN0cmFpbnRzOiB0LnU4KCksXG4gIGNvbHVtbnM6IHQuYXJyYXkodC51MTYoKSlcbn0pO1xuXG4vLyBzcmMvbGliL2F1dG9nZW4vcmF3X3NlcXVlbmNlX2RlZl92XzhfdHlwZS50c1xudmFyIHJhd19zZXF1ZW5jZV9kZWZfdl84X3R5cGVfZGVmYXVsdCA9IHQub2JqZWN0KFwiUmF3U2VxdWVuY2VEZWZWOFwiLCB7XG4gIHNlcXVlbmNlTmFtZTogdC5zdHJpbmcoKSxcbiAgY29sUG9zOiB0LnUxNigpLFxuICBpbmNyZW1lbnQ6IHQuaTEyOCgpLFxuICBzdGFydDogdC5vcHRpb24odC5pMTI4KCkpLFxuICBtaW5WYWx1ZTogdC5vcHRpb24odC5pMTI4KCkpLFxuICBtYXhWYWx1ZTogdC5vcHRpb24odC5pMTI4KCkpLFxuICBhbGxvY2F0ZWQ6IHQuaTEyOCgpXG59KTtcblxuLy8gc3JjL2xpYi9hdXRvZ2VuL3Jhd190YWJsZV9kZWZfdl84X3R5cGUudHNcbnZhciByYXdfdGFibGVfZGVmX3ZfOF90eXBlX2RlZmF1bHQgPSB0Lm9iamVjdChcIlJhd1RhYmxlRGVmVjhcIiwge1xuICB0YWJsZU5hbWU6IHQuc3RyaW5nKCksXG4gIGdldCBjb2x1bW5zKCkge1xuICAgIHJldHVybiB0LmFycmF5KHJhd19jb2x1bW5fZGVmX3ZfOF90eXBlX2RlZmF1bHQpO1xuICB9LFxuICBnZXQgaW5kZXhlcygpIHtcbiAgICByZXR1cm4gdC5hcnJheShyYXdfaW5kZXhfZGVmX3ZfOF90eXBlX2RlZmF1bHQpO1xuICB9LFxuICBnZXQgY29uc3RyYWludHMoKSB7XG4gICAgcmV0dXJuIHQuYXJyYXkocmF3X2NvbnN0cmFpbnRfZGVmX3ZfOF90eXBlX2RlZmF1bHQpO1xuICB9LFxuICBnZXQgc2VxdWVuY2VzKCkge1xuICAgIHJldHVybiB0LmFycmF5KHJhd19zZXF1ZW5jZV9kZWZfdl84X3R5cGVfZGVmYXVsdCk7XG4gIH0sXG4gIHRhYmxlVHlwZTogdC5zdHJpbmcoKSxcbiAgdGFibGVBY2Nlc3M6IHQuc3RyaW5nKCksXG4gIHNjaGVkdWxlZDogdC5vcHRpb24odC5zdHJpbmcoKSlcbn0pO1xuXG4vLyBzcmMvbGliL2F1dG9nZW4vdGFibGVfZGVzY190eXBlLnRzXG52YXIgdGFibGVfZGVzY190eXBlX2RlZmF1bHQgPSB0Lm9iamVjdChcIlRhYmxlRGVzY1wiLCB7XG4gIGdldCBzY2hlbWEoKSB7XG4gICAgcmV0dXJuIHJhd190YWJsZV9kZWZfdl84X3R5cGVfZGVmYXVsdDtcbiAgfSxcbiAgZGF0YTogdC51MzIoKVxufSk7XG5cbi8vIHNyYy9saWIvYXV0b2dlbi9yZWR1Y2VyX2RlZl90eXBlLnRzXG52YXIgcmVkdWNlcl9kZWZfdHlwZV9kZWZhdWx0ID0gdC5vYmplY3QoXCJSZWR1Y2VyRGVmXCIsIHtcbiAgbmFtZTogdC5zdHJpbmcoKSxcbiAgZ2V0IGFyZ3MoKSB7XG4gICAgcmV0dXJuIHQuYXJyYXkocHJvZHVjdF90eXBlX2VsZW1lbnRfdHlwZV9kZWZhdWx0KTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvYXV0b2dlbi90eXBlX2FsaWFzX3R5cGUudHNcbnZhciB0eXBlX2FsaWFzX3R5cGVfZGVmYXVsdCA9IHQub2JqZWN0KFwiVHlwZUFsaWFzXCIsIHtcbiAgbmFtZTogdC5zdHJpbmcoKSxcbiAgdHk6IHQudTMyKClcbn0pO1xuXG4vLyBzcmMvbGliL2F1dG9nZW4vbWlzY19tb2R1bGVfZXhwb3J0X3R5cGUudHNcbnZhciBNaXNjTW9kdWxlRXhwb3J0ID0gdC5lbnVtKFwiTWlzY01vZHVsZUV4cG9ydFwiLCB7XG4gIGdldCBUeXBlQWxpYXMoKSB7XG4gICAgcmV0dXJuIHR5cGVfYWxpYXNfdHlwZV9kZWZhdWx0O1xuICB9XG59KTtcbnZhciBtaXNjX21vZHVsZV9leHBvcnRfdHlwZV9kZWZhdWx0ID0gTWlzY01vZHVsZUV4cG9ydDtcblxuLy8gc3JjL2xpYi9hdXRvZ2VuL3Jhd19tb2R1bGVfZGVmX3ZfOF90eXBlLnRzXG52YXIgcmF3X21vZHVsZV9kZWZfdl84X3R5cGVfZGVmYXVsdCA9IHQub2JqZWN0KFwiUmF3TW9kdWxlRGVmVjhcIiwge1xuICBnZXQgdHlwZXNwYWNlKCkge1xuICAgIHJldHVybiB0eXBlc3BhY2VfdHlwZV9kZWZhdWx0O1xuICB9LFxuICBnZXQgdGFibGVzKCkge1xuICAgIHJldHVybiB0LmFycmF5KHRhYmxlX2Rlc2NfdHlwZV9kZWZhdWx0KTtcbiAgfSxcbiAgZ2V0IHJlZHVjZXJzKCkge1xuICAgIHJldHVybiB0LmFycmF5KHJlZHVjZXJfZGVmX3R5cGVfZGVmYXVsdCk7XG4gIH0sXG4gIGdldCBtaXNjRXhwb3J0cygpIHtcbiAgICByZXR1cm4gdC5hcnJheShtaXNjX21vZHVsZV9leHBvcnRfdHlwZV9kZWZhdWx0KTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvYXV0b2dlbi9yYXdfaW5kZXhfZGVmX3ZfOV90eXBlLnRzXG52YXIgcmF3X2luZGV4X2RlZl92XzlfdHlwZV9kZWZhdWx0ID0gdC5vYmplY3QoXCJSYXdJbmRleERlZlY5XCIsIHtcbiAgbmFtZTogdC5vcHRpb24odC5zdHJpbmcoKSksXG4gIGFjY2Vzc29yTmFtZTogdC5vcHRpb24odC5zdHJpbmcoKSksXG4gIGdldCBhbGdvcml0aG0oKSB7XG4gICAgcmV0dXJuIHJhd19pbmRleF9hbGdvcml0aG1fdHlwZV9kZWZhdWx0O1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi9hdXRvZ2VuL3Jhd191bmlxdWVfY29uc3RyYWludF9kYXRhX3ZfOV90eXBlLnRzXG52YXIgcmF3X3VuaXF1ZV9jb25zdHJhaW50X2RhdGFfdl85X3R5cGVfZGVmYXVsdCA9IHQub2JqZWN0KFwiUmF3VW5pcXVlQ29uc3RyYWludERhdGFWOVwiLCB7XG4gIGNvbHVtbnM6IHQuYXJyYXkodC51MTYoKSlcbn0pO1xuXG4vLyBzcmMvbGliL2F1dG9nZW4vcmF3X2NvbnN0cmFpbnRfZGF0YV92XzlfdHlwZS50c1xudmFyIFJhd0NvbnN0cmFpbnREYXRhVjkgPSB0LmVudW0oXCJSYXdDb25zdHJhaW50RGF0YVY5XCIsIHtcbiAgZ2V0IFVuaXF1ZSgpIHtcbiAgICByZXR1cm4gcmF3X3VuaXF1ZV9jb25zdHJhaW50X2RhdGFfdl85X3R5cGVfZGVmYXVsdDtcbiAgfVxufSk7XG52YXIgcmF3X2NvbnN0cmFpbnRfZGF0YV92XzlfdHlwZV9kZWZhdWx0ID0gUmF3Q29uc3RyYWludERhdGFWOTtcblxuLy8gc3JjL2xpYi9hdXRvZ2VuL3Jhd19jb25zdHJhaW50X2RlZl92XzlfdHlwZS50c1xudmFyIHJhd19jb25zdHJhaW50X2RlZl92XzlfdHlwZV9kZWZhdWx0ID0gdC5vYmplY3QoXCJSYXdDb25zdHJhaW50RGVmVjlcIiwge1xuICBuYW1lOiB0Lm9wdGlvbih0LnN0cmluZygpKSxcbiAgZ2V0IGRhdGEoKSB7XG4gICAgcmV0dXJuIHJhd19jb25zdHJhaW50X2RhdGFfdl85X3R5cGVfZGVmYXVsdDtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvYXV0b2dlbi9yYXdfc2VxdWVuY2VfZGVmX3ZfOV90eXBlLnRzXG52YXIgcmF3X3NlcXVlbmNlX2RlZl92XzlfdHlwZV9kZWZhdWx0ID0gdC5vYmplY3QoXCJSYXdTZXF1ZW5jZURlZlY5XCIsIHtcbiAgbmFtZTogdC5vcHRpb24odC5zdHJpbmcoKSksXG4gIGNvbHVtbjogdC51MTYoKSxcbiAgc3RhcnQ6IHQub3B0aW9uKHQuaTEyOCgpKSxcbiAgbWluVmFsdWU6IHQub3B0aW9uKHQuaTEyOCgpKSxcbiAgbWF4VmFsdWU6IHQub3B0aW9uKHQuaTEyOCgpKSxcbiAgaW5jcmVtZW50OiB0LmkxMjgoKVxufSk7XG5cbi8vIHNyYy9saWIvYXV0b2dlbi9yYXdfc2NoZWR1bGVfZGVmX3ZfOV90eXBlLnRzXG52YXIgcmF3X3NjaGVkdWxlX2RlZl92XzlfdHlwZV9kZWZhdWx0ID0gdC5vYmplY3QoXCJSYXdTY2hlZHVsZURlZlY5XCIsIHtcbiAgbmFtZTogdC5vcHRpb24odC5zdHJpbmcoKSksXG4gIHJlZHVjZXJOYW1lOiB0LnN0cmluZygpLFxuICBzY2hlZHVsZWRBdENvbHVtbjogdC51MTYoKVxufSk7XG5cbi8vIHNyYy9saWIvYXV0b2dlbi90YWJsZV90eXBlX3R5cGUudHNcbnZhciBUYWJsZVR5cGUgPSB0LmVudW0oXCJUYWJsZVR5cGVcIiwge1xuICBTeXN0ZW06IHQudW5pdCgpLFxuICBVc2VyOiB0LnVuaXQoKVxufSk7XG52YXIgdGFibGVfdHlwZV90eXBlX2RlZmF1bHQgPSBUYWJsZVR5cGU7XG5cbi8vIHNyYy9saWIvYXV0b2dlbi90YWJsZV9hY2Nlc3NfdHlwZS50c1xudmFyIFRhYmxlQWNjZXNzID0gdC5lbnVtKFwiVGFibGVBY2Nlc3NcIiwge1xuICBQdWJsaWM6IHQudW5pdCgpLFxuICBQcml2YXRlOiB0LnVuaXQoKVxufSk7XG52YXIgdGFibGVfYWNjZXNzX3R5cGVfZGVmYXVsdCA9IFRhYmxlQWNjZXNzO1xuXG4vLyBzcmMvbGliL2F1dG9nZW4vcmF3X3RhYmxlX2RlZl92XzlfdHlwZS50c1xudmFyIHJhd190YWJsZV9kZWZfdl85X3R5cGVfZGVmYXVsdCA9IHQub2JqZWN0KFwiUmF3VGFibGVEZWZWOVwiLCB7XG4gIG5hbWU6IHQuc3RyaW5nKCksXG4gIHByb2R1Y3RUeXBlUmVmOiB0LnUzMigpLFxuICBwcmltYXJ5S2V5OiB0LmFycmF5KHQudTE2KCkpLFxuICBnZXQgaW5kZXhlcygpIHtcbiAgICByZXR1cm4gdC5hcnJheShyYXdfaW5kZXhfZGVmX3ZfOV90eXBlX2RlZmF1bHQpO1xuICB9LFxuICBnZXQgY29uc3RyYWludHMoKSB7XG4gICAgcmV0dXJuIHQuYXJyYXkocmF3X2NvbnN0cmFpbnRfZGVmX3ZfOV90eXBlX2RlZmF1bHQpO1xuICB9LFxuICBnZXQgc2VxdWVuY2VzKCkge1xuICAgIHJldHVybiB0LmFycmF5KHJhd19zZXF1ZW5jZV9kZWZfdl85X3R5cGVfZGVmYXVsdCk7XG4gIH0sXG4gIGdldCBzY2hlZHVsZSgpIHtcbiAgICByZXR1cm4gdC5vcHRpb24ocmF3X3NjaGVkdWxlX2RlZl92XzlfdHlwZV9kZWZhdWx0KTtcbiAgfSxcbiAgZ2V0IHRhYmxlVHlwZSgpIHtcbiAgICByZXR1cm4gdGFibGVfdHlwZV90eXBlX2RlZmF1bHQ7XG4gIH0sXG4gIGdldCB0YWJsZUFjY2VzcygpIHtcbiAgICByZXR1cm4gdGFibGVfYWNjZXNzX3R5cGVfZGVmYXVsdDtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvYXV0b2dlbi9yYXdfcmVkdWNlcl9kZWZfdl85X3R5cGUudHNcbnZhciByYXdfcmVkdWNlcl9kZWZfdl85X3R5cGVfZGVmYXVsdCA9IHQub2JqZWN0KFwiUmF3UmVkdWNlckRlZlY5XCIsIHtcbiAgbmFtZTogdC5zdHJpbmcoKSxcbiAgZ2V0IHBhcmFtcygpIHtcbiAgICByZXR1cm4gcHJvZHVjdF90eXBlX3R5cGVfZGVmYXVsdDtcbiAgfSxcbiAgZ2V0IGxpZmVjeWNsZSgpIHtcbiAgICByZXR1cm4gdC5vcHRpb24obGlmZWN5Y2xlX3R5cGVfZGVmYXVsdCk7XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL2F1dG9nZW4vcmF3X3Njb3BlZF90eXBlX25hbWVfdl85X3R5cGUudHNcbnZhciByYXdfc2NvcGVkX3R5cGVfbmFtZV92XzlfdHlwZV9kZWZhdWx0ID0gdC5vYmplY3QoXCJSYXdTY29wZWRUeXBlTmFtZVY5XCIsIHtcbiAgc2NvcGU6IHQuYXJyYXkodC5zdHJpbmcoKSksXG4gIG5hbWU6IHQuc3RyaW5nKClcbn0pO1xuXG4vLyBzcmMvbGliL2F1dG9nZW4vcmF3X3R5cGVfZGVmX3ZfOV90eXBlLnRzXG52YXIgcmF3X3R5cGVfZGVmX3ZfOV90eXBlX2RlZmF1bHQgPSB0Lm9iamVjdChcIlJhd1R5cGVEZWZWOVwiLCB7XG4gIGdldCBuYW1lKCkge1xuICAgIHJldHVybiByYXdfc2NvcGVkX3R5cGVfbmFtZV92XzlfdHlwZV9kZWZhdWx0O1xuICB9LFxuICB0eTogdC51MzIoKSxcbiAgY3VzdG9tT3JkZXJpbmc6IHQuYm9vbCgpXG59KTtcblxuLy8gc3JjL2xpYi9hdXRvZ2VuL3Jhd19jb2x1bW5fZGVmYXVsdF92YWx1ZV92XzlfdHlwZS50c1xudmFyIHJhd19jb2x1bW5fZGVmYXVsdF92YWx1ZV92XzlfdHlwZV9kZWZhdWx0ID0gdC5vYmplY3QoXCJSYXdDb2x1bW5EZWZhdWx0VmFsdWVWOVwiLCB7XG4gIHRhYmxlOiB0LnN0cmluZygpLFxuICBjb2xJZDogdC51MTYoKSxcbiAgdmFsdWU6IHQuYnl0ZUFycmF5KClcbn0pO1xuXG4vLyBzcmMvbGliL2F1dG9nZW4vcmF3X3Byb2NlZHVyZV9kZWZfdl85X3R5cGUudHNcbnZhciByYXdfcHJvY2VkdXJlX2RlZl92XzlfdHlwZV9kZWZhdWx0ID0gdC5vYmplY3QoXCJSYXdQcm9jZWR1cmVEZWZWOVwiLCB7XG4gIG5hbWU6IHQuc3RyaW5nKCksXG4gIGdldCBwYXJhbXMoKSB7XG4gICAgcmV0dXJuIHByb2R1Y3RfdHlwZV90eXBlX2RlZmF1bHQ7XG4gIH0sXG4gIGdldCByZXR1cm5UeXBlKCkge1xuICAgIHJldHVybiBhbGdlYnJhaWNfdHlwZV90eXBlX2RlZmF1bHQ7XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL2F1dG9nZW4vcmF3X3ZpZXdfZGVmX3ZfOV90eXBlLnRzXG52YXIgcmF3X3ZpZXdfZGVmX3ZfOV90eXBlX2RlZmF1bHQgPSB0Lm9iamVjdChcIlJhd1ZpZXdEZWZWOVwiLCB7XG4gIG5hbWU6IHQuc3RyaW5nKCksXG4gIGluZGV4OiB0LnUzMigpLFxuICBpc1B1YmxpYzogdC5ib29sKCksXG4gIGlzQW5vbnltb3VzOiB0LmJvb2woKSxcbiAgZ2V0IHBhcmFtcygpIHtcbiAgICByZXR1cm4gcHJvZHVjdF90eXBlX3R5cGVfZGVmYXVsdDtcbiAgfSxcbiAgZ2V0IHJldHVyblR5cGUoKSB7XG4gICAgcmV0dXJuIGFsZ2VicmFpY190eXBlX3R5cGVfZGVmYXVsdDtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvYXV0b2dlbi9yYXdfbWlzY19tb2R1bGVfZXhwb3J0X3ZfOV90eXBlLnRzXG52YXIgUmF3TWlzY01vZHVsZUV4cG9ydFY5ID0gdC5lbnVtKFwiUmF3TWlzY01vZHVsZUV4cG9ydFY5XCIsIHtcbiAgZ2V0IENvbHVtbkRlZmF1bHRWYWx1ZSgpIHtcbiAgICByZXR1cm4gcmF3X2NvbHVtbl9kZWZhdWx0X3ZhbHVlX3ZfOV90eXBlX2RlZmF1bHQ7XG4gIH0sXG4gIGdldCBQcm9jZWR1cmUoKSB7XG4gICAgcmV0dXJuIHJhd19wcm9jZWR1cmVfZGVmX3ZfOV90eXBlX2RlZmF1bHQ7XG4gIH0sXG4gIGdldCBWaWV3KCkge1xuICAgIHJldHVybiByYXdfdmlld19kZWZfdl85X3R5cGVfZGVmYXVsdDtcbiAgfVxufSk7XG52YXIgcmF3X21pc2NfbW9kdWxlX2V4cG9ydF92XzlfdHlwZV9kZWZhdWx0ID0gUmF3TWlzY01vZHVsZUV4cG9ydFY5O1xuXG4vLyBzcmMvbGliL2F1dG9nZW4vcmF3X3Jvd19sZXZlbF9zZWN1cml0eV9kZWZfdl85X3R5cGUudHNcbnZhciByYXdfcm93X2xldmVsX3NlY3VyaXR5X2RlZl92XzlfdHlwZV9kZWZhdWx0ID0gdC5vYmplY3QoXCJSYXdSb3dMZXZlbFNlY3VyaXR5RGVmVjlcIiwge1xuICBzcWw6IHQuc3RyaW5nKClcbn0pO1xuXG4vLyBzcmMvbGliL2F1dG9nZW4vcmF3X21vZHVsZV9kZWZfdl85X3R5cGUudHNcbnZhciByYXdfbW9kdWxlX2RlZl92XzlfdHlwZV9kZWZhdWx0ID0gdC5vYmplY3QoXCJSYXdNb2R1bGVEZWZWOVwiLCB7XG4gIGdldCB0eXBlc3BhY2UoKSB7XG4gICAgcmV0dXJuIHR5cGVzcGFjZV90eXBlX2RlZmF1bHQ7XG4gIH0sXG4gIGdldCB0YWJsZXMoKSB7XG4gICAgcmV0dXJuIHQuYXJyYXkocmF3X3RhYmxlX2RlZl92XzlfdHlwZV9kZWZhdWx0KTtcbiAgfSxcbiAgZ2V0IHJlZHVjZXJzKCkge1xuICAgIHJldHVybiB0LmFycmF5KHJhd19yZWR1Y2VyX2RlZl92XzlfdHlwZV9kZWZhdWx0KTtcbiAgfSxcbiAgZ2V0IHR5cGVzKCkge1xuICAgIHJldHVybiB0LmFycmF5KHJhd190eXBlX2RlZl92XzlfdHlwZV9kZWZhdWx0KTtcbiAgfSxcbiAgZ2V0IG1pc2NFeHBvcnRzKCkge1xuICAgIHJldHVybiB0LmFycmF5KHJhd19taXNjX21vZHVsZV9leHBvcnRfdl85X3R5cGVfZGVmYXVsdCk7XG4gIH0sXG4gIGdldCByb3dMZXZlbFNlY3VyaXR5KCkge1xuICAgIHJldHVybiB0LmFycmF5KHJhd19yb3dfbGV2ZWxfc2VjdXJpdHlfZGVmX3ZfOV90eXBlX2RlZmF1bHQpO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi9hdXRvZ2VuL3Jhd19tb2R1bGVfZGVmX3R5cGUudHNcbnZhciBSYXdNb2R1bGVEZWYgPSB0LmVudW0oXCJSYXdNb2R1bGVEZWZcIiwge1xuICBnZXQgVjhCYWNrQ29tcGF0KCkge1xuICAgIHJldHVybiByYXdfbW9kdWxlX2RlZl92XzhfdHlwZV9kZWZhdWx0O1xuICB9LFxuICBnZXQgVjkoKSB7XG4gICAgcmV0dXJuIHJhd19tb2R1bGVfZGVmX3ZfOV90eXBlX2RlZmF1bHQ7XG4gIH1cbn0pO1xudmFyIHJhd19tb2R1bGVfZGVmX3R5cGVfZGVmYXVsdCA9IFJhd01vZHVsZURlZjtcblxuLy8gc3JjL3NlcnZlci9yYW5nZS50c1xudmFyIFJhbmdlID0gY2xhc3Mge1xuICAjZnJvbTtcbiAgI3RvO1xuICBjb25zdHJ1Y3Rvcihmcm9tLCB0bykge1xuICAgIHRoaXMuI2Zyb20gPSBmcm9tID8/IHsgdGFnOiBcInVuYm91bmRlZFwiIH07XG4gICAgdGhpcy4jdG8gPSB0byA/PyB7IHRhZzogXCJ1bmJvdW5kZWRcIiB9O1xuICB9XG4gIGdldCBmcm9tKCkge1xuICAgIHJldHVybiB0aGlzLiNmcm9tO1xuICB9XG4gIGdldCB0bygpIHtcbiAgICByZXR1cm4gdGhpcy4jdG87XG4gIH1cbn07XG5cbi8vIHNyYy9zZXJ2ZXIvaHR0cF9pbnRlcm5hbC50c1xudmFyIGltcG9ydF9zdGF0dXNlcyA9IF9fdG9FU00ocmVxdWlyZV9zdGF0dXNlcygpKTtcblxuLy8gc3JjL2xpYi9hdXRvZ2VuL2h0dHBfaGVhZGVyX3BhaXJfdHlwZS50c1xudmFyIGh0dHBfaGVhZGVyX3BhaXJfdHlwZV9kZWZhdWx0ID0gdC5vYmplY3QoXCJIdHRwSGVhZGVyUGFpclwiLCB7XG4gIG5hbWU6IHQuc3RyaW5nKCksXG4gIHZhbHVlOiB0LmJ5dGVBcnJheSgpXG59KTtcblxuLy8gc3JjL2xpYi9hdXRvZ2VuL2h0dHBfaGVhZGVyc190eXBlLnRzXG52YXIgaHR0cF9oZWFkZXJzX3R5cGVfZGVmYXVsdCA9IHQub2JqZWN0KFwiSHR0cEhlYWRlcnNcIiwge1xuICBnZXQgZW50cmllcygpIHtcbiAgICByZXR1cm4gdC5hcnJheShodHRwX2hlYWRlcl9wYWlyX3R5cGVfZGVmYXVsdCk7XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL2F1dG9nZW4vaHR0cF9tZXRob2RfdHlwZS50c1xudmFyIEh0dHBNZXRob2QgPSB0LmVudW0oXCJIdHRwTWV0aG9kXCIsIHtcbiAgR2V0OiB0LnVuaXQoKSxcbiAgSGVhZDogdC51bml0KCksXG4gIFBvc3Q6IHQudW5pdCgpLFxuICBQdXQ6IHQudW5pdCgpLFxuICBEZWxldGU6IHQudW5pdCgpLFxuICBDb25uZWN0OiB0LnVuaXQoKSxcbiAgT3B0aW9uczogdC51bml0KCksXG4gIFRyYWNlOiB0LnVuaXQoKSxcbiAgUGF0Y2g6IHQudW5pdCgpLFxuICBFeHRlbnNpb246IHQuc3RyaW5nKClcbn0pO1xudmFyIGh0dHBfbWV0aG9kX3R5cGVfZGVmYXVsdCA9IEh0dHBNZXRob2Q7XG5cbi8vIHNyYy9saWIvYXV0b2dlbi9odHRwX3ZlcnNpb25fdHlwZS50c1xudmFyIEh0dHBWZXJzaW9uID0gdC5lbnVtKFwiSHR0cFZlcnNpb25cIiwge1xuICBIdHRwMDk6IHQudW5pdCgpLFxuICBIdHRwMTA6IHQudW5pdCgpLFxuICBIdHRwMTE6IHQudW5pdCgpLFxuICBIdHRwMjogdC51bml0KCksXG4gIEh0dHAzOiB0LnVuaXQoKVxufSk7XG52YXIgaHR0cF92ZXJzaW9uX3R5cGVfZGVmYXVsdCA9IEh0dHBWZXJzaW9uO1xuXG4vLyBzcmMvbGliL2F1dG9nZW4vaHR0cF9yZXF1ZXN0X3R5cGUudHNcbnZhciBodHRwX3JlcXVlc3RfdHlwZV9kZWZhdWx0ID0gdC5vYmplY3QoXCJIdHRwUmVxdWVzdFwiLCB7XG4gIGdldCBtZXRob2QoKSB7XG4gICAgcmV0dXJuIGh0dHBfbWV0aG9kX3R5cGVfZGVmYXVsdDtcbiAgfSxcbiAgZ2V0IGhlYWRlcnMoKSB7XG4gICAgcmV0dXJuIGh0dHBfaGVhZGVyc190eXBlX2RlZmF1bHQ7XG4gIH0sXG4gIHRpbWVvdXQ6IHQub3B0aW9uKHQudGltZUR1cmF0aW9uKCkpLFxuICB1cmk6IHQuc3RyaW5nKCksXG4gIGdldCB2ZXJzaW9uKCkge1xuICAgIHJldHVybiBodHRwX3ZlcnNpb25fdHlwZV9kZWZhdWx0O1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi9hdXRvZ2VuL2h0dHBfcmVzcG9uc2VfdHlwZS50c1xudmFyIGh0dHBfcmVzcG9uc2VfdHlwZV9kZWZhdWx0ID0gdC5vYmplY3QoXCJIdHRwUmVzcG9uc2VcIiwge1xuICBnZXQgaGVhZGVycygpIHtcbiAgICByZXR1cm4gaHR0cF9oZWFkZXJzX3R5cGVfZGVmYXVsdDtcbiAgfSxcbiAgZ2V0IHZlcnNpb24oKSB7XG4gICAgcmV0dXJuIGh0dHBfdmVyc2lvbl90eXBlX2RlZmF1bHQ7XG4gIH0sXG4gIGNvZGU6IHQudTE2KClcbn0pO1xuXG4vLyBzcmMvc2VydmVyL2h0dHBfaW50ZXJuYWwudHNcbnZhciB7IGZyZWV6ZSB9ID0gT2JqZWN0O1xudmFyIHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG52YXIgdGV4dERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoXG4gIFwidXRmLThcIlxuICAvKiB7IGZhdGFsOiB0cnVlIH0gKi9cbik7XG52YXIgbWFrZVJlc3BvbnNlID0gU3ltYm9sKFwibWFrZVJlc3BvbnNlXCIpO1xudmFyIFN5bmNSZXNwb25zZSA9IGNsYXNzIF9TeW5jUmVzcG9uc2Uge1xuICAjYm9keTtcbiAgI2lubmVyO1xuICBjb25zdHJ1Y3Rvcihib2R5LCBpbml0Mikge1xuICAgIGlmIChib2R5ID09IG51bGwpIHtcbiAgICAgIHRoaXMuI2JvZHkgPSBudWxsO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGJvZHkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRoaXMuI2JvZHkgPSBib2R5O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNib2R5ID0gbmV3IFVpbnQ4QXJyYXkoYm9keSkuYnVmZmVyO1xuICAgIH1cbiAgICB0aGlzLiNpbm5lciA9IHtcbiAgICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKGluaXQyPy5oZWFkZXJzKSxcbiAgICAgIHN0YXR1czogaW5pdDI/LnN0YXR1cyA/PyAyMDAsXG4gICAgICBzdGF0dXNUZXh0OiBpbml0Mj8uc3RhdHVzVGV4dCA/PyBcIlwiLFxuICAgICAgdHlwZTogXCJkZWZhdWx0XCIsXG4gICAgICB1cmw6IG51bGwsXG4gICAgICBhYm9ydGVkOiBmYWxzZVxuICAgIH07XG4gIH1cbiAgc3RhdGljIFttYWtlUmVzcG9uc2VdKGJvZHksIGlubmVyKSB7XG4gICAgY29uc3QgbWUgPSBuZXcgX1N5bmNSZXNwb25zZShib2R5KTtcbiAgICBtZS4jaW5uZXIgPSBpbm5lcjtcbiAgICByZXR1cm4gbWU7XG4gIH1cbiAgZ2V0IGhlYWRlcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2lubmVyLmhlYWRlcnM7XG4gIH1cbiAgZ2V0IHN0YXR1cygpIHtcbiAgICByZXR1cm4gdGhpcy4jaW5uZXIuc3RhdHVzO1xuICB9XG4gIGdldCBzdGF0dXNUZXh0KCkge1xuICAgIHJldHVybiB0aGlzLiNpbm5lci5zdGF0dXNUZXh0O1xuICB9XG4gIGdldCBvaygpIHtcbiAgICByZXR1cm4gMjAwIDw9IHRoaXMuI2lubmVyLnN0YXR1cyAmJiB0aGlzLiNpbm5lci5zdGF0dXMgPD0gMjk5O1xuICB9XG4gIGdldCB1cmwoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2lubmVyLnVybCA/PyBcIlwiO1xuICB9XG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiB0aGlzLiNpbm5lci50eXBlO1xuICB9XG4gIGFycmF5QnVmZmVyKCkge1xuICAgIHJldHVybiB0aGlzLmJ5dGVzKCkuYnVmZmVyO1xuICB9XG4gIGJ5dGVzKCkge1xuICAgIGlmICh0aGlzLiNib2R5ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSgpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMuI2JvZHkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiB0ZXh0RW5jb2Rlci5lbmNvZGUodGhpcy4jYm9keSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSh0aGlzLiNib2R5KTtcbiAgICB9XG4gIH1cbiAganNvbigpIHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZSh0aGlzLnRleHQoKSk7XG4gIH1cbiAgdGV4dCgpIHtcbiAgICBpZiAodGhpcy4jYm9keSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLiNib2R5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gdGhpcy4jYm9keTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRleHREZWNvZGVyLmRlY29kZSh0aGlzLiNib2R5KTtcbiAgICB9XG4gIH1cbn07XG52YXIgcmVxdWVzdEJhc2VTaXplID0gYnNhdG5CYXNlU2l6ZSh7IHR5cGVzOiBbXSB9LCBodHRwX3JlcXVlc3RfdHlwZV9kZWZhdWx0LmFsZ2VicmFpY1R5cGUpO1xudmFyIG1ldGhvZHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gIFtcIkdFVFwiLCB7IHRhZzogXCJHZXRcIiB9XSxcbiAgW1wiSEVBRFwiLCB7IHRhZzogXCJIZWFkXCIgfV0sXG4gIFtcIlBPU1RcIiwgeyB0YWc6IFwiUG9zdFwiIH1dLFxuICBbXCJQVVRcIiwgeyB0YWc6IFwiUHV0XCIgfV0sXG4gIFtcIkRFTEVURVwiLCB7IHRhZzogXCJEZWxldGVcIiB9XSxcbiAgW1wiQ09OTkVDVFwiLCB7IHRhZzogXCJDb25uZWN0XCIgfV0sXG4gIFtcIk9QVElPTlNcIiwgeyB0YWc6IFwiT3B0aW9uc1wiIH1dLFxuICBbXCJUUkFDRVwiLCB7IHRhZzogXCJUcmFjZVwiIH1dLFxuICBbXCJQQVRDSFwiLCB7IHRhZzogXCJQYXRjaFwiIH1dXG5dKTtcbmZ1bmN0aW9uIGZldGNoKHVybCwgaW5pdDIgPSB7fSkge1xuICBjb25zdCBtZXRob2QgPSBtZXRob2RzLmdldChpbml0Mi5tZXRob2Q/LnRvVXBwZXJDYXNlKCkgPz8gXCJHRVRcIikgPz8ge1xuICAgIHRhZzogXCJFeHRlbnNpb25cIixcbiAgICB2YWx1ZTogaW5pdDIubWV0aG9kXG4gIH07XG4gIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgLy8gYW55cyBiZWNhdXNlIHRoZSB0eXBpbmdzIGFyZSB3b25reSAtIHNlZSBjb21tZW50IGluIFN5bmNSZXNwb25zZS5jb25zdHJ1Y3RvclxuICAgIGVudHJpZXM6IGhlYWRlcnNUb0xpc3QobmV3IEhlYWRlcnMoaW5pdDIuaGVhZGVycykpLmZsYXRNYXAoKFtrLCB2XSkgPT4gQXJyYXkuaXNBcnJheSh2KSA/IHYubWFwKCh2MikgPT4gW2ssIHYyXSkgOiBbW2ssIHZdXSkubWFwKChbbmFtZSwgdmFsdWVdKSA9PiAoeyBuYW1lLCB2YWx1ZTogdGV4dEVuY29kZXIuZW5jb2RlKHZhbHVlKSB9KSlcbiAgfTtcbiAgY29uc3QgdXJpID0gXCJcIiArIHVybDtcbiAgY29uc3QgcmVxdWVzdCA9IGZyZWV6ZSh7XG4gICAgbWV0aG9kLFxuICAgIGhlYWRlcnMsXG4gICAgdGltZW91dDogaW5pdDIudGltZW91dCxcbiAgICB1cmksXG4gICAgdmVyc2lvbjogeyB0YWc6IFwiSHR0cDExXCIgfVxuICB9KTtcbiAgY29uc3QgcmVxdWVzdEJ1ZiA9IG5ldyBCaW5hcnlXcml0ZXIocmVxdWVzdEJhc2VTaXplKTtcbiAgaHR0cF9yZXF1ZXN0X3R5cGVfZGVmYXVsdC5zZXJpYWxpemUocmVxdWVzdEJ1ZiwgcmVxdWVzdCk7XG4gIGNvbnN0IGJvZHkgPSBpbml0Mi5ib2R5ID09IG51bGwgPyBuZXcgVWludDhBcnJheSgpIDogdHlwZW9mIGluaXQyLmJvZHkgPT09IFwic3RyaW5nXCIgPyBpbml0Mi5ib2R5IDogbmV3IFVpbnQ4QXJyYXkoaW5pdDIuYm9keSk7XG4gIGNvbnN0IFtyZXNwb25zZUJ1ZiwgcmVzcG9uc2VCb2R5XSA9IHN5cy5wcm9jZWR1cmVfaHR0cF9yZXF1ZXN0KFxuICAgIHJlcXVlc3RCdWYuZ2V0QnVmZmVyKCksXG4gICAgYm9keVxuICApO1xuICBjb25zdCByZXNwb25zZSA9IGh0dHBfcmVzcG9uc2VfdHlwZV9kZWZhdWx0LmRlc2VyaWFsaXplKG5ldyBCaW5hcnlSZWFkZXIocmVzcG9uc2VCdWYpKTtcbiAgcmV0dXJuIFN5bmNSZXNwb25zZVttYWtlUmVzcG9uc2VdKHJlc3BvbnNlQm9keSwge1xuICAgIHR5cGU6IFwiYmFzaWNcIixcbiAgICB1cmw6IHVyaSxcbiAgICBzdGF0dXM6IHJlc3BvbnNlLmNvZGUsXG4gICAgc3RhdHVzVGV4dDogKDAsIGltcG9ydF9zdGF0dXNlcy5kZWZhdWx0KShyZXNwb25zZS5jb2RlKSxcbiAgICBoZWFkZXJzOiBuZXcgSGVhZGVycygpLFxuICAgIGFib3J0ZWQ6IGZhbHNlXG4gIH0pO1xufVxuZnJlZXplKGZldGNoKTtcbnZhciBodHRwQ2xpZW50ID0gZnJlZXplKHsgZmV0Y2ggfSk7XG5cbi8vIHNyYy9zZXJ2ZXIvcHJvY2VkdXJlcy50c1xudmFyIHsgZnJlZXplOiBmcmVlemUyIH0gPSBPYmplY3Q7XG5mdW5jdGlvbiBjYWxsUHJvY2VkdXJlKGlkLCBzZW5kZXIsIGNvbm5lY3Rpb25JZCwgdGltZXN0YW1wLCBhcmdzQnVmKSB7XG4gIGNvbnN0IHsgZm4sIHBhcmFtc1R5cGUsIHJldHVyblR5cGUsIHJldHVyblR5cGVCYXNlU2l6ZSB9ID0gUFJPQ0VEVVJFU1tpZF07XG4gIGNvbnN0IGFyZ3MgPSBQcm9kdWN0VHlwZS5kZXNlcmlhbGl6ZVZhbHVlKFxuICAgIG5ldyBCaW5hcnlSZWFkZXIoYXJnc0J1ZiksXG4gICAgcGFyYW1zVHlwZSxcbiAgICBNT0RVTEVfREVGLnR5cGVzcGFjZVxuICApO1xuICBjb25zdCBjdHggPSB7XG4gICAgc2VuZGVyLFxuICAgIHRpbWVzdGFtcCxcbiAgICBjb25uZWN0aW9uSWQsXG4gICAgaHR0cDogaHR0cENsaWVudCxcbiAgICAvLyAqKk5vdGU6KiogbXVzdCBiZSAwLi49dTMyOjpNQVhcbiAgICBjb3VudGVyX3V1aWQ6IHsgdmFsdWU6IE51bWJlcigwKSB9LFxuICAgIGdldCBpZGVudGl0eSgpIHtcbiAgICAgIHJldHVybiBuZXcgSWRlbnRpdHkoc3lzLmlkZW50aXR5KCkuX19pZGVudGl0eV9fKTtcbiAgICB9LFxuICAgIHdpdGhUeChib2R5KSB7XG4gICAgICBjb25zdCBydW4gPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHRpbWVzdGFtcDIgPSBzeXMucHJvY2VkdXJlX3N0YXJ0X211dF90eCgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGN0eDIgPSBuZXcgUmVkdWNlckN0eEltcGwoXG4gICAgICAgICAgICBzZW5kZXIsXG4gICAgICAgICAgICBuZXcgVGltZXN0YW1wKHRpbWVzdGFtcDIpLFxuICAgICAgICAgICAgY29ubmVjdGlvbklkXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gYm9keShjdHgyKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHN5cy5wcm9jZWR1cmVfYWJvcnRfbXV0X3R4KCk7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGxldCByZXMgPSBydW4oKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN5cy5wcm9jZWR1cmVfY29tbWl0X211dF90eCgpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICB9XG4gICAgICBjb25zb2xlLndhcm4oXCJjb21taXR0aW5nIGFub255bW91cyB0cmFuc2FjdGlvbiBmYWlsZWRcIik7XG4gICAgICByZXMgPSBydW4oKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN5cy5wcm9jZWR1cmVfY29tbWl0X211dF90eCgpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cmFuc2FjdGlvbiByZXRyeSBmYWlsZWQgYWdhaW5cIiwgeyBjYXVzZTogZSB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyByYW5kb20ge0BsaW5rIFV1aWR9IGB2NGAgdXNpbmcgdGhlIHtAbGluayBjcnlwdG99IFJORy5cbiAgICAgKlxuICAgICAqIFdBUk46IFVudGlsIHdlIHVzZSBhIHNwYWNldGltZSBSTkcgdGhpcyBtYWtlIGNhbGxzIG5vbi1kZXRlcm1pbmlzdGljLlxuICAgICAqL1xuICAgIG5ld1V1aWRWNCgpIHtcbiAgICAgIGNvbnN0IGJ5dGVzID0gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheSgxNikpO1xuICAgICAgcmV0dXJuIFV1aWQuZnJvbVJhbmRvbUJ5dGVzVjQoYnl0ZXMpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IHNvcnRhYmxlIHtAbGluayBVdWlkfSBgdjdgIHVzaW5nIHRoZSB7QGxpbmsgY3J5cHRvfSBSTkcsIGNvdW50ZXIsXG4gICAgICogYW5kIHRoZSB0aW1lc3RhbXAuXG4gICAgICpcbiAgICAgKiBXQVJOOiBVbnRpbCB3ZSB1c2UgYSBzcGFjZXRpbWUgUk5HIHRoaXMgbWFrZSBjYWxscyBub24tZGV0ZXJtaW5pc3RpYy5cbiAgICAgKi9cbiAgICBuZXdVdWlkVjcoKSB7XG4gICAgICBjb25zdCBieXRlcyA9IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoMTApKTtcbiAgICAgIHJldHVybiBVdWlkLmZyb21Db3VudGVyVjcodGhpcy5jb3VudGVyX3V1aWQsIHRoaXMudGltZXN0YW1wLCBieXRlcyk7XG4gICAgfVxuICB9O1xuICBmcmVlemUyKGN0eCk7XG4gIGNvbnN0IHJldCA9IGNhbGxVc2VyRnVuY3Rpb24oZm4sIGN0eCwgYXJncyk7XG4gIGNvbnN0IHJldEJ1ZiA9IG5ldyBCaW5hcnlXcml0ZXIocmV0dXJuVHlwZUJhc2VTaXplKTtcbiAgQWxnZWJyYWljVHlwZS5zZXJpYWxpemVWYWx1ZShyZXRCdWYsIHJldHVyblR5cGUsIHJldCwgTU9EVUxFX0RFRi50eXBlc3BhY2UpO1xuICByZXR1cm4gcmV0QnVmLmdldEJ1ZmZlcigpO1xufVxuXG4vLyBzcmMvbGliL2F1dG9nZW4vdmlld19yZXN1bHRfaGVhZGVyX3R5cGUudHNcbnZhciBWaWV3UmVzdWx0SGVhZGVyID0gdC5lbnVtKFwiVmlld1Jlc3VsdEhlYWRlclwiLCB7XG4gIFJvd0RhdGE6IHQudW5pdCgpLFxuICBSYXdTcWw6IHQuc3RyaW5nKClcbn0pO1xudmFyIHZpZXdfcmVzdWx0X2hlYWRlcl90eXBlX2RlZmF1bHQgPSBWaWV3UmVzdWx0SGVhZGVyO1xuXG4vLyBzcmMvc2VydmVyL3J1bnRpbWUudHNcbnZhciB7IGZyZWV6ZTogZnJlZXplMyB9ID0gT2JqZWN0O1xudmFyIHN5cyA9IGZyZWV6ZTMod3JhcFN5c2NhbGxzKF9zeXNjYWxsczFfMCwgX3N5c2NhbGxzMV8yKSk7XG5mdW5jdGlvbiBwYXJzZUpzb25PYmplY3QoanNvbikge1xuICBsZXQgdmFsdWU7XG4gIHRyeSB7XG4gICAgdmFsdWUgPSBKU09OLnBhcnNlKGpzb24pO1xuICB9IGNhdGNoIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIEpTT046IGZhaWxlZCB0byBwYXJzZSBzdHJpbmdcIik7XG4gIH1cbiAgaWYgKHZhbHVlID09PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCBBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIGEgSlNPTiBvYmplY3QgYXQgdGhlIHRvcCBsZXZlbFwiKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG52YXIgSnd0Q2xhaW1zSW1wbCA9IGNsYXNzIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgSnd0Q2xhaW1zIGluc3RhbmNlLlxuICAgKiBAcGFyYW0gcmF3UGF5bG9hZCBUaGUgSldUIHBheWxvYWQgYXMgYSByYXcgSlNPTiBzdHJpbmcuXG4gICAqIEBwYXJhbSBpZGVudGl0eSBUaGUgaWRlbnRpdHkgZm9yIHRoaXMgSldULiBXZSBhcmUgb25seSB0YWtpbmcgdGhpcyBiZWNhdXNlIHdlIGRvbid0IGhhdmUgYSBibGFrZTMgaW1wbGVtZW50YXRpb24gKHdoaWNoIHdlIG5lZWQgdG8gY29tcHV0ZSBpdCkuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihyYXdQYXlsb2FkLCBpZGVudGl0eSkge1xuICAgIHRoaXMucmF3UGF5bG9hZCA9IHJhd1BheWxvYWQ7XG4gICAgdGhpcy5mdWxsUGF5bG9hZCA9IHBhcnNlSnNvbk9iamVjdChyYXdQYXlsb2FkKTtcbiAgICB0aGlzLl9pZGVudGl0eSA9IGlkZW50aXR5O1xuICB9XG4gIGZ1bGxQYXlsb2FkO1xuICBfaWRlbnRpdHk7XG4gIGdldCBpZGVudGl0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5faWRlbnRpdHk7XG4gIH1cbiAgZ2V0IHN1YmplY3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuZnVsbFBheWxvYWRbXCJzdWJcIl07XG4gIH1cbiAgZ2V0IGlzc3VlcigpIHtcbiAgICByZXR1cm4gdGhpcy5mdWxsUGF5bG9hZFtcImlzc1wiXTtcbiAgfVxuICBnZXQgYXVkaWVuY2UoKSB7XG4gICAgY29uc3QgYXVkID0gdGhpcy5mdWxsUGF5bG9hZFtcImF1ZFwiXTtcbiAgICBpZiAoYXVkID09IG51bGwpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGVvZiBhdWQgPT09IFwic3RyaW5nXCIgPyBbYXVkXSA6IGF1ZDtcbiAgfVxufTtcbnZhciBBdXRoQ3R4SW1wbCA9IGNsYXNzIF9BdXRoQ3R4SW1wbCB7XG4gIGlzSW50ZXJuYWw7XG4gIC8vIFNvdXJjZSBvZiB0aGUgSldUIHBheWxvYWQgc3RyaW5nLCBpZiB0aGVyZSBpcyBvbmUuXG4gIF9qd3RTb3VyY2U7XG4gIC8vIFdoZXRoZXIgd2UgaGF2ZSBpbml0aWFsaXplZCB0aGUgSldUIGNsYWltcy5cbiAgX2luaXRpYWxpemVkSldUID0gZmFsc2U7XG4gIF9qd3RDbGFpbXM7XG4gIF9zZW5kZXJJZGVudGl0eTtcbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIHRoaXMuaXNJbnRlcm5hbCA9IG9wdHMuaXNJbnRlcm5hbDtcbiAgICB0aGlzLl9qd3RTb3VyY2UgPSBvcHRzLmp3dFNvdXJjZTtcbiAgICB0aGlzLl9zZW5kZXJJZGVudGl0eSA9IG9wdHMuc2VuZGVySWRlbnRpdHk7XG4gIH1cbiAgX2luaXRpYWxpemVKV1QoKSB7XG4gICAgaWYgKHRoaXMuX2luaXRpYWxpemVkSldUKSByZXR1cm47XG4gICAgdGhpcy5faW5pdGlhbGl6ZWRKV1QgPSB0cnVlO1xuICAgIGNvbnN0IHRva2VuID0gdGhpcy5fand0U291cmNlKCk7XG4gICAgaWYgKCF0b2tlbikge1xuICAgICAgdGhpcy5fand0Q2xhaW1zID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fand0Q2xhaW1zID0gbmV3IEp3dENsYWltc0ltcGwodG9rZW4sIHRoaXMuX3NlbmRlcklkZW50aXR5KTtcbiAgICB9XG4gICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgfVxuICAvKiogTGF6aWx5IGNvbXB1dGUgd2hldGhlciBhIEpXVCBleGlzdHMgYW5kIGlzIHBhcnNlYWJsZS4gKi9cbiAgZ2V0IGhhc0pXVCgpIHtcbiAgICB0aGlzLl9pbml0aWFsaXplSldUKCk7XG4gICAgcmV0dXJuIHRoaXMuX2p3dENsYWltcyAhPT0gbnVsbDtcbiAgfVxuICAvKiogTGF6aWx5IHBhcnNlIHRoZSBKd3RDbGFpbXMgb25seSB3aGVuIGFjY2Vzc2VkLiAqL1xuICBnZXQgand0KCkge1xuICAgIHRoaXMuX2luaXRpYWxpemVKV1QoKTtcbiAgICByZXR1cm4gdGhpcy5fand0Q2xhaW1zO1xuICB9XG4gIC8qKiBDcmVhdGUgYSBjb250ZXh0IHJlcHJlc2VudGluZyBpbnRlcm5hbCAobm9uLXVzZXIpIHJlcXVlc3RzLiAqL1xuICBzdGF0aWMgaW50ZXJuYWwoKSB7XG4gICAgcmV0dXJuIG5ldyBfQXV0aEN0eEltcGwoe1xuICAgICAgaXNJbnRlcm5hbDogdHJ1ZSxcbiAgICAgIGp3dFNvdXJjZTogKCkgPT4gbnVsbCxcbiAgICAgIHNlbmRlcklkZW50aXR5OiBJZGVudGl0eS56ZXJvKClcbiAgICB9KTtcbiAgfVxuICAvKiogSWYgdGhlcmUgaXMgYSBjb25uZWN0aW9uIGlkLCBsb29rIHVwIHRoZSBKV1QgcGF5bG9hZCBmcm9tIHRoZSBzeXN0ZW0gdGFibGVzLiAqL1xuICBzdGF0aWMgZnJvbVN5c3RlbVRhYmxlcyhjb25uZWN0aW9uSWQsIHNlbmRlcikge1xuICAgIGlmIChjb25uZWN0aW9uSWQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBuZXcgX0F1dGhDdHhJbXBsKHtcbiAgICAgICAgaXNJbnRlcm5hbDogZmFsc2UsXG4gICAgICAgIGp3dFNvdXJjZTogKCkgPT4gbnVsbCxcbiAgICAgICAgc2VuZGVySWRlbnRpdHk6IHNlbmRlclxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgX0F1dGhDdHhJbXBsKHtcbiAgICAgIGlzSW50ZXJuYWw6IGZhbHNlLFxuICAgICAgand0U291cmNlOiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHBheWxvYWRCdWYgPSBzeXMuZ2V0X2p3dF9wYXlsb2FkKGNvbm5lY3Rpb25JZC5fX2Nvbm5lY3Rpb25faWRfXyk7XG4gICAgICAgIGlmIChwYXlsb2FkQnVmLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG4gICAgICAgIGNvbnN0IHBheWxvYWRTdHIgPSBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUocGF5bG9hZEJ1Zik7XG4gICAgICAgIHJldHVybiBwYXlsb2FkU3RyO1xuICAgICAgfSxcbiAgICAgIHNlbmRlcklkZW50aXR5OiBzZW5kZXJcbiAgICB9KTtcbiAgfVxufTtcbnZhciBSZWR1Y2VyQ3R4SW1wbCA9IGNsYXNzIFJlZHVjZXJDdHgge1xuICAjaWRlbnRpdHk7XG4gICNzZW5kZXJBdXRoO1xuICAjdXVpZENvdW50ZXI7XG4gIHNlbmRlcjtcbiAgdGltZXN0YW1wO1xuICBjb25uZWN0aW9uSWQ7XG4gIGRiO1xuICBjb25zdHJ1Y3RvcihzZW5kZXIsIHRpbWVzdGFtcCwgY29ubmVjdGlvbklkKSB7XG4gICAgT2JqZWN0LnNlYWwodGhpcyk7XG4gICAgdGhpcy5zZW5kZXIgPSBzZW5kZXI7XG4gICAgdGhpcy50aW1lc3RhbXAgPSB0aW1lc3RhbXA7XG4gICAgdGhpcy5jb25uZWN0aW9uSWQgPSBjb25uZWN0aW9uSWQ7XG4gICAgdGhpcy5kYiA9IGdldERiVmlldygpO1xuICB9XG4gIGdldCBpZGVudGl0eSgpIHtcbiAgICByZXR1cm4gdGhpcy4jaWRlbnRpdHkgPz89IG5ldyBJZGVudGl0eShzeXMuaWRlbnRpdHkoKS5fX2lkZW50aXR5X18pO1xuICB9XG4gIGdldCBzZW5kZXJBdXRoKCkge1xuICAgIHJldHVybiB0aGlzLiNzZW5kZXJBdXRoID8/PSBBdXRoQ3R4SW1wbC5mcm9tU3lzdGVtVGFibGVzKFxuICAgICAgdGhpcy5jb25uZWN0aW9uSWQsXG4gICAgICB0aGlzLnNlbmRlclxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyByYW5kb20ge0BsaW5rIFV1aWR9IGB2NGAgdXNpbmcgdGhlIHtAbGluayBjcnlwdG99IFJORy5cbiAgICpcbiAgICogV0FSTjogVW50aWwgd2UgdXNlIGEgc3BhY2V0aW1lIFJORyB0aGlzIG1ha2UgY2FsbHMgbm9uLWRldGVybWluaXN0aWMuXG4gICAqL1xuICBuZXdVdWlkVjQoKSB7XG4gICAgY29uc3QgYnl0ZXMgPSBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KDE2KSk7XG4gICAgcmV0dXJuIFV1aWQuZnJvbVJhbmRvbUJ5dGVzVjQoYnl0ZXMpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgc29ydGFibGUge0BsaW5rIFV1aWR9IGB2N2AgdXNpbmcgdGhlIHtAbGluayBjcnlwdG99IFJORywgY291bnRlcixcbiAgICogYW5kIHRoZSB0aW1lc3RhbXAuXG4gICAqXG4gICAqIFdBUk46IFVudGlsIHdlIHVzZSBhIHNwYWNldGltZSBSTkcgdGhpcyBtYWtlIGNhbGxzIG5vbi1kZXRlcm1pbmlzdGljLlxuICAgKi9cbiAgbmV3VXVpZFY3KCkge1xuICAgIGNvbnN0IGJ5dGVzID0gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheSg0KSk7XG4gICAgY29uc3QgY291bnRlciA9IHRoaXMuI3V1aWRDb3VudGVyID8/PSB7IHZhbHVlOiAwIH07XG4gICAgcmV0dXJuIFV1aWQuZnJvbUNvdW50ZXJWNyhjb3VudGVyLCB0aGlzLnRpbWVzdGFtcCwgYnl0ZXMpO1xuICB9XG59O1xudmFyIGNhbGxVc2VyRnVuY3Rpb24gPSBmdW5jdGlvbiBfX3NwYWNldGltZWRiX2VuZF9zaG9ydF9iYWNrdHJhY2UoZm4sIC4uLmFyZ3MpIHtcbiAgcmV0dXJuIGZuKC4uLmFyZ3MpO1xufTtcbnZhciBob29rcyA9IHtcbiAgX19kZXNjcmliZV9tb2R1bGVfXygpIHtcbiAgICBjb25zdCB3cml0ZXIgPSBuZXcgQmluYXJ5V3JpdGVyKDEyOCk7XG4gICAgQWxnZWJyYWljVHlwZS5zZXJpYWxpemVWYWx1ZShcbiAgICAgIHdyaXRlcixcbiAgICAgIHJhd19tb2R1bGVfZGVmX3R5cGVfZGVmYXVsdC5hbGdlYnJhaWNUeXBlLFxuICAgICAgcmF3X21vZHVsZV9kZWZfdHlwZV9kZWZhdWx0LlY5KE1PRFVMRV9ERUYpXG4gICAgKTtcbiAgICByZXR1cm4gd3JpdGVyLmdldEJ1ZmZlcigpO1xuICB9LFxuICBfX2NhbGxfcmVkdWNlcl9fKHJlZHVjZXJJZCwgc2VuZGVyLCBjb25uSWQsIHRpbWVzdGFtcCwgYXJnc0J1Zikge1xuICAgIGNvbnN0IGFyZ3NUeXBlID0gQWxnZWJyYWljVHlwZS5Qcm9kdWN0KFxuICAgICAgTU9EVUxFX0RFRi5yZWR1Y2Vyc1tyZWR1Y2VySWRdLnBhcmFtc1xuICAgICk7XG4gICAgY29uc3QgYXJncyA9IEFsZ2VicmFpY1R5cGUuZGVzZXJpYWxpemVWYWx1ZShcbiAgICAgIG5ldyBCaW5hcnlSZWFkZXIoYXJnc0J1ZiksXG4gICAgICBhcmdzVHlwZSxcbiAgICAgIE1PRFVMRV9ERUYudHlwZXNwYWNlXG4gICAgKTtcbiAgICBjb25zdCBzZW5kZXJJZGVudGl0eSA9IG5ldyBJZGVudGl0eShzZW5kZXIpO1xuICAgIGNvbnN0IGN0eCA9IG5ldyBSZWR1Y2VyQ3R4SW1wbChcbiAgICAgIHNlbmRlcklkZW50aXR5LFxuICAgICAgbmV3IFRpbWVzdGFtcCh0aW1lc3RhbXApLFxuICAgICAgQ29ubmVjdGlvbklkLm51bGxJZlplcm8obmV3IENvbm5lY3Rpb25JZChjb25uSWQpKVxuICAgICk7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBjYWxsVXNlckZ1bmN0aW9uKFJFRFVDRVJTW3JlZHVjZXJJZF0sIGN0eCwgYXJncykgPz8geyB0YWc6IFwib2tcIiB9O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlIGluc3RhbmNlb2YgU2VuZGVyRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHsgdGFnOiBcImVyclwiLCB2YWx1ZTogZS5tZXNzYWdlIH07XG4gICAgICB9XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfVxufTtcbnZhciBob29rc192MV8xID0ge1xuICBfX2NhbGxfdmlld19fKGlkLCBzZW5kZXIsIGFyZ3NCdWYpIHtcbiAgICBjb25zdCB7IGZuLCBwYXJhbXMsIHJldHVyblR5cGUsIHJldHVyblR5cGVCYXNlU2l6ZSB9ID0gVklFV1NbaWRdO1xuICAgIGNvbnN0IGN0eCA9IGZyZWV6ZTMoe1xuICAgICAgc2VuZGVyOiBuZXcgSWRlbnRpdHkoc2VuZGVyKSxcbiAgICAgIC8vIHRoaXMgaXMgdGhlIG5vbi1yZWFkb25seSBEYlZpZXcsIGJ1dCB0aGUgdHlwaW5nIGZvciB0aGUgdXNlciB3aWxsIGJlXG4gICAgICAvLyB0aGUgcmVhZG9ubHkgb25lLCBhbmQgaWYgdGhleSBkbyBjYWxsIG11dGF0aW5nIGZ1bmN0aW9ucyBpdCB3aWxsIGZhaWxcbiAgICAgIC8vIGF0IHJ1bnRpbWVcbiAgICAgIGRiOiBnZXREYlZpZXcoKSxcbiAgICAgIGZyb206IG1ha2VRdWVyeUJ1aWxkZXIoZ2V0UmVnaXN0ZXJlZFNjaGVtYSgpKVxuICAgIH0pO1xuICAgIGNvbnN0IGFyZ3MgPSBQcm9kdWN0VHlwZS5kZXNlcmlhbGl6ZVZhbHVlKFxuICAgICAgbmV3IEJpbmFyeVJlYWRlcihhcmdzQnVmKSxcbiAgICAgIHBhcmFtcyxcbiAgICAgIE1PRFVMRV9ERUYudHlwZXNwYWNlXG4gICAgKTtcbiAgICBjb25zdCByZXQgPSBjYWxsVXNlckZ1bmN0aW9uKGZuLCBjdHgsIGFyZ3MpO1xuICAgIGNvbnN0IHJldEJ1ZiA9IG5ldyBCaW5hcnlXcml0ZXIocmV0dXJuVHlwZUJhc2VTaXplKTtcbiAgICBpZiAoaXNSb3dUeXBlZFF1ZXJ5KHJldCkpIHtcbiAgICAgIGNvbnN0IHF1ZXJ5ID0gdG9TcWwocmV0KTtcbiAgICAgIGNvbnN0IHYgPSB2aWV3X3Jlc3VsdF9oZWFkZXJfdHlwZV9kZWZhdWx0LlJhd1NxbChxdWVyeSk7XG4gICAgICBBbGdlYnJhaWNUeXBlLnNlcmlhbGl6ZVZhbHVlKFxuICAgICAgICByZXRCdWYsXG4gICAgICAgIHZpZXdfcmVzdWx0X2hlYWRlcl90eXBlX2RlZmF1bHQuYWxnZWJyYWljVHlwZSxcbiAgICAgICAgdixcbiAgICAgICAgTU9EVUxFX0RFRi50eXBlc3BhY2VcbiAgICAgICk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhOiByZXRCdWYuZ2V0QnVmZmVyKClcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIEFsZ2VicmFpY1R5cGUuc2VyaWFsaXplVmFsdWUoXG4gICAgICAgIHJldEJ1ZixcbiAgICAgICAgdmlld19yZXN1bHRfaGVhZGVyX3R5cGVfZGVmYXVsdC5hbGdlYnJhaWNUeXBlLFxuICAgICAgICB2aWV3X3Jlc3VsdF9oZWFkZXJfdHlwZV9kZWZhdWx0LlJvd0RhdGEsXG4gICAgICAgIE1PRFVMRV9ERUYudHlwZXNwYWNlXG4gICAgICApO1xuICAgICAgQWxnZWJyYWljVHlwZS5zZXJpYWxpemVWYWx1ZShcbiAgICAgICAgcmV0QnVmLFxuICAgICAgICByZXR1cm5UeXBlLFxuICAgICAgICByZXQsXG4gICAgICAgIE1PRFVMRV9ERUYudHlwZXNwYWNlXG4gICAgICApO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YTogcmV0QnVmLmdldEJ1ZmZlcigpXG4gICAgICB9O1xuICAgIH1cbiAgfSxcbiAgX19jYWxsX3ZpZXdfYW5vbl9fKGlkLCBhcmdzQnVmKSB7XG4gICAgY29uc3QgeyBmbiwgcGFyYW1zLCByZXR1cm5UeXBlLCByZXR1cm5UeXBlQmFzZVNpemUgfSA9IEFOT05fVklFV1NbaWRdO1xuICAgIGNvbnN0IGN0eCA9IGZyZWV6ZTMoe1xuICAgICAgLy8gdGhpcyBpcyB0aGUgbm9uLXJlYWRvbmx5IERiVmlldywgYnV0IHRoZSB0eXBpbmcgZm9yIHRoZSB1c2VyIHdpbGwgYmVcbiAgICAgIC8vIHRoZSByZWFkb25seSBvbmUsIGFuZCBpZiB0aGV5IGRvIGNhbGwgbXV0YXRpbmcgZnVuY3Rpb25zIGl0IHdpbGwgZmFpbFxuICAgICAgLy8gYXQgcnVudGltZVxuICAgICAgZGI6IGdldERiVmlldygpLFxuICAgICAgZnJvbTogbWFrZVF1ZXJ5QnVpbGRlcihnZXRSZWdpc3RlcmVkU2NoZW1hKCkpXG4gICAgfSk7XG4gICAgY29uc3QgYXJncyA9IFByb2R1Y3RUeXBlLmRlc2VyaWFsaXplVmFsdWUoXG4gICAgICBuZXcgQmluYXJ5UmVhZGVyKGFyZ3NCdWYpLFxuICAgICAgcGFyYW1zLFxuICAgICAgTU9EVUxFX0RFRi50eXBlc3BhY2VcbiAgICApO1xuICAgIGNvbnN0IHJldCA9IGNhbGxVc2VyRnVuY3Rpb24oZm4sIGN0eCwgYXJncyk7XG4gICAgY29uc3QgcmV0QnVmID0gbmV3IEJpbmFyeVdyaXRlcihyZXR1cm5UeXBlQmFzZVNpemUpO1xuICAgIGlmIChpc1Jvd1R5cGVkUXVlcnkocmV0KSkge1xuICAgICAgY29uc3QgcXVlcnkgPSB0b1NxbChyZXQpO1xuICAgICAgY29uc3QgdiA9IHZpZXdfcmVzdWx0X2hlYWRlcl90eXBlX2RlZmF1bHQuUmF3U3FsKHF1ZXJ5KTtcbiAgICAgIEFsZ2VicmFpY1R5cGUuc2VyaWFsaXplVmFsdWUoXG4gICAgICAgIHJldEJ1ZixcbiAgICAgICAgdmlld19yZXN1bHRfaGVhZGVyX3R5cGVfZGVmYXVsdC5hbGdlYnJhaWNUeXBlLFxuICAgICAgICB2LFxuICAgICAgICBNT0RVTEVfREVGLnR5cGVzcGFjZVxuICAgICAgKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IHJldEJ1Zi5nZXRCdWZmZXIoKVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgQWxnZWJyYWljVHlwZS5zZXJpYWxpemVWYWx1ZShcbiAgICAgICAgcmV0QnVmLFxuICAgICAgICB2aWV3X3Jlc3VsdF9oZWFkZXJfdHlwZV9kZWZhdWx0LmFsZ2VicmFpY1R5cGUsXG4gICAgICAgIHZpZXdfcmVzdWx0X2hlYWRlcl90eXBlX2RlZmF1bHQuUm93RGF0YSxcbiAgICAgICAgTU9EVUxFX0RFRi50eXBlc3BhY2VcbiAgICAgICk7XG4gICAgICBBbGdlYnJhaWNUeXBlLnNlcmlhbGl6ZVZhbHVlKFxuICAgICAgICByZXRCdWYsXG4gICAgICAgIHJldHVyblR5cGUsXG4gICAgICAgIHJldCxcbiAgICAgICAgTU9EVUxFX0RFRi50eXBlc3BhY2VcbiAgICAgICk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhOiByZXRCdWYuZ2V0QnVmZmVyKClcbiAgICAgIH07XG4gICAgfVxuICB9XG59O1xudmFyIGhvb2tzX3YxXzIgPSB7XG4gIF9fY2FsbF9wcm9jZWR1cmVfXyhpZCwgc2VuZGVyLCBjb25uZWN0aW9uX2lkLCB0aW1lc3RhbXAsIGFyZ3MpIHtcbiAgICByZXR1cm4gY2FsbFByb2NlZHVyZShcbiAgICAgIGlkLFxuICAgICAgbmV3IElkZW50aXR5KHNlbmRlciksXG4gICAgICBDb25uZWN0aW9uSWQubnVsbElmWmVybyhuZXcgQ29ubmVjdGlvbklkKGNvbm5lY3Rpb25faWQpKSxcbiAgICAgIG5ldyBUaW1lc3RhbXAodGltZXN0YW1wKSxcbiAgICAgIGFyZ3NcbiAgICApO1xuICB9XG59O1xudmFyIERCX1ZJRVcgPSBudWxsO1xuZnVuY3Rpb24gZ2V0RGJWaWV3KCkge1xuICBEQl9WSUVXID8/PSBtYWtlRGJWaWV3KE1PRFVMRV9ERUYpO1xuICByZXR1cm4gREJfVklFVztcbn1cbmZ1bmN0aW9uIG1ha2VEYlZpZXcobW9kdWxlRGVmKSB7XG4gIHJldHVybiBmcmVlemUzKFxuICAgIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgIG1vZHVsZURlZi50YWJsZXMubWFwKCh0YWJsZTIpID0+IFtcbiAgICAgICAgdG9DYW1lbENhc2UodGFibGUyLm5hbWUpLFxuICAgICAgICBtYWtlVGFibGVWaWV3KG1vZHVsZURlZi50eXBlc3BhY2UsIHRhYmxlMilcbiAgICAgIF0pXG4gICAgKVxuICApO1xufVxuZnVuY3Rpb24gbWFrZVRhYmxlVmlldyh0eXBlc3BhY2UsIHRhYmxlMikge1xuICBjb25zdCB0YWJsZV9pZCA9IHN5cy50YWJsZV9pZF9mcm9tX25hbWUodGFibGUyLm5hbWUpO1xuICBjb25zdCByb3dUeXBlID0gdHlwZXNwYWNlLnR5cGVzW3RhYmxlMi5wcm9kdWN0VHlwZVJlZl07XG4gIGlmIChyb3dUeXBlLnRhZyAhPT0gXCJQcm9kdWN0XCIpIHtcbiAgICB0aHJvdyBcImltcG9zc2libGVcIjtcbiAgfVxuICBjb25zdCBiYXNlU2l6ZSA9IGJzYXRuQmFzZVNpemUodHlwZXNwYWNlLCByb3dUeXBlKTtcbiAgY29uc3Qgc2VxdWVuY2VzID0gdGFibGUyLnNlcXVlbmNlcy5tYXAoKHNlcSkgPT4ge1xuICAgIGNvbnN0IGNvbCA9IHJvd1R5cGUudmFsdWUuZWxlbWVudHNbc2VxLmNvbHVtbl07XG4gICAgY29uc3QgY29sVHlwZSA9IGNvbC5hbGdlYnJhaWNUeXBlO1xuICAgIGxldCBzZXF1ZW5jZVRyaWdnZXI7XG4gICAgc3dpdGNoIChjb2xUeXBlLnRhZykge1xuICAgICAgY2FzZSBcIlU4XCI6XG4gICAgICBjYXNlIFwiSThcIjpcbiAgICAgIGNhc2UgXCJVMTZcIjpcbiAgICAgIGNhc2UgXCJJMTZcIjpcbiAgICAgIGNhc2UgXCJVMzJcIjpcbiAgICAgIGNhc2UgXCJJMzJcIjpcbiAgICAgICAgc2VxdWVuY2VUcmlnZ2VyID0gMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiVTY0XCI6XG4gICAgICBjYXNlIFwiSTY0XCI6XG4gICAgICBjYXNlIFwiVTEyOFwiOlxuICAgICAgY2FzZSBcIkkxMjhcIjpcbiAgICAgIGNhc2UgXCJVMjU2XCI6XG4gICAgICBjYXNlIFwiSTI1NlwiOlxuICAgICAgICBzZXF1ZW5jZVRyaWdnZXIgPSAwbjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCBzZXF1ZW5jZSB0eXBlXCIpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgY29sTmFtZTogY29sLm5hbWUsXG4gICAgICBzZXF1ZW5jZVRyaWdnZXIsXG4gICAgICByZWFkOiAocmVhZGVyKSA9PiBBbGdlYnJhaWNUeXBlLmRlc2VyaWFsaXplVmFsdWUocmVhZGVyLCBjb2xUeXBlLCB0eXBlc3BhY2UpXG4gICAgfTtcbiAgfSk7XG4gIGNvbnN0IGhhc0F1dG9JbmNyZW1lbnQgPSBzZXF1ZW5jZXMubGVuZ3RoID4gMDtcbiAgY29uc3QgaXRlciA9ICgpID0+IHRhYmxlSXRlcmF0b3Ioc3lzLmRhdGFzdG9yZV90YWJsZV9zY2FuX2JzYXRuKHRhYmxlX2lkKSwgcm93VHlwZSk7XG4gIGNvbnN0IGludGVncmF0ZUdlbmVyYXRlZENvbHVtbnMgPSBoYXNBdXRvSW5jcmVtZW50ID8gKHJvdywgcmV0X2J1ZikgPT4ge1xuICAgIGNvbnN0IHJlYWRlciA9IG5ldyBCaW5hcnlSZWFkZXIocmV0X2J1Zik7XG4gICAgZm9yIChjb25zdCB7IGNvbE5hbWUsIHJlYWQsIHNlcXVlbmNlVHJpZ2dlciB9IG9mIHNlcXVlbmNlcykge1xuICAgICAgaWYgKHJvd1tjb2xOYW1lXSA9PT0gc2VxdWVuY2VUcmlnZ2VyKSB7XG4gICAgICAgIHJvd1tjb2xOYW1lXSA9IHJlYWQocmVhZGVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gOiBudWxsO1xuICBjb25zdCB0YWJsZU1ldGhvZHMgPSB7XG4gICAgY291bnQ6ICgpID0+IHN5cy5kYXRhc3RvcmVfdGFibGVfcm93X2NvdW50KHRhYmxlX2lkKSxcbiAgICBpdGVyLFxuICAgIFtTeW1ib2wuaXRlcmF0b3JdOiAoKSA9PiBpdGVyKCksXG4gICAgaW5zZXJ0OiAocm93KSA9PiB7XG4gICAgICBjb25zdCB3cml0ZXIgPSBuZXcgQmluYXJ5V3JpdGVyKGJhc2VTaXplKTtcbiAgICAgIEFsZ2VicmFpY1R5cGUuc2VyaWFsaXplVmFsdWUod3JpdGVyLCByb3dUeXBlLCByb3csIHR5cGVzcGFjZSk7XG4gICAgICBjb25zdCByZXRfYnVmID0gc3lzLmRhdGFzdG9yZV9pbnNlcnRfYnNhdG4odGFibGVfaWQsIHdyaXRlci5nZXRCdWZmZXIoKSk7XG4gICAgICBjb25zdCByZXQgPSB7IC4uLnJvdyB9O1xuICAgICAgaW50ZWdyYXRlR2VuZXJhdGVkQ29sdW1ucz8uKHJldCwgcmV0X2J1Zik7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH0sXG4gICAgZGVsZXRlOiAocm93KSA9PiB7XG4gICAgICBjb25zdCB3cml0ZXIgPSBuZXcgQmluYXJ5V3JpdGVyKDQgKyBiYXNlU2l6ZSk7XG4gICAgICB3cml0ZXIud3JpdGVVMzIoMSk7XG4gICAgICBBbGdlYnJhaWNUeXBlLnNlcmlhbGl6ZVZhbHVlKHdyaXRlciwgcm93VHlwZSwgcm93LCB0eXBlc3BhY2UpO1xuICAgICAgY29uc3QgY291bnQgPSBzeXMuZGF0YXN0b3JlX2RlbGV0ZV9hbGxfYnlfZXFfYnNhdG4oXG4gICAgICAgIHRhYmxlX2lkLFxuICAgICAgICB3cml0ZXIuZ2V0QnVmZmVyKClcbiAgICAgICk7XG4gICAgICByZXR1cm4gY291bnQgPiAwO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgdGFibGVWaWV3ID0gT2JqZWN0LmFzc2lnbihcbiAgICAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICB0YWJsZU1ldGhvZHNcbiAgKTtcbiAgZm9yIChjb25zdCBpbmRleERlZiBvZiB0YWJsZTIuaW5kZXhlcykge1xuICAgIGNvbnN0IGluZGV4X2lkID0gc3lzLmluZGV4X2lkX2Zyb21fbmFtZShpbmRleERlZi5uYW1lKTtcbiAgICBsZXQgY29sdW1uX2lkcztcbiAgICBzd2l0Y2ggKGluZGV4RGVmLmFsZ29yaXRobS50YWcpIHtcbiAgICAgIGNhc2UgXCJCVHJlZVwiOlxuICAgICAgICBjb2x1bW5faWRzID0gaW5kZXhEZWYuYWxnb3JpdGhtLnZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJIYXNoXCI6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImltcG9zc2libGVcIik7XG4gICAgICBjYXNlIFwiRGlyZWN0XCI6XG4gICAgICAgIGNvbHVtbl9pZHMgPSBbaW5kZXhEZWYuYWxnb3JpdGhtLnZhbHVlXTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNvbnN0IG51bUNvbHVtbnMgPSBjb2x1bW5faWRzLmxlbmd0aDtcbiAgICBjb25zdCBjb2x1bW5TZXQgPSBuZXcgU2V0KGNvbHVtbl9pZHMpO1xuICAgIGNvbnN0IGlzVW5pcXVlID0gdGFibGUyLmNvbnN0cmFpbnRzLmZpbHRlcigoeCkgPT4geC5kYXRhLnRhZyA9PT0gXCJVbmlxdWVcIikuc29tZSgoeCkgPT4gY29sdW1uU2V0LmlzU3Vic2V0T2YobmV3IFNldCh4LmRhdGEudmFsdWUuY29sdW1ucykpKTtcbiAgICBjb25zdCBpbmRleFR5cGUgPSBBbGdlYnJhaWNUeXBlLlByb2R1Y3Qoe1xuICAgICAgZWxlbWVudHM6IGNvbHVtbl9pZHMubWFwKChpZCkgPT4gcm93VHlwZS52YWx1ZS5lbGVtZW50c1tpZF0pXG4gICAgfSk7XG4gICAgY29uc3QgYmFzZVNpemUyID0gYnNhdG5CYXNlU2l6ZSh0eXBlc3BhY2UsIGluZGV4VHlwZSk7XG4gICAgY29uc3Qgc2VyaWFsaXplUHJlZml4ID0gKHdyaXRlciwgcHJlZml4LCBwcmVmaXhfZWxlbXMpID0+IHtcbiAgICAgIGlmIChwcmVmaXhfZWxlbXMgPiBudW1Db2x1bW5zIC0gMSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInRvbyBtYW55IGVsZW1lbnRzIGluIHByZWZpeFwiKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJlZml4X2VsZW1zOyBpKyspIHtcbiAgICAgICAgY29uc3QgZWxlbVR5cGUgPSBpbmRleFR5cGUudmFsdWUuZWxlbWVudHNbaV0uYWxnZWJyYWljVHlwZTtcbiAgICAgICAgQWxnZWJyYWljVHlwZS5zZXJpYWxpemVWYWx1ZSh3cml0ZXIsIGVsZW1UeXBlLCBwcmVmaXhbaV0sIHR5cGVzcGFjZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH07XG4gICAgbGV0IGluZGV4O1xuICAgIGlmIChpc1VuaXF1ZSkge1xuICAgICAgY29uc3Qgc2VyaWFsaXplQm91bmQgPSAoY29sVmFsKSA9PiB7XG4gICAgICAgIGlmIChjb2xWYWwubGVuZ3RoICE9PSBudW1Db2x1bW5zKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJ3cm9uZyBudW1iZXIgb2YgZWxlbWVudHNcIik7XG4gICAgICAgIGNvbnN0IHdyaXRlciA9IG5ldyBCaW5hcnlXcml0ZXIoYmFzZVNpemUyICsgMSk7XG4gICAgICAgIGNvbnN0IHByZWZpeF9lbGVtcyA9IG51bUNvbHVtbnMgLSAxO1xuICAgICAgICBzZXJpYWxpemVQcmVmaXgod3JpdGVyLCBjb2xWYWwsIHByZWZpeF9lbGVtcyk7XG4gICAgICAgIGNvbnN0IHJzdGFydE9mZnNldCA9IHdyaXRlci5vZmZzZXQ7XG4gICAgICAgIHdyaXRlci53cml0ZVU4KDApO1xuICAgICAgICBBbGdlYnJhaWNUeXBlLnNlcmlhbGl6ZVZhbHVlKFxuICAgICAgICAgIHdyaXRlcixcbiAgICAgICAgICBpbmRleFR5cGUudmFsdWUuZWxlbWVudHNbbnVtQ29sdW1ucyAtIDFdLmFsZ2VicmFpY1R5cGUsXG4gICAgICAgICAgY29sVmFsW251bUNvbHVtbnMgLSAxXSxcbiAgICAgICAgICB0eXBlc3BhY2VcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gd3JpdGVyLmdldEJ1ZmZlcigpO1xuICAgICAgICBjb25zdCBwcmVmaXggPSBidWZmZXIuc2xpY2UoMCwgcnN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgY29uc3QgcnN0YXJ0ID0gYnVmZmVyLnNsaWNlKHJzdGFydE9mZnNldCk7XG4gICAgICAgIHJldHVybiBbcHJlZml4LCBwcmVmaXhfZWxlbXMsIHJzdGFydCwgcnN0YXJ0XTtcbiAgICAgIH07XG4gICAgICBpbmRleCA9IHtcbiAgICAgICAgZmluZDogKGNvbFZhbCkgPT4ge1xuICAgICAgICAgIGlmIChudW1Db2x1bW5zID09PSAxKSBjb2xWYWwgPSBbY29sVmFsXTtcbiAgICAgICAgICBjb25zdCBhcmdzID0gc2VyaWFsaXplQm91bmQoY29sVmFsKTtcbiAgICAgICAgICBjb25zdCBpdGVyMiA9IHRhYmxlSXRlcmF0b3IoXG4gICAgICAgICAgICBzeXMuZGF0YXN0b3JlX2luZGV4X3NjYW5fcmFuZ2VfYnNhdG4oaW5kZXhfaWQsIC4uLmFyZ3MpLFxuICAgICAgICAgICAgcm93VHlwZVxuICAgICAgICAgICk7XG4gICAgICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gaXRlcjIubmV4dCgpO1xuICAgICAgICAgIGlmIChkb25lKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICBpZiAoIWl0ZXIyLm5leHQoKS5kb25lKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICBcImBkYXRhc3RvcmVfaW5kZXhfc2Nhbl9yYW5nZV9ic2F0bmAgb24gdW5pcXVlIGZpZWxkIGNhbm5vdCByZXR1cm4gPjEgcm93c1wiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVsZXRlOiAoY29sVmFsKSA9PiB7XG4gICAgICAgICAgaWYgKG51bUNvbHVtbnMgPT09IDEpIGNvbFZhbCA9IFtjb2xWYWxdO1xuICAgICAgICAgIGNvbnN0IGFyZ3MgPSBzZXJpYWxpemVCb3VuZChjb2xWYWwpO1xuICAgICAgICAgIGNvbnN0IG51bSA9IHN5cy5kYXRhc3RvcmVfZGVsZXRlX2J5X2luZGV4X3NjYW5fcmFuZ2VfYnNhdG4oXG4gICAgICAgICAgICBpbmRleF9pZCxcbiAgICAgICAgICAgIC4uLmFyZ3NcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiBudW0gPiAwO1xuICAgICAgICB9LFxuICAgICAgICB1cGRhdGU6IChyb3cpID0+IHtcbiAgICAgICAgICBjb25zdCB3cml0ZXIgPSBuZXcgQmluYXJ5V3JpdGVyKGJhc2VTaXplMik7XG4gICAgICAgICAgQWxnZWJyYWljVHlwZS5zZXJpYWxpemVWYWx1ZSh3cml0ZXIsIHJvd1R5cGUsIHJvdywgdHlwZXNwYWNlKTtcbiAgICAgICAgICBjb25zdCByZXRfYnVmID0gc3lzLmRhdGFzdG9yZV91cGRhdGVfYnNhdG4oXG4gICAgICAgICAgICB0YWJsZV9pZCxcbiAgICAgICAgICAgIGluZGV4X2lkLFxuICAgICAgICAgICAgd3JpdGVyLmdldEJ1ZmZlcigpXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpbnRlZ3JhdGVHZW5lcmF0ZWRDb2x1bW5zPy4ocm93LCByZXRfYnVmKTtcbiAgICAgICAgICByZXR1cm4gcm93O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzZXJpYWxpemVSYW5nZSA9IChyYW5nZSkgPT4ge1xuICAgICAgICBpZiAocmFuZ2UubGVuZ3RoID4gbnVtQ29sdW1ucykgdGhyb3cgbmV3IFR5cGVFcnJvcihcInRvbyBtYW55IGVsZW1lbnRzXCIpO1xuICAgICAgICBjb25zdCB3cml0ZXIgPSBuZXcgQmluYXJ5V3JpdGVyKGJhc2VTaXplMiArIDEpO1xuICAgICAgICBjb25zdCBwcmVmaXhfZWxlbXMgPSByYW5nZS5sZW5ndGggLSAxO1xuICAgICAgICBzZXJpYWxpemVQcmVmaXgod3JpdGVyLCByYW5nZSwgcHJlZml4X2VsZW1zKTtcbiAgICAgICAgY29uc3QgcnN0YXJ0T2Zmc2V0ID0gd3JpdGVyLm9mZnNldDtcbiAgICAgICAgY29uc3QgdGVybSA9IHJhbmdlW3JhbmdlLmxlbmd0aCAtIDFdO1xuICAgICAgICBjb25zdCB0ZXJtVHlwZSA9IGluZGV4VHlwZS52YWx1ZS5lbGVtZW50c1tyYW5nZS5sZW5ndGggLSAxXS5hbGdlYnJhaWNUeXBlO1xuICAgICAgICBsZXQgcnN0YXJ0LCByZW5kO1xuICAgICAgICBpZiAodGVybSBpbnN0YW5jZW9mIFJhbmdlKSB7XG4gICAgICAgICAgY29uc3Qgd3JpdGVCb3VuZCA9IChib3VuZCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGFncyA9IHsgaW5jbHVkZWQ6IDAsIGV4Y2x1ZGVkOiAxLCB1bmJvdW5kZWQ6IDIgfTtcbiAgICAgICAgICAgIHdyaXRlci53cml0ZVU4KHRhZ3NbYm91bmQudGFnXSk7XG4gICAgICAgICAgICBpZiAoYm91bmQudGFnICE9PSBcInVuYm91bmRlZFwiKVxuICAgICAgICAgICAgICBBbGdlYnJhaWNUeXBlLnNlcmlhbGl6ZVZhbHVlKFxuICAgICAgICAgICAgICAgIHdyaXRlcixcbiAgICAgICAgICAgICAgICB0ZXJtVHlwZSxcbiAgICAgICAgICAgICAgICBib3VuZC52YWx1ZSxcbiAgICAgICAgICAgICAgICB0eXBlc3BhY2VcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHdyaXRlQm91bmQodGVybS5mcm9tKTtcbiAgICAgICAgICBjb25zdCByZW5kT2Zmc2V0ID0gd3JpdGVyLm9mZnNldDtcbiAgICAgICAgICB3cml0ZUJvdW5kKHRlcm0udG8pO1xuICAgICAgICAgIHJzdGFydCA9IHdyaXRlci5nZXRCdWZmZXIoKS5zbGljZShyc3RhcnRPZmZzZXQsIHJlbmRPZmZzZXQpO1xuICAgICAgICAgIHJlbmQgPSB3cml0ZXIuZ2V0QnVmZmVyKCkuc2xpY2UocmVuZE9mZnNldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd3JpdGVyLndyaXRlVTgoMCk7XG4gICAgICAgICAgQWxnZWJyYWljVHlwZS5zZXJpYWxpemVWYWx1ZSh3cml0ZXIsIHRlcm1UeXBlLCB0ZXJtLCB0eXBlc3BhY2UpO1xuICAgICAgICAgIHJzdGFydCA9IHJlbmQgPSB3cml0ZXIuZ2V0QnVmZmVyKCkuc2xpY2UocnN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBidWZmZXIgPSB3cml0ZXIuZ2V0QnVmZmVyKCk7XG4gICAgICAgIGNvbnN0IHByZWZpeCA9IGJ1ZmZlci5zbGljZSgwLCByc3RhcnRPZmZzZXQpO1xuICAgICAgICByZXR1cm4gW3ByZWZpeCwgcHJlZml4X2VsZW1zLCByc3RhcnQsIHJlbmRdO1xuICAgICAgfTtcbiAgICAgIGluZGV4ID0ge1xuICAgICAgICBmaWx0ZXI6IChyYW5nZSkgPT4ge1xuICAgICAgICAgIGlmIChudW1Db2x1bW5zID09PSAxKSByYW5nZSA9IFtyYW5nZV07XG4gICAgICAgICAgY29uc3QgYXJncyA9IHNlcmlhbGl6ZVJhbmdlKHJhbmdlKTtcbiAgICAgICAgICByZXR1cm4gdGFibGVJdGVyYXRvcihcbiAgICAgICAgICAgIHN5cy5kYXRhc3RvcmVfaW5kZXhfc2Nhbl9yYW5nZV9ic2F0bihpbmRleF9pZCwgLi4uYXJncyksXG4gICAgICAgICAgICByb3dUeXBlXG4gICAgICAgICAgKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVsZXRlOiAocmFuZ2UpID0+IHtcbiAgICAgICAgICBpZiAobnVtQ29sdW1ucyA9PT0gMSkgcmFuZ2UgPSBbcmFuZ2VdO1xuICAgICAgICAgIGNvbnN0IGFyZ3MgPSBzZXJpYWxpemVSYW5nZShyYW5nZSk7XG4gICAgICAgICAgcmV0dXJuIHN5cy5kYXRhc3RvcmVfZGVsZXRlX2J5X2luZGV4X3NjYW5fcmFuZ2VfYnNhdG4oXG4gICAgICAgICAgICBpbmRleF9pZCxcbiAgICAgICAgICAgIC4uLmFyZ3NcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoT2JqZWN0Lmhhc093bih0YWJsZVZpZXcsIGluZGV4RGVmLmFjY2Vzc29yTmFtZSkpIHtcbiAgICAgIGZyZWV6ZTMoT2JqZWN0LmFzc2lnbih0YWJsZVZpZXdbaW5kZXhEZWYuYWNjZXNzb3JOYW1lXSwgaW5kZXgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGFibGVWaWV3W2luZGV4RGVmLmFjY2Vzc29yTmFtZV0gPSBmcmVlemUzKGluZGV4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZyZWV6ZTModGFibGVWaWV3KTtcbn1cbmZ1bmN0aW9uIGhhc093bihvLCBrKSB7XG4gIHJldHVybiBPYmplY3QuaGFzT3duKG8sIGspO1xufVxuZnVuY3Rpb24qIHRhYmxlSXRlcmF0b3IoaWQsIHR5KSB7XG4gIHZhciBfc3RhY2sgPSBbXTtcbiAgdHJ5IHtcbiAgICBjb25zdCBpdGVyID0gX191c2luZyhfc3RhY2ssIG5ldyBJdGVyYXRvckhhbmRsZShpZCkpO1xuICAgIGNvbnN0IHsgdHlwZXNwYWNlIH0gPSBNT0RVTEVfREVGO1xuICAgIGxldCBidWY7XG4gICAgd2hpbGUgKChidWYgPSBhZHZhbmNlSXRlcihpdGVyKSkgIT0gbnVsbCkge1xuICAgICAgY29uc3QgcmVhZGVyID0gbmV3IEJpbmFyeVJlYWRlcihidWYpO1xuICAgICAgd2hpbGUgKHJlYWRlci5yZW1haW5pbmcgPiAwKSB7XG4gICAgICAgIHlpZWxkIEFsZ2VicmFpY1R5cGUuZGVzZXJpYWxpemVWYWx1ZShyZWFkZXIsIHR5LCB0eXBlc3BhY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoXykge1xuICAgIHZhciBfZXJyb3IgPSBfLCBfaGFzRXJyb3IgPSB0cnVlO1xuICB9IGZpbmFsbHkge1xuICAgIF9fY2FsbERpc3Bvc2UoX3N0YWNrLCBfZXJyb3IsIF9oYXNFcnJvcik7XG4gIH1cbn1cbmZ1bmN0aW9uIGFkdmFuY2VJdGVyKGl0ZXIpIHtcbiAgbGV0IGJ1Zl9tYXhfbGVuID0gNjU1MzY7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBpdGVyLmFkdmFuY2UoYnVmX21heF9sZW4pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlICYmIHR5cGVvZiBlID09PSBcIm9iamVjdFwiICYmIGhhc093bihlLCBcIl9fYnVmZmVyX3Rvb19zbWFsbF9fXCIpKSB7XG4gICAgICAgIGJ1Zl9tYXhfbGVuID0gZS5fX2J1ZmZlcl90b29fc21hbGxfXztcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfVxufVxudmFyIEl0ZXJhdG9ySGFuZGxlID0gY2xhc3MgX0l0ZXJhdG9ySGFuZGxlIHtcbiAgI2lkO1xuICBzdGF0aWMgI2ZpbmFsaXphdGlvblJlZ2lzdHJ5ID0gbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KFxuICAgIHN5cy5yb3dfaXRlcl9ic2F0bl9jbG9zZVxuICApO1xuICBjb25zdHJ1Y3RvcihpZCkge1xuICAgIHRoaXMuI2lkID0gaWQ7XG4gICAgX0l0ZXJhdG9ySGFuZGxlLiNmaW5hbGl6YXRpb25SZWdpc3RyeS5yZWdpc3Rlcih0aGlzLCBpZCwgdGhpcyk7XG4gIH1cbiAgLyoqIFVucmVnaXN0ZXIgdGhpcyBvYmplY3Qgd2l0aCB0aGUgZmluYWxpemF0aW9uIHJlZ2lzdHJ5IGFuZCByZXR1cm4gdGhlIGlkICovXG4gICNkZXRhY2goKSB7XG4gICAgY29uc3QgaWQgPSB0aGlzLiNpZDtcbiAgICB0aGlzLiNpZCA9IC0xO1xuICAgIF9JdGVyYXRvckhhbmRsZS4jZmluYWxpemF0aW9uUmVnaXN0cnkudW5yZWdpc3Rlcih0aGlzKTtcbiAgICByZXR1cm4gaWQ7XG4gIH1cbiAgLyoqIENhbGwgYHJvd19pdGVyX2JzYXRuX2FkdmFuY2VgLCByZXR1cm5pbmcgbnVsbCBpZiB0aGlzIGl0ZXJhdG9yIHdhcyBhbHJlYWR5IGV4aGF1c3RlZC4gKi9cbiAgYWR2YW5jZShidWZfbWF4X2xlbikge1xuICAgIGlmICh0aGlzLiNpZCA9PT0gLTEpIHJldHVybiBudWxsO1xuICAgIGNvbnN0IHsgMDogZG9uZSwgMTogYnVmIH0gPSBzeXMucm93X2l0ZXJfYnNhdG5fYWR2YW5jZShcbiAgICAgIHRoaXMuI2lkLFxuICAgICAgYnVmX21heF9sZW5cbiAgICApO1xuICAgIGlmIChkb25lKSB0aGlzLiNkZXRhY2goKTtcbiAgICByZXR1cm4gYnVmO1xuICB9XG4gIFtTeW1ib2wuZGlzcG9zZV0oKSB7XG4gICAgaWYgKHRoaXMuI2lkID49IDApIHtcbiAgICAgIGNvbnN0IGlkID0gdGhpcy4jZGV0YWNoKCk7XG4gICAgICBzeXMucm93X2l0ZXJfYnNhdG5fY2xvc2UoaWQpO1xuICAgIH1cbiAgfVxufTtcbmZ1bmN0aW9uIHdyYXBTeXNjYWxscyguLi5tb2R1bGVzKSB7XG4gIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgbW9kdWxlcy5mbGF0TWFwKE9iamVjdC5lbnRyaWVzKS5tYXAoKFtrLCB2XSkgPT4gW2ssIHdyYXBTeXNjYWxsKHYpXSlcbiAgKTtcbn1cbmZ1bmN0aW9uIHdyYXBTeXNjYWxsKGZ1bmMpIHtcbiAgY29uc3QgbmFtZSA9IGZ1bmMubmFtZTtcbiAgcmV0dXJuIHtcbiAgICBbbmFtZV0oLi4uYXJncykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGZ1bmMoLi4uYXJncyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChlICE9PSBudWxsICYmIHR5cGVvZiBlID09PSBcIm9iamVjdFwiICYmIGhhc093bihlLCBcIl9fY29kZV9lcnJvcl9fXCIpICYmIHR5cGVvZiBlLl9fY29kZV9lcnJvcl9fID09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICBjb25zdCBtZXNzYWdlID0gaGFzT3duKGUsIFwiX19lcnJvcl9tZXNzYWdlX19cIikgJiYgdHlwZW9mIGUuX19lcnJvcl9tZXNzYWdlX18gPT09IFwic3RyaW5nXCIgPyBlLl9fZXJyb3JfbWVzc2FnZV9fIDogdm9pZCAwO1xuICAgICAgICAgIHRocm93IG5ldyBTcGFjZXRpbWVIb3N0RXJyb3IoZS5fX2NvZGVfZXJyb3JfXywgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9XG4gIH1bbmFtZV07XG59XG5mdW5jdGlvbiBmbXRMb2coLi4uZGF0YSkge1xuICByZXR1cm4gZGF0YS5qb2luKFwiIFwiKTtcbn1cbnZhciBjb25zb2xlX2xldmVsX2Vycm9yID0gMDtcbnZhciBjb25zb2xlX2xldmVsX3dhcm4gPSAxO1xudmFyIGNvbnNvbGVfbGV2ZWxfaW5mbyA9IDI7XG52YXIgY29uc29sZV9sZXZlbF9kZWJ1ZyA9IDM7XG52YXIgY29uc29sZV9sZXZlbF90cmFjZSA9IDQ7XG52YXIgdGltZXJNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xudmFyIGNvbnNvbGUyID0ge1xuICAvLyBAdHMtZXhwZWN0LWVycm9yIHdlIHdhbnQgYSBibGFuayBwcm90b3R5cGUsIGJ1dCB0eXBlc2NyaXB0IGNvbXBsYWluc1xuICBfX3Byb3RvX186IHt9LFxuICBbU3ltYm9sLnRvU3RyaW5nVGFnXTogXCJjb25zb2xlXCIsXG4gIGFzc2VydDogKGNvbmRpdGlvbiA9IGZhbHNlLCAuLi5kYXRhKSA9PiB7XG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgIHN5cy5jb25zb2xlX2xvZyhjb25zb2xlX2xldmVsX2Vycm9yLCBmbXRMb2coLi4uZGF0YSkpO1xuICAgIH1cbiAgfSxcbiAgY2xlYXI6ICgpID0+IHtcbiAgfSxcbiAgZGVidWc6ICguLi5kYXRhKSA9PiB7XG4gICAgc3lzLmNvbnNvbGVfbG9nKGNvbnNvbGVfbGV2ZWxfZGVidWcsIGZtdExvZyguLi5kYXRhKSk7XG4gIH0sXG4gIGVycm9yOiAoLi4uZGF0YSkgPT4ge1xuICAgIHN5cy5jb25zb2xlX2xvZyhjb25zb2xlX2xldmVsX2Vycm9yLCBmbXRMb2coLi4uZGF0YSkpO1xuICB9LFxuICBpbmZvOiAoLi4uZGF0YSkgPT4ge1xuICAgIHN5cy5jb25zb2xlX2xvZyhjb25zb2xlX2xldmVsX2luZm8sIGZtdExvZyguLi5kYXRhKSk7XG4gIH0sXG4gIGxvZzogKC4uLmRhdGEpID0+IHtcbiAgICBzeXMuY29uc29sZV9sb2coY29uc29sZV9sZXZlbF9pbmZvLCBmbXRMb2coLi4uZGF0YSkpO1xuICB9LFxuICB0YWJsZTogKHRhYnVsYXJEYXRhLCBfcHJvcGVydGllcykgPT4ge1xuICAgIHN5cy5jb25zb2xlX2xvZyhjb25zb2xlX2xldmVsX2luZm8sIGZtdExvZyh0YWJ1bGFyRGF0YSkpO1xuICB9LFxuICB0cmFjZTogKC4uLmRhdGEpID0+IHtcbiAgICBzeXMuY29uc29sZV9sb2coY29uc29sZV9sZXZlbF90cmFjZSwgZm10TG9nKC4uLmRhdGEpKTtcbiAgfSxcbiAgd2FybjogKC4uLmRhdGEpID0+IHtcbiAgICBzeXMuY29uc29sZV9sb2coY29uc29sZV9sZXZlbF93YXJuLCBmbXRMb2coLi4uZGF0YSkpO1xuICB9LFxuICBkaXI6IChfaXRlbSwgX29wdGlvbnMpID0+IHtcbiAgfSxcbiAgZGlyeG1sOiAoLi4uX2RhdGEpID0+IHtcbiAgfSxcbiAgLy8gQ291bnRpbmdcbiAgY291bnQ6IChfbGFiZWwgPSBcImRlZmF1bHRcIikgPT4ge1xuICB9LFxuICBjb3VudFJlc2V0OiAoX2xhYmVsID0gXCJkZWZhdWx0XCIpID0+IHtcbiAgfSxcbiAgLy8gR3JvdXBpbmdcbiAgZ3JvdXA6ICguLi5fZGF0YSkgPT4ge1xuICB9LFxuICBncm91cENvbGxhcHNlZDogKC4uLl9kYXRhKSA9PiB7XG4gIH0sXG4gIGdyb3VwRW5kOiAoKSA9PiB7XG4gIH0sXG4gIC8vIFRpbWluZ1xuICB0aW1lOiAobGFiZWwgPSBcImRlZmF1bHRcIikgPT4ge1xuICAgIGlmICh0aW1lck1hcC5oYXMobGFiZWwpKSB7XG4gICAgICBzeXMuY29uc29sZV9sb2coY29uc29sZV9sZXZlbF93YXJuLCBgVGltZXIgJyR7bGFiZWx9JyBhbHJlYWR5IGV4aXN0cy5gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGltZXJNYXAuc2V0KGxhYmVsLCBzeXMuY29uc29sZV90aW1lcl9zdGFydChsYWJlbCkpO1xuICB9LFxuICB0aW1lTG9nOiAobGFiZWwgPSBcImRlZmF1bHRcIiwgLi4uZGF0YSkgPT4ge1xuICAgIHN5cy5jb25zb2xlX2xvZyhjb25zb2xlX2xldmVsX2luZm8sIGZtdExvZyhsYWJlbCwgLi4uZGF0YSkpO1xuICB9LFxuICB0aW1lRW5kOiAobGFiZWwgPSBcImRlZmF1bHRcIikgPT4ge1xuICAgIGNvbnN0IHNwYW5JZCA9IHRpbWVyTWFwLmdldChsYWJlbCk7XG4gICAgaWYgKHNwYW5JZCA9PT0gdm9pZCAwKSB7XG4gICAgICBzeXMuY29uc29sZV9sb2coY29uc29sZV9sZXZlbF93YXJuLCBgVGltZXIgJyR7bGFiZWx9JyBkb2VzIG5vdCBleGlzdC5gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3lzLmNvbnNvbGVfdGltZXJfZW5kKHNwYW5JZCk7XG4gICAgdGltZXJNYXAuZGVsZXRlKGxhYmVsKTtcbiAgfSxcbiAgLy8gQWRkaXRpb25hbCBjb25zb2xlIG1ldGhvZHMgdG8gc2F0aXNmeSB0aGUgQ29uc29sZSBpbnRlcmZhY2VcbiAgdGltZVN0YW1wOiAoKSA9PiB7XG4gIH0sXG4gIHByb2ZpbGU6ICgpID0+IHtcbiAgfSxcbiAgcHJvZmlsZUVuZDogKCkgPT4ge1xuICB9XG59O1xuY29uc29sZTIuQ29uc29sZSA9IGNvbnNvbGUyO1xuZ2xvYmFsVGhpcy5jb25zb2xlID0gY29uc29sZTI7XG5cbi8vIHNyYy9zZXJ2ZXIvcmVnaXN0ZXJfaG9va3MudHNcbnJlZ2lzdGVyX2hvb2tzKGhvb2tzKTtcbnJlZ2lzdGVyX2hvb2tzJDEoaG9va3NfdjFfMSk7XG5yZWdpc3Rlcl9ob29rcyQyKGhvb2tzX3YxXzIpO1xuLyohIEJ1bmRsZWQgbGljZW5zZSBpbmZvcm1hdGlvbjpcblxuc3RhdHVzZXMvaW5kZXguanM6XG4gICgqIVxuICAgKiBzdGF0dXNlc1xuICAgKiBDb3B5cmlnaHQoYykgMjAxNCBKb25hdGhhbiBPbmdcbiAgICogQ29weXJpZ2h0KGMpIDIwMTYgRG91Z2xhcyBDaHJpc3RvcGhlciBXaWxzb25cbiAgICogTUlUIExpY2Vuc2VkXG4gICAqKVxuKi9cblxuZXhwb3J0IHsgQXJyYXlCdWlsZGVyLCBBcnJheUNvbHVtbkJ1aWxkZXIsIEJvb2xCdWlsZGVyLCBCb29sQ29sdW1uQnVpbGRlciwgQnl0ZUFycmF5QnVpbGRlciwgQnl0ZUFycmF5Q29sdW1uQnVpbGRlciwgQ29sdW1uQnVpbGRlciwgQ29ubmVjdGlvbklkQnVpbGRlciwgQ29ubmVjdGlvbklkQ29sdW1uQnVpbGRlciwgRjMyQnVpbGRlciwgRjMyQ29sdW1uQnVpbGRlciwgRjY0QnVpbGRlciwgRjY0Q29sdW1uQnVpbGRlciwgSTEyOEJ1aWxkZXIsIEkxMjhDb2x1bW5CdWlsZGVyLCBJMTZCdWlsZGVyLCBJMTZDb2x1bW5CdWlsZGVyLCBJMjU2QnVpbGRlciwgSTI1NkNvbHVtbkJ1aWxkZXIsIEkzMkJ1aWxkZXIsIEkzMkNvbHVtbkJ1aWxkZXIsIEk2NEJ1aWxkZXIsIEk2NENvbHVtbkJ1aWxkZXIsIEk4QnVpbGRlciwgSThDb2x1bW5CdWlsZGVyLCBJZGVudGl0eUJ1aWxkZXIsIElkZW50aXR5Q29sdW1uQnVpbGRlciwgT3B0aW9uQnVpbGRlciwgT3B0aW9uQ29sdW1uQnVpbGRlciwgUHJvZHVjdEJ1aWxkZXIsIFByb2R1Y3RDb2x1bW5CdWlsZGVyLCBSZWZCdWlsZGVyLCBSZXN1bHRCdWlsZGVyLCBSZXN1bHRDb2x1bW5CdWlsZGVyLCBSb3dCdWlsZGVyLCBTY2hlZHVsZUF0QnVpbGRlciwgU2NoZWR1bGVBdENvbHVtbkJ1aWxkZXIsIFNlbmRlckVycm9yLCBTaW1wbGVTdW1CdWlsZGVyLCBTaW1wbGVTdW1Db2x1bW5CdWlsZGVyLCBTcGFjZXRpbWVIb3N0RXJyb3IsIFN0cmluZ0J1aWxkZXIsIFN0cmluZ0NvbHVtbkJ1aWxkZXIsIFN1bUJ1aWxkZXIsIFN1bUNvbHVtbkJ1aWxkZXIsIFRpbWVEdXJhdGlvbkJ1aWxkZXIsIFRpbWVEdXJhdGlvbkNvbHVtbkJ1aWxkZXIsIFRpbWVzdGFtcEJ1aWxkZXIsIFRpbWVzdGFtcENvbHVtbkJ1aWxkZXIsIFR5cGVCdWlsZGVyLCBVMTI4QnVpbGRlciwgVTEyOENvbHVtbkJ1aWxkZXIsIFUxNkJ1aWxkZXIsIFUxNkNvbHVtbkJ1aWxkZXIsIFUyNTZCdWlsZGVyLCBVMjU2Q29sdW1uQnVpbGRlciwgVTMyQnVpbGRlciwgVTMyQ29sdW1uQnVpbGRlciwgVTY0QnVpbGRlciwgVTY0Q29sdW1uQnVpbGRlciwgVThCdWlsZGVyLCBVOENvbHVtbkJ1aWxkZXIsIFV1aWRCdWlsZGVyLCBVdWlkQ29sdW1uQnVpbGRlciwgYW5kLCBlcnJvcnMsIG5vdCwgb3IsIHJlZHVjZXJzLCBzY2hlbWEsIHQsIHRhYmxlLCB0b0NhbWVsQ2FzZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yZWdleHBDb2RlID0gZXhwb3J0cy5nZXRFc21FeHBvcnROYW1lID0gZXhwb3J0cy5nZXRQcm9wZXJ0eSA9IGV4cG9ydHMuc2FmZVN0cmluZ2lmeSA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gZXhwb3J0cy5zdHJDb25jYXQgPSBleHBvcnRzLmFkZENvZGVBcmcgPSBleHBvcnRzLnN0ciA9IGV4cG9ydHMuXyA9IGV4cG9ydHMubmlsID0gZXhwb3J0cy5fQ29kZSA9IGV4cG9ydHMuTmFtZSA9IGV4cG9ydHMuSURFTlRJRklFUiA9IGV4cG9ydHMuX0NvZGVPck5hbWUgPSB2b2lkIDA7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4dHJhbmVvdXMtY2xhc3NcbmNsYXNzIF9Db2RlT3JOYW1lIHtcbn1cbmV4cG9ydHMuX0NvZGVPck5hbWUgPSBfQ29kZU9yTmFtZTtcbmV4cG9ydHMuSURFTlRJRklFUiA9IC9eW2EteiRfXVthLXokXzAtOV0qJC9pO1xuY2xhc3MgTmFtZSBleHRlbmRzIF9Db2RlT3JOYW1lIHtcbiAgICBjb25zdHJ1Y3RvcihzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIGlmICghZXhwb3J0cy5JREVOVElGSUVSLnRlc3QocykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb2RlR2VuOiBuYW1lIG11c3QgYmUgYSB2YWxpZCBpZGVudGlmaWVyXCIpO1xuICAgICAgICB0aGlzLnN0ciA9IHM7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHI7XG4gICAgfVxuICAgIGVtcHR5U3RyKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGdldCBuYW1lcygpIHtcbiAgICAgICAgcmV0dXJuIHsgW3RoaXMuc3RyXTogMSB9O1xuICAgIH1cbn1cbmV4cG9ydHMuTmFtZSA9IE5hbWU7XG5jbGFzcyBfQ29kZSBleHRlbmRzIF9Db2RlT3JOYW1lIHtcbiAgICBjb25zdHJ1Y3Rvcihjb2RlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX2l0ZW1zID0gdHlwZW9mIGNvZGUgPT09IFwic3RyaW5nXCIgPyBbY29kZV0gOiBjb2RlO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyO1xuICAgIH1cbiAgICBlbXB0eVN0cigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2l0ZW1zLmxlbmd0aCA+IDEpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9pdGVtc1swXTtcbiAgICAgICAgcmV0dXJuIGl0ZW0gPT09IFwiXCIgfHwgaXRlbSA9PT0gJ1wiXCInO1xuICAgIH1cbiAgICBnZXQgc3RyKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gdGhpcy5fc3RyKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAodGhpcy5fc3RyID0gdGhpcy5faXRlbXMucmVkdWNlKChzLCBjKSA9PiBgJHtzfSR7Y31gLCBcIlwiKSkpO1xuICAgIH1cbiAgICBnZXQgbmFtZXMoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuICgoX2EgPSB0aGlzLl9uYW1lcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKHRoaXMuX25hbWVzID0gdGhpcy5faXRlbXMucmVkdWNlKChuYW1lcywgYykgPT4ge1xuICAgICAgICAgICAgaWYgKGMgaW5zdGFuY2VvZiBOYW1lKVxuICAgICAgICAgICAgICAgIG5hbWVzW2Muc3RyXSA9IChuYW1lc1tjLnN0cl0gfHwgMCkgKyAxO1xuICAgICAgICAgICAgcmV0dXJuIG5hbWVzO1xuICAgICAgICB9LCB7fSkpKTtcbiAgICB9XG59XG5leHBvcnRzLl9Db2RlID0gX0NvZGU7XG5leHBvcnRzLm5pbCA9IG5ldyBfQ29kZShcIlwiKTtcbmZ1bmN0aW9uIF8oc3RycywgLi4uYXJncykge1xuICAgIGNvbnN0IGNvZGUgPSBbc3Ryc1swXV07XG4gICAgbGV0IGkgPSAwO1xuICAgIHdoaWxlIChpIDwgYXJncy5sZW5ndGgpIHtcbiAgICAgICAgYWRkQ29kZUFyZyhjb2RlLCBhcmdzW2ldKTtcbiAgICAgICAgY29kZS5wdXNoKHN0cnNbKytpXSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgX0NvZGUoY29kZSk7XG59XG5leHBvcnRzLl8gPSBfO1xuY29uc3QgcGx1cyA9IG5ldyBfQ29kZShcIitcIik7XG5mdW5jdGlvbiBzdHIoc3RycywgLi4uYXJncykge1xuICAgIGNvbnN0IGV4cHIgPSBbc2FmZVN0cmluZ2lmeShzdHJzWzBdKV07XG4gICAgbGV0IGkgPSAwO1xuICAgIHdoaWxlIChpIDwgYXJncy5sZW5ndGgpIHtcbiAgICAgICAgZXhwci5wdXNoKHBsdXMpO1xuICAgICAgICBhZGRDb2RlQXJnKGV4cHIsIGFyZ3NbaV0pO1xuICAgICAgICBleHByLnB1c2gocGx1cywgc2FmZVN0cmluZ2lmeShzdHJzWysraV0pKTtcbiAgICB9XG4gICAgb3B0aW1pemUoZXhwcik7XG4gICAgcmV0dXJuIG5ldyBfQ29kZShleHByKTtcbn1cbmV4cG9ydHMuc3RyID0gc3RyO1xuZnVuY3Rpb24gYWRkQ29kZUFyZyhjb2RlLCBhcmcpIHtcbiAgICBpZiAoYXJnIGluc3RhbmNlb2YgX0NvZGUpXG4gICAgICAgIGNvZGUucHVzaCguLi5hcmcuX2l0ZW1zKTtcbiAgICBlbHNlIGlmIChhcmcgaW5zdGFuY2VvZiBOYW1lKVxuICAgICAgICBjb2RlLnB1c2goYXJnKTtcbiAgICBlbHNlXG4gICAgICAgIGNvZGUucHVzaChpbnRlcnBvbGF0ZShhcmcpKTtcbn1cbmV4cG9ydHMuYWRkQ29kZUFyZyA9IGFkZENvZGVBcmc7XG5mdW5jdGlvbiBvcHRpbWl6ZShleHByKSB7XG4gICAgbGV0IGkgPSAxO1xuICAgIHdoaWxlIChpIDwgZXhwci5sZW5ndGggLSAxKSB7XG4gICAgICAgIGlmIChleHByW2ldID09PSBwbHVzKSB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBtZXJnZUV4cHJJdGVtcyhleHByW2kgLSAxXSwgZXhwcltpICsgMV0pO1xuICAgICAgICAgICAgaWYgKHJlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZXhwci5zcGxpY2UoaSAtIDEsIDMsIHJlcyk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleHByW2krK10gPSBcIitcIjtcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgfVxufVxuZnVuY3Rpb24gbWVyZ2VFeHBySXRlbXMoYSwgYikge1xuICAgIGlmIChiID09PSAnXCJcIicpXG4gICAgICAgIHJldHVybiBhO1xuICAgIGlmIChhID09PSAnXCJcIicpXG4gICAgICAgIHJldHVybiBiO1xuICAgIGlmICh0eXBlb2YgYSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmIChiIGluc3RhbmNlb2YgTmFtZSB8fCBhW2EubGVuZ3RoIC0gMV0gIT09ICdcIicpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgcmV0dXJuIGAke2Euc2xpY2UoMCwgLTEpfSR7Yn1cImA7XG4gICAgICAgIGlmIChiWzBdID09PSAnXCInKVxuICAgICAgICAgICAgcmV0dXJuIGEuc2xpY2UoMCwgLTEpICsgYi5zbGljZSgxKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGIgPT0gXCJzdHJpbmdcIiAmJiBiWzBdID09PSAnXCInICYmICEoYSBpbnN0YW5jZW9mIE5hbWUpKVxuICAgICAgICByZXR1cm4gYFwiJHthfSR7Yi5zbGljZSgxKX1gO1xuICAgIHJldHVybjtcbn1cbmZ1bmN0aW9uIHN0ckNvbmNhdChjMSwgYzIpIHtcbiAgICByZXR1cm4gYzIuZW1wdHlTdHIoKSA/IGMxIDogYzEuZW1wdHlTdHIoKSA/IGMyIDogc3RyIGAke2MxfSR7YzJ9YDtcbn1cbmV4cG9ydHMuc3RyQ29uY2F0ID0gc3RyQ29uY2F0O1xuLy8gVE9ETyBkbyBub3QgYWxsb3cgYXJyYXlzIGhlcmVcbmZ1bmN0aW9uIGludGVycG9sYXRlKHgpIHtcbiAgICByZXR1cm4gdHlwZW9mIHggPT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgeCA9PSBcImJvb2xlYW5cIiB8fCB4ID09PSBudWxsXG4gICAgICAgID8geFxuICAgICAgICA6IHNhZmVTdHJpbmdpZnkoQXJyYXkuaXNBcnJheSh4KSA/IHguam9pbihcIixcIikgOiB4KTtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeSh4KSB7XG4gICAgcmV0dXJuIG5ldyBfQ29kZShzYWZlU3RyaW5naWZ5KHgpKTtcbn1cbmV4cG9ydHMuc3RyaW5naWZ5ID0gc3RyaW5naWZ5O1xuZnVuY3Rpb24gc2FmZVN0cmluZ2lmeSh4KSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHgpXG4gICAgICAgIC5yZXBsYWNlKC9cXHUyMDI4L2csIFwiXFxcXHUyMDI4XCIpXG4gICAgICAgIC5yZXBsYWNlKC9cXHUyMDI5L2csIFwiXFxcXHUyMDI5XCIpO1xufVxuZXhwb3J0cy5zYWZlU3RyaW5naWZ5ID0gc2FmZVN0cmluZ2lmeTtcbmZ1bmN0aW9uIGdldFByb3BlcnR5KGtleSkge1xuICAgIHJldHVybiB0eXBlb2Yga2V5ID09IFwic3RyaW5nXCIgJiYgZXhwb3J0cy5JREVOVElGSUVSLnRlc3Qoa2V5KSA/IG5ldyBfQ29kZShgLiR7a2V5fWApIDogXyBgWyR7a2V5fV1gO1xufVxuZXhwb3J0cy5nZXRQcm9wZXJ0eSA9IGdldFByb3BlcnR5O1xuLy9Eb2VzIGJlc3QgZWZmb3J0IHRvIGZvcm1hdCB0aGUgbmFtZSBwcm9wZXJseVxuZnVuY3Rpb24gZ2V0RXNtRXhwb3J0TmFtZShrZXkpIHtcbiAgICBpZiAodHlwZW9mIGtleSA9PSBcInN0cmluZ1wiICYmIGV4cG9ydHMuSURFTlRJRklFUi50ZXN0KGtleSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBfQ29kZShgJHtrZXl9YCk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgQ29kZUdlbjogaW52YWxpZCBleHBvcnQgbmFtZTogJHtrZXl9LCB1c2UgZXhwbGljaXQgJGlkIG5hbWUgbWFwcGluZ2ApO1xufVxuZXhwb3J0cy5nZXRFc21FeHBvcnROYW1lID0gZ2V0RXNtRXhwb3J0TmFtZTtcbmZ1bmN0aW9uIHJlZ2V4cENvZGUocngpIHtcbiAgICByZXR1cm4gbmV3IF9Db2RlKHJ4LnRvU3RyaW5nKCkpO1xufVxuZXhwb3J0cy5yZWdleHBDb2RlID0gcmVnZXhwQ29kZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvZGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlZhbHVlU2NvcGUgPSBleHBvcnRzLlZhbHVlU2NvcGVOYW1lID0gZXhwb3J0cy5TY29wZSA9IGV4cG9ydHMudmFyS2luZHMgPSBleHBvcnRzLlVzZWRWYWx1ZVN0YXRlID0gdm9pZCAwO1xuY29uc3QgY29kZV8xID0gcmVxdWlyZShcIi4vY29kZVwiKTtcbmNsYXNzIFZhbHVlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobmFtZSkge1xuICAgICAgICBzdXBlcihgQ29kZUdlbjogXCJjb2RlXCIgZm9yICR7bmFtZX0gbm90IGRlZmluZWRgKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IG5hbWUudmFsdWU7XG4gICAgfVxufVxudmFyIFVzZWRWYWx1ZVN0YXRlO1xuKGZ1bmN0aW9uIChVc2VkVmFsdWVTdGF0ZSkge1xuICAgIFVzZWRWYWx1ZVN0YXRlW1VzZWRWYWx1ZVN0YXRlW1wiU3RhcnRlZFwiXSA9IDBdID0gXCJTdGFydGVkXCI7XG4gICAgVXNlZFZhbHVlU3RhdGVbVXNlZFZhbHVlU3RhdGVbXCJDb21wbGV0ZWRcIl0gPSAxXSA9IFwiQ29tcGxldGVkXCI7XG59KShVc2VkVmFsdWVTdGF0ZSB8fCAoZXhwb3J0cy5Vc2VkVmFsdWVTdGF0ZSA9IFVzZWRWYWx1ZVN0YXRlID0ge30pKTtcbmV4cG9ydHMudmFyS2luZHMgPSB7XG4gICAgY29uc3Q6IG5ldyBjb2RlXzEuTmFtZShcImNvbnN0XCIpLFxuICAgIGxldDogbmV3IGNvZGVfMS5OYW1lKFwibGV0XCIpLFxuICAgIHZhcjogbmV3IGNvZGVfMS5OYW1lKFwidmFyXCIpLFxufTtcbmNsYXNzIFNjb3BlIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHByZWZpeGVzLCBwYXJlbnQgfSA9IHt9KSB7XG4gICAgICAgIHRoaXMuX25hbWVzID0ge307XG4gICAgICAgIHRoaXMuX3ByZWZpeGVzID0gcHJlZml4ZXM7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcbiAgICB9XG4gICAgdG9OYW1lKG5hbWVPclByZWZpeCkge1xuICAgICAgICByZXR1cm4gbmFtZU9yUHJlZml4IGluc3RhbmNlb2YgY29kZV8xLk5hbWUgPyBuYW1lT3JQcmVmaXggOiB0aGlzLm5hbWUobmFtZU9yUHJlZml4KTtcbiAgICB9XG4gICAgbmFtZShwcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBjb2RlXzEuTmFtZSh0aGlzLl9uZXdOYW1lKHByZWZpeCkpO1xuICAgIH1cbiAgICBfbmV3TmFtZShwcmVmaXgpIHtcbiAgICAgICAgY29uc3QgbmcgPSB0aGlzLl9uYW1lc1twcmVmaXhdIHx8IHRoaXMuX25hbWVHcm91cChwcmVmaXgpO1xuICAgICAgICByZXR1cm4gYCR7cHJlZml4fSR7bmcuaW5kZXgrK31gO1xuICAgIH1cbiAgICBfbmFtZUdyb3VwKHByZWZpeCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAoKChfYiA9IChfYSA9IHRoaXMuX3BhcmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLl9wcmVmaXhlcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmhhcyhwcmVmaXgpKSB8fCAodGhpcy5fcHJlZml4ZXMgJiYgIXRoaXMuX3ByZWZpeGVzLmhhcyhwcmVmaXgpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb2RlR2VuOiBwcmVmaXggXCIke3ByZWZpeH1cIiBpcyBub3QgYWxsb3dlZCBpbiB0aGlzIHNjb3BlYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICh0aGlzLl9uYW1lc1twcmVmaXhdID0geyBwcmVmaXgsIGluZGV4OiAwIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuU2NvcGUgPSBTY29wZTtcbmNsYXNzIFZhbHVlU2NvcGVOYW1lIGV4dGVuZHMgY29kZV8xLk5hbWUge1xuICAgIGNvbnN0cnVjdG9yKHByZWZpeCwgbmFtZVN0cikge1xuICAgICAgICBzdXBlcihuYW1lU3RyKTtcbiAgICAgICAgdGhpcy5wcmVmaXggPSBwcmVmaXg7XG4gICAgfVxuICAgIHNldFZhbHVlKHZhbHVlLCB7IHByb3BlcnR5LCBpdGVtSW5kZXggfSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuc2NvcGVQYXRoID0gKDAsIGNvZGVfMS5fKSBgLiR7bmV3IGNvZGVfMS5OYW1lKHByb3BlcnR5KX1bJHtpdGVtSW5kZXh9XWA7XG4gICAgfVxufVxuZXhwb3J0cy5WYWx1ZVNjb3BlTmFtZSA9IFZhbHVlU2NvcGVOYW1lO1xuY29uc3QgbGluZSA9ICgwLCBjb2RlXzEuXykgYFxcbmA7XG5jbGFzcyBWYWx1ZVNjb3BlIGV4dGVuZHMgU2NvcGUge1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgc3VwZXIob3B0cyk7XG4gICAgICAgIHRoaXMuX3ZhbHVlcyA9IHt9O1xuICAgICAgICB0aGlzLl9zY29wZSA9IG9wdHMuc2NvcGU7XG4gICAgICAgIHRoaXMub3B0cyA9IHsgLi4ub3B0cywgX246IG9wdHMubGluZXMgPyBsaW5lIDogY29kZV8xLm5pbCB9O1xuICAgIH1cbiAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zY29wZTtcbiAgICB9XG4gICAgbmFtZShwcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWYWx1ZVNjb3BlTmFtZShwcmVmaXgsIHRoaXMuX25ld05hbWUocHJlZml4KSk7XG4gICAgfVxuICAgIHZhbHVlKG5hbWVPclByZWZpeCwgdmFsdWUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAodmFsdWUucmVmID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb2RlR2VuOiByZWYgbXVzdCBiZSBwYXNzZWQgaW4gdmFsdWVcIik7XG4gICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLnRvTmFtZShuYW1lT3JQcmVmaXgpO1xuICAgICAgICBjb25zdCB7IHByZWZpeCB9ID0gbmFtZTtcbiAgICAgICAgY29uc3QgdmFsdWVLZXkgPSAoX2EgPSB2YWx1ZS5rZXkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHZhbHVlLnJlZjtcbiAgICAgICAgbGV0IHZzID0gdGhpcy5fdmFsdWVzW3ByZWZpeF07XG4gICAgICAgIGlmICh2cykge1xuICAgICAgICAgICAgY29uc3QgX25hbWUgPSB2cy5nZXQodmFsdWVLZXkpO1xuICAgICAgICAgICAgaWYgKF9uYW1lKVxuICAgICAgICAgICAgICAgIHJldHVybiBfbmFtZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZzID0gdGhpcy5fdmFsdWVzW3ByZWZpeF0gPSBuZXcgTWFwKCk7XG4gICAgICAgIH1cbiAgICAgICAgdnMuc2V0KHZhbHVlS2V5LCBuYW1lKTtcbiAgICAgICAgY29uc3QgcyA9IHRoaXMuX3Njb3BlW3ByZWZpeF0gfHwgKHRoaXMuX3Njb3BlW3ByZWZpeF0gPSBbXSk7XG4gICAgICAgIGNvbnN0IGl0ZW1JbmRleCA9IHMubGVuZ3RoO1xuICAgICAgICBzW2l0ZW1JbmRleF0gPSB2YWx1ZS5yZWY7XG4gICAgICAgIG5hbWUuc2V0VmFsdWUodmFsdWUsIHsgcHJvcGVydHk6IHByZWZpeCwgaXRlbUluZGV4IH0pO1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG4gICAgZ2V0VmFsdWUocHJlZml4LCBrZXlPclJlZikge1xuICAgICAgICBjb25zdCB2cyA9IHRoaXMuX3ZhbHVlc1twcmVmaXhdO1xuICAgICAgICBpZiAoIXZzKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICByZXR1cm4gdnMuZ2V0KGtleU9yUmVmKTtcbiAgICB9XG4gICAgc2NvcGVSZWZzKHNjb3BlTmFtZSwgdmFsdWVzID0gdGhpcy5fdmFsdWVzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWR1Y2VWYWx1ZXModmFsdWVzLCAobmFtZSkgPT4ge1xuICAgICAgICAgICAgaWYgKG5hbWUuc2NvcGVQYXRoID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb2RlR2VuOiBuYW1lIFwiJHtuYW1lfVwiIGhhcyBubyB2YWx1ZWApO1xuICAgICAgICAgICAgcmV0dXJuICgwLCBjb2RlXzEuXykgYCR7c2NvcGVOYW1lfSR7bmFtZS5zY29wZVBhdGh9YDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNjb3BlQ29kZSh2YWx1ZXMgPSB0aGlzLl92YWx1ZXMsIHVzZWRWYWx1ZXMsIGdldENvZGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZHVjZVZhbHVlcyh2YWx1ZXMsIChuYW1lKSA9PiB7XG4gICAgICAgICAgICBpZiAobmFtZS52YWx1ZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29kZUdlbjogbmFtZSBcIiR7bmFtZX1cIiBoYXMgbm8gdmFsdWVgKTtcbiAgICAgICAgICAgIHJldHVybiBuYW1lLnZhbHVlLmNvZGU7XG4gICAgICAgIH0sIHVzZWRWYWx1ZXMsIGdldENvZGUpO1xuICAgIH1cbiAgICBfcmVkdWNlVmFsdWVzKHZhbHVlcywgdmFsdWVDb2RlLCB1c2VkVmFsdWVzID0ge30sIGdldENvZGUpIHtcbiAgICAgICAgbGV0IGNvZGUgPSBjb2RlXzEubmlsO1xuICAgICAgICBmb3IgKGNvbnN0IHByZWZpeCBpbiB2YWx1ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHZzID0gdmFsdWVzW3ByZWZpeF07XG4gICAgICAgICAgICBpZiAoIXZzKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgY29uc3QgbmFtZVNldCA9ICh1c2VkVmFsdWVzW3ByZWZpeF0gPSB1c2VkVmFsdWVzW3ByZWZpeF0gfHwgbmV3IE1hcCgpKTtcbiAgICAgICAgICAgIHZzLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobmFtZVNldC5oYXMobmFtZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBuYW1lU2V0LnNldChuYW1lLCBVc2VkVmFsdWVTdGF0ZS5TdGFydGVkKTtcbiAgICAgICAgICAgICAgICBsZXQgYyA9IHZhbHVlQ29kZShuYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoYykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWYgPSB0aGlzLm9wdHMuZXM1ID8gZXhwb3J0cy52YXJLaW5kcy52YXIgOiBleHBvcnRzLnZhcktpbmRzLmNvbnN0O1xuICAgICAgICAgICAgICAgICAgICBjb2RlID0gKDAsIGNvZGVfMS5fKSBgJHtjb2RlfSR7ZGVmfSAke25hbWV9ID0gJHtjfTske3RoaXMub3B0cy5fbn1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICgoYyA9IGdldENvZGUgPT09IG51bGwgfHwgZ2V0Q29kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZ2V0Q29kZShuYW1lKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZSA9ICgwLCBjb2RlXzEuXykgYCR7Y29kZX0ke2N9JHt0aGlzLm9wdHMuX259YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKG5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuYW1lU2V0LnNldChuYW1lLCBVc2VkVmFsdWVTdGF0ZS5Db21wbGV0ZWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvZGU7XG4gICAgfVxufVxuZXhwb3J0cy5WYWx1ZVNjb3BlID0gVmFsdWVTY29wZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNjb3BlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5vciA9IGV4cG9ydHMuYW5kID0gZXhwb3J0cy5ub3QgPSBleHBvcnRzLkNvZGVHZW4gPSBleHBvcnRzLm9wZXJhdG9ycyA9IGV4cG9ydHMudmFyS2luZHMgPSBleHBvcnRzLlZhbHVlU2NvcGVOYW1lID0gZXhwb3J0cy5WYWx1ZVNjb3BlID0gZXhwb3J0cy5TY29wZSA9IGV4cG9ydHMuTmFtZSA9IGV4cG9ydHMucmVnZXhwQ29kZSA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gZXhwb3J0cy5nZXRQcm9wZXJ0eSA9IGV4cG9ydHMubmlsID0gZXhwb3J0cy5zdHJDb25jYXQgPSBleHBvcnRzLnN0ciA9IGV4cG9ydHMuXyA9IHZvaWQgMDtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuL2NvZGVcIik7XG5jb25zdCBzY29wZV8xID0gcmVxdWlyZShcIi4vc2NvcGVcIik7XG52YXIgY29kZV8yID0gcmVxdWlyZShcIi4vY29kZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVfMi5fOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3RyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlXzIuc3RyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3RyQ29uY2F0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlXzIuc3RyQ29uY2F0OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibmlsXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlXzIubmlsOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0UHJvcGVydHlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVfMi5nZXRQcm9wZXJ0eTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0cmluZ2lmeVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZV8yLnN0cmluZ2lmeTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJlZ2V4cENvZGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVfMi5yZWdleHBDb2RlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTmFtZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZV8yLk5hbWU7IH0gfSk7XG52YXIgc2NvcGVfMiA9IHJlcXVpcmUoXCIuL3Njb3BlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2NvcGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNjb3BlXzIuU2NvcGU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJWYWx1ZVNjb3BlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzY29wZV8yLlZhbHVlU2NvcGU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJWYWx1ZVNjb3BlTmFtZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2NvcGVfMi5WYWx1ZVNjb3BlTmFtZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInZhcktpbmRzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzY29wZV8yLnZhcktpbmRzOyB9IH0pO1xuZXhwb3J0cy5vcGVyYXRvcnMgPSB7XG4gICAgR1Q6IG5ldyBjb2RlXzEuX0NvZGUoXCI+XCIpLFxuICAgIEdURTogbmV3IGNvZGVfMS5fQ29kZShcIj49XCIpLFxuICAgIExUOiBuZXcgY29kZV8xLl9Db2RlKFwiPFwiKSxcbiAgICBMVEU6IG5ldyBjb2RlXzEuX0NvZGUoXCI8PVwiKSxcbiAgICBFUTogbmV3IGNvZGVfMS5fQ29kZShcIj09PVwiKSxcbiAgICBORVE6IG5ldyBjb2RlXzEuX0NvZGUoXCIhPT1cIiksXG4gICAgTk9UOiBuZXcgY29kZV8xLl9Db2RlKFwiIVwiKSxcbiAgICBPUjogbmV3IGNvZGVfMS5fQ29kZShcInx8XCIpLFxuICAgIEFORDogbmV3IGNvZGVfMS5fQ29kZShcIiYmXCIpLFxuICAgIEFERDogbmV3IGNvZGVfMS5fQ29kZShcIitcIiksXG59O1xuY2xhc3MgTm9kZSB7XG4gICAgb3B0aW1pemVOb2RlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG9wdGltaXplTmFtZXMoX25hbWVzLCBfY29uc3RhbnRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cbmNsYXNzIERlZiBleHRlbmRzIE5vZGUge1xuICAgIGNvbnN0cnVjdG9yKHZhcktpbmQsIG5hbWUsIHJocykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnZhcktpbmQgPSB2YXJLaW5kO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnJocyA9IHJocztcbiAgICB9XG4gICAgcmVuZGVyKHsgZXM1LCBfbiB9KSB7XG4gICAgICAgIGNvbnN0IHZhcktpbmQgPSBlczUgPyBzY29wZV8xLnZhcktpbmRzLnZhciA6IHRoaXMudmFyS2luZDtcbiAgICAgICAgY29uc3QgcmhzID0gdGhpcy5yaHMgPT09IHVuZGVmaW5lZCA/IFwiXCIgOiBgID0gJHt0aGlzLnJoc31gO1xuICAgICAgICByZXR1cm4gYCR7dmFyS2luZH0gJHt0aGlzLm5hbWV9JHtyaHN9O2AgKyBfbjtcbiAgICB9XG4gICAgb3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSB7XG4gICAgICAgIGlmICghbmFtZXNbdGhpcy5uYW1lLnN0cl0pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLnJocylcbiAgICAgICAgICAgIHRoaXMucmhzID0gb3B0aW1pemVFeHByKHRoaXMucmhzLCBuYW1lcywgY29uc3RhbnRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdldCBuYW1lcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmhzIGluc3RhbmNlb2YgY29kZV8xLl9Db2RlT3JOYW1lID8gdGhpcy5yaHMubmFtZXMgOiB7fTtcbiAgICB9XG59XG5jbGFzcyBBc3NpZ24gZXh0ZW5kcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihsaHMsIHJocywgc2lkZUVmZmVjdHMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5saHMgPSBsaHM7XG4gICAgICAgIHRoaXMucmhzID0gcmhzO1xuICAgICAgICB0aGlzLnNpZGVFZmZlY3RzID0gc2lkZUVmZmVjdHM7XG4gICAgfVxuICAgIHJlbmRlcih7IF9uIH0pIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMubGhzfSA9ICR7dGhpcy5yaHN9O2AgKyBfbjtcbiAgICB9XG4gICAgb3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSB7XG4gICAgICAgIGlmICh0aGlzLmxocyBpbnN0YW5jZW9mIGNvZGVfMS5OYW1lICYmICFuYW1lc1t0aGlzLmxocy5zdHJdICYmICF0aGlzLnNpZGVFZmZlY3RzKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnJocyA9IG9wdGltaXplRXhwcih0aGlzLnJocywgbmFtZXMsIGNvbnN0YW50cyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXQgbmFtZXMoKSB7XG4gICAgICAgIGNvbnN0IG5hbWVzID0gdGhpcy5saHMgaW5zdGFuY2VvZiBjb2RlXzEuTmFtZSA/IHt9IDogeyAuLi50aGlzLmxocy5uYW1lcyB9O1xuICAgICAgICByZXR1cm4gYWRkRXhwck5hbWVzKG5hbWVzLCB0aGlzLnJocyk7XG4gICAgfVxufVxuY2xhc3MgQXNzaWduT3AgZXh0ZW5kcyBBc3NpZ24ge1xuICAgIGNvbnN0cnVjdG9yKGxocywgb3AsIHJocywgc2lkZUVmZmVjdHMpIHtcbiAgICAgICAgc3VwZXIobGhzLCByaHMsIHNpZGVFZmZlY3RzKTtcbiAgICAgICAgdGhpcy5vcCA9IG9wO1xuICAgIH1cbiAgICByZW5kZXIoeyBfbiB9KSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmxoc30gJHt0aGlzLm9wfT0gJHt0aGlzLnJoc307YCArIF9uO1xuICAgIH1cbn1cbmNsYXNzIExhYmVsIGV4dGVuZHMgTm9kZSB7XG4gICAgY29uc3RydWN0b3IobGFiZWwpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5sYWJlbCA9IGxhYmVsO1xuICAgICAgICB0aGlzLm5hbWVzID0ge307XG4gICAgfVxuICAgIHJlbmRlcih7IF9uIH0pIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMubGFiZWx9OmAgKyBfbjtcbiAgICB9XG59XG5jbGFzcyBCcmVhayBleHRlbmRzIE5vZGUge1xuICAgIGNvbnN0cnVjdG9yKGxhYmVsKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubGFiZWwgPSBsYWJlbDtcbiAgICAgICAgdGhpcy5uYW1lcyA9IHt9O1xuICAgIH1cbiAgICByZW5kZXIoeyBfbiB9KSB7XG4gICAgICAgIGNvbnN0IGxhYmVsID0gdGhpcy5sYWJlbCA/IGAgJHt0aGlzLmxhYmVsfWAgOiBcIlwiO1xuICAgICAgICByZXR1cm4gYGJyZWFrJHtsYWJlbH07YCArIF9uO1xuICAgIH1cbn1cbmNsYXNzIFRocm93IGV4dGVuZHMgTm9kZSB7XG4gICAgY29uc3RydWN0b3IoZXJyb3IpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgIH1cbiAgICByZW5kZXIoeyBfbiB9KSB7XG4gICAgICAgIHJldHVybiBgdGhyb3cgJHt0aGlzLmVycm9yfTtgICsgX247XG4gICAgfVxuICAgIGdldCBuYW1lcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IubmFtZXM7XG4gICAgfVxufVxuY2xhc3MgQW55Q29kZSBleHRlbmRzIE5vZGUge1xuICAgIGNvbnN0cnVjdG9yKGNvZGUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICB9XG4gICAgcmVuZGVyKHsgX24gfSkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5jb2RlfTtgICsgX247XG4gICAgfVxuICAgIG9wdGltaXplTm9kZXMoKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmNvZGV9YCA/IHRoaXMgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIG9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cykge1xuICAgICAgICB0aGlzLmNvZGUgPSBvcHRpbWl6ZUV4cHIodGhpcy5jb2RlLCBuYW1lcywgY29uc3RhbnRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdldCBuYW1lcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29kZSBpbnN0YW5jZW9mIGNvZGVfMS5fQ29kZU9yTmFtZSA/IHRoaXMuY29kZS5uYW1lcyA6IHt9O1xuICAgIH1cbn1cbmNsYXNzIFBhcmVudE5vZGUgZXh0ZW5kcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3Rvcihub2RlcyA9IFtdKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubm9kZXMgPSBub2RlcztcbiAgICB9XG4gICAgcmVuZGVyKG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZXMucmVkdWNlKChjb2RlLCBuKSA9PiBjb2RlICsgbi5yZW5kZXIob3B0cyksIFwiXCIpO1xuICAgIH1cbiAgICBvcHRpbWl6ZU5vZGVzKCkge1xuICAgICAgICBjb25zdCB7IG5vZGVzIH0gPSB0aGlzO1xuICAgICAgICBsZXQgaSA9IG5vZGVzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgY29uc3QgbiA9IG5vZGVzW2ldLm9wdGltaXplTm9kZXMoKTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG4pKVxuICAgICAgICAgICAgICAgIG5vZGVzLnNwbGljZShpLCAxLCAuLi5uKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKG4pXG4gICAgICAgICAgICAgICAgbm9kZXNbaV0gPSBuO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG5vZGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZXMubGVuZ3RoID4gMCA/IHRoaXMgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIG9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cykge1xuICAgICAgICBjb25zdCB7IG5vZGVzIH0gPSB0aGlzO1xuICAgICAgICBsZXQgaSA9IG5vZGVzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgLy8gaXRlcmF0aW5nIGJhY2t3YXJkcyBpbXByb3ZlcyAxLXBhc3Mgb3B0aW1pemF0aW9uXG4gICAgICAgICAgICBjb25zdCBuID0gbm9kZXNbaV07XG4gICAgICAgICAgICBpZiAobi5vcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgc3VidHJhY3ROYW1lcyhuYW1lcywgbi5uYW1lcyk7XG4gICAgICAgICAgICBub2Rlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGVzLmxlbmd0aCA+IDAgPyB0aGlzIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXQgbmFtZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVzLnJlZHVjZSgobmFtZXMsIG4pID0+IGFkZE5hbWVzKG5hbWVzLCBuLm5hbWVzKSwge30pO1xuICAgIH1cbn1cbmNsYXNzIEJsb2NrTm9kZSBleHRlbmRzIFBhcmVudE5vZGUge1xuICAgIHJlbmRlcihvcHRzKSB7XG4gICAgICAgIHJldHVybiBcIntcIiArIG9wdHMuX24gKyBzdXBlci5yZW5kZXIob3B0cykgKyBcIn1cIiArIG9wdHMuX247XG4gICAgfVxufVxuY2xhc3MgUm9vdCBleHRlbmRzIFBhcmVudE5vZGUge1xufVxuY2xhc3MgRWxzZSBleHRlbmRzIEJsb2NrTm9kZSB7XG59XG5FbHNlLmtpbmQgPSBcImVsc2VcIjtcbmNsYXNzIElmIGV4dGVuZHMgQmxvY2tOb2RlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25kaXRpb24sIG5vZGVzKSB7XG4gICAgICAgIHN1cGVyKG5vZGVzKTtcbiAgICAgICAgdGhpcy5jb25kaXRpb24gPSBjb25kaXRpb247XG4gICAgfVxuICAgIHJlbmRlcihvcHRzKSB7XG4gICAgICAgIGxldCBjb2RlID0gYGlmKCR7dGhpcy5jb25kaXRpb259KWAgKyBzdXBlci5yZW5kZXIob3B0cyk7XG4gICAgICAgIGlmICh0aGlzLmVsc2UpXG4gICAgICAgICAgICBjb2RlICs9IFwiZWxzZSBcIiArIHRoaXMuZWxzZS5yZW5kZXIob3B0cyk7XG4gICAgICAgIHJldHVybiBjb2RlO1xuICAgIH1cbiAgICBvcHRpbWl6ZU5vZGVzKCkge1xuICAgICAgICBzdXBlci5vcHRpbWl6ZU5vZGVzKCk7XG4gICAgICAgIGNvbnN0IGNvbmQgPSB0aGlzLmNvbmRpdGlvbjtcbiAgICAgICAgaWYgKGNvbmQgPT09IHRydWUpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ub2RlczsgLy8gZWxzZSBpcyBpZ25vcmVkIGhlcmVcbiAgICAgICAgbGV0IGUgPSB0aGlzLmVsc2U7XG4gICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICBjb25zdCBucyA9IGUub3B0aW1pemVOb2RlcygpO1xuICAgICAgICAgICAgZSA9IHRoaXMuZWxzZSA9IEFycmF5LmlzQXJyYXkobnMpID8gbmV3IEVsc2UobnMpIDogbnM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgIGlmIChjb25kID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZSBpbnN0YW5jZW9mIElmID8gZSA6IGUubm9kZXM7XG4gICAgICAgICAgICBpZiAodGhpcy5ub2Rlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gbmV3IElmKG5vdChjb25kKSwgZSBpbnN0YW5jZW9mIElmID8gW2VdIDogZS5ub2Rlcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmQgPT09IGZhbHNlIHx8ICF0aGlzLm5vZGVzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBvcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLmVsc2UgPSAoX2EgPSB0aGlzLmVsc2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpO1xuICAgICAgICBpZiAoIShzdXBlci5vcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpIHx8IHRoaXMuZWxzZSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuY29uZGl0aW9uID0gb3B0aW1pemVFeHByKHRoaXMuY29uZGl0aW9uLCBuYW1lcywgY29uc3RhbnRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdldCBuYW1lcygpIHtcbiAgICAgICAgY29uc3QgbmFtZXMgPSBzdXBlci5uYW1lcztcbiAgICAgICAgYWRkRXhwck5hbWVzKG5hbWVzLCB0aGlzLmNvbmRpdGlvbik7XG4gICAgICAgIGlmICh0aGlzLmVsc2UpXG4gICAgICAgICAgICBhZGROYW1lcyhuYW1lcywgdGhpcy5lbHNlLm5hbWVzKTtcbiAgICAgICAgcmV0dXJuIG5hbWVzO1xuICAgIH1cbn1cbklmLmtpbmQgPSBcImlmXCI7XG5jbGFzcyBGb3IgZXh0ZW5kcyBCbG9ja05vZGUge1xufVxuRm9yLmtpbmQgPSBcImZvclwiO1xuY2xhc3MgRm9yTG9vcCBleHRlbmRzIEZvciB7XG4gICAgY29uc3RydWN0b3IoaXRlcmF0aW9uKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuaXRlcmF0aW9uID0gaXRlcmF0aW9uO1xuICAgIH1cbiAgICByZW5kZXIob3B0cykge1xuICAgICAgICByZXR1cm4gYGZvcigke3RoaXMuaXRlcmF0aW9ufSlgICsgc3VwZXIucmVuZGVyKG9wdHMpO1xuICAgIH1cbiAgICBvcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpIHtcbiAgICAgICAgaWYgKCFzdXBlci5vcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLml0ZXJhdGlvbiA9IG9wdGltaXplRXhwcih0aGlzLml0ZXJhdGlvbiwgbmFtZXMsIGNvbnN0YW50cyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXQgbmFtZXMoKSB7XG4gICAgICAgIHJldHVybiBhZGROYW1lcyhzdXBlci5uYW1lcywgdGhpcy5pdGVyYXRpb24ubmFtZXMpO1xuICAgIH1cbn1cbmNsYXNzIEZvclJhbmdlIGV4dGVuZHMgRm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih2YXJLaW5kLCBuYW1lLCBmcm9tLCB0bykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnZhcktpbmQgPSB2YXJLaW5kO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgfVxuICAgIHJlbmRlcihvcHRzKSB7XG4gICAgICAgIGNvbnN0IHZhcktpbmQgPSBvcHRzLmVzNSA/IHNjb3BlXzEudmFyS2luZHMudmFyIDogdGhpcy52YXJLaW5kO1xuICAgICAgICBjb25zdCB7IG5hbWUsIGZyb20sIHRvIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gYGZvcigke3ZhcktpbmR9ICR7bmFtZX09JHtmcm9tfTsgJHtuYW1lfTwke3RvfTsgJHtuYW1lfSsrKWAgKyBzdXBlci5yZW5kZXIob3B0cyk7XG4gICAgfVxuICAgIGdldCBuYW1lcygpIHtcbiAgICAgICAgY29uc3QgbmFtZXMgPSBhZGRFeHByTmFtZXMoc3VwZXIubmFtZXMsIHRoaXMuZnJvbSk7XG4gICAgICAgIHJldHVybiBhZGRFeHByTmFtZXMobmFtZXMsIHRoaXMudG8pO1xuICAgIH1cbn1cbmNsYXNzIEZvckl0ZXIgZXh0ZW5kcyBGb3Ige1xuICAgIGNvbnN0cnVjdG9yKGxvb3AsIHZhcktpbmQsIG5hbWUsIGl0ZXJhYmxlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubG9vcCA9IGxvb3A7XG4gICAgICAgIHRoaXMudmFyS2luZCA9IHZhcktpbmQ7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuaXRlcmFibGUgPSBpdGVyYWJsZTtcbiAgICB9XG4gICAgcmVuZGVyKG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIGBmb3IoJHt0aGlzLnZhcktpbmR9ICR7dGhpcy5uYW1lfSAke3RoaXMubG9vcH0gJHt0aGlzLml0ZXJhYmxlfSlgICsgc3VwZXIucmVuZGVyKG9wdHMpO1xuICAgIH1cbiAgICBvcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpIHtcbiAgICAgICAgaWYgKCFzdXBlci5vcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLml0ZXJhYmxlID0gb3B0aW1pemVFeHByKHRoaXMuaXRlcmFibGUsIG5hbWVzLCBjb25zdGFudHMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0IG5hbWVzKCkge1xuICAgICAgICByZXR1cm4gYWRkTmFtZXMoc3VwZXIubmFtZXMsIHRoaXMuaXRlcmFibGUubmFtZXMpO1xuICAgIH1cbn1cbmNsYXNzIEZ1bmMgZXh0ZW5kcyBCbG9ja05vZGUge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGFyZ3MsIGFzeW5jKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgICAgIHRoaXMuYXN5bmMgPSBhc3luYztcbiAgICB9XG4gICAgcmVuZGVyKG9wdHMpIHtcbiAgICAgICAgY29uc3QgX2FzeW5jID0gdGhpcy5hc3luYyA/IFwiYXN5bmMgXCIgOiBcIlwiO1xuICAgICAgICByZXR1cm4gYCR7X2FzeW5jfWZ1bmN0aW9uICR7dGhpcy5uYW1lfSgke3RoaXMuYXJnc30pYCArIHN1cGVyLnJlbmRlcihvcHRzKTtcbiAgICB9XG59XG5GdW5jLmtpbmQgPSBcImZ1bmNcIjtcbmNsYXNzIFJldHVybiBleHRlbmRzIFBhcmVudE5vZGUge1xuICAgIHJlbmRlcihvcHRzKSB7XG4gICAgICAgIHJldHVybiBcInJldHVybiBcIiArIHN1cGVyLnJlbmRlcihvcHRzKTtcbiAgICB9XG59XG5SZXR1cm4ua2luZCA9IFwicmV0dXJuXCI7XG5jbGFzcyBUcnkgZXh0ZW5kcyBCbG9ja05vZGUge1xuICAgIHJlbmRlcihvcHRzKSB7XG4gICAgICAgIGxldCBjb2RlID0gXCJ0cnlcIiArIHN1cGVyLnJlbmRlcihvcHRzKTtcbiAgICAgICAgaWYgKHRoaXMuY2F0Y2gpXG4gICAgICAgICAgICBjb2RlICs9IHRoaXMuY2F0Y2gucmVuZGVyKG9wdHMpO1xuICAgICAgICBpZiAodGhpcy5maW5hbGx5KVxuICAgICAgICAgICAgY29kZSArPSB0aGlzLmZpbmFsbHkucmVuZGVyKG9wdHMpO1xuICAgICAgICByZXR1cm4gY29kZTtcbiAgICB9XG4gICAgb3B0aW1pemVOb2RlcygpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgc3VwZXIub3B0aW1pemVOb2RlcygpO1xuICAgICAgICAoX2EgPSB0aGlzLmNhdGNoKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub3B0aW1pemVOb2RlcygpO1xuICAgICAgICAoX2IgPSB0aGlzLmZpbmFsbHkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5vcHRpbWl6ZU5vZGVzKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBvcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgc3VwZXIub3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKTtcbiAgICAgICAgKF9hID0gdGhpcy5jYXRjaCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cyk7XG4gICAgICAgIChfYiA9IHRoaXMuZmluYWxseSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXQgbmFtZXMoKSB7XG4gICAgICAgIGNvbnN0IG5hbWVzID0gc3VwZXIubmFtZXM7XG4gICAgICAgIGlmICh0aGlzLmNhdGNoKVxuICAgICAgICAgICAgYWRkTmFtZXMobmFtZXMsIHRoaXMuY2F0Y2gubmFtZXMpO1xuICAgICAgICBpZiAodGhpcy5maW5hbGx5KVxuICAgICAgICAgICAgYWRkTmFtZXMobmFtZXMsIHRoaXMuZmluYWxseS5uYW1lcyk7XG4gICAgICAgIHJldHVybiBuYW1lcztcbiAgICB9XG59XG5jbGFzcyBDYXRjaCBleHRlbmRzIEJsb2NrTm9kZSB7XG4gICAgY29uc3RydWN0b3IoZXJyb3IpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgIH1cbiAgICByZW5kZXIob3B0cykge1xuICAgICAgICByZXR1cm4gYGNhdGNoKCR7dGhpcy5lcnJvcn0pYCArIHN1cGVyLnJlbmRlcihvcHRzKTtcbiAgICB9XG59XG5DYXRjaC5raW5kID0gXCJjYXRjaFwiO1xuY2xhc3MgRmluYWxseSBleHRlbmRzIEJsb2NrTm9kZSB7XG4gICAgcmVuZGVyKG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIFwiZmluYWxseVwiICsgc3VwZXIucmVuZGVyKG9wdHMpO1xuICAgIH1cbn1cbkZpbmFsbHkua2luZCA9IFwiZmluYWxseVwiO1xuY2xhc3MgQ29kZUdlbiB7XG4gICAgY29uc3RydWN0b3IoZXh0U2NvcGUsIG9wdHMgPSB7fSkge1xuICAgICAgICB0aGlzLl92YWx1ZXMgPSB7fTtcbiAgICAgICAgdGhpcy5fYmxvY2tTdGFydHMgPSBbXTtcbiAgICAgICAgdGhpcy5fY29uc3RhbnRzID0ge307XG4gICAgICAgIHRoaXMub3B0cyA9IHsgLi4ub3B0cywgX246IG9wdHMubGluZXMgPyBcIlxcblwiIDogXCJcIiB9O1xuICAgICAgICB0aGlzLl9leHRTY29wZSA9IGV4dFNjb3BlO1xuICAgICAgICB0aGlzLl9zY29wZSA9IG5ldyBzY29wZV8xLlNjb3BlKHsgcGFyZW50OiBleHRTY29wZSB9KTtcbiAgICAgICAgdGhpcy5fbm9kZXMgPSBbbmV3IFJvb3QoKV07XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcm9vdC5yZW5kZXIodGhpcy5vcHRzKTtcbiAgICB9XG4gICAgLy8gcmV0dXJucyB1bmlxdWUgbmFtZSBpbiB0aGUgaW50ZXJuYWwgc2NvcGVcbiAgICBuYW1lKHByZWZpeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2NvcGUubmFtZShwcmVmaXgpO1xuICAgIH1cbiAgICAvLyByZXNlcnZlcyB1bmlxdWUgbmFtZSBpbiB0aGUgZXh0ZXJuYWwgc2NvcGVcbiAgICBzY29wZU5hbWUocHJlZml4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9leHRTY29wZS5uYW1lKHByZWZpeCk7XG4gICAgfVxuICAgIC8vIHJlc2VydmVzIHVuaXF1ZSBuYW1lIGluIHRoZSBleHRlcm5hbCBzY29wZSBhbmQgYXNzaWducyB2YWx1ZSB0byBpdFxuICAgIHNjb3BlVmFsdWUocHJlZml4T3JOYW1lLCB2YWx1ZSkge1xuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5fZXh0U2NvcGUudmFsdWUocHJlZml4T3JOYW1lLCB2YWx1ZSk7XG4gICAgICAgIGNvbnN0IHZzID0gdGhpcy5fdmFsdWVzW25hbWUucHJlZml4XSB8fCAodGhpcy5fdmFsdWVzW25hbWUucHJlZml4XSA9IG5ldyBTZXQoKSk7XG4gICAgICAgIHZzLmFkZChuYW1lKTtcbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuICAgIGdldFNjb3BlVmFsdWUocHJlZml4LCBrZXlPclJlZikge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXh0U2NvcGUuZ2V0VmFsdWUocHJlZml4LCBrZXlPclJlZik7XG4gICAgfVxuICAgIC8vIHJldHVybiBjb2RlIHRoYXQgYXNzaWducyB2YWx1ZXMgaW4gdGhlIGV4dGVybmFsIHNjb3BlIHRvIHRoZSBuYW1lcyB0aGF0IGFyZSB1c2VkIGludGVybmFsbHlcbiAgICAvLyAoc2FtZSBuYW1lcyB0aGF0IHdlcmUgcmV0dXJuZWQgYnkgZ2VuLnNjb3BlTmFtZSBvciBnZW4uc2NvcGVWYWx1ZSlcbiAgICBzY29wZVJlZnMoc2NvcGVOYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9leHRTY29wZS5zY29wZVJlZnMoc2NvcGVOYW1lLCB0aGlzLl92YWx1ZXMpO1xuICAgIH1cbiAgICBzY29wZUNvZGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9leHRTY29wZS5zY29wZUNvZGUodGhpcy5fdmFsdWVzKTtcbiAgICB9XG4gICAgX2RlZih2YXJLaW5kLCBuYW1lT3JQcmVmaXgsIHJocywgY29uc3RhbnQpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMuX3Njb3BlLnRvTmFtZShuYW1lT3JQcmVmaXgpO1xuICAgICAgICBpZiAocmhzICE9PSB1bmRlZmluZWQgJiYgY29uc3RhbnQpXG4gICAgICAgICAgICB0aGlzLl9jb25zdGFudHNbbmFtZS5zdHJdID0gcmhzO1xuICAgICAgICB0aGlzLl9sZWFmTm9kZShuZXcgRGVmKHZhcktpbmQsIG5hbWUsIHJocykpO1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG4gICAgLy8gYGNvbnN0YCBkZWNsYXJhdGlvbiAoYHZhcmAgaW4gZXM1IG1vZGUpXG4gICAgY29uc3QobmFtZU9yUHJlZml4LCByaHMsIF9jb25zdGFudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmKHNjb3BlXzEudmFyS2luZHMuY29uc3QsIG5hbWVPclByZWZpeCwgcmhzLCBfY29uc3RhbnQpO1xuICAgIH1cbiAgICAvLyBgbGV0YCBkZWNsYXJhdGlvbiB3aXRoIG9wdGlvbmFsIGFzc2lnbm1lbnQgKGB2YXJgIGluIGVzNSBtb2RlKVxuICAgIGxldChuYW1lT3JQcmVmaXgsIHJocywgX2NvbnN0YW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYoc2NvcGVfMS52YXJLaW5kcy5sZXQsIG5hbWVPclByZWZpeCwgcmhzLCBfY29uc3RhbnQpO1xuICAgIH1cbiAgICAvLyBgdmFyYCBkZWNsYXJhdGlvbiB3aXRoIG9wdGlvbmFsIGFzc2lnbm1lbnRcbiAgICB2YXIobmFtZU9yUHJlZml4LCByaHMsIF9jb25zdGFudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmKHNjb3BlXzEudmFyS2luZHMudmFyLCBuYW1lT3JQcmVmaXgsIHJocywgX2NvbnN0YW50KTtcbiAgICB9XG4gICAgLy8gYXNzaWdubWVudCBjb2RlXG4gICAgYXNzaWduKGxocywgcmhzLCBzaWRlRWZmZWN0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGVhZk5vZGUobmV3IEFzc2lnbihsaHMsIHJocywgc2lkZUVmZmVjdHMpKTtcbiAgICB9XG4gICAgLy8gYCs9YCBjb2RlXG4gICAgYWRkKGxocywgcmhzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sZWFmTm9kZShuZXcgQXNzaWduT3AobGhzLCBleHBvcnRzLm9wZXJhdG9ycy5BREQsIHJocykpO1xuICAgIH1cbiAgICAvLyBhcHBlbmRzIHBhc3NlZCBTYWZlRXhwciB0byBjb2RlIG9yIGV4ZWN1dGVzIEJsb2NrXG4gICAgY29kZShjKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYyA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICBjKCk7XG4gICAgICAgIGVsc2UgaWYgKGMgIT09IGNvZGVfMS5uaWwpXG4gICAgICAgICAgICB0aGlzLl9sZWFmTm9kZShuZXcgQW55Q29kZShjKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyByZXR1cm5zIGNvZGUgZm9yIG9iamVjdCBsaXRlcmFsIGZvciB0aGUgcGFzc2VkIGFyZ3VtZW50IGxpc3Qgb2Yga2V5LXZhbHVlIHBhaXJzXG4gICAgb2JqZWN0KC4uLmtleVZhbHVlcykge1xuICAgICAgICBjb25zdCBjb2RlID0gW1wie1wiXTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2Yga2V5VmFsdWVzKSB7XG4gICAgICAgICAgICBpZiAoY29kZS5sZW5ndGggPiAxKVxuICAgICAgICAgICAgICAgIGNvZGUucHVzaChcIixcIik7XG4gICAgICAgICAgICBjb2RlLnB1c2goa2V5KTtcbiAgICAgICAgICAgIGlmIChrZXkgIT09IHZhbHVlIHx8IHRoaXMub3B0cy5lczUpIHtcbiAgICAgICAgICAgICAgICBjb2RlLnB1c2goXCI6XCIpO1xuICAgICAgICAgICAgICAgICgwLCBjb2RlXzEuYWRkQ29kZUFyZykoY29kZSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvZGUucHVzaChcIn1cIik7XG4gICAgICAgIHJldHVybiBuZXcgY29kZV8xLl9Db2RlKGNvZGUpO1xuICAgIH1cbiAgICAvLyBgaWZgIGNsYXVzZSAob3Igc3RhdGVtZW50IGlmIGB0aGVuQm9keWAgYW5kLCBvcHRpb25hbGx5LCBgZWxzZUJvZHlgIGFyZSBwYXNzZWQpXG4gICAgaWYoY29uZGl0aW9uLCB0aGVuQm9keSwgZWxzZUJvZHkpIHtcbiAgICAgICAgdGhpcy5fYmxvY2tOb2RlKG5ldyBJZihjb25kaXRpb24pKTtcbiAgICAgICAgaWYgKHRoZW5Cb2R5ICYmIGVsc2VCb2R5KSB7XG4gICAgICAgICAgICB0aGlzLmNvZGUodGhlbkJvZHkpLmVsc2UoKS5jb2RlKGVsc2VCb2R5KS5lbmRJZigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoZW5Cb2R5KSB7XG4gICAgICAgICAgICB0aGlzLmNvZGUodGhlbkJvZHkpLmVuZElmKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWxzZUJvZHkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29kZUdlbjogXCJlbHNlXCIgYm9keSB3aXRob3V0IFwidGhlblwiIGJvZHknKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gYGVsc2UgaWZgIGNsYXVzZSAtIGludmFsaWQgd2l0aG91dCBgaWZgIG9yIGFmdGVyIGBlbHNlYCBjbGF1c2VzXG4gICAgZWxzZUlmKGNvbmRpdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5fZWxzZU5vZGUobmV3IElmKGNvbmRpdGlvbikpO1xuICAgIH1cbiAgICAvLyBgZWxzZWAgY2xhdXNlIC0gb25seSB2YWxpZCBhZnRlciBgaWZgIG9yIGBlbHNlIGlmYCBjbGF1c2VzXG4gICAgZWxzZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Vsc2VOb2RlKG5ldyBFbHNlKCkpO1xuICAgIH1cbiAgICAvLyBlbmQgYGlmYCBzdGF0ZW1lbnQgKG5lZWRlZCBpZiBnZW4uaWYgd2FzIHVzZWQgb25seSB3aXRoIGNvbmRpdGlvbilcbiAgICBlbmRJZigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuZEJsb2NrTm9kZShJZiwgRWxzZSk7XG4gICAgfVxuICAgIF9mb3Iobm9kZSwgZm9yQm9keSkge1xuICAgICAgICB0aGlzLl9ibG9ja05vZGUobm9kZSk7XG4gICAgICAgIGlmIChmb3JCb2R5KVxuICAgICAgICAgICAgdGhpcy5jb2RlKGZvckJvZHkpLmVuZEZvcigpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gYSBnZW5lcmljIGBmb3JgIGNsYXVzZSAob3Igc3RhdGVtZW50IGlmIGBmb3JCb2R5YCBpcyBwYXNzZWQpXG4gICAgZm9yKGl0ZXJhdGlvbiwgZm9yQm9keSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZm9yKG5ldyBGb3JMb29wKGl0ZXJhdGlvbiksIGZvckJvZHkpO1xuICAgIH1cbiAgICAvLyBgZm9yYCBzdGF0ZW1lbnQgZm9yIGEgcmFuZ2Ugb2YgdmFsdWVzXG4gICAgZm9yUmFuZ2UobmFtZU9yUHJlZml4LCBmcm9tLCB0bywgZm9yQm9keSwgdmFyS2luZCA9IHRoaXMub3B0cy5lczUgPyBzY29wZV8xLnZhcktpbmRzLnZhciA6IHNjb3BlXzEudmFyS2luZHMubGV0KSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLl9zY29wZS50b05hbWUobmFtZU9yUHJlZml4KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZvcihuZXcgRm9yUmFuZ2UodmFyS2luZCwgbmFtZSwgZnJvbSwgdG8pLCAoKSA9PiBmb3JCb2R5KG5hbWUpKTtcbiAgICB9XG4gICAgLy8gYGZvci1vZmAgc3RhdGVtZW50IChpbiBlczUgbW9kZSByZXBsYWNlIHdpdGggYSBub3JtYWwgZm9yIGxvb3ApXG4gICAgZm9yT2YobmFtZU9yUHJlZml4LCBpdGVyYWJsZSwgZm9yQm9keSwgdmFyS2luZCA9IHNjb3BlXzEudmFyS2luZHMuY29uc3QpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMuX3Njb3BlLnRvTmFtZShuYW1lT3JQcmVmaXgpO1xuICAgICAgICBpZiAodGhpcy5vcHRzLmVzNSkge1xuICAgICAgICAgICAgY29uc3QgYXJyID0gaXRlcmFibGUgaW5zdGFuY2VvZiBjb2RlXzEuTmFtZSA/IGl0ZXJhYmxlIDogdGhpcy52YXIoXCJfYXJyXCIsIGl0ZXJhYmxlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZvclJhbmdlKFwiX2lcIiwgMCwgKDAsIGNvZGVfMS5fKSBgJHthcnJ9Lmxlbmd0aGAsIChpKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy52YXIobmFtZSwgKDAsIGNvZGVfMS5fKSBgJHthcnJ9WyR7aX1dYCk7XG4gICAgICAgICAgICAgICAgZm9yQm9keShuYW1lKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9mb3IobmV3IEZvckl0ZXIoXCJvZlwiLCB2YXJLaW5kLCBuYW1lLCBpdGVyYWJsZSksICgpID0+IGZvckJvZHkobmFtZSkpO1xuICAgIH1cbiAgICAvLyBgZm9yLWluYCBzdGF0ZW1lbnQuXG4gICAgLy8gV2l0aCBvcHRpb24gYG93blByb3BlcnRpZXNgIHJlcGxhY2VkIHdpdGggYSBgZm9yLW9mYCBsb29wIGZvciBvYmplY3Qga2V5c1xuICAgIGZvckluKG5hbWVPclByZWZpeCwgb2JqLCBmb3JCb2R5LCB2YXJLaW5kID0gdGhpcy5vcHRzLmVzNSA/IHNjb3BlXzEudmFyS2luZHMudmFyIDogc2NvcGVfMS52YXJLaW5kcy5jb25zdCkge1xuICAgICAgICBpZiAodGhpcy5vcHRzLm93blByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZvck9mKG5hbWVPclByZWZpeCwgKDAsIGNvZGVfMS5fKSBgT2JqZWN0LmtleXMoJHtvYmp9KWAsIGZvckJvZHkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLl9zY29wZS50b05hbWUobmFtZU9yUHJlZml4KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZvcihuZXcgRm9ySXRlcihcImluXCIsIHZhcktpbmQsIG5hbWUsIG9iaiksICgpID0+IGZvckJvZHkobmFtZSkpO1xuICAgIH1cbiAgICAvLyBlbmQgYGZvcmAgbG9vcFxuICAgIGVuZEZvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuZEJsb2NrTm9kZShGb3IpO1xuICAgIH1cbiAgICAvLyBgbGFiZWxgIHN0YXRlbWVudFxuICAgIGxhYmVsKGxhYmVsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sZWFmTm9kZShuZXcgTGFiZWwobGFiZWwpKTtcbiAgICB9XG4gICAgLy8gYGJyZWFrYCBzdGF0ZW1lbnRcbiAgICBicmVhayhsYWJlbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGVhZk5vZGUobmV3IEJyZWFrKGxhYmVsKSk7XG4gICAgfVxuICAgIC8vIGByZXR1cm5gIHN0YXRlbWVudFxuICAgIHJldHVybih2YWx1ZSkge1xuICAgICAgICBjb25zdCBub2RlID0gbmV3IFJldHVybigpO1xuICAgICAgICB0aGlzLl9ibG9ja05vZGUobm9kZSk7XG4gICAgICAgIHRoaXMuY29kZSh2YWx1ZSk7XG4gICAgICAgIGlmIChub2RlLm5vZGVzLmxlbmd0aCAhPT0gMSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29kZUdlbjogXCJyZXR1cm5cIiBzaG91bGQgaGF2ZSBvbmUgbm9kZScpO1xuICAgICAgICByZXR1cm4gdGhpcy5fZW5kQmxvY2tOb2RlKFJldHVybik7XG4gICAgfVxuICAgIC8vIGB0cnlgIHN0YXRlbWVudFxuICAgIHRyeSh0cnlCb2R5LCBjYXRjaENvZGUsIGZpbmFsbHlDb2RlKSB7XG4gICAgICAgIGlmICghY2F0Y2hDb2RlICYmICFmaW5hbGx5Q29kZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29kZUdlbjogXCJ0cnlcIiB3aXRob3V0IFwiY2F0Y2hcIiBhbmQgXCJmaW5hbGx5XCInKTtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5ldyBUcnkoKTtcbiAgICAgICAgdGhpcy5fYmxvY2tOb2RlKG5vZGUpO1xuICAgICAgICB0aGlzLmNvZGUodHJ5Qm9keSk7XG4gICAgICAgIGlmIChjYXRjaENvZGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5uYW1lKFwiZVwiKTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJOb2RlID0gbm9kZS5jYXRjaCA9IG5ldyBDYXRjaChlcnJvcik7XG4gICAgICAgICAgICBjYXRjaENvZGUoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaW5hbGx5Q29kZSkge1xuICAgICAgICAgICAgdGhpcy5fY3Vyck5vZGUgPSBub2RlLmZpbmFsbHkgPSBuZXcgRmluYWxseSgpO1xuICAgICAgICAgICAgdGhpcy5jb2RlKGZpbmFsbHlDb2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZW5kQmxvY2tOb2RlKENhdGNoLCBGaW5hbGx5KTtcbiAgICB9XG4gICAgLy8gYHRocm93YCBzdGF0ZW1lbnRcbiAgICB0aHJvdyhlcnJvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGVhZk5vZGUobmV3IFRocm93KGVycm9yKSk7XG4gICAgfVxuICAgIC8vIHN0YXJ0IHNlbGYtYmFsYW5jaW5nIGJsb2NrXG4gICAgYmxvY2soYm9keSwgbm9kZUNvdW50KSB7XG4gICAgICAgIHRoaXMuX2Jsb2NrU3RhcnRzLnB1c2godGhpcy5fbm9kZXMubGVuZ3RoKTtcbiAgICAgICAgaWYgKGJvZHkpXG4gICAgICAgICAgICB0aGlzLmNvZGUoYm9keSkuZW5kQmxvY2sobm9kZUNvdW50KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIGVuZCB0aGUgY3VycmVudCBzZWxmLWJhbGFuY2luZyBibG9ja1xuICAgIGVuZEJsb2NrKG5vZGVDb3VudCkge1xuICAgICAgICBjb25zdCBsZW4gPSB0aGlzLl9ibG9ja1N0YXJ0cy5wb3AoKTtcbiAgICAgICAgaWYgKGxlbiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29kZUdlbjogbm90IGluIHNlbGYtYmFsYW5jaW5nIGJsb2NrXCIpO1xuICAgICAgICBjb25zdCB0b0Nsb3NlID0gdGhpcy5fbm9kZXMubGVuZ3RoIC0gbGVuO1xuICAgICAgICBpZiAodG9DbG9zZSA8IDAgfHwgKG5vZGVDb3VudCAhPT0gdW5kZWZpbmVkICYmIHRvQ2xvc2UgIT09IG5vZGVDb3VudCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29kZUdlbjogd3JvbmcgbnVtYmVyIG9mIG5vZGVzOiAke3RvQ2xvc2V9IHZzICR7bm9kZUNvdW50fSBleHBlY3RlZGApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX25vZGVzLmxlbmd0aCA9IGxlbjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIGBmdW5jdGlvbmAgaGVhZGluZyAob3IgZGVmaW5pdGlvbiBpZiBmdW5jQm9keSBpcyBwYXNzZWQpXG4gICAgZnVuYyhuYW1lLCBhcmdzID0gY29kZV8xLm5pbCwgYXN5bmMsIGZ1bmNCb2R5KSB7XG4gICAgICAgIHRoaXMuX2Jsb2NrTm9kZShuZXcgRnVuYyhuYW1lLCBhcmdzLCBhc3luYykpO1xuICAgICAgICBpZiAoZnVuY0JvZHkpXG4gICAgICAgICAgICB0aGlzLmNvZGUoZnVuY0JvZHkpLmVuZEZ1bmMoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIGVuZCBmdW5jdGlvbiBkZWZpbml0aW9uXG4gICAgZW5kRnVuYygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuZEJsb2NrTm9kZShGdW5jKTtcbiAgICB9XG4gICAgb3B0aW1pemUobiA9IDEpIHtcbiAgICAgICAgd2hpbGUgKG4tLSA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3Qub3B0aW1pemVOb2RlcygpO1xuICAgICAgICAgICAgdGhpcy5fcm9vdC5vcHRpbWl6ZU5hbWVzKHRoaXMuX3Jvb3QubmFtZXMsIHRoaXMuX2NvbnN0YW50cyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2xlYWZOb2RlKG5vZGUpIHtcbiAgICAgICAgdGhpcy5fY3Vyck5vZGUubm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIF9ibG9ja05vZGUobm9kZSkge1xuICAgICAgICB0aGlzLl9jdXJyTm9kZS5ub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICB0aGlzLl9ub2Rlcy5wdXNoKG5vZGUpO1xuICAgIH1cbiAgICBfZW5kQmxvY2tOb2RlKE4xLCBOMikge1xuICAgICAgICBjb25zdCBuID0gdGhpcy5fY3Vyck5vZGU7XG4gICAgICAgIGlmIChuIGluc3RhbmNlb2YgTjEgfHwgKE4yICYmIG4gaW5zdGFuY2VvZiBOMikpIHtcbiAgICAgICAgICAgIHRoaXMuX25vZGVzLnBvcCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb2RlR2VuOiBub3QgaW4gYmxvY2sgXCIke04yID8gYCR7TjEua2luZH0vJHtOMi5raW5kfWAgOiBOMS5raW5kfVwiYCk7XG4gICAgfVxuICAgIF9lbHNlTm9kZShub2RlKSB7XG4gICAgICAgIGNvbnN0IG4gPSB0aGlzLl9jdXJyTm9kZTtcbiAgICAgICAgaWYgKCEobiBpbnN0YW5jZW9mIElmKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb2RlR2VuOiBcImVsc2VcIiB3aXRob3V0IFwiaWZcIicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2N1cnJOb2RlID0gbi5lbHNlID0gbm9kZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdldCBfcm9vdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25vZGVzWzBdO1xuICAgIH1cbiAgICBnZXQgX2N1cnJOb2RlKCkge1xuICAgICAgICBjb25zdCBucyA9IHRoaXMuX25vZGVzO1xuICAgICAgICByZXR1cm4gbnNbbnMubGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIHNldCBfY3Vyck5vZGUobm9kZSkge1xuICAgICAgICBjb25zdCBucyA9IHRoaXMuX25vZGVzO1xuICAgICAgICBuc1tucy5sZW5ndGggLSAxXSA9IG5vZGU7XG4gICAgfVxufVxuZXhwb3J0cy5Db2RlR2VuID0gQ29kZUdlbjtcbmZ1bmN0aW9uIGFkZE5hbWVzKG5hbWVzLCBmcm9tKSB7XG4gICAgZm9yIChjb25zdCBuIGluIGZyb20pXG4gICAgICAgIG5hbWVzW25dID0gKG5hbWVzW25dIHx8IDApICsgKGZyb21bbl0gfHwgMCk7XG4gICAgcmV0dXJuIG5hbWVzO1xufVxuZnVuY3Rpb24gYWRkRXhwck5hbWVzKG5hbWVzLCBmcm9tKSB7XG4gICAgcmV0dXJuIGZyb20gaW5zdGFuY2VvZiBjb2RlXzEuX0NvZGVPck5hbWUgPyBhZGROYW1lcyhuYW1lcywgZnJvbS5uYW1lcykgOiBuYW1lcztcbn1cbmZ1bmN0aW9uIG9wdGltaXplRXhwcihleHByLCBuYW1lcywgY29uc3RhbnRzKSB7XG4gICAgaWYgKGV4cHIgaW5zdGFuY2VvZiBjb2RlXzEuTmFtZSlcbiAgICAgICAgcmV0dXJuIHJlcGxhY2VOYW1lKGV4cHIpO1xuICAgIGlmICghY2FuT3B0aW1pemUoZXhwcikpXG4gICAgICAgIHJldHVybiBleHByO1xuICAgIHJldHVybiBuZXcgY29kZV8xLl9Db2RlKGV4cHIuX2l0ZW1zLnJlZHVjZSgoaXRlbXMsIGMpID0+IHtcbiAgICAgICAgaWYgKGMgaW5zdGFuY2VvZiBjb2RlXzEuTmFtZSlcbiAgICAgICAgICAgIGMgPSByZXBsYWNlTmFtZShjKTtcbiAgICAgICAgaWYgKGMgaW5zdGFuY2VvZiBjb2RlXzEuX0NvZGUpXG4gICAgICAgICAgICBpdGVtcy5wdXNoKC4uLmMuX2l0ZW1zKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgaXRlbXMucHVzaChjKTtcbiAgICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgIH0sIFtdKSk7XG4gICAgZnVuY3Rpb24gcmVwbGFjZU5hbWUobikge1xuICAgICAgICBjb25zdCBjID0gY29uc3RhbnRzW24uc3RyXTtcbiAgICAgICAgaWYgKGMgPT09IHVuZGVmaW5lZCB8fCBuYW1lc1tuLnN0cl0gIT09IDEpXG4gICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgZGVsZXRlIG5hbWVzW24uc3RyXTtcbiAgICAgICAgcmV0dXJuIGM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNhbk9wdGltaXplKGUpIHtcbiAgICAgICAgcmV0dXJuIChlIGluc3RhbmNlb2YgY29kZV8xLl9Db2RlICYmXG4gICAgICAgICAgICBlLl9pdGVtcy5zb21lKChjKSA9PiBjIGluc3RhbmNlb2YgY29kZV8xLk5hbWUgJiYgbmFtZXNbYy5zdHJdID09PSAxICYmIGNvbnN0YW50c1tjLnN0cl0gIT09IHVuZGVmaW5lZCkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHN1YnRyYWN0TmFtZXMobmFtZXMsIGZyb20pIHtcbiAgICBmb3IgKGNvbnN0IG4gaW4gZnJvbSlcbiAgICAgICAgbmFtZXNbbl0gPSAobmFtZXNbbl0gfHwgMCkgLSAoZnJvbVtuXSB8fCAwKTtcbn1cbmZ1bmN0aW9uIG5vdCh4KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB4ID09IFwiYm9vbGVhblwiIHx8IHR5cGVvZiB4ID09IFwibnVtYmVyXCIgfHwgeCA9PT0gbnVsbCA/ICF4IDogKDAsIGNvZGVfMS5fKSBgISR7cGFyKHgpfWA7XG59XG5leHBvcnRzLm5vdCA9IG5vdDtcbmNvbnN0IGFuZENvZGUgPSBtYXBwZW5kKGV4cG9ydHMub3BlcmF0b3JzLkFORCk7XG4vLyBib29sZWFuIEFORCAoJiYpIGV4cHJlc3Npb24gd2l0aCB0aGUgcGFzc2VkIGFyZ3VtZW50c1xuZnVuY3Rpb24gYW5kKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gYXJncy5yZWR1Y2UoYW5kQ29kZSk7XG59XG5leHBvcnRzLmFuZCA9IGFuZDtcbmNvbnN0IG9yQ29kZSA9IG1hcHBlbmQoZXhwb3J0cy5vcGVyYXRvcnMuT1IpO1xuLy8gYm9vbGVhbiBPUiAofHwpIGV4cHJlc3Npb24gd2l0aCB0aGUgcGFzc2VkIGFyZ3VtZW50c1xuZnVuY3Rpb24gb3IoLi4uYXJncykge1xuICAgIHJldHVybiBhcmdzLnJlZHVjZShvckNvZGUpO1xufVxuZXhwb3J0cy5vciA9IG9yO1xuZnVuY3Rpb24gbWFwcGVuZChvcCkge1xuICAgIHJldHVybiAoeCwgeSkgPT4gKHggPT09IGNvZGVfMS5uaWwgPyB5IDogeSA9PT0gY29kZV8xLm5pbCA/IHggOiAoMCwgY29kZV8xLl8pIGAke3Bhcih4KX0gJHtvcH0gJHtwYXIoeSl9YCk7XG59XG5mdW5jdGlvbiBwYXIoeCkge1xuICAgIHJldHVybiB4IGluc3RhbmNlb2YgY29kZV8xLk5hbWUgPyB4IDogKDAsIGNvZGVfMS5fKSBgKCR7eH0pYDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jaGVja1N0cmljdE1vZGUgPSBleHBvcnRzLmdldEVycm9yUGF0aCA9IGV4cG9ydHMuVHlwZSA9IGV4cG9ydHMudXNlRnVuYyA9IGV4cG9ydHMuc2V0RXZhbHVhdGVkID0gZXhwb3J0cy5ldmFsdWF0ZWRQcm9wc1RvTmFtZSA9IGV4cG9ydHMubWVyZ2VFdmFsdWF0ZWQgPSBleHBvcnRzLmVhY2hJdGVtID0gZXhwb3J0cy51bmVzY2FwZUpzb25Qb2ludGVyID0gZXhwb3J0cy5lc2NhcGVKc29uUG9pbnRlciA9IGV4cG9ydHMuZXNjYXBlRnJhZ21lbnQgPSBleHBvcnRzLnVuZXNjYXBlRnJhZ21lbnQgPSBleHBvcnRzLnNjaGVtYVJlZk9yVmFsID0gZXhwb3J0cy5zY2hlbWFIYXNSdWxlc0J1dFJlZiA9IGV4cG9ydHMuc2NoZW1hSGFzUnVsZXMgPSBleHBvcnRzLmNoZWNrVW5rbm93blJ1bGVzID0gZXhwb3J0cy5hbHdheXNWYWxpZFNjaGVtYSA9IGV4cG9ydHMudG9IYXNoID0gdm9pZCAwO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4vY29kZWdlblwiKTtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuL2NvZGVnZW4vY29kZVwiKTtcbi8vIFRPRE8gcmVmYWN0b3IgdG8gdXNlIFNldFxuZnVuY3Rpb24gdG9IYXNoKGFycikge1xuICAgIGNvbnN0IGhhc2ggPSB7fTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgYXJyKVxuICAgICAgICBoYXNoW2l0ZW1dID0gdHJ1ZTtcbiAgICByZXR1cm4gaGFzaDtcbn1cbmV4cG9ydHMudG9IYXNoID0gdG9IYXNoO1xuZnVuY3Rpb24gYWx3YXlzVmFsaWRTY2hlbWEoaXQsIHNjaGVtYSkge1xuICAgIGlmICh0eXBlb2Ygc2NoZW1hID09IFwiYm9vbGVhblwiKVxuICAgICAgICByZXR1cm4gc2NoZW1hO1xuICAgIGlmIChPYmplY3Qua2V5cyhzY2hlbWEpLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgY2hlY2tVbmtub3duUnVsZXMoaXQsIHNjaGVtYSk7XG4gICAgcmV0dXJuICFzY2hlbWFIYXNSdWxlcyhzY2hlbWEsIGl0LnNlbGYuUlVMRVMuYWxsKTtcbn1cbmV4cG9ydHMuYWx3YXlzVmFsaWRTY2hlbWEgPSBhbHdheXNWYWxpZFNjaGVtYTtcbmZ1bmN0aW9uIGNoZWNrVW5rbm93blJ1bGVzKGl0LCBzY2hlbWEgPSBpdC5zY2hlbWEpIHtcbiAgICBjb25zdCB7IG9wdHMsIHNlbGYgfSA9IGl0O1xuICAgIGlmICghb3B0cy5zdHJpY3RTY2hlbWEpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAodHlwZW9mIHNjaGVtYSA9PT0gXCJib29sZWFuXCIpXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCBydWxlcyA9IHNlbGYuUlVMRVMua2V5d29yZHM7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKSB7XG4gICAgICAgIGlmICghcnVsZXNba2V5XSlcbiAgICAgICAgICAgIGNoZWNrU3RyaWN0TW9kZShpdCwgYHVua25vd24ga2V5d29yZDogXCIke2tleX1cImApO1xuICAgIH1cbn1cbmV4cG9ydHMuY2hlY2tVbmtub3duUnVsZXMgPSBjaGVja1Vua25vd25SdWxlcztcbmZ1bmN0aW9uIHNjaGVtYUhhc1J1bGVzKHNjaGVtYSwgcnVsZXMpIHtcbiAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcImJvb2xlYW5cIilcbiAgICAgICAgcmV0dXJuICFzY2hlbWE7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKVxuICAgICAgICBpZiAocnVsZXNba2V5XSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydHMuc2NoZW1hSGFzUnVsZXMgPSBzY2hlbWFIYXNSdWxlcztcbmZ1bmN0aW9uIHNjaGVtYUhhc1J1bGVzQnV0UmVmKHNjaGVtYSwgUlVMRVMpIHtcbiAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcImJvb2xlYW5cIilcbiAgICAgICAgcmV0dXJuICFzY2hlbWE7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKVxuICAgICAgICBpZiAoa2V5ICE9PSBcIiRyZWZcIiAmJiBSVUxFUy5hbGxba2V5XSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydHMuc2NoZW1hSGFzUnVsZXNCdXRSZWYgPSBzY2hlbWFIYXNSdWxlc0J1dFJlZjtcbmZ1bmN0aW9uIHNjaGVtYVJlZk9yVmFsKHsgdG9wU2NoZW1hUmVmLCBzY2hlbWFQYXRoIH0sIHNjaGVtYSwga2V5d29yZCwgJGRhdGEpIHtcbiAgICBpZiAoISRkYXRhKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hID09IFwibnVtYmVyXCIgfHwgdHlwZW9mIHNjaGVtYSA9PSBcImJvb2xlYW5cIilcbiAgICAgICAgICAgIHJldHVybiBzY2hlbWE7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICByZXR1cm4gKDAsIGNvZGVnZW5fMS5fKSBgJHtzY2hlbWF9YDtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEuXykgYCR7dG9wU2NoZW1hUmVmfSR7c2NoZW1hUGF0aH0keygwLCBjb2RlZ2VuXzEuZ2V0UHJvcGVydHkpKGtleXdvcmQpfWA7XG59XG5leHBvcnRzLnNjaGVtYVJlZk9yVmFsID0gc2NoZW1hUmVmT3JWYWw7XG5mdW5jdGlvbiB1bmVzY2FwZUZyYWdtZW50KHN0cikge1xuICAgIHJldHVybiB1bmVzY2FwZUpzb25Qb2ludGVyKGRlY29kZVVSSUNvbXBvbmVudChzdHIpKTtcbn1cbmV4cG9ydHMudW5lc2NhcGVGcmFnbWVudCA9IHVuZXNjYXBlRnJhZ21lbnQ7XG5mdW5jdGlvbiBlc2NhcGVGcmFnbWVudChzdHIpIHtcbiAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KGVzY2FwZUpzb25Qb2ludGVyKHN0cikpO1xufVxuZXhwb3J0cy5lc2NhcGVGcmFnbWVudCA9IGVzY2FwZUZyYWdtZW50O1xuZnVuY3Rpb24gZXNjYXBlSnNvblBvaW50ZXIoc3RyKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgPT0gXCJudW1iZXJcIilcbiAgICAgICAgcmV0dXJuIGAke3N0cn1gO1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvfi9nLCBcIn4wXCIpLnJlcGxhY2UoL1xcLy9nLCBcIn4xXCIpO1xufVxuZXhwb3J0cy5lc2NhcGVKc29uUG9pbnRlciA9IGVzY2FwZUpzb25Qb2ludGVyO1xuZnVuY3Rpb24gdW5lc2NhcGVKc29uUG9pbnRlcihzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL34xL2csIFwiL1wiKS5yZXBsYWNlKC9+MC9nLCBcIn5cIik7XG59XG5leHBvcnRzLnVuZXNjYXBlSnNvblBvaW50ZXIgPSB1bmVzY2FwZUpzb25Qb2ludGVyO1xuZnVuY3Rpb24gZWFjaEl0ZW0oeHMsIGYpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh4cykpIHtcbiAgICAgICAgZm9yIChjb25zdCB4IG9mIHhzKVxuICAgICAgICAgICAgZih4KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGYoeHMpO1xuICAgIH1cbn1cbmV4cG9ydHMuZWFjaEl0ZW0gPSBlYWNoSXRlbTtcbmZ1bmN0aW9uIG1ha2VNZXJnZUV2YWx1YXRlZCh7IG1lcmdlTmFtZXMsIG1lcmdlVG9OYW1lLCBtZXJnZVZhbHVlcywgcmVzdWx0VG9OYW1lLCB9KSB7XG4gICAgcmV0dXJuIChnZW4sIGZyb20sIHRvLCB0b05hbWUpID0+IHtcbiAgICAgICAgY29uc3QgcmVzID0gdG8gPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBmcm9tXG4gICAgICAgICAgICA6IHRvIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWVcbiAgICAgICAgICAgICAgICA/IChmcm9tIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWUgPyBtZXJnZU5hbWVzKGdlbiwgZnJvbSwgdG8pIDogbWVyZ2VUb05hbWUoZ2VuLCBmcm9tLCB0byksIHRvKVxuICAgICAgICAgICAgICAgIDogZnJvbSBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lXG4gICAgICAgICAgICAgICAgICAgID8gKG1lcmdlVG9OYW1lKGdlbiwgdG8sIGZyb20pLCBmcm9tKVxuICAgICAgICAgICAgICAgICAgICA6IG1lcmdlVmFsdWVzKGZyb20sIHRvKTtcbiAgICAgICAgcmV0dXJuIHRvTmFtZSA9PT0gY29kZWdlbl8xLk5hbWUgJiYgIShyZXMgaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZSkgPyByZXN1bHRUb05hbWUoZ2VuLCByZXMpIDogcmVzO1xuICAgIH07XG59XG5leHBvcnRzLm1lcmdlRXZhbHVhdGVkID0ge1xuICAgIHByb3BzOiBtYWtlTWVyZ2VFdmFsdWF0ZWQoe1xuICAgICAgICBtZXJnZU5hbWVzOiAoZ2VuLCBmcm9tLCB0bykgPT4gZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7dG99ICE9PSB0cnVlICYmICR7ZnJvbX0gIT09IHVuZGVmaW5lZGAsICgpID0+IHtcbiAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke2Zyb219ID09PSB0cnVlYCwgKCkgPT4gZ2VuLmFzc2lnbih0bywgdHJ1ZSksICgpID0+IGdlbi5hc3NpZ24odG8sICgwLCBjb2RlZ2VuXzEuXykgYCR7dG99IHx8IHt9YCkuY29kZSgoMCwgY29kZWdlbl8xLl8pIGBPYmplY3QuYXNzaWduKCR7dG99LCAke2Zyb219KWApKTtcbiAgICAgICAgfSksXG4gICAgICAgIG1lcmdlVG9OYW1lOiAoZ2VuLCBmcm9tLCB0bykgPT4gZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7dG99ICE9PSB0cnVlYCwgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGZyb20gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBnZW4uYXNzaWduKHRvLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odG8sICgwLCBjb2RlZ2VuXzEuXykgYCR7dG99IHx8IHt9YCk7XG4gICAgICAgICAgICAgICAgc2V0RXZhbHVhdGVkKGdlbiwgdG8sIGZyb20pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICAgICAgbWVyZ2VWYWx1ZXM6IChmcm9tLCB0bykgPT4gKGZyb20gPT09IHRydWUgPyB0cnVlIDogeyAuLi5mcm9tLCAuLi50byB9KSxcbiAgICAgICAgcmVzdWx0VG9OYW1lOiBldmFsdWF0ZWRQcm9wc1RvTmFtZSxcbiAgICB9KSxcbiAgICBpdGVtczogbWFrZU1lcmdlRXZhbHVhdGVkKHtcbiAgICAgICAgbWVyZ2VOYW1lczogKGdlbiwgZnJvbSwgdG8pID0+IGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke3RvfSAhPT0gdHJ1ZSAmJiAke2Zyb219ICE9PSB1bmRlZmluZWRgLCAoKSA9PiBnZW4uYXNzaWduKHRvLCAoMCwgY29kZWdlbl8xLl8pIGAke2Zyb219ID09PSB0cnVlID8gdHJ1ZSA6ICR7dG99ID4gJHtmcm9tfSA/ICR7dG99IDogJHtmcm9tfWApKSxcbiAgICAgICAgbWVyZ2VUb05hbWU6IChnZW4sIGZyb20sIHRvKSA9PiBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHt0b30gIT09IHRydWVgLCAoKSA9PiBnZW4uYXNzaWduKHRvLCBmcm9tID09PSB0cnVlID8gdHJ1ZSA6ICgwLCBjb2RlZ2VuXzEuXykgYCR7dG99ID4gJHtmcm9tfSA/ICR7dG99IDogJHtmcm9tfWApKSxcbiAgICAgICAgbWVyZ2VWYWx1ZXM6IChmcm9tLCB0bykgPT4gKGZyb20gPT09IHRydWUgPyB0cnVlIDogTWF0aC5tYXgoZnJvbSwgdG8pKSxcbiAgICAgICAgcmVzdWx0VG9OYW1lOiAoZ2VuLCBpdGVtcykgPT4gZ2VuLnZhcihcIml0ZW1zXCIsIGl0ZW1zKSxcbiAgICB9KSxcbn07XG5mdW5jdGlvbiBldmFsdWF0ZWRQcm9wc1RvTmFtZShnZW4sIHBzKSB7XG4gICAgaWYgKHBzID09PSB0cnVlKVxuICAgICAgICByZXR1cm4gZ2VuLnZhcihcInByb3BzXCIsIHRydWUpO1xuICAgIGNvbnN0IHByb3BzID0gZ2VuLnZhcihcInByb3BzXCIsICgwLCBjb2RlZ2VuXzEuXykgYHt9YCk7XG4gICAgaWYgKHBzICE9PSB1bmRlZmluZWQpXG4gICAgICAgIHNldEV2YWx1YXRlZChnZW4sIHByb3BzLCBwcyk7XG4gICAgcmV0dXJuIHByb3BzO1xufVxuZXhwb3J0cy5ldmFsdWF0ZWRQcm9wc1RvTmFtZSA9IGV2YWx1YXRlZFByb3BzVG9OYW1lO1xuZnVuY3Rpb24gc2V0RXZhbHVhdGVkKGdlbiwgcHJvcHMsIHBzKSB7XG4gICAgT2JqZWN0LmtleXMocHMpLmZvckVhY2goKHApID0+IGdlbi5hc3NpZ24oKDAsIGNvZGVnZW5fMS5fKSBgJHtwcm9wc30keygwLCBjb2RlZ2VuXzEuZ2V0UHJvcGVydHkpKHApfWAsIHRydWUpKTtcbn1cbmV4cG9ydHMuc2V0RXZhbHVhdGVkID0gc2V0RXZhbHVhdGVkO1xuY29uc3Qgc25pcHBldHMgPSB7fTtcbmZ1bmN0aW9uIHVzZUZ1bmMoZ2VuLCBmKSB7XG4gICAgcmV0dXJuIGdlbi5zY29wZVZhbHVlKFwiZnVuY1wiLCB7XG4gICAgICAgIHJlZjogZixcbiAgICAgICAgY29kZTogc25pcHBldHNbZi5jb2RlXSB8fCAoc25pcHBldHNbZi5jb2RlXSA9IG5ldyBjb2RlXzEuX0NvZGUoZi5jb2RlKSksXG4gICAgfSk7XG59XG5leHBvcnRzLnVzZUZ1bmMgPSB1c2VGdW5jO1xudmFyIFR5cGU7XG4oZnVuY3Rpb24gKFR5cGUpIHtcbiAgICBUeXBlW1R5cGVbXCJOdW1cIl0gPSAwXSA9IFwiTnVtXCI7XG4gICAgVHlwZVtUeXBlW1wiU3RyXCJdID0gMV0gPSBcIlN0clwiO1xufSkoVHlwZSB8fCAoZXhwb3J0cy5UeXBlID0gVHlwZSA9IHt9KSk7XG5mdW5jdGlvbiBnZXRFcnJvclBhdGgoZGF0YVByb3AsIGRhdGFQcm9wVHlwZSwganNQcm9wZXJ0eVN5bnRheCkge1xuICAgIC8vIGxldCBwYXRoXG4gICAgaWYgKGRhdGFQcm9wIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWUpIHtcbiAgICAgICAgY29uc3QgaXNOdW1iZXIgPSBkYXRhUHJvcFR5cGUgPT09IFR5cGUuTnVtO1xuICAgICAgICByZXR1cm4ganNQcm9wZXJ0eVN5bnRheFxuICAgICAgICAgICAgPyBpc051bWJlclxuICAgICAgICAgICAgICAgID8gKDAsIGNvZGVnZW5fMS5fKSBgXCJbXCIgKyAke2RhdGFQcm9wfSArIFwiXVwiYFxuICAgICAgICAgICAgICAgIDogKDAsIGNvZGVnZW5fMS5fKSBgXCJbJ1wiICsgJHtkYXRhUHJvcH0gKyBcIiddXCJgXG4gICAgICAgICAgICA6IGlzTnVtYmVyXG4gICAgICAgICAgICAgICAgPyAoMCwgY29kZWdlbl8xLl8pIGBcIi9cIiArICR7ZGF0YVByb3B9YFxuICAgICAgICAgICAgICAgIDogKDAsIGNvZGVnZW5fMS5fKSBgXCIvXCIgKyAke2RhdGFQcm9wfS5yZXBsYWNlKC9+L2csIFwifjBcIikucmVwbGFjZSgvXFxcXC8vZywgXCJ+MVwiKWA7IC8vIFRPRE8gbWF5YmUgdXNlIGdsb2JhbCBlc2NhcGVQb2ludGVyXG4gICAgfVxuICAgIHJldHVybiBqc1Byb3BlcnR5U3ludGF4ID8gKDAsIGNvZGVnZW5fMS5nZXRQcm9wZXJ0eSkoZGF0YVByb3ApLnRvU3RyaW5nKCkgOiBcIi9cIiArIGVzY2FwZUpzb25Qb2ludGVyKGRhdGFQcm9wKTtcbn1cbmV4cG9ydHMuZ2V0RXJyb3JQYXRoID0gZ2V0RXJyb3JQYXRoO1xuZnVuY3Rpb24gY2hlY2tTdHJpY3RNb2RlKGl0LCBtc2csIG1vZGUgPSBpdC5vcHRzLnN0cmljdFNjaGVtYSkge1xuICAgIGlmICghbW9kZSlcbiAgICAgICAgcmV0dXJuO1xuICAgIG1zZyA9IGBzdHJpY3QgbW9kZTogJHttc2d9YDtcbiAgICBpZiAobW9kZSA9PT0gdHJ1ZSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgaXQuc2VsZi5sb2dnZXIud2Fybihtc2cpO1xufVxuZXhwb3J0cy5jaGVja1N0cmljdE1vZGUgPSBjaGVja1N0cmljdE1vZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4vY29kZWdlblwiKTtcbmNvbnN0IG5hbWVzID0ge1xuICAgIC8vIHZhbGlkYXRpb24gZnVuY3Rpb24gYXJndW1lbnRzXG4gICAgZGF0YTogbmV3IGNvZGVnZW5fMS5OYW1lKFwiZGF0YVwiKSwgLy8gZGF0YSBwYXNzZWQgdG8gdmFsaWRhdGlvbiBmdW5jdGlvblxuICAgIC8vIGFyZ3MgcGFzc2VkIGZyb20gcmVmZXJlbmNpbmcgc2NoZW1hXG4gICAgdmFsQ3h0OiBuZXcgY29kZWdlbl8xLk5hbWUoXCJ2YWxDeHRcIiksIC8vIHZhbGlkYXRpb24vZGF0YSBjb250ZXh0IC0gc2hvdWxkIG5vdCBiZSB1c2VkIGRpcmVjdGx5LCBpdCBpcyBkZXN0cnVjdHVyZWQgdG8gdGhlIG5hbWVzIGJlbG93XG4gICAgaW5zdGFuY2VQYXRoOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJpbnN0YW5jZVBhdGhcIiksXG4gICAgcGFyZW50RGF0YTogbmV3IGNvZGVnZW5fMS5OYW1lKFwicGFyZW50RGF0YVwiKSxcbiAgICBwYXJlbnREYXRhUHJvcGVydHk6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInBhcmVudERhdGFQcm9wZXJ0eVwiKSxcbiAgICByb290RGF0YTogbmV3IGNvZGVnZW5fMS5OYW1lKFwicm9vdERhdGFcIiksIC8vIHJvb3QgZGF0YSAtIHNhbWUgYXMgdGhlIGRhdGEgcGFzc2VkIHRvIHRoZSBmaXJzdC90b3AgdmFsaWRhdGlvbiBmdW5jdGlvblxuICAgIGR5bmFtaWNBbmNob3JzOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJkeW5hbWljQW5jaG9yc1wiKSwgLy8gdXNlZCB0byBzdXBwb3J0IHJlY3Vyc2l2ZVJlZiBhbmQgZHluYW1pY1JlZlxuICAgIC8vIGZ1bmN0aW9uIHNjb3BlZCB2YXJpYWJsZXNcbiAgICB2RXJyb3JzOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJ2RXJyb3JzXCIpLCAvLyBudWxsIG9yIGFycmF5IG9mIHZhbGlkYXRpb24gZXJyb3JzXG4gICAgZXJyb3JzOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJlcnJvcnNcIiksIC8vIGNvdW50ZXIgb2YgdmFsaWRhdGlvbiBlcnJvcnNcbiAgICB0aGlzOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJ0aGlzXCIpLFxuICAgIC8vIFwiZ2xvYmFsc1wiXG4gICAgc2VsZjogbmV3IGNvZGVnZW5fMS5OYW1lKFwic2VsZlwiKSxcbiAgICBzY29wZTogbmV3IGNvZGVnZW5fMS5OYW1lKFwic2NvcGVcIiksXG4gICAgLy8gSlREIHNlcmlhbGl6ZS9wYXJzZSBuYW1lIGZvciBKU09OIHN0cmluZyBhbmQgcG9zaXRpb25cbiAgICBqc29uOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJqc29uXCIpLFxuICAgIGpzb25Qb3M6IG5ldyBjb2RlZ2VuXzEuTmFtZShcImpzb25Qb3NcIiksXG4gICAganNvbkxlbjogbmV3IGNvZGVnZW5fMS5OYW1lKFwianNvbkxlblwiKSxcbiAgICBqc29uUGFydDogbmV3IGNvZGVnZW5fMS5OYW1lKFwianNvblBhcnRcIiksXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gbmFtZXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1uYW1lcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZXh0ZW5kRXJyb3JzID0gZXhwb3J0cy5yZXNldEVycm9yc0NvdW50ID0gZXhwb3J0cy5yZXBvcnRFeHRyYUVycm9yID0gZXhwb3J0cy5yZXBvcnRFcnJvciA9IGV4cG9ydHMua2V5d29yZCREYXRhRXJyb3IgPSBleHBvcnRzLmtleXdvcmRFcnJvciA9IHZvaWQgMDtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuY29uc3QgbmFtZXNfMSA9IHJlcXVpcmUoXCIuL25hbWVzXCIpO1xuZXhwb3J0cy5rZXl3b3JkRXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsga2V5d29yZCB9KSA9PiAoMCwgY29kZWdlbl8xLnN0cikgYG11c3QgcGFzcyBcIiR7a2V5d29yZH1cIiBrZXl3b3JkIHZhbGlkYXRpb25gLFxufTtcbmV4cG9ydHMua2V5d29yZCREYXRhRXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsga2V5d29yZCwgc2NoZW1hVHlwZSB9KSA9PiBzY2hlbWFUeXBlXG4gICAgICAgID8gKDAsIGNvZGVnZW5fMS5zdHIpIGBcIiR7a2V5d29yZH1cIiBrZXl3b3JkIG11c3QgYmUgJHtzY2hlbWFUeXBlfSAoJGRhdGEpYFxuICAgICAgICA6ICgwLCBjb2RlZ2VuXzEuc3RyKSBgXCIke2tleXdvcmR9XCIga2V5d29yZCBpcyBpbnZhbGlkICgkZGF0YSlgLFxufTtcbmZ1bmN0aW9uIHJlcG9ydEVycm9yKGN4dCwgZXJyb3IgPSBleHBvcnRzLmtleXdvcmRFcnJvciwgZXJyb3JQYXRocywgb3ZlcnJpZGVBbGxFcnJvcnMpIHtcbiAgICBjb25zdCB7IGl0IH0gPSBjeHQ7XG4gICAgY29uc3QgeyBnZW4sIGNvbXBvc2l0ZVJ1bGUsIGFsbEVycm9ycyB9ID0gaXQ7XG4gICAgY29uc3QgZXJyT2JqID0gZXJyb3JPYmplY3RDb2RlKGN4dCwgZXJyb3IsIGVycm9yUGF0aHMpO1xuICAgIGlmIChvdmVycmlkZUFsbEVycm9ycyAhPT0gbnVsbCAmJiBvdmVycmlkZUFsbEVycm9ycyAhPT0gdm9pZCAwID8gb3ZlcnJpZGVBbGxFcnJvcnMgOiAoY29tcG9zaXRlUnVsZSB8fCBhbGxFcnJvcnMpKSB7XG4gICAgICAgIGFkZEVycm9yKGdlbiwgZXJyT2JqKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybkVycm9ycyhpdCwgKDAsIGNvZGVnZW5fMS5fKSBgWyR7ZXJyT2JqfV1gKTtcbiAgICB9XG59XG5leHBvcnRzLnJlcG9ydEVycm9yID0gcmVwb3J0RXJyb3I7XG5mdW5jdGlvbiByZXBvcnRFeHRyYUVycm9yKGN4dCwgZXJyb3IgPSBleHBvcnRzLmtleXdvcmRFcnJvciwgZXJyb3JQYXRocykge1xuICAgIGNvbnN0IHsgaXQgfSA9IGN4dDtcbiAgICBjb25zdCB7IGdlbiwgY29tcG9zaXRlUnVsZSwgYWxsRXJyb3JzIH0gPSBpdDtcbiAgICBjb25zdCBlcnJPYmogPSBlcnJvck9iamVjdENvZGUoY3h0LCBlcnJvciwgZXJyb3JQYXRocyk7XG4gICAgYWRkRXJyb3IoZ2VuLCBlcnJPYmopO1xuICAgIGlmICghKGNvbXBvc2l0ZVJ1bGUgfHwgYWxsRXJyb3JzKSkge1xuICAgICAgICByZXR1cm5FcnJvcnMoaXQsIG5hbWVzXzEuZGVmYXVsdC52RXJyb3JzKTtcbiAgICB9XG59XG5leHBvcnRzLnJlcG9ydEV4dHJhRXJyb3IgPSByZXBvcnRFeHRyYUVycm9yO1xuZnVuY3Rpb24gcmVzZXRFcnJvcnNDb3VudChnZW4sIGVycnNDb3VudCkge1xuICAgIGdlbi5hc3NpZ24obmFtZXNfMS5kZWZhdWx0LmVycm9ycywgZXJyc0NvdW50KTtcbiAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc30gIT09IG51bGxgLCAoKSA9PiBnZW4uaWYoZXJyc0NvdW50LCAoKSA9PiBnZW4uYXNzaWduKCgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LnZFcnJvcnN9Lmxlbmd0aGAsIGVycnNDb3VudCksICgpID0+IGdlbi5hc3NpZ24obmFtZXNfMS5kZWZhdWx0LnZFcnJvcnMsIG51bGwpKSk7XG59XG5leHBvcnRzLnJlc2V0RXJyb3JzQ291bnQgPSByZXNldEVycm9yc0NvdW50O1xuZnVuY3Rpb24gZXh0ZW5kRXJyb3JzKHsgZ2VuLCBrZXl3b3JkLCBzY2hlbWFWYWx1ZSwgZGF0YSwgZXJyc0NvdW50LCBpdCwgfSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChlcnJzQ291bnQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpO1xuICAgIGNvbnN0IGVyciA9IGdlbi5uYW1lKFwiZXJyXCIpO1xuICAgIGdlbi5mb3JSYW5nZShcImlcIiwgZXJyc0NvdW50LCBuYW1lc18xLmRlZmF1bHQuZXJyb3JzLCAoaSkgPT4ge1xuICAgICAgICBnZW4uY29uc3QoZXJyLCAoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC52RXJyb3JzfVske2l9XWApO1xuICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtlcnJ9Lmluc3RhbmNlUGF0aCA9PT0gdW5kZWZpbmVkYCwgKCkgPT4gZ2VuLmFzc2lnbigoMCwgY29kZWdlbl8xLl8pIGAke2Vycn0uaW5zdGFuY2VQYXRoYCwgKDAsIGNvZGVnZW5fMS5zdHJDb25jYXQpKG5hbWVzXzEuZGVmYXVsdC5pbnN0YW5jZVBhdGgsIGl0LmVycm9yUGF0aCkpKTtcbiAgICAgICAgZ2VuLmFzc2lnbigoMCwgY29kZWdlbl8xLl8pIGAke2Vycn0uc2NoZW1hUGF0aGAsICgwLCBjb2RlZ2VuXzEuc3RyKSBgJHtpdC5lcnJTY2hlbWFQYXRofS8ke2tleXdvcmR9YCk7XG4gICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgICAgIGdlbi5hc3NpZ24oKDAsIGNvZGVnZW5fMS5fKSBgJHtlcnJ9LnNjaGVtYWAsIHNjaGVtYVZhbHVlKTtcbiAgICAgICAgICAgIGdlbi5hc3NpZ24oKDAsIGNvZGVnZW5fMS5fKSBgJHtlcnJ9LmRhdGFgLCBkYXRhKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0cy5leHRlbmRFcnJvcnMgPSBleHRlbmRFcnJvcnM7XG5mdW5jdGlvbiBhZGRFcnJvcihnZW4sIGVyck9iaikge1xuICAgIGNvbnN0IGVyciA9IGdlbi5jb25zdChcImVyclwiLCBlcnJPYmopO1xuICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC52RXJyb3JzfSA9PT0gbnVsbGAsICgpID0+IGdlbi5hc3NpZ24obmFtZXNfMS5kZWZhdWx0LnZFcnJvcnMsICgwLCBjb2RlZ2VuXzEuXykgYFske2Vycn1dYCksICgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LnZFcnJvcnN9LnB1c2goJHtlcnJ9KWApO1xuICAgIGdlbi5jb2RlKCgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LmVycm9yc30rK2ApO1xufVxuZnVuY3Rpb24gcmV0dXJuRXJyb3JzKGl0LCBlcnJzKSB7XG4gICAgY29uc3QgeyBnZW4sIHZhbGlkYXRlTmFtZSwgc2NoZW1hRW52IH0gPSBpdDtcbiAgICBpZiAoc2NoZW1hRW52LiRhc3luYykge1xuICAgICAgICBnZW4udGhyb3coKDAsIGNvZGVnZW5fMS5fKSBgbmV3ICR7aXQuVmFsaWRhdGlvbkVycm9yfSgke2VycnN9KWApO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZ2VuLmFzc2lnbigoMCwgY29kZWdlbl8xLl8pIGAke3ZhbGlkYXRlTmFtZX0uZXJyb3JzYCwgZXJycyk7XG4gICAgICAgIGdlbi5yZXR1cm4oZmFsc2UpO1xuICAgIH1cbn1cbmNvbnN0IEUgPSB7XG4gICAga2V5d29yZDogbmV3IGNvZGVnZW5fMS5OYW1lKFwia2V5d29yZFwiKSxcbiAgICBzY2hlbWFQYXRoOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJzY2hlbWFQYXRoXCIpLCAvLyBhbHNvIHVzZWQgaW4gSlREIGVycm9yc1xuICAgIHBhcmFtczogbmV3IGNvZGVnZW5fMS5OYW1lKFwicGFyYW1zXCIpLFxuICAgIHByb3BlcnR5TmFtZTogbmV3IGNvZGVnZW5fMS5OYW1lKFwicHJvcGVydHlOYW1lXCIpLFxuICAgIG1lc3NhZ2U6IG5ldyBjb2RlZ2VuXzEuTmFtZShcIm1lc3NhZ2VcIiksXG4gICAgc2NoZW1hOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJzY2hlbWFcIiksXG4gICAgcGFyZW50U2NoZW1hOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJwYXJlbnRTY2hlbWFcIiksXG59O1xuZnVuY3Rpb24gZXJyb3JPYmplY3RDb2RlKGN4dCwgZXJyb3IsIGVycm9yUGF0aHMpIHtcbiAgICBjb25zdCB7IGNyZWF0ZUVycm9ycyB9ID0gY3h0Lml0O1xuICAgIGlmIChjcmVhdGVFcnJvcnMgPT09IGZhbHNlKVxuICAgICAgICByZXR1cm4gKDAsIGNvZGVnZW5fMS5fKSBge31gO1xuICAgIHJldHVybiBlcnJvck9iamVjdChjeHQsIGVycm9yLCBlcnJvclBhdGhzKTtcbn1cbmZ1bmN0aW9uIGVycm9yT2JqZWN0KGN4dCwgZXJyb3IsIGVycm9yUGF0aHMgPSB7fSkge1xuICAgIGNvbnN0IHsgZ2VuLCBpdCB9ID0gY3h0O1xuICAgIGNvbnN0IGtleVZhbHVlcyA9IFtcbiAgICAgICAgZXJyb3JJbnN0YW5jZVBhdGgoaXQsIGVycm9yUGF0aHMpLFxuICAgICAgICBlcnJvclNjaGVtYVBhdGgoY3h0LCBlcnJvclBhdGhzKSxcbiAgICBdO1xuICAgIGV4dHJhRXJyb3JQcm9wcyhjeHQsIGVycm9yLCBrZXlWYWx1ZXMpO1xuICAgIHJldHVybiBnZW4ub2JqZWN0KC4uLmtleVZhbHVlcyk7XG59XG5mdW5jdGlvbiBlcnJvckluc3RhbmNlUGF0aCh7IGVycm9yUGF0aCB9LCB7IGluc3RhbmNlUGF0aCB9KSB7XG4gICAgY29uc3QgaW5zdFBhdGggPSBpbnN0YW5jZVBhdGhcbiAgICAgICAgPyAoMCwgY29kZWdlbl8xLnN0cikgYCR7ZXJyb3JQYXRofSR7KDAsIHV0aWxfMS5nZXRFcnJvclBhdGgpKGluc3RhbmNlUGF0aCwgdXRpbF8xLlR5cGUuU3RyKX1gXG4gICAgICAgIDogZXJyb3JQYXRoO1xuICAgIHJldHVybiBbbmFtZXNfMS5kZWZhdWx0Lmluc3RhbmNlUGF0aCwgKDAsIGNvZGVnZW5fMS5zdHJDb25jYXQpKG5hbWVzXzEuZGVmYXVsdC5pbnN0YW5jZVBhdGgsIGluc3RQYXRoKV07XG59XG5mdW5jdGlvbiBlcnJvclNjaGVtYVBhdGgoeyBrZXl3b3JkLCBpdDogeyBlcnJTY2hlbWFQYXRoIH0gfSwgeyBzY2hlbWFQYXRoLCBwYXJlbnRTY2hlbWEgfSkge1xuICAgIGxldCBzY2hQYXRoID0gcGFyZW50U2NoZW1hID8gZXJyU2NoZW1hUGF0aCA6ICgwLCBjb2RlZ2VuXzEuc3RyKSBgJHtlcnJTY2hlbWFQYXRofS8ke2tleXdvcmR9YDtcbiAgICBpZiAoc2NoZW1hUGF0aCkge1xuICAgICAgICBzY2hQYXRoID0gKDAsIGNvZGVnZW5fMS5zdHIpIGAke3NjaFBhdGh9JHsoMCwgdXRpbF8xLmdldEVycm9yUGF0aCkoc2NoZW1hUGF0aCwgdXRpbF8xLlR5cGUuU3RyKX1gO1xuICAgIH1cbiAgICByZXR1cm4gW0Uuc2NoZW1hUGF0aCwgc2NoUGF0aF07XG59XG5mdW5jdGlvbiBleHRyYUVycm9yUHJvcHMoY3h0LCB7IHBhcmFtcywgbWVzc2FnZSB9LCBrZXlWYWx1ZXMpIHtcbiAgICBjb25zdCB7IGtleXdvcmQsIGRhdGEsIHNjaGVtYVZhbHVlLCBpdCB9ID0gY3h0O1xuICAgIGNvbnN0IHsgb3B0cywgcHJvcGVydHlOYW1lLCB0b3BTY2hlbWFSZWYsIHNjaGVtYVBhdGggfSA9IGl0O1xuICAgIGtleVZhbHVlcy5wdXNoKFtFLmtleXdvcmQsIGtleXdvcmRdLCBbRS5wYXJhbXMsIHR5cGVvZiBwYXJhbXMgPT0gXCJmdW5jdGlvblwiID8gcGFyYW1zKGN4dCkgOiBwYXJhbXMgfHwgKDAsIGNvZGVnZW5fMS5fKSBge31gXSk7XG4gICAgaWYgKG9wdHMubWVzc2FnZXMpIHtcbiAgICAgICAga2V5VmFsdWVzLnB1c2goW0UubWVzc2FnZSwgdHlwZW9mIG1lc3NhZ2UgPT0gXCJmdW5jdGlvblwiID8gbWVzc2FnZShjeHQpIDogbWVzc2FnZV0pO1xuICAgIH1cbiAgICBpZiAob3B0cy52ZXJib3NlKSB7XG4gICAgICAgIGtleVZhbHVlcy5wdXNoKFtFLnNjaGVtYSwgc2NoZW1hVmFsdWVdLCBbRS5wYXJlbnRTY2hlbWEsICgwLCBjb2RlZ2VuXzEuXykgYCR7dG9wU2NoZW1hUmVmfSR7c2NoZW1hUGF0aH1gXSwgW25hbWVzXzEuZGVmYXVsdC5kYXRhLCBkYXRhXSk7XG4gICAgfVxuICAgIGlmIChwcm9wZXJ0eU5hbWUpXG4gICAgICAgIGtleVZhbHVlcy5wdXNoKFtFLnByb3BlcnR5TmFtZSwgcHJvcGVydHlOYW1lXSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcnJvcnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmJvb2xPckVtcHR5U2NoZW1hID0gZXhwb3J0cy50b3BCb29sT3JFbXB0eVNjaGVtYSA9IHZvaWQgMDtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4uL2Vycm9yc1wiKTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi9jb2RlZ2VuXCIpO1xuY29uc3QgbmFtZXNfMSA9IHJlcXVpcmUoXCIuLi9uYW1lc1wiKTtcbmNvbnN0IGJvb2xFcnJvciA9IHtcbiAgICBtZXNzYWdlOiBcImJvb2xlYW4gc2NoZW1hIGlzIGZhbHNlXCIsXG59O1xuZnVuY3Rpb24gdG9wQm9vbE9yRW1wdHlTY2hlbWEoaXQpIHtcbiAgICBjb25zdCB7IGdlbiwgc2NoZW1hLCB2YWxpZGF0ZU5hbWUgfSA9IGl0O1xuICAgIGlmIChzY2hlbWEgPT09IGZhbHNlKSB7XG4gICAgICAgIGZhbHNlU2NoZW1hRXJyb3IoaXQsIGZhbHNlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHNjaGVtYSA9PSBcIm9iamVjdFwiICYmIHNjaGVtYS4kYXN5bmMgPT09IHRydWUpIHtcbiAgICAgICAgZ2VuLnJldHVybihuYW1lc18xLmRlZmF1bHQuZGF0YSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBnZW4uYXNzaWduKCgwLCBjb2RlZ2VuXzEuXykgYCR7dmFsaWRhdGVOYW1lfS5lcnJvcnNgLCBudWxsKTtcbiAgICAgICAgZ2VuLnJldHVybih0cnVlKTtcbiAgICB9XG59XG5leHBvcnRzLnRvcEJvb2xPckVtcHR5U2NoZW1hID0gdG9wQm9vbE9yRW1wdHlTY2hlbWE7XG5mdW5jdGlvbiBib29sT3JFbXB0eVNjaGVtYShpdCwgdmFsaWQpIHtcbiAgICBjb25zdCB7IGdlbiwgc2NoZW1hIH0gPSBpdDtcbiAgICBpZiAoc2NoZW1hID09PSBmYWxzZSkge1xuICAgICAgICBnZW4udmFyKHZhbGlkLCBmYWxzZSk7IC8vIFRPRE8gdmFyXG4gICAgICAgIGZhbHNlU2NoZW1hRXJyb3IoaXQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZ2VuLnZhcih2YWxpZCwgdHJ1ZSk7IC8vIFRPRE8gdmFyXG4gICAgfVxufVxuZXhwb3J0cy5ib29sT3JFbXB0eVNjaGVtYSA9IGJvb2xPckVtcHR5U2NoZW1hO1xuZnVuY3Rpb24gZmFsc2VTY2hlbWFFcnJvcihpdCwgb3ZlcnJpZGVBbGxFcnJvcnMpIHtcbiAgICBjb25zdCB7IGdlbiwgZGF0YSB9ID0gaXQ7XG4gICAgLy8gVE9ETyBtYXliZSBzb21lIG90aGVyIGludGVyZmFjZSBzaG91bGQgYmUgdXNlZCBmb3Igbm9uLWtleXdvcmQgdmFsaWRhdGlvbiBlcnJvcnMuLi5cbiAgICBjb25zdCBjeHQgPSB7XG4gICAgICAgIGdlbixcbiAgICAgICAga2V5d29yZDogXCJmYWxzZSBzY2hlbWFcIixcbiAgICAgICAgZGF0YSxcbiAgICAgICAgc2NoZW1hOiBmYWxzZSxcbiAgICAgICAgc2NoZW1hQ29kZTogZmFsc2UsXG4gICAgICAgIHNjaGVtYVZhbHVlOiBmYWxzZSxcbiAgICAgICAgcGFyYW1zOiB7fSxcbiAgICAgICAgaXQsXG4gICAgfTtcbiAgICAoMCwgZXJyb3JzXzEucmVwb3J0RXJyb3IpKGN4dCwgYm9vbEVycm9yLCB1bmRlZmluZWQsIG92ZXJyaWRlQWxsRXJyb3JzKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJvb2xTY2hlbWEuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldFJ1bGVzID0gZXhwb3J0cy5pc0pTT05UeXBlID0gdm9pZCAwO1xuY29uc3QgX2pzb25UeXBlcyA9IFtcInN0cmluZ1wiLCBcIm51bWJlclwiLCBcImludGVnZXJcIiwgXCJib29sZWFuXCIsIFwibnVsbFwiLCBcIm9iamVjdFwiLCBcImFycmF5XCJdO1xuY29uc3QganNvblR5cGVzID0gbmV3IFNldChfanNvblR5cGVzKTtcbmZ1bmN0aW9uIGlzSlNPTlR5cGUoeCkge1xuICAgIHJldHVybiB0eXBlb2YgeCA9PSBcInN0cmluZ1wiICYmIGpzb25UeXBlcy5oYXMoeCk7XG59XG5leHBvcnRzLmlzSlNPTlR5cGUgPSBpc0pTT05UeXBlO1xuZnVuY3Rpb24gZ2V0UnVsZXMoKSB7XG4gICAgY29uc3QgZ3JvdXBzID0ge1xuICAgICAgICBudW1iZXI6IHsgdHlwZTogXCJudW1iZXJcIiwgcnVsZXM6IFtdIH0sXG4gICAgICAgIHN0cmluZzogeyB0eXBlOiBcInN0cmluZ1wiLCBydWxlczogW10gfSxcbiAgICAgICAgYXJyYXk6IHsgdHlwZTogXCJhcnJheVwiLCBydWxlczogW10gfSxcbiAgICAgICAgb2JqZWN0OiB7IHR5cGU6IFwib2JqZWN0XCIsIHJ1bGVzOiBbXSB9LFxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZXM6IHsgLi4uZ3JvdXBzLCBpbnRlZ2VyOiB0cnVlLCBib29sZWFuOiB0cnVlLCBudWxsOiB0cnVlIH0sXG4gICAgICAgIHJ1bGVzOiBbeyBydWxlczogW10gfSwgZ3JvdXBzLm51bWJlciwgZ3JvdXBzLnN0cmluZywgZ3JvdXBzLmFycmF5LCBncm91cHMub2JqZWN0XSxcbiAgICAgICAgcG9zdDogeyBydWxlczogW10gfSxcbiAgICAgICAgYWxsOiB7fSxcbiAgICAgICAga2V5d29yZHM6IHt9LFxuICAgIH07XG59XG5leHBvcnRzLmdldFJ1bGVzID0gZ2V0UnVsZXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ydWxlcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2hvdWxkVXNlUnVsZSA9IGV4cG9ydHMuc2hvdWxkVXNlR3JvdXAgPSBleHBvcnRzLnNjaGVtYUhhc1J1bGVzRm9yVHlwZSA9IHZvaWQgMDtcbmZ1bmN0aW9uIHNjaGVtYUhhc1J1bGVzRm9yVHlwZSh7IHNjaGVtYSwgc2VsZiB9LCB0eXBlKSB7XG4gICAgY29uc3QgZ3JvdXAgPSBzZWxmLlJVTEVTLnR5cGVzW3R5cGVdO1xuICAgIHJldHVybiBncm91cCAmJiBncm91cCAhPT0gdHJ1ZSAmJiBzaG91bGRVc2VHcm91cChzY2hlbWEsIGdyb3VwKTtcbn1cbmV4cG9ydHMuc2NoZW1hSGFzUnVsZXNGb3JUeXBlID0gc2NoZW1hSGFzUnVsZXNGb3JUeXBlO1xuZnVuY3Rpb24gc2hvdWxkVXNlR3JvdXAoc2NoZW1hLCBncm91cCkge1xuICAgIHJldHVybiBncm91cC5ydWxlcy5zb21lKChydWxlKSA9PiBzaG91bGRVc2VSdWxlKHNjaGVtYSwgcnVsZSkpO1xufVxuZXhwb3J0cy5zaG91bGRVc2VHcm91cCA9IHNob3VsZFVzZUdyb3VwO1xuZnVuY3Rpb24gc2hvdWxkVXNlUnVsZShzY2hlbWEsIHJ1bGUpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIChzY2hlbWFbcnVsZS5rZXl3b3JkXSAhPT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICgoX2EgPSBydWxlLmRlZmluaXRpb24uaW1wbGVtZW50cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNvbWUoKGt3ZCkgPT4gc2NoZW1hW2t3ZF0gIT09IHVuZGVmaW5lZCkpKTtcbn1cbmV4cG9ydHMuc2hvdWxkVXNlUnVsZSA9IHNob3VsZFVzZVJ1bGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcHBsaWNhYmlsaXR5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yZXBvcnRUeXBlRXJyb3IgPSBleHBvcnRzLmNoZWNrRGF0YVR5cGVzID0gZXhwb3J0cy5jaGVja0RhdGFUeXBlID0gZXhwb3J0cy5jb2VyY2VBbmRDaGVja0RhdGFUeXBlID0gZXhwb3J0cy5nZXRKU09OVHlwZXMgPSBleHBvcnRzLmdldFNjaGVtYVR5cGVzID0gZXhwb3J0cy5EYXRhVHlwZSA9IHZvaWQgMDtcbmNvbnN0IHJ1bGVzXzEgPSByZXF1aXJlKFwiLi4vcnVsZXNcIik7XG5jb25zdCBhcHBsaWNhYmlsaXR5XzEgPSByZXF1aXJlKFwiLi9hcHBsaWNhYmlsaXR5XCIpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzXCIpO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbnZhciBEYXRhVHlwZTtcbihmdW5jdGlvbiAoRGF0YVR5cGUpIHtcbiAgICBEYXRhVHlwZVtEYXRhVHlwZVtcIkNvcnJlY3RcIl0gPSAwXSA9IFwiQ29ycmVjdFwiO1xuICAgIERhdGFUeXBlW0RhdGFUeXBlW1wiV3JvbmdcIl0gPSAxXSA9IFwiV3JvbmdcIjtcbn0pKERhdGFUeXBlIHx8IChleHBvcnRzLkRhdGFUeXBlID0gRGF0YVR5cGUgPSB7fSkpO1xuZnVuY3Rpb24gZ2V0U2NoZW1hVHlwZXMoc2NoZW1hKSB7XG4gICAgY29uc3QgdHlwZXMgPSBnZXRKU09OVHlwZXMoc2NoZW1hLnR5cGUpO1xuICAgIGNvbnN0IGhhc051bGwgPSB0eXBlcy5pbmNsdWRlcyhcIm51bGxcIik7XG4gICAgaWYgKGhhc051bGwpIHtcbiAgICAgICAgaWYgKHNjaGVtYS5udWxsYWJsZSA9PT0gZmFsc2UpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0eXBlOiBudWxsIGNvbnRyYWRpY3RzIG51bGxhYmxlOiBmYWxzZVwiKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmICghdHlwZXMubGVuZ3RoICYmIHNjaGVtYS5udWxsYWJsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wibnVsbGFibGVcIiBjYW5ub3QgYmUgdXNlZCB3aXRob3V0IFwidHlwZVwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjaGVtYS5udWxsYWJsZSA9PT0gdHJ1ZSlcbiAgICAgICAgICAgIHR5cGVzLnB1c2goXCJudWxsXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZXM7XG59XG5leHBvcnRzLmdldFNjaGVtYVR5cGVzID0gZ2V0U2NoZW1hVHlwZXM7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlZHVuZGFudC10eXBlLWNvbnN0aXR1ZW50c1xuZnVuY3Rpb24gZ2V0SlNPTlR5cGVzKHRzKSB7XG4gICAgY29uc3QgdHlwZXMgPSBBcnJheS5pc0FycmF5KHRzKSA/IHRzIDogdHMgPyBbdHNdIDogW107XG4gICAgaWYgKHR5cGVzLmV2ZXJ5KHJ1bGVzXzEuaXNKU09OVHlwZSkpXG4gICAgICAgIHJldHVybiB0eXBlcztcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0eXBlIG11c3QgYmUgSlNPTlR5cGUgb3IgSlNPTlR5cGVbXTogXCIgKyB0eXBlcy5qb2luKFwiLFwiKSk7XG59XG5leHBvcnRzLmdldEpTT05UeXBlcyA9IGdldEpTT05UeXBlcztcbmZ1bmN0aW9uIGNvZXJjZUFuZENoZWNrRGF0YVR5cGUoaXQsIHR5cGVzKSB7XG4gICAgY29uc3QgeyBnZW4sIGRhdGEsIG9wdHMgfSA9IGl0O1xuICAgIGNvbnN0IGNvZXJjZVRvID0gY29lcmNlVG9UeXBlcyh0eXBlcywgb3B0cy5jb2VyY2VUeXBlcyk7XG4gICAgY29uc3QgY2hlY2tUeXBlcyA9IHR5cGVzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgIShjb2VyY2VUby5sZW5ndGggPT09IDAgJiYgdHlwZXMubGVuZ3RoID09PSAxICYmICgwLCBhcHBsaWNhYmlsaXR5XzEuc2NoZW1hSGFzUnVsZXNGb3JUeXBlKShpdCwgdHlwZXNbMF0pKTtcbiAgICBpZiAoY2hlY2tUeXBlcykge1xuICAgICAgICBjb25zdCB3cm9uZ1R5cGUgPSBjaGVja0RhdGFUeXBlcyh0eXBlcywgZGF0YSwgb3B0cy5zdHJpY3ROdW1iZXJzLCBEYXRhVHlwZS5Xcm9uZyk7XG4gICAgICAgIGdlbi5pZih3cm9uZ1R5cGUsICgpID0+IHtcbiAgICAgICAgICAgIGlmIChjb2VyY2VUby5sZW5ndGgpXG4gICAgICAgICAgICAgICAgY29lcmNlRGF0YShpdCwgdHlwZXMsIGNvZXJjZVRvKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXBvcnRUeXBlRXJyb3IoaXQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGNoZWNrVHlwZXM7XG59XG5leHBvcnRzLmNvZXJjZUFuZENoZWNrRGF0YVR5cGUgPSBjb2VyY2VBbmRDaGVja0RhdGFUeXBlO1xuY29uc3QgQ09FUkNJQkxFID0gbmV3IFNldChbXCJzdHJpbmdcIiwgXCJudW1iZXJcIiwgXCJpbnRlZ2VyXCIsIFwiYm9vbGVhblwiLCBcIm51bGxcIl0pO1xuZnVuY3Rpb24gY29lcmNlVG9UeXBlcyh0eXBlcywgY29lcmNlVHlwZXMpIHtcbiAgICByZXR1cm4gY29lcmNlVHlwZXNcbiAgICAgICAgPyB0eXBlcy5maWx0ZXIoKHQpID0+IENPRVJDSUJMRS5oYXModCkgfHwgKGNvZXJjZVR5cGVzID09PSBcImFycmF5XCIgJiYgdCA9PT0gXCJhcnJheVwiKSlcbiAgICAgICAgOiBbXTtcbn1cbmZ1bmN0aW9uIGNvZXJjZURhdGEoaXQsIHR5cGVzLCBjb2VyY2VUbykge1xuICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCBvcHRzIH0gPSBpdDtcbiAgICBjb25zdCBkYXRhVHlwZSA9IGdlbi5sZXQoXCJkYXRhVHlwZVwiLCAoMCwgY29kZWdlbl8xLl8pIGB0eXBlb2YgJHtkYXRhfWApO1xuICAgIGNvbnN0IGNvZXJjZWQgPSBnZW4ubGV0KFwiY29lcmNlZFwiLCAoMCwgY29kZWdlbl8xLl8pIGB1bmRlZmluZWRgKTtcbiAgICBpZiAob3B0cy5jb2VyY2VUeXBlcyA9PT0gXCJhcnJheVwiKSB7XG4gICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke2RhdGFUeXBlfSA9PSAnb2JqZWN0JyAmJiBBcnJheS5pc0FycmF5KCR7ZGF0YX0pICYmICR7ZGF0YX0ubGVuZ3RoID09IDFgLCAoKSA9PiBnZW5cbiAgICAgICAgICAgIC5hc3NpZ24oZGF0YSwgKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfVswXWApXG4gICAgICAgICAgICAuYXNzaWduKGRhdGFUeXBlLCAoMCwgY29kZWdlbl8xLl8pIGB0eXBlb2YgJHtkYXRhfWApXG4gICAgICAgICAgICAuaWYoY2hlY2tEYXRhVHlwZXModHlwZXMsIGRhdGEsIG9wdHMuc3RyaWN0TnVtYmVycyksICgpID0+IGdlbi5hc3NpZ24oY29lcmNlZCwgZGF0YSkpKTtcbiAgICB9XG4gICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7Y29lcmNlZH0gIT09IHVuZGVmaW5lZGApO1xuICAgIGZvciAoY29uc3QgdCBvZiBjb2VyY2VUbykge1xuICAgICAgICBpZiAoQ09FUkNJQkxFLmhhcyh0KSB8fCAodCA9PT0gXCJhcnJheVwiICYmIG9wdHMuY29lcmNlVHlwZXMgPT09IFwiYXJyYXlcIikpIHtcbiAgICAgICAgICAgIGNvZXJjZVNwZWNpZmljVHlwZSh0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZW4uZWxzZSgpO1xuICAgIHJlcG9ydFR5cGVFcnJvcihpdCk7XG4gICAgZ2VuLmVuZElmKCk7XG4gICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7Y29lcmNlZH0gIT09IHVuZGVmaW5lZGAsICgpID0+IHtcbiAgICAgICAgZ2VuLmFzc2lnbihkYXRhLCBjb2VyY2VkKTtcbiAgICAgICAgYXNzaWduUGFyZW50RGF0YShpdCwgY29lcmNlZCk7XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gY29lcmNlU3BlY2lmaWNUeXBlKHQpIHtcbiAgICAgICAgc3dpdGNoICh0KSB7XG4gICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgZ2VuXG4gICAgICAgICAgICAgICAgICAgIC5lbHNlSWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhVHlwZX0gPT0gXCJudW1iZXJcIiB8fCAke2RhdGFUeXBlfSA9PSBcImJvb2xlYW5cImApXG4gICAgICAgICAgICAgICAgICAgIC5hc3NpZ24oY29lcmNlZCwgKDAsIGNvZGVnZW5fMS5fKSBgXCJcIiArICR7ZGF0YX1gKVxuICAgICAgICAgICAgICAgICAgICAuZWxzZUlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0gPT09IG51bGxgKVxuICAgICAgICAgICAgICAgICAgICAuYXNzaWduKGNvZXJjZWQsICgwLCBjb2RlZ2VuXzEuXykgYFwiXCJgKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICAgICAgZ2VuXG4gICAgICAgICAgICAgICAgICAgIC5lbHNlSWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhVHlwZX0gPT0gXCJib29sZWFuXCIgfHwgJHtkYXRhfSA9PT0gbnVsbFxuICAgICAgICAgICAgICB8fCAoJHtkYXRhVHlwZX0gPT0gXCJzdHJpbmdcIiAmJiAke2RhdGF9ICYmICR7ZGF0YX0gPT0gKyR7ZGF0YX0pYClcbiAgICAgICAgICAgICAgICAgICAgLmFzc2lnbihjb2VyY2VkLCAoMCwgY29kZWdlbl8xLl8pIGArJHtkYXRhfWApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgXCJpbnRlZ2VyXCI6XG4gICAgICAgICAgICAgICAgZ2VuXG4gICAgICAgICAgICAgICAgICAgIC5lbHNlSWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhVHlwZX0gPT09IFwiYm9vbGVhblwiIHx8ICR7ZGF0YX0gPT09IG51bGxcbiAgICAgICAgICAgICAgfHwgKCR7ZGF0YVR5cGV9ID09PSBcInN0cmluZ1wiICYmICR7ZGF0YX0gJiYgJHtkYXRhfSA9PSArJHtkYXRhfSAmJiAhKCR7ZGF0YX0gJSAxKSlgKVxuICAgICAgICAgICAgICAgICAgICAuYXNzaWduKGNvZXJjZWQsICgwLCBjb2RlZ2VuXzEuXykgYCske2RhdGF9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICAgICAgICBnZW5cbiAgICAgICAgICAgICAgICAgICAgLmVsc2VJZigoMCwgY29kZWdlbl8xLl8pIGAke2RhdGF9ID09PSBcImZhbHNlXCIgfHwgJHtkYXRhfSA9PT0gMCB8fCAke2RhdGF9ID09PSBudWxsYClcbiAgICAgICAgICAgICAgICAgICAgLmFzc2lnbihjb2VyY2VkLCBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgLmVsc2VJZigoMCwgY29kZWdlbl8xLl8pIGAke2RhdGF9ID09PSBcInRydWVcIiB8fCAke2RhdGF9ID09PSAxYClcbiAgICAgICAgICAgICAgICAgICAgLmFzc2lnbihjb2VyY2VkLCB0cnVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlIFwibnVsbFwiOlxuICAgICAgICAgICAgICAgIGdlbi5lbHNlSWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfSA9PT0gXCJcIiB8fCAke2RhdGF9ID09PSAwIHx8ICR7ZGF0YX0gPT09IGZhbHNlYCk7XG4gICAgICAgICAgICAgICAgZ2VuLmFzc2lnbihjb2VyY2VkLCBudWxsKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICAgICAgICAgICAgICBnZW5cbiAgICAgICAgICAgICAgICAgICAgLmVsc2VJZigoMCwgY29kZWdlbl8xLl8pIGAke2RhdGFUeXBlfSA9PT0gXCJzdHJpbmdcIiB8fCAke2RhdGFUeXBlfSA9PT0gXCJudW1iZXJcIlxuICAgICAgICAgICAgICB8fCAke2RhdGFUeXBlfSA9PT0gXCJib29sZWFuXCIgfHwgJHtkYXRhfSA9PT0gbnVsbGApXG4gICAgICAgICAgICAgICAgICAgIC5hc3NpZ24oY29lcmNlZCwgKDAsIGNvZGVnZW5fMS5fKSBgWyR7ZGF0YX1dYCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBhc3NpZ25QYXJlbnREYXRhKHsgZ2VuLCBwYXJlbnREYXRhLCBwYXJlbnREYXRhUHJvcGVydHkgfSwgZXhwcikge1xuICAgIC8vIFRPRE8gdXNlIGdlbi5wcm9wZXJ0eVxuICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke3BhcmVudERhdGF9ICE9PSB1bmRlZmluZWRgLCAoKSA9PiBnZW4uYXNzaWduKCgwLCBjb2RlZ2VuXzEuXykgYCR7cGFyZW50RGF0YX1bJHtwYXJlbnREYXRhUHJvcGVydHl9XWAsIGV4cHIpKTtcbn1cbmZ1bmN0aW9uIGNoZWNrRGF0YVR5cGUoZGF0YVR5cGUsIGRhdGEsIHN0cmljdE51bXMsIGNvcnJlY3QgPSBEYXRhVHlwZS5Db3JyZWN0KSB7XG4gICAgY29uc3QgRVEgPSBjb3JyZWN0ID09PSBEYXRhVHlwZS5Db3JyZWN0ID8gY29kZWdlbl8xLm9wZXJhdG9ycy5FUSA6IGNvZGVnZW5fMS5vcGVyYXRvcnMuTkVRO1xuICAgIGxldCBjb25kO1xuICAgIHN3aXRjaCAoZGF0YVR5cGUpIHtcbiAgICAgICAgY2FzZSBcIm51bGxcIjpcbiAgICAgICAgICAgIHJldHVybiAoMCwgY29kZWdlbl8xLl8pIGAke2RhdGF9ICR7RVF9IG51bGxgO1xuICAgICAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICAgICAgICAgIGNvbmQgPSAoMCwgY29kZWdlbl8xLl8pIGBBcnJheS5pc0FycmF5KCR7ZGF0YX0pYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgICBjb25kID0gKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfSAmJiB0eXBlb2YgJHtkYXRhfSA9PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KCR7ZGF0YX0pYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiaW50ZWdlclwiOlxuICAgICAgICAgICAgY29uZCA9IG51bUNvbmQoKDAsIGNvZGVnZW5fMS5fKSBgISgke2RhdGF9ICUgMSkgJiYgIWlzTmFOKCR7ZGF0YX0pYCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgY29uZCA9IG51bUNvbmQoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEuXykgYHR5cGVvZiAke2RhdGF9ICR7RVF9ICR7ZGF0YVR5cGV9YDtcbiAgICB9XG4gICAgcmV0dXJuIGNvcnJlY3QgPT09IERhdGFUeXBlLkNvcnJlY3QgPyBjb25kIDogKDAsIGNvZGVnZW5fMS5ub3QpKGNvbmQpO1xuICAgIGZ1bmN0aW9uIG51bUNvbmQoX2NvbmQgPSBjb2RlZ2VuXzEubmlsKSB7XG4gICAgICAgIHJldHVybiAoMCwgY29kZWdlbl8xLmFuZCkoKDAsIGNvZGVnZW5fMS5fKSBgdHlwZW9mICR7ZGF0YX0gPT0gXCJudW1iZXJcImAsIF9jb25kLCBzdHJpY3ROdW1zID8gKDAsIGNvZGVnZW5fMS5fKSBgaXNGaW5pdGUoJHtkYXRhfSlgIDogY29kZWdlbl8xLm5pbCk7XG4gICAgfVxufVxuZXhwb3J0cy5jaGVja0RhdGFUeXBlID0gY2hlY2tEYXRhVHlwZTtcbmZ1bmN0aW9uIGNoZWNrRGF0YVR5cGVzKGRhdGFUeXBlcywgZGF0YSwgc3RyaWN0TnVtcywgY29ycmVjdCkge1xuICAgIGlmIChkYXRhVHlwZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBjaGVja0RhdGFUeXBlKGRhdGFUeXBlc1swXSwgZGF0YSwgc3RyaWN0TnVtcywgY29ycmVjdCk7XG4gICAgfVxuICAgIGxldCBjb25kO1xuICAgIGNvbnN0IHR5cGVzID0gKDAsIHV0aWxfMS50b0hhc2gpKGRhdGFUeXBlcyk7XG4gICAgaWYgKHR5cGVzLmFycmF5ICYmIHR5cGVzLm9iamVjdCkge1xuICAgICAgICBjb25zdCBub3RPYmogPSAoMCwgY29kZWdlbl8xLl8pIGB0eXBlb2YgJHtkYXRhfSAhPSBcIm9iamVjdFwiYDtcbiAgICAgICAgY29uZCA9IHR5cGVzLm51bGwgPyBub3RPYmogOiAoMCwgY29kZWdlbl8xLl8pIGAhJHtkYXRhfSB8fCAke25vdE9ian1gO1xuICAgICAgICBkZWxldGUgdHlwZXMubnVsbDtcbiAgICAgICAgZGVsZXRlIHR5cGVzLmFycmF5O1xuICAgICAgICBkZWxldGUgdHlwZXMub2JqZWN0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uZCA9IGNvZGVnZW5fMS5uaWw7XG4gICAgfVxuICAgIGlmICh0eXBlcy5udW1iZXIpXG4gICAgICAgIGRlbGV0ZSB0eXBlcy5pbnRlZ2VyO1xuICAgIGZvciAoY29uc3QgdCBpbiB0eXBlcylcbiAgICAgICAgY29uZCA9ICgwLCBjb2RlZ2VuXzEuYW5kKShjb25kLCBjaGVja0RhdGFUeXBlKHQsIGRhdGEsIHN0cmljdE51bXMsIGNvcnJlY3QpKTtcbiAgICByZXR1cm4gY29uZDtcbn1cbmV4cG9ydHMuY2hlY2tEYXRhVHlwZXMgPSBjaGVja0RhdGFUeXBlcztcbmNvbnN0IHR5cGVFcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBzY2hlbWEgfSkgPT4gYG11c3QgYmUgJHtzY2hlbWF9YCxcbiAgICBwYXJhbXM6ICh7IHNjaGVtYSwgc2NoZW1hVmFsdWUgfSkgPT4gdHlwZW9mIHNjaGVtYSA9PSBcInN0cmluZ1wiID8gKDAsIGNvZGVnZW5fMS5fKSBge3R5cGU6ICR7c2NoZW1hfX1gIDogKDAsIGNvZGVnZW5fMS5fKSBge3R5cGU6ICR7c2NoZW1hVmFsdWV9fWAsXG59O1xuZnVuY3Rpb24gcmVwb3J0VHlwZUVycm9yKGl0KSB7XG4gICAgY29uc3QgY3h0ID0gZ2V0VHlwZUVycm9yQ29udGV4dChpdCk7XG4gICAgKDAsIGVycm9yc18xLnJlcG9ydEVycm9yKShjeHQsIHR5cGVFcnJvcik7XG59XG5leHBvcnRzLnJlcG9ydFR5cGVFcnJvciA9IHJlcG9ydFR5cGVFcnJvcjtcbmZ1bmN0aW9uIGdldFR5cGVFcnJvckNvbnRleHQoaXQpIHtcbiAgICBjb25zdCB7IGdlbiwgZGF0YSwgc2NoZW1hIH0gPSBpdDtcbiAgICBjb25zdCBzY2hlbWFDb2RlID0gKDAsIHV0aWxfMS5zY2hlbWFSZWZPclZhbCkoaXQsIHNjaGVtYSwgXCJ0eXBlXCIpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGdlbixcbiAgICAgICAga2V5d29yZDogXCJ0eXBlXCIsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIHNjaGVtYTogc2NoZW1hLnR5cGUsXG4gICAgICAgIHNjaGVtYUNvZGUsXG4gICAgICAgIHNjaGVtYVZhbHVlOiBzY2hlbWFDb2RlLFxuICAgICAgICBwYXJlbnRTY2hlbWE6IHNjaGVtYSxcbiAgICAgICAgcGFyYW1zOiB7fSxcbiAgICAgICAgaXQsXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGFUeXBlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hc3NpZ25EZWZhdWx0cyA9IHZvaWQgMDtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG5mdW5jdGlvbiBhc3NpZ25EZWZhdWx0cyhpdCwgdHkpIHtcbiAgICBjb25zdCB7IHByb3BlcnRpZXMsIGl0ZW1zIH0gPSBpdC5zY2hlbWE7XG4gICAgaWYgKHR5ID09PSBcIm9iamVjdFwiICYmIHByb3BlcnRpZXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcGVydGllcykge1xuICAgICAgICAgICAgYXNzaWduRGVmYXVsdChpdCwga2V5LCBwcm9wZXJ0aWVzW2tleV0uZGVmYXVsdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodHkgPT09IFwiYXJyYXlcIiAmJiBBcnJheS5pc0FycmF5KGl0ZW1zKSkge1xuICAgICAgICBpdGVtcy5mb3JFYWNoKChzY2gsIGkpID0+IGFzc2lnbkRlZmF1bHQoaXQsIGksIHNjaC5kZWZhdWx0KSk7XG4gICAgfVxufVxuZXhwb3J0cy5hc3NpZ25EZWZhdWx0cyA9IGFzc2lnbkRlZmF1bHRzO1xuZnVuY3Rpb24gYXNzaWduRGVmYXVsdChpdCwgcHJvcCwgZGVmYXVsdFZhbHVlKSB7XG4gICAgY29uc3QgeyBnZW4sIGNvbXBvc2l0ZVJ1bGUsIGRhdGEsIG9wdHMgfSA9IGl0O1xuICAgIGlmIChkZWZhdWx0VmFsdWUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGNoaWxkRGF0YSA9ICgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0keygwLCBjb2RlZ2VuXzEuZ2V0UHJvcGVydHkpKHByb3ApfWA7XG4gICAgaWYgKGNvbXBvc2l0ZVJ1bGUpIHtcbiAgICAgICAgKDAsIHV0aWxfMS5jaGVja1N0cmljdE1vZGUpKGl0LCBgZGVmYXVsdCBpcyBpZ25vcmVkIGZvcjogJHtjaGlsZERhdGF9YCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGNvbmRpdGlvbiA9ICgwLCBjb2RlZ2VuXzEuXykgYCR7Y2hpbGREYXRhfSA9PT0gdW5kZWZpbmVkYDtcbiAgICBpZiAob3B0cy51c2VEZWZhdWx0cyA9PT0gXCJlbXB0eVwiKSB7XG4gICAgICAgIGNvbmRpdGlvbiA9ICgwLCBjb2RlZ2VuXzEuXykgYCR7Y29uZGl0aW9ufSB8fCAke2NoaWxkRGF0YX0gPT09IG51bGwgfHwgJHtjaGlsZERhdGF9ID09PSBcIlwiYDtcbiAgICB9XG4gICAgLy8gYCR7Y2hpbGREYXRhfSA9PT0gdW5kZWZpbmVkYCArXG4gICAgLy8gKG9wdHMudXNlRGVmYXVsdHMgPT09IFwiZW1wdHlcIiA/IGAgfHwgJHtjaGlsZERhdGF9ID09PSBudWxsIHx8ICR7Y2hpbGREYXRhfSA9PT0gXCJcImAgOiBcIlwiKVxuICAgIGdlbi5pZihjb25kaXRpb24sICgwLCBjb2RlZ2VuXzEuXykgYCR7Y2hpbGREYXRhfSA9ICR7KDAsIGNvZGVnZW5fMS5zdHJpbmdpZnkpKGRlZmF1bHRWYWx1ZSl9YCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWZhdWx0cy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudmFsaWRhdGVVbmlvbiA9IGV4cG9ydHMudmFsaWRhdGVBcnJheSA9IGV4cG9ydHMudXNlUGF0dGVybiA9IGV4cG9ydHMuY2FsbFZhbGlkYXRlQ29kZSA9IGV4cG9ydHMuc2NoZW1hUHJvcGVydGllcyA9IGV4cG9ydHMuYWxsU2NoZW1hUHJvcGVydGllcyA9IGV4cG9ydHMubm9Qcm9wZXJ0eUluRGF0YSA9IGV4cG9ydHMucHJvcGVydHlJbkRhdGEgPSBleHBvcnRzLmlzT3duUHJvcGVydHkgPSBleHBvcnRzLmhhc1Byb3BGdW5jID0gZXhwb3J0cy5yZXBvcnRNaXNzaW5nUHJvcCA9IGV4cG9ydHMuY2hlY2tNaXNzaW5nUHJvcCA9IGV4cG9ydHMuY2hlY2tSZXBvcnRNaXNzaW5nUHJvcCA9IHZvaWQgMDtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgbmFtZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21waWxlL25hbWVzXCIpO1xuY29uc3QgdXRpbF8yID0gcmVxdWlyZShcIi4uL2NvbXBpbGUvdXRpbFwiKTtcbmZ1bmN0aW9uIGNoZWNrUmVwb3J0TWlzc2luZ1Byb3AoY3h0LCBwcm9wKSB7XG4gICAgY29uc3QgeyBnZW4sIGRhdGEsIGl0IH0gPSBjeHQ7XG4gICAgZ2VuLmlmKG5vUHJvcGVydHlJbkRhdGEoZ2VuLCBkYXRhLCBwcm9wLCBpdC5vcHRzLm93blByb3BlcnRpZXMpLCAoKSA9PiB7XG4gICAgICAgIGN4dC5zZXRQYXJhbXMoeyBtaXNzaW5nUHJvcGVydHk6ICgwLCBjb2RlZ2VuXzEuXykgYCR7cHJvcH1gIH0sIHRydWUpO1xuICAgICAgICBjeHQuZXJyb3IoKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuY2hlY2tSZXBvcnRNaXNzaW5nUHJvcCA9IGNoZWNrUmVwb3J0TWlzc2luZ1Byb3A7XG5mdW5jdGlvbiBjaGVja01pc3NpbmdQcm9wKHsgZ2VuLCBkYXRhLCBpdDogeyBvcHRzIH0gfSwgcHJvcGVydGllcywgbWlzc2luZykge1xuICAgIHJldHVybiAoMCwgY29kZWdlbl8xLm9yKSguLi5wcm9wZXJ0aWVzLm1hcCgocHJvcCkgPT4gKDAsIGNvZGVnZW5fMS5hbmQpKG5vUHJvcGVydHlJbkRhdGEoZ2VuLCBkYXRhLCBwcm9wLCBvcHRzLm93blByb3BlcnRpZXMpLCAoMCwgY29kZWdlbl8xLl8pIGAke21pc3Npbmd9ID0gJHtwcm9wfWApKSk7XG59XG5leHBvcnRzLmNoZWNrTWlzc2luZ1Byb3AgPSBjaGVja01pc3NpbmdQcm9wO1xuZnVuY3Rpb24gcmVwb3J0TWlzc2luZ1Byb3AoY3h0LCBtaXNzaW5nKSB7XG4gICAgY3h0LnNldFBhcmFtcyh7IG1pc3NpbmdQcm9wZXJ0eTogbWlzc2luZyB9LCB0cnVlKTtcbiAgICBjeHQuZXJyb3IoKTtcbn1cbmV4cG9ydHMucmVwb3J0TWlzc2luZ1Byb3AgPSByZXBvcnRNaXNzaW5nUHJvcDtcbmZ1bmN0aW9uIGhhc1Byb3BGdW5jKGdlbikge1xuICAgIHJldHVybiBnZW4uc2NvcGVWYWx1ZShcImZ1bmNcIiwge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3VuYm91bmQtbWV0aG9kXG4gICAgICAgIHJlZjogT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxcbiAgICAgICAgY29kZTogKDAsIGNvZGVnZW5fMS5fKSBgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eWAsXG4gICAgfSk7XG59XG5leHBvcnRzLmhhc1Byb3BGdW5jID0gaGFzUHJvcEZ1bmM7XG5mdW5jdGlvbiBpc093blByb3BlcnR5KGdlbiwgZGF0YSwgcHJvcGVydHkpIHtcbiAgICByZXR1cm4gKDAsIGNvZGVnZW5fMS5fKSBgJHtoYXNQcm9wRnVuYyhnZW4pfS5jYWxsKCR7ZGF0YX0sICR7cHJvcGVydHl9KWA7XG59XG5leHBvcnRzLmlzT3duUHJvcGVydHkgPSBpc093blByb3BlcnR5O1xuZnVuY3Rpb24gcHJvcGVydHlJbkRhdGEoZ2VuLCBkYXRhLCBwcm9wZXJ0eSwgb3duUHJvcGVydGllcykge1xuICAgIGNvbnN0IGNvbmQgPSAoMCwgY29kZWdlbl8xLl8pIGAke2RhdGF9JHsoMCwgY29kZWdlbl8xLmdldFByb3BlcnR5KShwcm9wZXJ0eSl9ICE9PSB1bmRlZmluZWRgO1xuICAgIHJldHVybiBvd25Qcm9wZXJ0aWVzID8gKDAsIGNvZGVnZW5fMS5fKSBgJHtjb25kfSAmJiAke2lzT3duUHJvcGVydHkoZ2VuLCBkYXRhLCBwcm9wZXJ0eSl9YCA6IGNvbmQ7XG59XG5leHBvcnRzLnByb3BlcnR5SW5EYXRhID0gcHJvcGVydHlJbkRhdGE7XG5mdW5jdGlvbiBub1Byb3BlcnR5SW5EYXRhKGdlbiwgZGF0YSwgcHJvcGVydHksIG93blByb3BlcnRpZXMpIHtcbiAgICBjb25zdCBjb25kID0gKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfSR7KDAsIGNvZGVnZW5fMS5nZXRQcm9wZXJ0eSkocHJvcGVydHkpfSA9PT0gdW5kZWZpbmVkYDtcbiAgICByZXR1cm4gb3duUHJvcGVydGllcyA/ICgwLCBjb2RlZ2VuXzEub3IpKGNvbmQsICgwLCBjb2RlZ2VuXzEubm90KShpc093blByb3BlcnR5KGdlbiwgZGF0YSwgcHJvcGVydHkpKSkgOiBjb25kO1xufVxuZXhwb3J0cy5ub1Byb3BlcnR5SW5EYXRhID0gbm9Qcm9wZXJ0eUluRGF0YTtcbmZ1bmN0aW9uIGFsbFNjaGVtYVByb3BlcnRpZXMoc2NoZW1hTWFwKSB7XG4gICAgcmV0dXJuIHNjaGVtYU1hcCA/IE9iamVjdC5rZXlzKHNjaGVtYU1hcCkuZmlsdGVyKChwKSA9PiBwICE9PSBcIl9fcHJvdG9fX1wiKSA6IFtdO1xufVxuZXhwb3J0cy5hbGxTY2hlbWFQcm9wZXJ0aWVzID0gYWxsU2NoZW1hUHJvcGVydGllcztcbmZ1bmN0aW9uIHNjaGVtYVByb3BlcnRpZXMoaXQsIHNjaGVtYU1hcCkge1xuICAgIHJldHVybiBhbGxTY2hlbWFQcm9wZXJ0aWVzKHNjaGVtYU1hcCkuZmlsdGVyKChwKSA9PiAhKDAsIHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYSkoaXQsIHNjaGVtYU1hcFtwXSkpO1xufVxuZXhwb3J0cy5zY2hlbWFQcm9wZXJ0aWVzID0gc2NoZW1hUHJvcGVydGllcztcbmZ1bmN0aW9uIGNhbGxWYWxpZGF0ZUNvZGUoeyBzY2hlbWFDb2RlLCBkYXRhLCBpdDogeyBnZW4sIHRvcFNjaGVtYVJlZiwgc2NoZW1hUGF0aCwgZXJyb3JQYXRoIH0sIGl0IH0sIGZ1bmMsIGNvbnRleHQsIHBhc3NTY2hlbWEpIHtcbiAgICBjb25zdCBkYXRhQW5kU2NoZW1hID0gcGFzc1NjaGVtYSA/ICgwLCBjb2RlZ2VuXzEuXykgYCR7c2NoZW1hQ29kZX0sICR7ZGF0YX0sICR7dG9wU2NoZW1hUmVmfSR7c2NoZW1hUGF0aH1gIDogZGF0YTtcbiAgICBjb25zdCB2YWxDeHQgPSBbXG4gICAgICAgIFtuYW1lc18xLmRlZmF1bHQuaW5zdGFuY2VQYXRoLCAoMCwgY29kZWdlbl8xLnN0ckNvbmNhdCkobmFtZXNfMS5kZWZhdWx0Lmluc3RhbmNlUGF0aCwgZXJyb3JQYXRoKV0sXG4gICAgICAgIFtuYW1lc18xLmRlZmF1bHQucGFyZW50RGF0YSwgaXQucGFyZW50RGF0YV0sXG4gICAgICAgIFtuYW1lc18xLmRlZmF1bHQucGFyZW50RGF0YVByb3BlcnR5LCBpdC5wYXJlbnREYXRhUHJvcGVydHldLFxuICAgICAgICBbbmFtZXNfMS5kZWZhdWx0LnJvb3REYXRhLCBuYW1lc18xLmRlZmF1bHQucm9vdERhdGFdLFxuICAgIF07XG4gICAgaWYgKGl0Lm9wdHMuZHluYW1pY1JlZilcbiAgICAgICAgdmFsQ3h0LnB1c2goW25hbWVzXzEuZGVmYXVsdC5keW5hbWljQW5jaG9ycywgbmFtZXNfMS5kZWZhdWx0LmR5bmFtaWNBbmNob3JzXSk7XG4gICAgY29uc3QgYXJncyA9ICgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YUFuZFNjaGVtYX0sICR7Z2VuLm9iamVjdCguLi52YWxDeHQpfWA7XG4gICAgcmV0dXJuIGNvbnRleHQgIT09IGNvZGVnZW5fMS5uaWwgPyAoMCwgY29kZWdlbl8xLl8pIGAke2Z1bmN9LmNhbGwoJHtjb250ZXh0fSwgJHthcmdzfSlgIDogKDAsIGNvZGVnZW5fMS5fKSBgJHtmdW5jfSgke2FyZ3N9KWA7XG59XG5leHBvcnRzLmNhbGxWYWxpZGF0ZUNvZGUgPSBjYWxsVmFsaWRhdGVDb2RlO1xuY29uc3QgbmV3UmVnRXhwID0gKDAsIGNvZGVnZW5fMS5fKSBgbmV3IFJlZ0V4cGA7XG5mdW5jdGlvbiB1c2VQYXR0ZXJuKHsgZ2VuLCBpdDogeyBvcHRzIH0gfSwgcGF0dGVybikge1xuICAgIGNvbnN0IHUgPSBvcHRzLnVuaWNvZGVSZWdFeHAgPyBcInVcIiA6IFwiXCI7XG4gICAgY29uc3QgeyByZWdFeHAgfSA9IG9wdHMuY29kZTtcbiAgICBjb25zdCByeCA9IHJlZ0V4cChwYXR0ZXJuLCB1KTtcbiAgICByZXR1cm4gZ2VuLnNjb3BlVmFsdWUoXCJwYXR0ZXJuXCIsIHtcbiAgICAgICAga2V5OiByeC50b1N0cmluZygpLFxuICAgICAgICByZWY6IHJ4LFxuICAgICAgICBjb2RlOiAoMCwgY29kZWdlbl8xLl8pIGAke3JlZ0V4cC5jb2RlID09PSBcIm5ldyBSZWdFeHBcIiA/IG5ld1JlZ0V4cCA6ICgwLCB1dGlsXzIudXNlRnVuYykoZ2VuLCByZWdFeHApfSgke3BhdHRlcm59LCAke3V9KWAsXG4gICAgfSk7XG59XG5leHBvcnRzLnVzZVBhdHRlcm4gPSB1c2VQYXR0ZXJuO1xuZnVuY3Rpb24gdmFsaWRhdGVBcnJheShjeHQpIHtcbiAgICBjb25zdCB7IGdlbiwgZGF0YSwga2V5d29yZCwgaXQgfSA9IGN4dDtcbiAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIik7XG4gICAgaWYgKGl0LmFsbEVycm9ycykge1xuICAgICAgICBjb25zdCB2YWxpZEFyciA9IGdlbi5sZXQoXCJ2YWxpZFwiLCB0cnVlKTtcbiAgICAgICAgdmFsaWRhdGVJdGVtcygoKSA9PiBnZW4uYXNzaWduKHZhbGlkQXJyLCBmYWxzZSkpO1xuICAgICAgICByZXR1cm4gdmFsaWRBcnI7XG4gICAgfVxuICAgIGdlbi52YXIodmFsaWQsIHRydWUpO1xuICAgIHZhbGlkYXRlSXRlbXMoKCkgPT4gZ2VuLmJyZWFrKCkpO1xuICAgIHJldHVybiB2YWxpZDtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUl0ZW1zKG5vdFZhbGlkKSB7XG4gICAgICAgIGNvbnN0IGxlbiA9IGdlbi5jb25zdChcImxlblwiLCAoMCwgY29kZWdlbl8xLl8pIGAke2RhdGF9Lmxlbmd0aGApO1xuICAgICAgICBnZW4uZm9yUmFuZ2UoXCJpXCIsIDAsIGxlbiwgKGkpID0+IHtcbiAgICAgICAgICAgIGN4dC5zdWJzY2hlbWEoe1xuICAgICAgICAgICAgICAgIGtleXdvcmQsXG4gICAgICAgICAgICAgICAgZGF0YVByb3A6IGksXG4gICAgICAgICAgICAgICAgZGF0YVByb3BUeXBlOiB1dGlsXzEuVHlwZS5OdW0sXG4gICAgICAgICAgICB9LCB2YWxpZCk7XG4gICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5ub3QpKHZhbGlkKSwgbm90VmFsaWQpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlQXJyYXkgPSB2YWxpZGF0ZUFycmF5O1xuZnVuY3Rpb24gdmFsaWRhdGVVbmlvbihjeHQpIHtcbiAgICBjb25zdCB7IGdlbiwgc2NoZW1hLCBrZXl3b3JkLCBpdCB9ID0gY3h0O1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghQXJyYXkuaXNBcnJheShzY2hlbWEpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhanYgaW1wbGVtZW50YXRpb24gZXJyb3JcIik7XG4gICAgY29uc3QgYWx3YXlzVmFsaWQgPSBzY2hlbWEuc29tZSgoc2NoKSA9PiAoMCwgdXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKShpdCwgc2NoKSk7XG4gICAgaWYgKGFsd2F5c1ZhbGlkICYmICFpdC5vcHRzLnVuZXZhbHVhdGVkKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3QgdmFsaWQgPSBnZW4ubGV0KFwidmFsaWRcIiwgZmFsc2UpO1xuICAgIGNvbnN0IHNjaFZhbGlkID0gZ2VuLm5hbWUoXCJfdmFsaWRcIik7XG4gICAgZ2VuLmJsb2NrKCgpID0+IHNjaGVtYS5mb3JFYWNoKChfc2NoLCBpKSA9PiB7XG4gICAgICAgIGNvbnN0IHNjaEN4dCA9IGN4dC5zdWJzY2hlbWEoe1xuICAgICAgICAgICAga2V5d29yZCxcbiAgICAgICAgICAgIHNjaGVtYVByb3A6IGksXG4gICAgICAgICAgICBjb21wb3NpdGVSdWxlOiB0cnVlLFxuICAgICAgICB9LCBzY2hWYWxpZCk7XG4gICAgICAgIGdlbi5hc3NpZ24odmFsaWQsICgwLCBjb2RlZ2VuXzEuXykgYCR7dmFsaWR9IHx8ICR7c2NoVmFsaWR9YCk7XG4gICAgICAgIGNvbnN0IG1lcmdlZCA9IGN4dC5tZXJnZVZhbGlkRXZhbHVhdGVkKHNjaEN4dCwgc2NoVmFsaWQpO1xuICAgICAgICAvLyBjYW4gc2hvcnQtY2lyY3VpdCBpZiBgdW5ldmFsdWF0ZWRQcm9wZXJ0aWVzL0l0ZW1zYCBub3Qgc3VwcG9ydGVkIChvcHRzLnVuZXZhbHVhdGVkICE9PSB0cnVlKVxuICAgICAgICAvLyBvciBpZiBhbGwgcHJvcGVydGllcyBhbmQgaXRlbXMgd2VyZSBldmFsdWF0ZWQgKGl0LnByb3BzID09PSB0cnVlICYmIGl0Lml0ZW1zID09PSB0cnVlKVxuICAgICAgICBpZiAoIW1lcmdlZClcbiAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLm5vdCkodmFsaWQpKTtcbiAgICB9KSk7XG4gICAgY3h0LnJlc3VsdCh2YWxpZCwgKCkgPT4gY3h0LnJlc2V0KCksICgpID0+IGN4dC5lcnJvcih0cnVlKSk7XG59XG5leHBvcnRzLnZhbGlkYXRlVW5pb24gPSB2YWxpZGF0ZVVuaW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29kZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudmFsaWRhdGVLZXl3b3JkVXNhZ2UgPSBleHBvcnRzLnZhbGlkU2NoZW1hVHlwZSA9IGV4cG9ydHMuZnVuY0tleXdvcmRDb2RlID0gZXhwb3J0cy5tYWNyb0tleXdvcmRDb2RlID0gdm9pZCAwO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uL2NvZGVnZW5cIik7XG5jb25zdCBuYW1lc18xID0gcmVxdWlyZShcIi4uL25hbWVzXCIpO1xuY29uc3QgY29kZV8xID0gcmVxdWlyZShcIi4uLy4uL3ZvY2FidWxhcmllcy9jb2RlXCIpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzXCIpO1xuZnVuY3Rpb24gbWFjcm9LZXl3b3JkQ29kZShjeHQsIGRlZikge1xuICAgIGNvbnN0IHsgZ2VuLCBrZXl3b3JkLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgaXQgfSA9IGN4dDtcbiAgICBjb25zdCBtYWNyb1NjaGVtYSA9IGRlZi5tYWNyby5jYWxsKGl0LnNlbGYsIHNjaGVtYSwgcGFyZW50U2NoZW1hLCBpdCk7XG4gICAgY29uc3Qgc2NoZW1hUmVmID0gdXNlS2V5d29yZChnZW4sIGtleXdvcmQsIG1hY3JvU2NoZW1hKTtcbiAgICBpZiAoaXQub3B0cy52YWxpZGF0ZVNjaGVtYSAhPT0gZmFsc2UpXG4gICAgICAgIGl0LnNlbGYudmFsaWRhdGVTY2hlbWEobWFjcm9TY2hlbWEsIHRydWUpO1xuICAgIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKTtcbiAgICBjeHQuc3Vic2NoZW1hKHtcbiAgICAgICAgc2NoZW1hOiBtYWNyb1NjaGVtYSxcbiAgICAgICAgc2NoZW1hUGF0aDogY29kZWdlbl8xLm5pbCxcbiAgICAgICAgZXJyU2NoZW1hUGF0aDogYCR7aXQuZXJyU2NoZW1hUGF0aH0vJHtrZXl3b3JkfWAsXG4gICAgICAgIHRvcFNjaGVtYVJlZjogc2NoZW1hUmVmLFxuICAgICAgICBjb21wb3NpdGVSdWxlOiB0cnVlLFxuICAgIH0sIHZhbGlkKTtcbiAgICBjeHQucGFzcyh2YWxpZCwgKCkgPT4gY3h0LmVycm9yKHRydWUpKTtcbn1cbmV4cG9ydHMubWFjcm9LZXl3b3JkQ29kZSA9IG1hY3JvS2V5d29yZENvZGU7XG5mdW5jdGlvbiBmdW5jS2V5d29yZENvZGUoY3h0LCBkZWYpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgeyBnZW4sIGtleXdvcmQsIHNjaGVtYSwgcGFyZW50U2NoZW1hLCAkZGF0YSwgaXQgfSA9IGN4dDtcbiAgICBjaGVja0FzeW5jS2V5d29yZChpdCwgZGVmKTtcbiAgICBjb25zdCB2YWxpZGF0ZSA9ICEkZGF0YSAmJiBkZWYuY29tcGlsZSA/IGRlZi5jb21waWxlLmNhbGwoaXQuc2VsZiwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIGl0KSA6IGRlZi52YWxpZGF0ZTtcbiAgICBjb25zdCB2YWxpZGF0ZVJlZiA9IHVzZUtleXdvcmQoZ2VuLCBrZXl3b3JkLCB2YWxpZGF0ZSk7XG4gICAgY29uc3QgdmFsaWQgPSBnZW4ubGV0KFwidmFsaWRcIik7XG4gICAgY3h0LmJsb2NrJGRhdGEodmFsaWQsIHZhbGlkYXRlS2V5d29yZCk7XG4gICAgY3h0Lm9rKChfYSA9IGRlZi52YWxpZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdmFsaWQpO1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlS2V5d29yZCgpIHtcbiAgICAgICAgaWYgKGRlZi5lcnJvcnMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBhc3NpZ25WYWxpZCgpO1xuICAgICAgICAgICAgaWYgKGRlZi5tb2RpZnlpbmcpXG4gICAgICAgICAgICAgICAgbW9kaWZ5RGF0YShjeHQpO1xuICAgICAgICAgICAgcmVwb3J0RXJycygoKSA9PiBjeHQuZXJyb3IoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBydWxlRXJycyA9IGRlZi5hc3luYyA/IHZhbGlkYXRlQXN5bmMoKSA6IHZhbGlkYXRlU3luYygpO1xuICAgICAgICAgICAgaWYgKGRlZi5tb2RpZnlpbmcpXG4gICAgICAgICAgICAgICAgbW9kaWZ5RGF0YShjeHQpO1xuICAgICAgICAgICAgcmVwb3J0RXJycygoKSA9PiBhZGRFcnJzKGN4dCwgcnVsZUVycnMpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUFzeW5jKCkge1xuICAgICAgICBjb25zdCBydWxlRXJycyA9IGdlbi5sZXQoXCJydWxlRXJyc1wiLCBudWxsKTtcbiAgICAgICAgZ2VuLnRyeSgoKSA9PiBhc3NpZ25WYWxpZCgoMCwgY29kZWdlbl8xLl8pIGBhd2FpdCBgKSwgKGUpID0+IGdlbi5hc3NpZ24odmFsaWQsIGZhbHNlKS5pZigoMCwgY29kZWdlbl8xLl8pIGAke2V9IGluc3RhbmNlb2YgJHtpdC5WYWxpZGF0aW9uRXJyb3J9YCwgKCkgPT4gZ2VuLmFzc2lnbihydWxlRXJycywgKDAsIGNvZGVnZW5fMS5fKSBgJHtlfS5lcnJvcnNgKSwgKCkgPT4gZ2VuLnRocm93KGUpKSk7XG4gICAgICAgIHJldHVybiBydWxlRXJycztcbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVTeW5jKCkge1xuICAgICAgICBjb25zdCB2YWxpZGF0ZUVycnMgPSAoMCwgY29kZWdlbl8xLl8pIGAke3ZhbGlkYXRlUmVmfS5lcnJvcnNgO1xuICAgICAgICBnZW4uYXNzaWduKHZhbGlkYXRlRXJycywgbnVsbCk7XG4gICAgICAgIGFzc2lnblZhbGlkKGNvZGVnZW5fMS5uaWwpO1xuICAgICAgICByZXR1cm4gdmFsaWRhdGVFcnJzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhc3NpZ25WYWxpZChfYXdhaXQgPSBkZWYuYXN5bmMgPyAoMCwgY29kZWdlbl8xLl8pIGBhd2FpdCBgIDogY29kZWdlbl8xLm5pbCkge1xuICAgICAgICBjb25zdCBwYXNzQ3h0ID0gaXQub3B0cy5wYXNzQ29udGV4dCA/IG5hbWVzXzEuZGVmYXVsdC50aGlzIDogbmFtZXNfMS5kZWZhdWx0LnNlbGY7XG4gICAgICAgIGNvbnN0IHBhc3NTY2hlbWEgPSAhKChcImNvbXBpbGVcIiBpbiBkZWYgJiYgISRkYXRhKSB8fCBkZWYuc2NoZW1hID09PSBmYWxzZSk7XG4gICAgICAgIGdlbi5hc3NpZ24odmFsaWQsICgwLCBjb2RlZ2VuXzEuXykgYCR7X2F3YWl0fSR7KDAsIGNvZGVfMS5jYWxsVmFsaWRhdGVDb2RlKShjeHQsIHZhbGlkYXRlUmVmLCBwYXNzQ3h0LCBwYXNzU2NoZW1hKX1gLCBkZWYubW9kaWZ5aW5nKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVwb3J0RXJycyhlcnJvcnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5ub3QpKChfYSA9IGRlZi52YWxpZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdmFsaWQpLCBlcnJvcnMpO1xuICAgIH1cbn1cbmV4cG9ydHMuZnVuY0tleXdvcmRDb2RlID0gZnVuY0tleXdvcmRDb2RlO1xuZnVuY3Rpb24gbW9kaWZ5RGF0YShjeHQpIHtcbiAgICBjb25zdCB7IGdlbiwgZGF0YSwgaXQgfSA9IGN4dDtcbiAgICBnZW4uaWYoaXQucGFyZW50RGF0YSwgKCkgPT4gZ2VuLmFzc2lnbihkYXRhLCAoMCwgY29kZWdlbl8xLl8pIGAke2l0LnBhcmVudERhdGF9WyR7aXQucGFyZW50RGF0YVByb3BlcnR5fV1gKSk7XG59XG5mdW5jdGlvbiBhZGRFcnJzKGN4dCwgZXJycykge1xuICAgIGNvbnN0IHsgZ2VuIH0gPSBjeHQ7XG4gICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYEFycmF5LmlzQXJyYXkoJHtlcnJzfSlgLCAoKSA9PiB7XG4gICAgICAgIGdlblxuICAgICAgICAgICAgLmFzc2lnbihuYW1lc18xLmRlZmF1bHQudkVycm9ycywgKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc30gPT09IG51bGwgPyAke2VycnN9IDogJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc30uY29uY2F0KCR7ZXJyc30pYClcbiAgICAgICAgICAgIC5hc3NpZ24obmFtZXNfMS5kZWZhdWx0LmVycm9ycywgKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc30ubGVuZ3RoYCk7XG4gICAgICAgICgwLCBlcnJvcnNfMS5leHRlbmRFcnJvcnMpKGN4dCk7XG4gICAgfSwgKCkgPT4gY3h0LmVycm9yKCkpO1xufVxuZnVuY3Rpb24gY2hlY2tBc3luY0tleXdvcmQoeyBzY2hlbWFFbnYgfSwgZGVmKSB7XG4gICAgaWYgKGRlZi5hc3luYyAmJiAhc2NoZW1hRW52LiRhc3luYylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXN5bmMga2V5d29yZCBpbiBzeW5jIHNjaGVtYVwiKTtcbn1cbmZ1bmN0aW9uIHVzZUtleXdvcmQoZ2VuLCBrZXl3b3JkLCByZXN1bHQpIHtcbiAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihga2V5d29yZCBcIiR7a2V5d29yZH1cIiBmYWlsZWQgdG8gY29tcGlsZWApO1xuICAgIHJldHVybiBnZW4uc2NvcGVWYWx1ZShcImtleXdvcmRcIiwgdHlwZW9mIHJlc3VsdCA9PSBcImZ1bmN0aW9uXCIgPyB7IHJlZjogcmVzdWx0IH0gOiB7IHJlZjogcmVzdWx0LCBjb2RlOiAoMCwgY29kZWdlbl8xLnN0cmluZ2lmeSkocmVzdWx0KSB9KTtcbn1cbmZ1bmN0aW9uIHZhbGlkU2NoZW1hVHlwZShzY2hlbWEsIHNjaGVtYVR5cGUsIGFsbG93VW5kZWZpbmVkID0gZmFsc2UpIHtcbiAgICAvLyBUT0RPIGFkZCB0ZXN0c1xuICAgIHJldHVybiAoIXNjaGVtYVR5cGUubGVuZ3RoIHx8XG4gICAgICAgIHNjaGVtYVR5cGUuc29tZSgoc3QpID0+IHN0ID09PSBcImFycmF5XCJcbiAgICAgICAgICAgID8gQXJyYXkuaXNBcnJheShzY2hlbWEpXG4gICAgICAgICAgICA6IHN0ID09PSBcIm9iamVjdFwiXG4gICAgICAgICAgICAgICAgPyBzY2hlbWEgJiYgdHlwZW9mIHNjaGVtYSA9PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KHNjaGVtYSlcbiAgICAgICAgICAgICAgICA6IHR5cGVvZiBzY2hlbWEgPT0gc3QgfHwgKGFsbG93VW5kZWZpbmVkICYmIHR5cGVvZiBzY2hlbWEgPT0gXCJ1bmRlZmluZWRcIikpKTtcbn1cbmV4cG9ydHMudmFsaWRTY2hlbWFUeXBlID0gdmFsaWRTY2hlbWFUeXBlO1xuZnVuY3Rpb24gdmFsaWRhdGVLZXl3b3JkVXNhZ2UoeyBzY2hlbWEsIG9wdHMsIHNlbGYsIGVyclNjaGVtYVBhdGggfSwgZGVmLCBrZXl3b3JkKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGVmLmtleXdvcmQpID8gIWRlZi5rZXl3b3JkLmluY2x1ZGVzKGtleXdvcmQpIDogZGVmLmtleXdvcmQgIT09IGtleXdvcmQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpO1xuICAgIH1cbiAgICBjb25zdCBkZXBzID0gZGVmLmRlcGVuZGVuY2llcztcbiAgICBpZiAoZGVwcyA9PT0gbnVsbCB8fCBkZXBzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkZXBzLnNvbWUoKGt3ZCkgPT4gIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzY2hlbWEsIGt3ZCkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgcGFyZW50IHNjaGVtYSBtdXN0IGhhdmUgZGVwZW5kZW5jaWVzIG9mICR7a2V5d29yZH06ICR7ZGVwcy5qb2luKFwiLFwiKX1gKTtcbiAgICB9XG4gICAgaWYgKGRlZi52YWxpZGF0ZVNjaGVtYSkge1xuICAgICAgICBjb25zdCB2YWxpZCA9IGRlZi52YWxpZGF0ZVNjaGVtYShzY2hlbWFba2V5d29yZF0pO1xuICAgICAgICBpZiAoIXZhbGlkKSB7XG4gICAgICAgICAgICBjb25zdCBtc2cgPSBga2V5d29yZCBcIiR7a2V5d29yZH1cIiB2YWx1ZSBpcyBpbnZhbGlkIGF0IHBhdGggXCIke2VyclNjaGVtYVBhdGh9XCI6IGAgK1xuICAgICAgICAgICAgICAgIHNlbGYuZXJyb3JzVGV4dChkZWYudmFsaWRhdGVTY2hlbWEuZXJyb3JzKTtcbiAgICAgICAgICAgIGlmIChvcHRzLnZhbGlkYXRlU2NoZW1hID09PSBcImxvZ1wiKVxuICAgICAgICAgICAgICAgIHNlbGYubG9nZ2VyLmVycm9yKG1zZyk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlS2V5d29yZFVzYWdlID0gdmFsaWRhdGVLZXl3b3JkVXNhZ2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1rZXl3b3JkLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5leHRlbmRTdWJzY2hlbWFNb2RlID0gZXhwb3J0cy5leHRlbmRTdWJzY2hlbWFEYXRhID0gZXhwb3J0cy5nZXRTdWJzY2hlbWEgPSB2b2lkIDA7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuZnVuY3Rpb24gZ2V0U3Vic2NoZW1hKGl0LCB7IGtleXdvcmQsIHNjaGVtYVByb3AsIHNjaGVtYSwgc2NoZW1hUGF0aCwgZXJyU2NoZW1hUGF0aCwgdG9wU2NoZW1hUmVmIH0pIHtcbiAgICBpZiAoa2V5d29yZCAhPT0gdW5kZWZpbmVkICYmIHNjaGVtYSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYm90aCBcImtleXdvcmRcIiBhbmQgXCJzY2hlbWFcIiBwYXNzZWQsIG9ubHkgb25lIGFsbG93ZWQnKTtcbiAgICB9XG4gICAgaWYgKGtleXdvcmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBzY2ggPSBpdC5zY2hlbWFba2V5d29yZF07XG4gICAgICAgIHJldHVybiBzY2hlbWFQcm9wID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgIHNjaGVtYTogc2NoLFxuICAgICAgICAgICAgICAgIHNjaGVtYVBhdGg6ICgwLCBjb2RlZ2VuXzEuXykgYCR7aXQuc2NoZW1hUGF0aH0keygwLCBjb2RlZ2VuXzEuZ2V0UHJvcGVydHkpKGtleXdvcmQpfWAsXG4gICAgICAgICAgICAgICAgZXJyU2NoZW1hUGF0aDogYCR7aXQuZXJyU2NoZW1hUGF0aH0vJHtrZXl3b3JkfWAsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICBzY2hlbWE6IHNjaFtzY2hlbWFQcm9wXSxcbiAgICAgICAgICAgICAgICBzY2hlbWFQYXRoOiAoMCwgY29kZWdlbl8xLl8pIGAke2l0LnNjaGVtYVBhdGh9JHsoMCwgY29kZWdlbl8xLmdldFByb3BlcnR5KShrZXl3b3JkKX0keygwLCBjb2RlZ2VuXzEuZ2V0UHJvcGVydHkpKHNjaGVtYVByb3ApfWAsXG4gICAgICAgICAgICAgICAgZXJyU2NoZW1hUGF0aDogYCR7aXQuZXJyU2NoZW1hUGF0aH0vJHtrZXl3b3JkfS8keygwLCB1dGlsXzEuZXNjYXBlRnJhZ21lbnQpKHNjaGVtYVByb3ApfWAsXG4gICAgICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoc2NoZW1hICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHNjaGVtYVBhdGggPT09IHVuZGVmaW5lZCB8fCBlcnJTY2hlbWFQYXRoID09PSB1bmRlZmluZWQgfHwgdG9wU2NoZW1hUmVmID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignXCJzY2hlbWFQYXRoXCIsIFwiZXJyU2NoZW1hUGF0aFwiIGFuZCBcInRvcFNjaGVtYVJlZlwiIGFyZSByZXF1aXJlZCB3aXRoIFwic2NoZW1hXCInKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2NoZW1hLFxuICAgICAgICAgICAgc2NoZW1hUGF0aCxcbiAgICAgICAgICAgIHRvcFNjaGVtYVJlZixcbiAgICAgICAgICAgIGVyclNjaGVtYVBhdGgsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignZWl0aGVyIFwia2V5d29yZFwiIG9yIFwic2NoZW1hXCIgbXVzdCBiZSBwYXNzZWQnKTtcbn1cbmV4cG9ydHMuZ2V0U3Vic2NoZW1hID0gZ2V0U3Vic2NoZW1hO1xuZnVuY3Rpb24gZXh0ZW5kU3Vic2NoZW1hRGF0YShzdWJzY2hlbWEsIGl0LCB7IGRhdGFQcm9wLCBkYXRhUHJvcFR5cGU6IGRwVHlwZSwgZGF0YSwgZGF0YVR5cGVzLCBwcm9wZXJ0eU5hbWUgfSkge1xuICAgIGlmIChkYXRhICE9PSB1bmRlZmluZWQgJiYgZGF0YVByb3AgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JvdGggXCJkYXRhXCIgYW5kIFwiZGF0YVByb3BcIiBwYXNzZWQsIG9ubHkgb25lIGFsbG93ZWQnKTtcbiAgICB9XG4gICAgY29uc3QgeyBnZW4gfSA9IGl0O1xuICAgIGlmIChkYXRhUHJvcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHsgZXJyb3JQYXRoLCBkYXRhUGF0aEFyciwgb3B0cyB9ID0gaXQ7XG4gICAgICAgIGNvbnN0IG5leHREYXRhID0gZ2VuLmxldChcImRhdGFcIiwgKDAsIGNvZGVnZW5fMS5fKSBgJHtpdC5kYXRhfSR7KDAsIGNvZGVnZW5fMS5nZXRQcm9wZXJ0eSkoZGF0YVByb3ApfWAsIHRydWUpO1xuICAgICAgICBkYXRhQ29udGV4dFByb3BzKG5leHREYXRhKTtcbiAgICAgICAgc3Vic2NoZW1hLmVycm9yUGF0aCA9ICgwLCBjb2RlZ2VuXzEuc3RyKSBgJHtlcnJvclBhdGh9JHsoMCwgdXRpbF8xLmdldEVycm9yUGF0aCkoZGF0YVByb3AsIGRwVHlwZSwgb3B0cy5qc1Byb3BlcnR5U3ludGF4KX1gO1xuICAgICAgICBzdWJzY2hlbWEucGFyZW50RGF0YVByb3BlcnR5ID0gKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhUHJvcH1gO1xuICAgICAgICBzdWJzY2hlbWEuZGF0YVBhdGhBcnIgPSBbLi4uZGF0YVBhdGhBcnIsIHN1YnNjaGVtYS5wYXJlbnREYXRhUHJvcGVydHldO1xuICAgIH1cbiAgICBpZiAoZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IG5leHREYXRhID0gZGF0YSBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lID8gZGF0YSA6IGdlbi5sZXQoXCJkYXRhXCIsIGRhdGEsIHRydWUpOyAvLyByZXBsYWNlYWJsZSBpZiB1c2VkIG9uY2U/XG4gICAgICAgIGRhdGFDb250ZXh0UHJvcHMobmV4dERhdGEpO1xuICAgICAgICBpZiAocHJvcGVydHlOYW1lICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBzdWJzY2hlbWEucHJvcGVydHlOYW1lID0gcHJvcGVydHlOYW1lO1xuICAgICAgICAvLyBUT0RPIHNvbWV0aGluZyBpcyBwb3NzaWJseSB3cm9uZyBoZXJlIHdpdGggbm90IGNoYW5naW5nIHBhcmVudERhdGFQcm9wZXJ0eSBhbmQgbm90IGFwcGVuZGluZyBkYXRhUGF0aEFyclxuICAgIH1cbiAgICBpZiAoZGF0YVR5cGVzKVxuICAgICAgICBzdWJzY2hlbWEuZGF0YVR5cGVzID0gZGF0YVR5cGVzO1xuICAgIGZ1bmN0aW9uIGRhdGFDb250ZXh0UHJvcHMoX25leHREYXRhKSB7XG4gICAgICAgIHN1YnNjaGVtYS5kYXRhID0gX25leHREYXRhO1xuICAgICAgICBzdWJzY2hlbWEuZGF0YUxldmVsID0gaXQuZGF0YUxldmVsICsgMTtcbiAgICAgICAgc3Vic2NoZW1hLmRhdGFUeXBlcyA9IFtdO1xuICAgICAgICBpdC5kZWZpbmVkUHJvcGVydGllcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgc3Vic2NoZW1hLnBhcmVudERhdGEgPSBpdC5kYXRhO1xuICAgICAgICBzdWJzY2hlbWEuZGF0YU5hbWVzID0gWy4uLml0LmRhdGFOYW1lcywgX25leHREYXRhXTtcbiAgICB9XG59XG5leHBvcnRzLmV4dGVuZFN1YnNjaGVtYURhdGEgPSBleHRlbmRTdWJzY2hlbWFEYXRhO1xuZnVuY3Rpb24gZXh0ZW5kU3Vic2NoZW1hTW9kZShzdWJzY2hlbWEsIHsganRkRGlzY3JpbWluYXRvciwganRkTWV0YWRhdGEsIGNvbXBvc2l0ZVJ1bGUsIGNyZWF0ZUVycm9ycywgYWxsRXJyb3JzIH0pIHtcbiAgICBpZiAoY29tcG9zaXRlUnVsZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICBzdWJzY2hlbWEuY29tcG9zaXRlUnVsZSA9IGNvbXBvc2l0ZVJ1bGU7XG4gICAgaWYgKGNyZWF0ZUVycm9ycyAhPT0gdW5kZWZpbmVkKVxuICAgICAgICBzdWJzY2hlbWEuY3JlYXRlRXJyb3JzID0gY3JlYXRlRXJyb3JzO1xuICAgIGlmIChhbGxFcnJvcnMgIT09IHVuZGVmaW5lZClcbiAgICAgICAgc3Vic2NoZW1hLmFsbEVycm9ycyA9IGFsbEVycm9ycztcbiAgICBzdWJzY2hlbWEuanRkRGlzY3JpbWluYXRvciA9IGp0ZERpc2NyaW1pbmF0b3I7IC8vIG5vdCBpbmhlcml0ZWRcbiAgICBzdWJzY2hlbWEuanRkTWV0YWRhdGEgPSBqdGRNZXRhZGF0YTsgLy8gbm90IGluaGVyaXRlZFxufVxuZXhwb3J0cy5leHRlbmRTdWJzY2hlbWFNb2RlID0gZXh0ZW5kU3Vic2NoZW1hTW9kZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN1YnNjaGVtYS5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbi8vIGRvIG5vdCBlZGl0IC5qcyBmaWxlcyBkaXJlY3RseSAtIGVkaXQgc3JjL2luZGV4LmpzdFxuXG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBlcXVhbChhLCBiKSB7XG4gIGlmIChhID09PSBiKSByZXR1cm4gdHJ1ZTtcblxuICBpZiAoYSAmJiBiICYmIHR5cGVvZiBhID09ICdvYmplY3QnICYmIHR5cGVvZiBiID09ICdvYmplY3QnKSB7XG4gICAgaWYgKGEuY29uc3RydWN0b3IgIT09IGIuY29uc3RydWN0b3IpIHJldHVybiBmYWxzZTtcblxuICAgIHZhciBsZW5ndGgsIGksIGtleXM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYSkpIHtcbiAgICAgIGxlbmd0aCA9IGEubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCAhPSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KVxuICAgICAgICBpZiAoIWVxdWFsKGFbaV0sIGJbaV0pKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cblxuXG4gICAgaWYgKGEuY29uc3RydWN0b3IgPT09IFJlZ0V4cCkgcmV0dXJuIGEuc291cmNlID09PSBiLnNvdXJjZSAmJiBhLmZsYWdzID09PSBiLmZsYWdzO1xuICAgIGlmIChhLnZhbHVlT2YgIT09IE9iamVjdC5wcm90b3R5cGUudmFsdWVPZikgcmV0dXJuIGEudmFsdWVPZigpID09PSBiLnZhbHVlT2YoKTtcbiAgICBpZiAoYS50b1N0cmluZyAhPT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZykgcmV0dXJuIGEudG9TdHJpbmcoKSA9PT0gYi50b1N0cmluZygpO1xuXG4gICAga2V5cyA9IE9iamVjdC5rZXlzKGEpO1xuICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIGlmIChsZW5ndGggIT09IE9iamVjdC5rZXlzKGIpLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KVxuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwga2V5c1tpXSkpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgIGlmICghZXF1YWwoYVtrZXldLCBiW2tleV0pKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyB0cnVlIGlmIGJvdGggTmFOLCBmYWxzZSBvdGhlcndpc2VcbiAgcmV0dXJuIGEhPT1hICYmIGIhPT1iO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHRyYXZlcnNlID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc2NoZW1hLCBvcHRzLCBjYikge1xuICAvLyBMZWdhY3kgc3VwcG9ydCBmb3IgdjAuMy4xIGFuZCBlYXJsaWVyLlxuICBpZiAodHlwZW9mIG9wdHMgPT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gb3B0cztcbiAgICBvcHRzID0ge307XG4gIH1cblxuICBjYiA9IG9wdHMuY2IgfHwgY2I7XG4gIHZhciBwcmUgPSAodHlwZW9mIGNiID09ICdmdW5jdGlvbicpID8gY2IgOiBjYi5wcmUgfHwgZnVuY3Rpb24oKSB7fTtcbiAgdmFyIHBvc3QgPSBjYi5wb3N0IHx8IGZ1bmN0aW9uKCkge307XG5cbiAgX3RyYXZlcnNlKG9wdHMsIHByZSwgcG9zdCwgc2NoZW1hLCAnJywgc2NoZW1hKTtcbn07XG5cblxudHJhdmVyc2Uua2V5d29yZHMgPSB7XG4gIGFkZGl0aW9uYWxJdGVtczogdHJ1ZSxcbiAgaXRlbXM6IHRydWUsXG4gIGNvbnRhaW5zOiB0cnVlLFxuICBhZGRpdGlvbmFsUHJvcGVydGllczogdHJ1ZSxcbiAgcHJvcGVydHlOYW1lczogdHJ1ZSxcbiAgbm90OiB0cnVlLFxuICBpZjogdHJ1ZSxcbiAgdGhlbjogdHJ1ZSxcbiAgZWxzZTogdHJ1ZVxufTtcblxudHJhdmVyc2UuYXJyYXlLZXl3b3JkcyA9IHtcbiAgaXRlbXM6IHRydWUsXG4gIGFsbE9mOiB0cnVlLFxuICBhbnlPZjogdHJ1ZSxcbiAgb25lT2Y6IHRydWVcbn07XG5cbnRyYXZlcnNlLnByb3BzS2V5d29yZHMgPSB7XG4gICRkZWZzOiB0cnVlLFxuICBkZWZpbml0aW9uczogdHJ1ZSxcbiAgcHJvcGVydGllczogdHJ1ZSxcbiAgcGF0dGVyblByb3BlcnRpZXM6IHRydWUsXG4gIGRlcGVuZGVuY2llczogdHJ1ZVxufTtcblxudHJhdmVyc2Uuc2tpcEtleXdvcmRzID0ge1xuICBkZWZhdWx0OiB0cnVlLFxuICBlbnVtOiB0cnVlLFxuICBjb25zdDogdHJ1ZSxcbiAgcmVxdWlyZWQ6IHRydWUsXG4gIG1heGltdW06IHRydWUsXG4gIG1pbmltdW06IHRydWUsXG4gIGV4Y2x1c2l2ZU1heGltdW06IHRydWUsXG4gIGV4Y2x1c2l2ZU1pbmltdW06IHRydWUsXG4gIG11bHRpcGxlT2Y6IHRydWUsXG4gIG1heExlbmd0aDogdHJ1ZSxcbiAgbWluTGVuZ3RoOiB0cnVlLFxuICBwYXR0ZXJuOiB0cnVlLFxuICBmb3JtYXQ6IHRydWUsXG4gIG1heEl0ZW1zOiB0cnVlLFxuICBtaW5JdGVtczogdHJ1ZSxcbiAgdW5pcXVlSXRlbXM6IHRydWUsXG4gIG1heFByb3BlcnRpZXM6IHRydWUsXG4gIG1pblByb3BlcnRpZXM6IHRydWVcbn07XG5cblxuZnVuY3Rpb24gX3RyYXZlcnNlKG9wdHMsIHByZSwgcG9zdCwgc2NoZW1hLCBqc29uUHRyLCByb290U2NoZW1hLCBwYXJlbnRKc29uUHRyLCBwYXJlbnRLZXl3b3JkLCBwYXJlbnRTY2hlbWEsIGtleUluZGV4KSB7XG4gIGlmIChzY2hlbWEgJiYgdHlwZW9mIHNjaGVtYSA9PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShzY2hlbWEpKSB7XG4gICAgcHJlKHNjaGVtYSwganNvblB0ciwgcm9vdFNjaGVtYSwgcGFyZW50SnNvblB0ciwgcGFyZW50S2V5d29yZCwgcGFyZW50U2NoZW1hLCBrZXlJbmRleCk7XG4gICAgZm9yICh2YXIga2V5IGluIHNjaGVtYSkge1xuICAgICAgdmFyIHNjaCA9IHNjaGVtYVtrZXldO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoKSkge1xuICAgICAgICBpZiAoa2V5IGluIHRyYXZlcnNlLmFycmF5S2V5d29yZHMpIHtcbiAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8c2NoLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgX3RyYXZlcnNlKG9wdHMsIHByZSwgcG9zdCwgc2NoW2ldLCBqc29uUHRyICsgJy8nICsga2V5ICsgJy8nICsgaSwgcm9vdFNjaGVtYSwganNvblB0ciwga2V5LCBzY2hlbWEsIGkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGtleSBpbiB0cmF2ZXJzZS5wcm9wc0tleXdvcmRzKSB7XG4gICAgICAgIGlmIChzY2ggJiYgdHlwZW9mIHNjaCA9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gc2NoKVxuICAgICAgICAgICAgX3RyYXZlcnNlKG9wdHMsIHByZSwgcG9zdCwgc2NoW3Byb3BdLCBqc29uUHRyICsgJy8nICsga2V5ICsgJy8nICsgZXNjYXBlSnNvblB0cihwcm9wKSwgcm9vdFNjaGVtYSwganNvblB0ciwga2V5LCBzY2hlbWEsIHByb3ApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGtleSBpbiB0cmF2ZXJzZS5rZXl3b3JkcyB8fCAob3B0cy5hbGxLZXlzICYmICEoa2V5IGluIHRyYXZlcnNlLnNraXBLZXl3b3JkcykpKSB7XG4gICAgICAgIF90cmF2ZXJzZShvcHRzLCBwcmUsIHBvc3QsIHNjaCwganNvblB0ciArICcvJyArIGtleSwgcm9vdFNjaGVtYSwganNvblB0ciwga2V5LCBzY2hlbWEpO1xuICAgICAgfVxuICAgIH1cbiAgICBwb3N0KHNjaGVtYSwganNvblB0ciwgcm9vdFNjaGVtYSwgcGFyZW50SnNvblB0ciwgcGFyZW50S2V5d29yZCwgcGFyZW50U2NoZW1hLCBrZXlJbmRleCk7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBlc2NhcGVKc29uUHRyKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL34vZywgJ34wJykucmVwbGFjZSgvXFwvL2csICd+MScpO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldFNjaGVtYVJlZnMgPSBleHBvcnRzLnJlc29sdmVVcmwgPSBleHBvcnRzLm5vcm1hbGl6ZUlkID0gZXhwb3J0cy5fZ2V0RnVsbFBhdGggPSBleHBvcnRzLmdldEZ1bGxQYXRoID0gZXhwb3J0cy5pbmxpbmVSZWYgPSB2b2lkIDA7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuY29uc3QgZXF1YWwgPSByZXF1aXJlKFwiZmFzdC1kZWVwLWVxdWFsXCIpO1xuY29uc3QgdHJhdmVyc2UgPSByZXF1aXJlKFwianNvbi1zY2hlbWEtdHJhdmVyc2VcIik7XG4vLyBUT0RPIHJlZmFjdG9yIHRvIHVzZSBrZXl3b3JkIGRlZmluaXRpb25zXG5jb25zdCBTSU1QTEVfSU5MSU5FRCA9IG5ldyBTZXQoW1xuICAgIFwidHlwZVwiLFxuICAgIFwiZm9ybWF0XCIsXG4gICAgXCJwYXR0ZXJuXCIsXG4gICAgXCJtYXhMZW5ndGhcIixcbiAgICBcIm1pbkxlbmd0aFwiLFxuICAgIFwibWF4UHJvcGVydGllc1wiLFxuICAgIFwibWluUHJvcGVydGllc1wiLFxuICAgIFwibWF4SXRlbXNcIixcbiAgICBcIm1pbkl0ZW1zXCIsXG4gICAgXCJtYXhpbXVtXCIsXG4gICAgXCJtaW5pbXVtXCIsXG4gICAgXCJ1bmlxdWVJdGVtc1wiLFxuICAgIFwibXVsdGlwbGVPZlwiLFxuICAgIFwicmVxdWlyZWRcIixcbiAgICBcImVudW1cIixcbiAgICBcImNvbnN0XCIsXG5dKTtcbmZ1bmN0aW9uIGlubGluZVJlZihzY2hlbWEsIGxpbWl0ID0gdHJ1ZSkge1xuICAgIGlmICh0eXBlb2Ygc2NoZW1hID09IFwiYm9vbGVhblwiKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAobGltaXQgPT09IHRydWUpXG4gICAgICAgIHJldHVybiAhaGFzUmVmKHNjaGVtYSk7XG4gICAgaWYgKCFsaW1pdClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBjb3VudEtleXMoc2NoZW1hKSA8PSBsaW1pdDtcbn1cbmV4cG9ydHMuaW5saW5lUmVmID0gaW5saW5lUmVmO1xuY29uc3QgUkVGX0tFWVdPUkRTID0gbmV3IFNldChbXG4gICAgXCIkcmVmXCIsXG4gICAgXCIkcmVjdXJzaXZlUmVmXCIsXG4gICAgXCIkcmVjdXJzaXZlQW5jaG9yXCIsXG4gICAgXCIkZHluYW1pY1JlZlwiLFxuICAgIFwiJGR5bmFtaWNBbmNob3JcIixcbl0pO1xuZnVuY3Rpb24gaGFzUmVmKHNjaGVtYSkge1xuICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYSkge1xuICAgICAgICBpZiAoUkVGX0tFWVdPUkRTLmhhcyhrZXkpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGNvbnN0IHNjaCA9IHNjaGVtYVtrZXldO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzY2gpICYmIHNjaC5zb21lKGhhc1JlZikpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBzY2ggPT0gXCJvYmplY3RcIiAmJiBoYXNSZWYoc2NoKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBjb3VudEtleXMoc2NoZW1hKSB7XG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gXCIkcmVmXCIpXG4gICAgICAgICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgICAgIGNvdW50Kys7XG4gICAgICAgIGlmIChTSU1QTEVfSU5MSU5FRC5oYXMoa2V5KSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYVtrZXldID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICgwLCB1dGlsXzEuZWFjaEl0ZW0pKHNjaGVtYVtrZXldLCAoc2NoKSA9PiAoY291bnQgKz0gY291bnRLZXlzKHNjaCkpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY291bnQgPT09IEluZmluaXR5KVxuICAgICAgICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgIH1cbiAgICByZXR1cm4gY291bnQ7XG59XG5mdW5jdGlvbiBnZXRGdWxsUGF0aChyZXNvbHZlciwgaWQgPSBcIlwiLCBub3JtYWxpemUpIHtcbiAgICBpZiAobm9ybWFsaXplICE9PSBmYWxzZSlcbiAgICAgICAgaWQgPSBub3JtYWxpemVJZChpZCk7XG4gICAgY29uc3QgcCA9IHJlc29sdmVyLnBhcnNlKGlkKTtcbiAgICByZXR1cm4gX2dldEZ1bGxQYXRoKHJlc29sdmVyLCBwKTtcbn1cbmV4cG9ydHMuZ2V0RnVsbFBhdGggPSBnZXRGdWxsUGF0aDtcbmZ1bmN0aW9uIF9nZXRGdWxsUGF0aChyZXNvbHZlciwgcCkge1xuICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSByZXNvbHZlci5zZXJpYWxpemUocCk7XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWQuc3BsaXQoXCIjXCIpWzBdICsgXCIjXCI7XG59XG5leHBvcnRzLl9nZXRGdWxsUGF0aCA9IF9nZXRGdWxsUGF0aDtcbmNvbnN0IFRSQUlMSU5HX1NMQVNIX0hBU0ggPSAvI1xcLz8kLztcbmZ1bmN0aW9uIG5vcm1hbGl6ZUlkKGlkKSB7XG4gICAgcmV0dXJuIGlkID8gaWQucmVwbGFjZShUUkFJTElOR19TTEFTSF9IQVNILCBcIlwiKSA6IFwiXCI7XG59XG5leHBvcnRzLm5vcm1hbGl6ZUlkID0gbm9ybWFsaXplSWQ7XG5mdW5jdGlvbiByZXNvbHZlVXJsKHJlc29sdmVyLCBiYXNlSWQsIGlkKSB7XG4gICAgaWQgPSBub3JtYWxpemVJZChpZCk7XG4gICAgcmV0dXJuIHJlc29sdmVyLnJlc29sdmUoYmFzZUlkLCBpZCk7XG59XG5leHBvcnRzLnJlc29sdmVVcmwgPSByZXNvbHZlVXJsO1xuY29uc3QgQU5DSE9SID0gL15bYS16X11bLWEtejAtOS5fXSokL2k7XG5mdW5jdGlvbiBnZXRTY2hlbWFSZWZzKHNjaGVtYSwgYmFzZUlkKSB7XG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJib29sZWFuXCIpXG4gICAgICAgIHJldHVybiB7fTtcbiAgICBjb25zdCB7IHNjaGVtYUlkLCB1cmlSZXNvbHZlciB9ID0gdGhpcy5vcHRzO1xuICAgIGNvbnN0IHNjaElkID0gbm9ybWFsaXplSWQoc2NoZW1hW3NjaGVtYUlkXSB8fCBiYXNlSWQpO1xuICAgIGNvbnN0IGJhc2VJZHMgPSB7IFwiXCI6IHNjaElkIH07XG4gICAgY29uc3QgcGF0aFByZWZpeCA9IGdldEZ1bGxQYXRoKHVyaVJlc29sdmVyLCBzY2hJZCwgZmFsc2UpO1xuICAgIGNvbnN0IGxvY2FsUmVmcyA9IHt9O1xuICAgIGNvbnN0IHNjaGVtYVJlZnMgPSBuZXcgU2V0KCk7XG4gICAgdHJhdmVyc2Uoc2NoZW1hLCB7IGFsbEtleXM6IHRydWUgfSwgKHNjaCwganNvblB0ciwgXywgcGFyZW50SnNvblB0cikgPT4ge1xuICAgICAgICBpZiAocGFyZW50SnNvblB0ciA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBmdWxsUGF0aCA9IHBhdGhQcmVmaXggKyBqc29uUHRyO1xuICAgICAgICBsZXQgaW5uZXJCYXNlSWQgPSBiYXNlSWRzW3BhcmVudEpzb25QdHJdO1xuICAgICAgICBpZiAodHlwZW9mIHNjaFtzY2hlbWFJZF0gPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIGlubmVyQmFzZUlkID0gYWRkUmVmLmNhbGwodGhpcywgc2NoW3NjaGVtYUlkXSk7XG4gICAgICAgIGFkZEFuY2hvci5jYWxsKHRoaXMsIHNjaC4kYW5jaG9yKTtcbiAgICAgICAgYWRkQW5jaG9yLmNhbGwodGhpcywgc2NoLiRkeW5hbWljQW5jaG9yKTtcbiAgICAgICAgYmFzZUlkc1tqc29uUHRyXSA9IGlubmVyQmFzZUlkO1xuICAgICAgICBmdW5jdGlvbiBhZGRSZWYocmVmKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3VuYm91bmQtbWV0aG9kXG4gICAgICAgICAgICBjb25zdCBfcmVzb2x2ZSA9IHRoaXMub3B0cy51cmlSZXNvbHZlci5yZXNvbHZlO1xuICAgICAgICAgICAgcmVmID0gbm9ybWFsaXplSWQoaW5uZXJCYXNlSWQgPyBfcmVzb2x2ZShpbm5lckJhc2VJZCwgcmVmKSA6IHJlZik7XG4gICAgICAgICAgICBpZiAoc2NoZW1hUmVmcy5oYXMocmVmKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBhbWJpZ3VvcyhyZWYpO1xuICAgICAgICAgICAgc2NoZW1hUmVmcy5hZGQocmVmKTtcbiAgICAgICAgICAgIGxldCBzY2hPclJlZiA9IHRoaXMucmVmc1tyZWZdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzY2hPclJlZiA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgIHNjaE9yUmVmID0gdGhpcy5yZWZzW3NjaE9yUmVmXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NoT3JSZWYgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIGNoZWNrQW1iaWd1b3NSZWYoc2NoLCBzY2hPclJlZi5zY2hlbWEsIHJlZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyZWYgIT09IG5vcm1hbGl6ZUlkKGZ1bGxQYXRoKSkge1xuICAgICAgICAgICAgICAgIGlmIChyZWZbMF0gPT09IFwiI1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrQW1iaWd1b3NSZWYoc2NoLCBsb2NhbFJlZnNbcmVmXSwgcmVmKTtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxSZWZzW3JlZl0gPSBzY2g7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZnNbcmVmXSA9IGZ1bGxQYXRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZWY7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYWRkQW5jaG9yKGFuY2hvcikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBhbmNob3IgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGlmICghQU5DSE9SLnRlc3QoYW5jaG9yKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGFuY2hvciBcIiR7YW5jaG9yfVwiYCk7XG4gICAgICAgICAgICAgICAgYWRkUmVmLmNhbGwodGhpcywgYCMke2FuY2hvcn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBsb2NhbFJlZnM7XG4gICAgZnVuY3Rpb24gY2hlY2tBbWJpZ3Vvc1JlZihzY2gxLCBzY2gyLCByZWYpIHtcbiAgICAgICAgaWYgKHNjaDIgIT09IHVuZGVmaW5lZCAmJiAhZXF1YWwoc2NoMSwgc2NoMikpXG4gICAgICAgICAgICB0aHJvdyBhbWJpZ3VvcyhyZWYpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhbWJpZ3VvcyhyZWYpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihgcmVmZXJlbmNlIFwiJHtyZWZ9XCIgcmVzb2x2ZXMgdG8gbW9yZSB0aGFuIG9uZSBzY2hlbWFgKTtcbiAgICB9XG59XG5leHBvcnRzLmdldFNjaGVtYVJlZnMgPSBnZXRTY2hlbWFSZWZzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzb2x2ZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0RGF0YSA9IGV4cG9ydHMuS2V5d29yZEN4dCA9IGV4cG9ydHMudmFsaWRhdGVGdW5jdGlvbkNvZGUgPSB2b2lkIDA7XG5jb25zdCBib29sU2NoZW1hXzEgPSByZXF1aXJlKFwiLi9ib29sU2NoZW1hXCIpO1xuY29uc3QgZGF0YVR5cGVfMSA9IHJlcXVpcmUoXCIuL2RhdGFUeXBlXCIpO1xuY29uc3QgYXBwbGljYWJpbGl0eV8xID0gcmVxdWlyZShcIi4vYXBwbGljYWJpbGl0eVwiKTtcbmNvbnN0IGRhdGFUeXBlXzIgPSByZXF1aXJlKFwiLi9kYXRhVHlwZVwiKTtcbmNvbnN0IGRlZmF1bHRzXzEgPSByZXF1aXJlKFwiLi9kZWZhdWx0c1wiKTtcbmNvbnN0IGtleXdvcmRfMSA9IHJlcXVpcmUoXCIuL2tleXdvcmRcIik7XG5jb25zdCBzdWJzY2hlbWFfMSA9IHJlcXVpcmUoXCIuL3N1YnNjaGVtYVwiKTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi9jb2RlZ2VuXCIpO1xuY29uc3QgbmFtZXNfMSA9IHJlcXVpcmUoXCIuLi9uYW1lc1wiKTtcbmNvbnN0IHJlc29sdmVfMSA9IHJlcXVpcmUoXCIuLi9yZXNvbHZlXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuLi9lcnJvcnNcIik7XG4vLyBzY2hlbWEgY29tcGlsYXRpb24gLSBnZW5lcmF0ZXMgdmFsaWRhdGlvbiBmdW5jdGlvbiwgc3Vic2NoZW1hQ29kZSAoYmVsb3cpIGlzIHVzZWQgZm9yIHN1YnNjaGVtYXNcbmZ1bmN0aW9uIHZhbGlkYXRlRnVuY3Rpb25Db2RlKGl0KSB7XG4gICAgaWYgKGlzU2NoZW1hT2JqKGl0KSkge1xuICAgICAgICBjaGVja0tleXdvcmRzKGl0KTtcbiAgICAgICAgaWYgKHNjaGVtYUN4dEhhc1J1bGVzKGl0KSkge1xuICAgICAgICAgICAgdG9wU2NoZW1hT2JqQ29kZShpdCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFsaWRhdGVGdW5jdGlvbihpdCwgKCkgPT4gKDAsIGJvb2xTY2hlbWFfMS50b3BCb29sT3JFbXB0eVNjaGVtYSkoaXQpKTtcbn1cbmV4cG9ydHMudmFsaWRhdGVGdW5jdGlvbkNvZGUgPSB2YWxpZGF0ZUZ1bmN0aW9uQ29kZTtcbmZ1bmN0aW9uIHZhbGlkYXRlRnVuY3Rpb24oeyBnZW4sIHZhbGlkYXRlTmFtZSwgc2NoZW1hLCBzY2hlbWFFbnYsIG9wdHMgfSwgYm9keSkge1xuICAgIGlmIChvcHRzLmNvZGUuZXM1KSB7XG4gICAgICAgIGdlbi5mdW5jKHZhbGlkYXRlTmFtZSwgKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQuZGF0YX0sICR7bmFtZXNfMS5kZWZhdWx0LnZhbEN4dH1gLCBzY2hlbWFFbnYuJGFzeW5jLCAoKSA9PiB7XG4gICAgICAgICAgICBnZW4uY29kZSgoMCwgY29kZWdlbl8xLl8pIGBcInVzZSBzdHJpY3RcIjsgJHtmdW5jU291cmNlVXJsKHNjaGVtYSwgb3B0cyl9YCk7XG4gICAgICAgICAgICBkZXN0cnVjdHVyZVZhbEN4dEVTNShnZW4sIG9wdHMpO1xuICAgICAgICAgICAgZ2VuLmNvZGUoYm9keSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZ2VuLmZ1bmModmFsaWRhdGVOYW1lLCAoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC5kYXRhfSwgJHtkZXN0cnVjdHVyZVZhbEN4dChvcHRzKX1gLCBzY2hlbWFFbnYuJGFzeW5jLCAoKSA9PiBnZW4uY29kZShmdW5jU291cmNlVXJsKHNjaGVtYSwgb3B0cykpLmNvZGUoYm9keSkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRlc3RydWN0dXJlVmFsQ3h0KG9wdHMpIHtcbiAgICByZXR1cm4gKDAsIGNvZGVnZW5fMS5fKSBgeyR7bmFtZXNfMS5kZWZhdWx0Lmluc3RhbmNlUGF0aH09XCJcIiwgJHtuYW1lc18xLmRlZmF1bHQucGFyZW50RGF0YX0sICR7bmFtZXNfMS5kZWZhdWx0LnBhcmVudERhdGFQcm9wZXJ0eX0sICR7bmFtZXNfMS5kZWZhdWx0LnJvb3REYXRhfT0ke25hbWVzXzEuZGVmYXVsdC5kYXRhfSR7b3B0cy5keW5hbWljUmVmID8gKDAsIGNvZGVnZW5fMS5fKSBgLCAke25hbWVzXzEuZGVmYXVsdC5keW5hbWljQW5jaG9yc309e31gIDogY29kZWdlbl8xLm5pbH19PXt9YDtcbn1cbmZ1bmN0aW9uIGRlc3RydWN0dXJlVmFsQ3h0RVM1KGdlbiwgb3B0cykge1xuICAgIGdlbi5pZihuYW1lc18xLmRlZmF1bHQudmFsQ3h0LCAoKSA9PiB7XG4gICAgICAgIGdlbi52YXIobmFtZXNfMS5kZWZhdWx0Lmluc3RhbmNlUGF0aCwgKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQudmFsQ3h0fS4ke25hbWVzXzEuZGVmYXVsdC5pbnN0YW5jZVBhdGh9YCk7XG4gICAgICAgIGdlbi52YXIobmFtZXNfMS5kZWZhdWx0LnBhcmVudERhdGEsICgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LnZhbEN4dH0uJHtuYW1lc18xLmRlZmF1bHQucGFyZW50RGF0YX1gKTtcbiAgICAgICAgZ2VuLnZhcihuYW1lc18xLmRlZmF1bHQucGFyZW50RGF0YVByb3BlcnR5LCAoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC52YWxDeHR9LiR7bmFtZXNfMS5kZWZhdWx0LnBhcmVudERhdGFQcm9wZXJ0eX1gKTtcbiAgICAgICAgZ2VuLnZhcihuYW1lc18xLmRlZmF1bHQucm9vdERhdGEsICgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LnZhbEN4dH0uJHtuYW1lc18xLmRlZmF1bHQucm9vdERhdGF9YCk7XG4gICAgICAgIGlmIChvcHRzLmR5bmFtaWNSZWYpXG4gICAgICAgICAgICBnZW4udmFyKG5hbWVzXzEuZGVmYXVsdC5keW5hbWljQW5jaG9ycywgKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQudmFsQ3h0fS4ke25hbWVzXzEuZGVmYXVsdC5keW5hbWljQW5jaG9yc31gKTtcbiAgICB9LCAoKSA9PiB7XG4gICAgICAgIGdlbi52YXIobmFtZXNfMS5kZWZhdWx0Lmluc3RhbmNlUGF0aCwgKDAsIGNvZGVnZW5fMS5fKSBgXCJcImApO1xuICAgICAgICBnZW4udmFyKG5hbWVzXzEuZGVmYXVsdC5wYXJlbnREYXRhLCAoMCwgY29kZWdlbl8xLl8pIGB1bmRlZmluZWRgKTtcbiAgICAgICAgZ2VuLnZhcihuYW1lc18xLmRlZmF1bHQucGFyZW50RGF0YVByb3BlcnR5LCAoMCwgY29kZWdlbl8xLl8pIGB1bmRlZmluZWRgKTtcbiAgICAgICAgZ2VuLnZhcihuYW1lc18xLmRlZmF1bHQucm9vdERhdGEsIG5hbWVzXzEuZGVmYXVsdC5kYXRhKTtcbiAgICAgICAgaWYgKG9wdHMuZHluYW1pY1JlZilcbiAgICAgICAgICAgIGdlbi52YXIobmFtZXNfMS5kZWZhdWx0LmR5bmFtaWNBbmNob3JzLCAoMCwgY29kZWdlbl8xLl8pIGB7fWApO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gdG9wU2NoZW1hT2JqQ29kZShpdCkge1xuICAgIGNvbnN0IHsgc2NoZW1hLCBvcHRzLCBnZW4gfSA9IGl0O1xuICAgIHZhbGlkYXRlRnVuY3Rpb24oaXQsICgpID0+IHtcbiAgICAgICAgaWYgKG9wdHMuJGNvbW1lbnQgJiYgc2NoZW1hLiRjb21tZW50KVxuICAgICAgICAgICAgY29tbWVudEtleXdvcmQoaXQpO1xuICAgICAgICBjaGVja05vRGVmYXVsdChpdCk7XG4gICAgICAgIGdlbi5sZXQobmFtZXNfMS5kZWZhdWx0LnZFcnJvcnMsIG51bGwpO1xuICAgICAgICBnZW4ubGV0KG5hbWVzXzEuZGVmYXVsdC5lcnJvcnMsIDApO1xuICAgICAgICBpZiAob3B0cy51bmV2YWx1YXRlZClcbiAgICAgICAgICAgIHJlc2V0RXZhbHVhdGVkKGl0KTtcbiAgICAgICAgdHlwZUFuZEtleXdvcmRzKGl0KTtcbiAgICAgICAgcmV0dXJuUmVzdWx0cyhpdCk7XG4gICAgfSk7XG4gICAgcmV0dXJuO1xufVxuZnVuY3Rpb24gcmVzZXRFdmFsdWF0ZWQoaXQpIHtcbiAgICAvLyBUT0RPIG1heWJlIHNvbWUgaG9vayB0byBleGVjdXRlIGl0IGluIHRoZSBlbmQgdG8gY2hlY2sgd2hldGhlciBwcm9wcy9pdGVtcyBhcmUgTmFtZSwgYXMgaW4gYXNzaWduRXZhbHVhdGVkXG4gICAgY29uc3QgeyBnZW4sIHZhbGlkYXRlTmFtZSB9ID0gaXQ7XG4gICAgaXQuZXZhbHVhdGVkID0gZ2VuLmNvbnN0KFwiZXZhbHVhdGVkXCIsICgwLCBjb2RlZ2VuXzEuXykgYCR7dmFsaWRhdGVOYW1lfS5ldmFsdWF0ZWRgKTtcbiAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtpdC5ldmFsdWF0ZWR9LmR5bmFtaWNQcm9wc2AsICgpID0+IGdlbi5hc3NpZ24oKDAsIGNvZGVnZW5fMS5fKSBgJHtpdC5ldmFsdWF0ZWR9LnByb3BzYCwgKDAsIGNvZGVnZW5fMS5fKSBgdW5kZWZpbmVkYCkpO1xuICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke2l0LmV2YWx1YXRlZH0uZHluYW1pY0l0ZW1zYCwgKCkgPT4gZ2VuLmFzc2lnbigoMCwgY29kZWdlbl8xLl8pIGAke2l0LmV2YWx1YXRlZH0uaXRlbXNgLCAoMCwgY29kZWdlbl8xLl8pIGB1bmRlZmluZWRgKSk7XG59XG5mdW5jdGlvbiBmdW5jU291cmNlVXJsKHNjaGVtYSwgb3B0cykge1xuICAgIGNvbnN0IHNjaElkID0gdHlwZW9mIHNjaGVtYSA9PSBcIm9iamVjdFwiICYmIHNjaGVtYVtvcHRzLnNjaGVtYUlkXTtcbiAgICByZXR1cm4gc2NoSWQgJiYgKG9wdHMuY29kZS5zb3VyY2UgfHwgb3B0cy5jb2RlLnByb2Nlc3MpID8gKDAsIGNvZGVnZW5fMS5fKSBgLyojIHNvdXJjZVVSTD0ke3NjaElkfSAqL2AgOiBjb2RlZ2VuXzEubmlsO1xufVxuLy8gc2NoZW1hIGNvbXBpbGF0aW9uIC0gdGhpcyBmdW5jdGlvbiBpcyB1c2VkIHJlY3Vyc2l2ZWx5IHRvIGdlbmVyYXRlIGNvZGUgZm9yIHN1Yi1zY2hlbWFzXG5mdW5jdGlvbiBzdWJzY2hlbWFDb2RlKGl0LCB2YWxpZCkge1xuICAgIGlmIChpc1NjaGVtYU9iaihpdCkpIHtcbiAgICAgICAgY2hlY2tLZXl3b3JkcyhpdCk7XG4gICAgICAgIGlmIChzY2hlbWFDeHRIYXNSdWxlcyhpdCkpIHtcbiAgICAgICAgICAgIHN1YlNjaGVtYU9iakNvZGUoaXQsIHZhbGlkKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAoMCwgYm9vbFNjaGVtYV8xLmJvb2xPckVtcHR5U2NoZW1hKShpdCwgdmFsaWQpO1xufVxuZnVuY3Rpb24gc2NoZW1hQ3h0SGFzUnVsZXMoeyBzY2hlbWEsIHNlbGYgfSkge1xuICAgIGlmICh0eXBlb2Ygc2NoZW1hID09IFwiYm9vbGVhblwiKVxuICAgICAgICByZXR1cm4gIXNjaGVtYTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpXG4gICAgICAgIGlmIChzZWxmLlJVTEVTLmFsbFtrZXldKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNTY2hlbWFPYmooaXQpIHtcbiAgICByZXR1cm4gdHlwZW9mIGl0LnNjaGVtYSAhPSBcImJvb2xlYW5cIjtcbn1cbmZ1bmN0aW9uIHN1YlNjaGVtYU9iakNvZGUoaXQsIHZhbGlkKSB7XG4gICAgY29uc3QgeyBzY2hlbWEsIGdlbiwgb3B0cyB9ID0gaXQ7XG4gICAgaWYgKG9wdHMuJGNvbW1lbnQgJiYgc2NoZW1hLiRjb21tZW50KVxuICAgICAgICBjb21tZW50S2V5d29yZChpdCk7XG4gICAgdXBkYXRlQ29udGV4dChpdCk7XG4gICAgY2hlY2tBc3luY1NjaGVtYShpdCk7XG4gICAgY29uc3QgZXJyc0NvdW50ID0gZ2VuLmNvbnN0KFwiX2VycnNcIiwgbmFtZXNfMS5kZWZhdWx0LmVycm9ycyk7XG4gICAgdHlwZUFuZEtleXdvcmRzKGl0LCBlcnJzQ291bnQpO1xuICAgIC8vIFRPRE8gdmFyXG4gICAgZ2VuLnZhcih2YWxpZCwgKDAsIGNvZGVnZW5fMS5fKSBgJHtlcnJzQ291bnR9ID09PSAke25hbWVzXzEuZGVmYXVsdC5lcnJvcnN9YCk7XG59XG5mdW5jdGlvbiBjaGVja0tleXdvcmRzKGl0KSB7XG4gICAgKDAsIHV0aWxfMS5jaGVja1Vua25vd25SdWxlcykoaXQpO1xuICAgIGNoZWNrUmVmc0FuZEtleXdvcmRzKGl0KTtcbn1cbmZ1bmN0aW9uIHR5cGVBbmRLZXl3b3JkcyhpdCwgZXJyc0NvdW50KSB7XG4gICAgaWYgKGl0Lm9wdHMuanRkKVxuICAgICAgICByZXR1cm4gc2NoZW1hS2V5d29yZHMoaXQsIFtdLCBmYWxzZSwgZXJyc0NvdW50KTtcbiAgICBjb25zdCB0eXBlcyA9ICgwLCBkYXRhVHlwZV8xLmdldFNjaGVtYVR5cGVzKShpdC5zY2hlbWEpO1xuICAgIGNvbnN0IGNoZWNrZWRUeXBlcyA9ICgwLCBkYXRhVHlwZV8xLmNvZXJjZUFuZENoZWNrRGF0YVR5cGUpKGl0LCB0eXBlcyk7XG4gICAgc2NoZW1hS2V5d29yZHMoaXQsIHR5cGVzLCAhY2hlY2tlZFR5cGVzLCBlcnJzQ291bnQpO1xufVxuZnVuY3Rpb24gY2hlY2tSZWZzQW5kS2V5d29yZHMoaXQpIHtcbiAgICBjb25zdCB7IHNjaGVtYSwgZXJyU2NoZW1hUGF0aCwgb3B0cywgc2VsZiB9ID0gaXQ7XG4gICAgaWYgKHNjaGVtYS4kcmVmICYmIG9wdHMuaWdub3JlS2V5d29yZHNXaXRoUmVmICYmICgwLCB1dGlsXzEuc2NoZW1hSGFzUnVsZXNCdXRSZWYpKHNjaGVtYSwgc2VsZi5SVUxFUykpIHtcbiAgICAgICAgc2VsZi5sb2dnZXIud2FybihgJHJlZjoga2V5d29yZHMgaWdub3JlZCBpbiBzY2hlbWEgYXQgcGF0aCBcIiR7ZXJyU2NoZW1hUGF0aH1cImApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrTm9EZWZhdWx0KGl0KSB7XG4gICAgY29uc3QgeyBzY2hlbWEsIG9wdHMgfSA9IGl0O1xuICAgIGlmIChzY2hlbWEuZGVmYXVsdCAhPT0gdW5kZWZpbmVkICYmIG9wdHMudXNlRGVmYXVsdHMgJiYgb3B0cy5zdHJpY3RTY2hlbWEpIHtcbiAgICAgICAgKDAsIHV0aWxfMS5jaGVja1N0cmljdE1vZGUpKGl0LCBcImRlZmF1bHQgaXMgaWdub3JlZCBpbiB0aGUgc2NoZW1hIHJvb3RcIik7XG4gICAgfVxufVxuZnVuY3Rpb24gdXBkYXRlQ29udGV4dChpdCkge1xuICAgIGNvbnN0IHNjaElkID0gaXQuc2NoZW1hW2l0Lm9wdHMuc2NoZW1hSWRdO1xuICAgIGlmIChzY2hJZClcbiAgICAgICAgaXQuYmFzZUlkID0gKDAsIHJlc29sdmVfMS5yZXNvbHZlVXJsKShpdC5vcHRzLnVyaVJlc29sdmVyLCBpdC5iYXNlSWQsIHNjaElkKTtcbn1cbmZ1bmN0aW9uIGNoZWNrQXN5bmNTY2hlbWEoaXQpIHtcbiAgICBpZiAoaXQuc2NoZW1hLiRhc3luYyAmJiAhaXQuc2NoZW1hRW52LiRhc3luYylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXN5bmMgc2NoZW1hIGluIHN5bmMgc2NoZW1hXCIpO1xufVxuZnVuY3Rpb24gY29tbWVudEtleXdvcmQoeyBnZW4sIHNjaGVtYUVudiwgc2NoZW1hLCBlcnJTY2hlbWFQYXRoLCBvcHRzIH0pIHtcbiAgICBjb25zdCBtc2cgPSBzY2hlbWEuJGNvbW1lbnQ7XG4gICAgaWYgKG9wdHMuJGNvbW1lbnQgPT09IHRydWUpIHtcbiAgICAgICAgZ2VuLmNvZGUoKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQuc2VsZn0ubG9nZ2VyLmxvZygke21zZ30pYCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBvcHRzLiRjb21tZW50ID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjb25zdCBzY2hlbWFQYXRoID0gKDAsIGNvZGVnZW5fMS5zdHIpIGAke2VyclNjaGVtYVBhdGh9LyRjb21tZW50YDtcbiAgICAgICAgY29uc3Qgcm9vdE5hbWUgPSBnZW4uc2NvcGVWYWx1ZShcInJvb3RcIiwgeyByZWY6IHNjaGVtYUVudi5yb290IH0pO1xuICAgICAgICBnZW4uY29kZSgoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC5zZWxmfS5vcHRzLiRjb21tZW50KCR7bXNnfSwgJHtzY2hlbWFQYXRofSwgJHtyb290TmFtZX0uc2NoZW1hKWApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJldHVyblJlc3VsdHMoaXQpIHtcbiAgICBjb25zdCB7IGdlbiwgc2NoZW1hRW52LCB2YWxpZGF0ZU5hbWUsIFZhbGlkYXRpb25FcnJvciwgb3B0cyB9ID0gaXQ7XG4gICAgaWYgKHNjaGVtYUVudi4kYXN5bmMpIHtcbiAgICAgICAgLy8gVE9ETyBhc3NpZ24gdW5ldmFsdWF0ZWRcbiAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LmVycm9yc30gPT09IDBgLCAoKSA9PiBnZW4ucmV0dXJuKG5hbWVzXzEuZGVmYXVsdC5kYXRhKSwgKCkgPT4gZ2VuLnRocm93KCgwLCBjb2RlZ2VuXzEuXykgYG5ldyAke1ZhbGlkYXRpb25FcnJvcn0oJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc30pYCkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZ2VuLmFzc2lnbigoMCwgY29kZWdlbl8xLl8pIGAke3ZhbGlkYXRlTmFtZX0uZXJyb3JzYCwgbmFtZXNfMS5kZWZhdWx0LnZFcnJvcnMpO1xuICAgICAgICBpZiAob3B0cy51bmV2YWx1YXRlZClcbiAgICAgICAgICAgIGFzc2lnbkV2YWx1YXRlZChpdCk7XG4gICAgICAgIGdlbi5yZXR1cm4oKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQuZXJyb3JzfSA9PT0gMGApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFzc2lnbkV2YWx1YXRlZCh7IGdlbiwgZXZhbHVhdGVkLCBwcm9wcywgaXRlbXMgfSkge1xuICAgIGlmIChwcm9wcyBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lKVxuICAgICAgICBnZW4uYXNzaWduKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZXZhbHVhdGVkfS5wcm9wc2AsIHByb3BzKTtcbiAgICBpZiAoaXRlbXMgaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZSlcbiAgICAgICAgZ2VuLmFzc2lnbigoMCwgY29kZWdlbl8xLl8pIGAke2V2YWx1YXRlZH0uaXRlbXNgLCBpdGVtcyk7XG59XG5mdW5jdGlvbiBzY2hlbWFLZXl3b3JkcyhpdCwgdHlwZXMsIHR5cGVFcnJvcnMsIGVycnNDb3VudCkge1xuICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWEsIGRhdGEsIGFsbEVycm9ycywgb3B0cywgc2VsZiB9ID0gaXQ7XG4gICAgY29uc3QgeyBSVUxFUyB9ID0gc2VsZjtcbiAgICBpZiAoc2NoZW1hLiRyZWYgJiYgKG9wdHMuaWdub3JlS2V5d29yZHNXaXRoUmVmIHx8ICEoMCwgdXRpbF8xLnNjaGVtYUhhc1J1bGVzQnV0UmVmKShzY2hlbWEsIFJVTEVTKSkpIHtcbiAgICAgICAgZ2VuLmJsb2NrKCgpID0+IGtleXdvcmRDb2RlKGl0LCBcIiRyZWZcIiwgUlVMRVMuYWxsLiRyZWYuZGVmaW5pdGlvbikpOyAvLyBUT0RPIHR5cGVjYXN0XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFvcHRzLmp0ZClcbiAgICAgICAgY2hlY2tTdHJpY3RUeXBlcyhpdCwgdHlwZXMpO1xuICAgIGdlbi5ibG9jaygoKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgZ3JvdXAgb2YgUlVMRVMucnVsZXMpXG4gICAgICAgICAgICBncm91cEtleXdvcmRzKGdyb3VwKTtcbiAgICAgICAgZ3JvdXBLZXl3b3JkcyhSVUxFUy5wb3N0KTtcbiAgICB9KTtcbiAgICBmdW5jdGlvbiBncm91cEtleXdvcmRzKGdyb3VwKSB7XG4gICAgICAgIGlmICghKDAsIGFwcGxpY2FiaWxpdHlfMS5zaG91bGRVc2VHcm91cCkoc2NoZW1hLCBncm91cCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChncm91cC50eXBlKSB7XG4gICAgICAgICAgICBnZW4uaWYoKDAsIGRhdGFUeXBlXzIuY2hlY2tEYXRhVHlwZSkoZ3JvdXAudHlwZSwgZGF0YSwgb3B0cy5zdHJpY3ROdW1iZXJzKSk7XG4gICAgICAgICAgICBpdGVyYXRlS2V5d29yZHMoaXQsIGdyb3VwKTtcbiAgICAgICAgICAgIGlmICh0eXBlcy5sZW5ndGggPT09IDEgJiYgdHlwZXNbMF0gPT09IGdyb3VwLnR5cGUgJiYgdHlwZUVycm9ycykge1xuICAgICAgICAgICAgICAgIGdlbi5lbHNlKCk7XG4gICAgICAgICAgICAgICAgKDAsIGRhdGFUeXBlXzIucmVwb3J0VHlwZUVycm9yKShpdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnZW4uZW5kSWYoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGl0ZXJhdGVLZXl3b3JkcyhpdCwgZ3JvdXApO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE8gbWFrZSBpdCBcIm9rXCIgY2FsbD9cbiAgICAgICAgaWYgKCFhbGxFcnJvcnMpXG4gICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQuZXJyb3JzfSA9PT0gJHtlcnJzQ291bnQgfHwgMH1gKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpdGVyYXRlS2V5d29yZHMoaXQsIGdyb3VwKSB7XG4gICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgb3B0czogeyB1c2VEZWZhdWx0cyB9LCB9ID0gaXQ7XG4gICAgaWYgKHVzZURlZmF1bHRzKVxuICAgICAgICAoMCwgZGVmYXVsdHNfMS5hc3NpZ25EZWZhdWx0cykoaXQsIGdyb3VwLnR5cGUpO1xuICAgIGdlbi5ibG9jaygoKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgcnVsZSBvZiBncm91cC5ydWxlcykge1xuICAgICAgICAgICAgaWYgKCgwLCBhcHBsaWNhYmlsaXR5XzEuc2hvdWxkVXNlUnVsZSkoc2NoZW1hLCBydWxlKSkge1xuICAgICAgICAgICAgICAgIGtleXdvcmRDb2RlKGl0LCBydWxlLmtleXdvcmQsIHJ1bGUuZGVmaW5pdGlvbiwgZ3JvdXAudHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGNoZWNrU3RyaWN0VHlwZXMoaXQsIHR5cGVzKSB7XG4gICAgaWYgKGl0LnNjaGVtYUVudi5tZXRhIHx8ICFpdC5vcHRzLnN0cmljdFR5cGVzKVxuICAgICAgICByZXR1cm47XG4gICAgY2hlY2tDb250ZXh0VHlwZXMoaXQsIHR5cGVzKTtcbiAgICBpZiAoIWl0Lm9wdHMuYWxsb3dVbmlvblR5cGVzKVxuICAgICAgICBjaGVja011bHRpcGxlVHlwZXMoaXQsIHR5cGVzKTtcbiAgICBjaGVja0tleXdvcmRUeXBlcyhpdCwgaXQuZGF0YVR5cGVzKTtcbn1cbmZ1bmN0aW9uIGNoZWNrQ29udGV4dFR5cGVzKGl0LCB0eXBlcykge1xuICAgIGlmICghdHlwZXMubGVuZ3RoKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKCFpdC5kYXRhVHlwZXMubGVuZ3RoKSB7XG4gICAgICAgIGl0LmRhdGFUeXBlcyA9IHR5cGVzO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHR5cGVzLmZvckVhY2goKHQpID0+IHtcbiAgICAgICAgaWYgKCFpbmNsdWRlc1R5cGUoaXQuZGF0YVR5cGVzLCB0KSkge1xuICAgICAgICAgICAgc3RyaWN0VHlwZXNFcnJvcihpdCwgYHR5cGUgXCIke3R9XCIgbm90IGFsbG93ZWQgYnkgY29udGV4dCBcIiR7aXQuZGF0YVR5cGVzLmpvaW4oXCIsXCIpfVwiYCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBuYXJyb3dTY2hlbWFUeXBlcyhpdCwgdHlwZXMpO1xufVxuZnVuY3Rpb24gY2hlY2tNdWx0aXBsZVR5cGVzKGl0LCB0cykge1xuICAgIGlmICh0cy5sZW5ndGggPiAxICYmICEodHMubGVuZ3RoID09PSAyICYmIHRzLmluY2x1ZGVzKFwibnVsbFwiKSkpIHtcbiAgICAgICAgc3RyaWN0VHlwZXNFcnJvcihpdCwgXCJ1c2UgYWxsb3dVbmlvblR5cGVzIHRvIGFsbG93IHVuaW9uIHR5cGUga2V5d29yZFwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjaGVja0tleXdvcmRUeXBlcyhpdCwgdHMpIHtcbiAgICBjb25zdCBydWxlcyA9IGl0LnNlbGYuUlVMRVMuYWxsO1xuICAgIGZvciAoY29uc3Qga2V5d29yZCBpbiBydWxlcykge1xuICAgICAgICBjb25zdCBydWxlID0gcnVsZXNba2V5d29yZF07XG4gICAgICAgIGlmICh0eXBlb2YgcnVsZSA9PSBcIm9iamVjdFwiICYmICgwLCBhcHBsaWNhYmlsaXR5XzEuc2hvdWxkVXNlUnVsZSkoaXQuc2NoZW1hLCBydWxlKSkge1xuICAgICAgICAgICAgY29uc3QgeyB0eXBlIH0gPSBydWxlLmRlZmluaXRpb247XG4gICAgICAgICAgICBpZiAodHlwZS5sZW5ndGggJiYgIXR5cGUuc29tZSgodCkgPT4gaGFzQXBwbGljYWJsZVR5cGUodHMsIHQpKSkge1xuICAgICAgICAgICAgICAgIHN0cmljdFR5cGVzRXJyb3IoaXQsIGBtaXNzaW5nIHR5cGUgXCIke3R5cGUuam9pbihcIixcIil9XCIgZm9yIGtleXdvcmQgXCIke2tleXdvcmR9XCJgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGhhc0FwcGxpY2FibGVUeXBlKHNjaFRzLCBrd2RUKSB7XG4gICAgcmV0dXJuIHNjaFRzLmluY2x1ZGVzKGt3ZFQpIHx8IChrd2RUID09PSBcIm51bWJlclwiICYmIHNjaFRzLmluY2x1ZGVzKFwiaW50ZWdlclwiKSk7XG59XG5mdW5jdGlvbiBpbmNsdWRlc1R5cGUodHMsIHQpIHtcbiAgICByZXR1cm4gdHMuaW5jbHVkZXModCkgfHwgKHQgPT09IFwiaW50ZWdlclwiICYmIHRzLmluY2x1ZGVzKFwibnVtYmVyXCIpKTtcbn1cbmZ1bmN0aW9uIG5hcnJvd1NjaGVtYVR5cGVzKGl0LCB3aXRoVHlwZXMpIHtcbiAgICBjb25zdCB0cyA9IFtdO1xuICAgIGZvciAoY29uc3QgdCBvZiBpdC5kYXRhVHlwZXMpIHtcbiAgICAgICAgaWYgKGluY2x1ZGVzVHlwZSh3aXRoVHlwZXMsIHQpKVxuICAgICAgICAgICAgdHMucHVzaCh0KTtcbiAgICAgICAgZWxzZSBpZiAod2l0aFR5cGVzLmluY2x1ZGVzKFwiaW50ZWdlclwiKSAmJiB0ID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgdHMucHVzaChcImludGVnZXJcIik7XG4gICAgfVxuICAgIGl0LmRhdGFUeXBlcyA9IHRzO1xufVxuZnVuY3Rpb24gc3RyaWN0VHlwZXNFcnJvcihpdCwgbXNnKSB7XG4gICAgY29uc3Qgc2NoZW1hUGF0aCA9IGl0LnNjaGVtYUVudi5iYXNlSWQgKyBpdC5lcnJTY2hlbWFQYXRoO1xuICAgIG1zZyArPSBgIGF0IFwiJHtzY2hlbWFQYXRofVwiIChzdHJpY3RUeXBlcylgO1xuICAgICgwLCB1dGlsXzEuY2hlY2tTdHJpY3RNb2RlKShpdCwgbXNnLCBpdC5vcHRzLnN0cmljdFR5cGVzKTtcbn1cbmNsYXNzIEtleXdvcmRDeHQge1xuICAgIGNvbnN0cnVjdG9yKGl0LCBkZWYsIGtleXdvcmQpIHtcbiAgICAgICAgKDAsIGtleXdvcmRfMS52YWxpZGF0ZUtleXdvcmRVc2FnZSkoaXQsIGRlZiwga2V5d29yZCk7XG4gICAgICAgIHRoaXMuZ2VuID0gaXQuZ2VuO1xuICAgICAgICB0aGlzLmFsbEVycm9ycyA9IGl0LmFsbEVycm9ycztcbiAgICAgICAgdGhpcy5rZXl3b3JkID0ga2V5d29yZDtcbiAgICAgICAgdGhpcy5kYXRhID0gaXQuZGF0YTtcbiAgICAgICAgdGhpcy5zY2hlbWEgPSBpdC5zY2hlbWFba2V5d29yZF07XG4gICAgICAgIHRoaXMuJGRhdGEgPSBkZWYuJGRhdGEgJiYgaXQub3B0cy4kZGF0YSAmJiB0aGlzLnNjaGVtYSAmJiB0aGlzLnNjaGVtYS4kZGF0YTtcbiAgICAgICAgdGhpcy5zY2hlbWFWYWx1ZSA9ICgwLCB1dGlsXzEuc2NoZW1hUmVmT3JWYWwpKGl0LCB0aGlzLnNjaGVtYSwga2V5d29yZCwgdGhpcy4kZGF0YSk7XG4gICAgICAgIHRoaXMuc2NoZW1hVHlwZSA9IGRlZi5zY2hlbWFUeXBlO1xuICAgICAgICB0aGlzLnBhcmVudFNjaGVtYSA9IGl0LnNjaGVtYTtcbiAgICAgICAgdGhpcy5wYXJhbXMgPSB7fTtcbiAgICAgICAgdGhpcy5pdCA9IGl0O1xuICAgICAgICB0aGlzLmRlZiA9IGRlZjtcbiAgICAgICAgaWYgKHRoaXMuJGRhdGEpIHtcbiAgICAgICAgICAgIHRoaXMuc2NoZW1hQ29kZSA9IGl0Lmdlbi5jb25zdChcInZTY2hlbWFcIiwgZ2V0RGF0YSh0aGlzLiRkYXRhLCBpdCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zY2hlbWFDb2RlID0gdGhpcy5zY2hlbWFWYWx1ZTtcbiAgICAgICAgICAgIGlmICghKDAsIGtleXdvcmRfMS52YWxpZFNjaGVtYVR5cGUpKHRoaXMuc2NoZW1hLCBkZWYuc2NoZW1hVHlwZSwgZGVmLmFsbG93VW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtrZXl3b3JkfSB2YWx1ZSBtdXN0IGJlICR7SlNPTi5zdHJpbmdpZnkoZGVmLnNjaGVtYVR5cGUpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChcImNvZGVcIiBpbiBkZWYgPyBkZWYudHJhY2tFcnJvcnMgOiBkZWYuZXJyb3JzICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5lcnJzQ291bnQgPSBpdC5nZW4uY29uc3QoXCJfZXJyc1wiLCBuYW1lc18xLmRlZmF1bHQuZXJyb3JzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQoY29uZGl0aW9uLCBzdWNjZXNzQWN0aW9uLCBmYWlsQWN0aW9uKSB7XG4gICAgICAgIHRoaXMuZmFpbFJlc3VsdCgoMCwgY29kZWdlbl8xLm5vdCkoY29uZGl0aW9uKSwgc3VjY2Vzc0FjdGlvbiwgZmFpbEFjdGlvbik7XG4gICAgfVxuICAgIGZhaWxSZXN1bHQoY29uZGl0aW9uLCBzdWNjZXNzQWN0aW9uLCBmYWlsQWN0aW9uKSB7XG4gICAgICAgIHRoaXMuZ2VuLmlmKGNvbmRpdGlvbik7XG4gICAgICAgIGlmIChmYWlsQWN0aW9uKVxuICAgICAgICAgICAgZmFpbEFjdGlvbigpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLmVycm9yKCk7XG4gICAgICAgIGlmIChzdWNjZXNzQWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmdlbi5lbHNlKCk7XG4gICAgICAgICAgICBzdWNjZXNzQWN0aW9uKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5hbGxFcnJvcnMpXG4gICAgICAgICAgICAgICAgdGhpcy5nZW4uZW5kSWYoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFsbEVycm9ycylcbiAgICAgICAgICAgICAgICB0aGlzLmdlbi5lbmRJZigpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMuZ2VuLmVsc2UoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwYXNzKGNvbmRpdGlvbiwgZmFpbEFjdGlvbikge1xuICAgICAgICB0aGlzLmZhaWxSZXN1bHQoKDAsIGNvZGVnZW5fMS5ub3QpKGNvbmRpdGlvbiksIHVuZGVmaW5lZCwgZmFpbEFjdGlvbik7XG4gICAgfVxuICAgIGZhaWwoY29uZGl0aW9uKSB7XG4gICAgICAgIGlmIChjb25kaXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5lcnJvcigpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmFsbEVycm9ycylcbiAgICAgICAgICAgICAgICB0aGlzLmdlbi5pZihmYWxzZSk7IC8vIHRoaXMgYnJhbmNoIHdpbGwgYmUgcmVtb3ZlZCBieSBnZW4ub3B0aW1pemVcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdlbi5pZihjb25kaXRpb24pO1xuICAgICAgICB0aGlzLmVycm9yKCk7XG4gICAgICAgIGlmICh0aGlzLmFsbEVycm9ycylcbiAgICAgICAgICAgIHRoaXMuZ2VuLmVuZElmKCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuZ2VuLmVsc2UoKTtcbiAgICB9XG4gICAgZmFpbCRkYXRhKGNvbmRpdGlvbikge1xuICAgICAgICBpZiAoIXRoaXMuJGRhdGEpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mYWlsKGNvbmRpdGlvbik7XG4gICAgICAgIGNvbnN0IHsgc2NoZW1hQ29kZSB9ID0gdGhpcztcbiAgICAgICAgdGhpcy5mYWlsKCgwLCBjb2RlZ2VuXzEuXykgYCR7c2NoZW1hQ29kZX0gIT09IHVuZGVmaW5lZCAmJiAoJHsoMCwgY29kZWdlbl8xLm9yKSh0aGlzLmludmFsaWQkZGF0YSgpLCBjb25kaXRpb24pfSlgKTtcbiAgICB9XG4gICAgZXJyb3IoYXBwZW5kLCBlcnJvclBhcmFtcywgZXJyb3JQYXRocykge1xuICAgICAgICBpZiAoZXJyb3JQYXJhbXMpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0UGFyYW1zKGVycm9yUGFyYW1zKTtcbiAgICAgICAgICAgIHRoaXMuX2Vycm9yKGFwcGVuZCwgZXJyb3JQYXRocyk7XG4gICAgICAgICAgICB0aGlzLnNldFBhcmFtcyh7fSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZXJyb3IoYXBwZW5kLCBlcnJvclBhdGhzKTtcbiAgICB9XG4gICAgX2Vycm9yKGFwcGVuZCwgZXJyb3JQYXRocykge1xuICAgICAgICA7XG4gICAgICAgIChhcHBlbmQgPyBlcnJvcnNfMS5yZXBvcnRFeHRyYUVycm9yIDogZXJyb3JzXzEucmVwb3J0RXJyb3IpKHRoaXMsIHRoaXMuZGVmLmVycm9yLCBlcnJvclBhdGhzKTtcbiAgICB9XG4gICAgJGRhdGFFcnJvcigpIHtcbiAgICAgICAgKDAsIGVycm9yc18xLnJlcG9ydEVycm9yKSh0aGlzLCB0aGlzLmRlZi4kZGF0YUVycm9yIHx8IGVycm9yc18xLmtleXdvcmQkRGF0YUVycm9yKTtcbiAgICB9XG4gICAgcmVzZXQoKSB7XG4gICAgICAgIGlmICh0aGlzLmVycnNDb3VudCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhZGQgXCJ0cmFja0Vycm9yc1wiIHRvIGtleXdvcmQgZGVmaW5pdGlvbicpO1xuICAgICAgICAoMCwgZXJyb3JzXzEucmVzZXRFcnJvcnNDb3VudCkodGhpcy5nZW4sIHRoaXMuZXJyc0NvdW50KTtcbiAgICB9XG4gICAgb2soY29uZCkge1xuICAgICAgICBpZiAoIXRoaXMuYWxsRXJyb3JzKVxuICAgICAgICAgICAgdGhpcy5nZW4uaWYoY29uZCk7XG4gICAgfVxuICAgIHNldFBhcmFtcyhvYmosIGFzc2lnbikge1xuICAgICAgICBpZiAoYXNzaWduKVxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLnBhcmFtcywgb2JqKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5wYXJhbXMgPSBvYmo7XG4gICAgfVxuICAgIGJsb2NrJGRhdGEodmFsaWQsIGNvZGVCbG9jaywgJGRhdGFWYWxpZCA9IGNvZGVnZW5fMS5uaWwpIHtcbiAgICAgICAgdGhpcy5nZW4uYmxvY2soKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jaGVjayRkYXRhKHZhbGlkLCAkZGF0YVZhbGlkKTtcbiAgICAgICAgICAgIGNvZGVCbG9jaygpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2hlY2skZGF0YSh2YWxpZCA9IGNvZGVnZW5fMS5uaWwsICRkYXRhVmFsaWQgPSBjb2RlZ2VuXzEubmlsKSB7XG4gICAgICAgIGlmICghdGhpcy4kZGF0YSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYUNvZGUsIHNjaGVtYVR5cGUsIGRlZiB9ID0gdGhpcztcbiAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEub3IpKCgwLCBjb2RlZ2VuXzEuXykgYCR7c2NoZW1hQ29kZX0gPT09IHVuZGVmaW5lZGAsICRkYXRhVmFsaWQpKTtcbiAgICAgICAgaWYgKHZhbGlkICE9PSBjb2RlZ2VuXzEubmlsKVxuICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgdHJ1ZSk7XG4gICAgICAgIGlmIChzY2hlbWFUeXBlLmxlbmd0aCB8fCBkZWYudmFsaWRhdGVTY2hlbWEpIHtcbiAgICAgICAgICAgIGdlbi5lbHNlSWYodGhpcy5pbnZhbGlkJGRhdGEoKSk7XG4gICAgICAgICAgICB0aGlzLiRkYXRhRXJyb3IoKTtcbiAgICAgICAgICAgIGlmICh2YWxpZCAhPT0gY29kZWdlbl8xLm5pbClcbiAgICAgICAgICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZ2VuLmVsc2UoKTtcbiAgICB9XG4gICAgaW52YWxpZCRkYXRhKCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgc2NoZW1hQ29kZSwgc2NoZW1hVHlwZSwgZGVmLCBpdCB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEub3IpKHdyb25nJERhdGFUeXBlKCksIGludmFsaWQkRGF0YVNjaGVtYSgpKTtcbiAgICAgICAgZnVuY3Rpb24gd3JvbmckRGF0YVR5cGUoKSB7XG4gICAgICAgICAgICBpZiAoc2NoZW1hVHlwZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgICBpZiAoIShzY2hlbWFDb2RlIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWUpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhanYgaW1wbGVtZW50YXRpb24gZXJyb3JcIik7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3QgPSBBcnJheS5pc0FycmF5KHNjaGVtYVR5cGUpID8gc2NoZW1hVHlwZSA6IFtzY2hlbWFUeXBlXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGNvZGVnZW5fMS5fKSBgJHsoMCwgZGF0YVR5cGVfMi5jaGVja0RhdGFUeXBlcykoc3QsIHNjaGVtYUNvZGUsIGl0Lm9wdHMuc3RyaWN0TnVtYmVycywgZGF0YVR5cGVfMi5EYXRhVHlwZS5Xcm9uZyl9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb2RlZ2VuXzEubmlsO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGludmFsaWQkRGF0YVNjaGVtYSgpIHtcbiAgICAgICAgICAgIGlmIChkZWYudmFsaWRhdGVTY2hlbWEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWxpZGF0ZVNjaGVtYVJlZiA9IGdlbi5zY29wZVZhbHVlKFwidmFsaWRhdGUkZGF0YVwiLCB7IHJlZjogZGVmLnZhbGlkYXRlU2NoZW1hIH0pOyAvLyBUT0RPIHZhbHVlLmNvZGUgZm9yIHN0YW5kYWxvbmVcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGNvZGVnZW5fMS5fKSBgISR7dmFsaWRhdGVTY2hlbWFSZWZ9KCR7c2NoZW1hQ29kZX0pYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb2RlZ2VuXzEubmlsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN1YnNjaGVtYShhcHBsLCB2YWxpZCkge1xuICAgICAgICBjb25zdCBzdWJzY2hlbWEgPSAoMCwgc3Vic2NoZW1hXzEuZ2V0U3Vic2NoZW1hKSh0aGlzLml0LCBhcHBsKTtcbiAgICAgICAgKDAsIHN1YnNjaGVtYV8xLmV4dGVuZFN1YnNjaGVtYURhdGEpKHN1YnNjaGVtYSwgdGhpcy5pdCwgYXBwbCk7XG4gICAgICAgICgwLCBzdWJzY2hlbWFfMS5leHRlbmRTdWJzY2hlbWFNb2RlKShzdWJzY2hlbWEsIGFwcGwpO1xuICAgICAgICBjb25zdCBuZXh0Q29udGV4dCA9IHsgLi4udGhpcy5pdCwgLi4uc3Vic2NoZW1hLCBpdGVtczogdW5kZWZpbmVkLCBwcm9wczogdW5kZWZpbmVkIH07XG4gICAgICAgIHN1YnNjaGVtYUNvZGUobmV4dENvbnRleHQsIHZhbGlkKTtcbiAgICAgICAgcmV0dXJuIG5leHRDb250ZXh0O1xuICAgIH1cbiAgICBtZXJnZUV2YWx1YXRlZChzY2hlbWFDeHQsIHRvTmFtZSkge1xuICAgICAgICBjb25zdCB7IGl0LCBnZW4gfSA9IHRoaXM7XG4gICAgICAgIGlmICghaXQub3B0cy51bmV2YWx1YXRlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKGl0LnByb3BzICE9PSB0cnVlICYmIHNjaGVtYUN4dC5wcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpdC5wcm9wcyA9IHV0aWxfMS5tZXJnZUV2YWx1YXRlZC5wcm9wcyhnZW4sIHNjaGVtYUN4dC5wcm9wcywgaXQucHJvcHMsIHRvTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGl0Lml0ZW1zICE9PSB0cnVlICYmIHNjaGVtYUN4dC5pdGVtcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpdC5pdGVtcyA9IHV0aWxfMS5tZXJnZUV2YWx1YXRlZC5pdGVtcyhnZW4sIHNjaGVtYUN4dC5pdGVtcywgaXQuaXRlbXMsIHRvTmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWVyZ2VWYWxpZEV2YWx1YXRlZChzY2hlbWFDeHQsIHZhbGlkKSB7XG4gICAgICAgIGNvbnN0IHsgaXQsIGdlbiB9ID0gdGhpcztcbiAgICAgICAgaWYgKGl0Lm9wdHMudW5ldmFsdWF0ZWQgJiYgKGl0LnByb3BzICE9PSB0cnVlIHx8IGl0Lml0ZW1zICE9PSB0cnVlKSkge1xuICAgICAgICAgICAgZ2VuLmlmKHZhbGlkLCAoKSA9PiB0aGlzLm1lcmdlRXZhbHVhdGVkKHNjaGVtYUN4dCwgY29kZWdlbl8xLk5hbWUpKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5LZXl3b3JkQ3h0ID0gS2V5d29yZEN4dDtcbmZ1bmN0aW9uIGtleXdvcmRDb2RlKGl0LCBrZXl3b3JkLCBkZWYsIHJ1bGVUeXBlKSB7XG4gICAgY29uc3QgY3h0ID0gbmV3IEtleXdvcmRDeHQoaXQsIGRlZiwga2V5d29yZCk7XG4gICAgaWYgKFwiY29kZVwiIGluIGRlZikge1xuICAgICAgICBkZWYuY29kZShjeHQsIHJ1bGVUeXBlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY3h0LiRkYXRhICYmIGRlZi52YWxpZGF0ZSkge1xuICAgICAgICAoMCwga2V5d29yZF8xLmZ1bmNLZXl3b3JkQ29kZSkoY3h0LCBkZWYpO1xuICAgIH1cbiAgICBlbHNlIGlmIChcIm1hY3JvXCIgaW4gZGVmKSB7XG4gICAgICAgICgwLCBrZXl3b3JkXzEubWFjcm9LZXl3b3JkQ29kZSkoY3h0LCBkZWYpO1xuICAgIH1cbiAgICBlbHNlIGlmIChkZWYuY29tcGlsZSB8fCBkZWYudmFsaWRhdGUpIHtcbiAgICAgICAgKDAsIGtleXdvcmRfMS5mdW5jS2V5d29yZENvZGUpKGN4dCwgZGVmKTtcbiAgICB9XG59XG5jb25zdCBKU09OX1BPSU5URVIgPSAvXlxcLyg/Oltefl18fjB8fjEpKiQvO1xuY29uc3QgUkVMQVRJVkVfSlNPTl9QT0lOVEVSID0gL14oWzAtOV0rKSgjfFxcLyg/Oltefl18fjB8fjEpKik/JC87XG5mdW5jdGlvbiBnZXREYXRhKCRkYXRhLCB7IGRhdGFMZXZlbCwgZGF0YU5hbWVzLCBkYXRhUGF0aEFyciB9KSB7XG4gICAgbGV0IGpzb25Qb2ludGVyO1xuICAgIGxldCBkYXRhO1xuICAgIGlmICgkZGF0YSA9PT0gXCJcIilcbiAgICAgICAgcmV0dXJuIG5hbWVzXzEuZGVmYXVsdC5yb290RGF0YTtcbiAgICBpZiAoJGRhdGFbMF0gPT09IFwiL1wiKSB7XG4gICAgICAgIGlmICghSlNPTl9QT0lOVEVSLnRlc3QoJGRhdGEpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIEpTT04tcG9pbnRlcjogJHskZGF0YX1gKTtcbiAgICAgICAganNvblBvaW50ZXIgPSAkZGF0YTtcbiAgICAgICAgZGF0YSA9IG5hbWVzXzEuZGVmYXVsdC5yb290RGF0YTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IG1hdGNoZXMgPSBSRUxBVElWRV9KU09OX1BPSU5URVIuZXhlYygkZGF0YSk7XG4gICAgICAgIGlmICghbWF0Y2hlcylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBKU09OLXBvaW50ZXI6ICR7JGRhdGF9YCk7XG4gICAgICAgIGNvbnN0IHVwID0gK21hdGNoZXNbMV07XG4gICAgICAgIGpzb25Qb2ludGVyID0gbWF0Y2hlc1syXTtcbiAgICAgICAgaWYgKGpzb25Qb2ludGVyID09PSBcIiNcIikge1xuICAgICAgICAgICAgaWYgKHVwID49IGRhdGFMZXZlbClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNc2coXCJwcm9wZXJ0eS9pbmRleFwiLCB1cCkpO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGFQYXRoQXJyW2RhdGFMZXZlbCAtIHVwXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXAgPiBkYXRhTGV2ZWwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNc2coXCJkYXRhXCIsIHVwKSk7XG4gICAgICAgIGRhdGEgPSBkYXRhTmFtZXNbZGF0YUxldmVsIC0gdXBdO1xuICAgICAgICBpZiAoIWpzb25Qb2ludGVyKVxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGxldCBleHByID0gZGF0YTtcbiAgICBjb25zdCBzZWdtZW50cyA9IGpzb25Qb2ludGVyLnNwbGl0KFwiL1wiKTtcbiAgICBmb3IgKGNvbnN0IHNlZ21lbnQgb2Ygc2VnbWVudHMpIHtcbiAgICAgICAgaWYgKHNlZ21lbnQpIHtcbiAgICAgICAgICAgIGRhdGEgPSAoMCwgY29kZWdlbl8xLl8pIGAke2RhdGF9JHsoMCwgY29kZWdlbl8xLmdldFByb3BlcnR5KSgoMCwgdXRpbF8xLnVuZXNjYXBlSnNvblBvaW50ZXIpKHNlZ21lbnQpKX1gO1xuICAgICAgICAgICAgZXhwciA9ICgwLCBjb2RlZ2VuXzEuXykgYCR7ZXhwcn0gJiYgJHtkYXRhfWA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGV4cHI7XG4gICAgZnVuY3Rpb24gZXJyb3JNc2cocG9pbnRlclR5cGUsIHVwKSB7XG4gICAgICAgIHJldHVybiBgQ2Fubm90IGFjY2VzcyAke3BvaW50ZXJUeXBlfSAke3VwfSBsZXZlbHMgdXAsIGN1cnJlbnQgbGV2ZWwgaXMgJHtkYXRhTGV2ZWx9YDtcbiAgICB9XG59XG5leHBvcnRzLmdldERhdGEgPSBnZXREYXRhO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jbGFzcyBWYWxpZGF0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoZXJyb3JzKSB7XG4gICAgICAgIHN1cGVyKFwidmFsaWRhdGlvbiBmYWlsZWRcIik7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgICB0aGlzLmFqdiA9IHRoaXMudmFsaWRhdGlvbiA9IHRydWU7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gVmFsaWRhdGlvbkVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmFsaWRhdGlvbl9lcnJvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHJlc29sdmVfMSA9IHJlcXVpcmUoXCIuL3Jlc29sdmVcIik7XG5jbGFzcyBNaXNzaW5nUmVmRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IocmVzb2x2ZXIsIGJhc2VJZCwgcmVmLCBtc2cpIHtcbiAgICAgICAgc3VwZXIobXNnIHx8IGBjYW4ndCByZXNvbHZlIHJlZmVyZW5jZSAke3JlZn0gZnJvbSBpZCAke2Jhc2VJZH1gKTtcbiAgICAgICAgdGhpcy5taXNzaW5nUmVmID0gKDAsIHJlc29sdmVfMS5yZXNvbHZlVXJsKShyZXNvbHZlciwgYmFzZUlkLCByZWYpO1xuICAgICAgICB0aGlzLm1pc3NpbmdTY2hlbWEgPSAoMCwgcmVzb2x2ZV8xLm5vcm1hbGl6ZUlkKSgoMCwgcmVzb2x2ZV8xLmdldEZ1bGxQYXRoKShyZXNvbHZlciwgdGhpcy5taXNzaW5nUmVmKSk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gTWlzc2luZ1JlZkVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVmX2Vycm9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yZXNvbHZlU2NoZW1hID0gZXhwb3J0cy5nZXRDb21waWxpbmdTY2hlbWEgPSBleHBvcnRzLnJlc29sdmVSZWYgPSBleHBvcnRzLmNvbXBpbGVTY2hlbWEgPSBleHBvcnRzLlNjaGVtYUVudiA9IHZvaWQgMDtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuL2NvZGVnZW5cIik7XG5jb25zdCB2YWxpZGF0aW9uX2Vycm9yXzEgPSByZXF1aXJlKFwiLi4vcnVudGltZS92YWxpZGF0aW9uX2Vycm9yXCIpO1xuY29uc3QgbmFtZXNfMSA9IHJlcXVpcmUoXCIuL25hbWVzXCIpO1xuY29uc3QgcmVzb2x2ZV8xID0gcmVxdWlyZShcIi4vcmVzb2x2ZVwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5jb25zdCB2YWxpZGF0ZV8xID0gcmVxdWlyZShcIi4vdmFsaWRhdGVcIik7XG5jbGFzcyBTY2hlbWFFbnYge1xuICAgIGNvbnN0cnVjdG9yKGVudikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMucmVmcyA9IHt9O1xuICAgICAgICB0aGlzLmR5bmFtaWNBbmNob3JzID0ge307XG4gICAgICAgIGxldCBzY2hlbWE7XG4gICAgICAgIGlmICh0eXBlb2YgZW52LnNjaGVtYSA9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgc2NoZW1hID0gZW52LnNjaGVtYTtcbiAgICAgICAgdGhpcy5zY2hlbWEgPSBlbnYuc2NoZW1hO1xuICAgICAgICB0aGlzLnNjaGVtYUlkID0gZW52LnNjaGVtYUlkO1xuICAgICAgICB0aGlzLnJvb3QgPSBlbnYucm9vdCB8fCB0aGlzO1xuICAgICAgICB0aGlzLmJhc2VJZCA9IChfYSA9IGVudi5iYXNlSWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICgwLCByZXNvbHZlXzEubm9ybWFsaXplSWQpKHNjaGVtYSA9PT0gbnVsbCB8fCBzY2hlbWEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNjaGVtYVtlbnYuc2NoZW1hSWQgfHwgXCIkaWRcIl0pO1xuICAgICAgICB0aGlzLnNjaGVtYVBhdGggPSBlbnYuc2NoZW1hUGF0aDtcbiAgICAgICAgdGhpcy5sb2NhbFJlZnMgPSBlbnYubG9jYWxSZWZzO1xuICAgICAgICB0aGlzLm1ldGEgPSBlbnYubWV0YTtcbiAgICAgICAgdGhpcy4kYXN5bmMgPSBzY2hlbWEgPT09IG51bGwgfHwgc2NoZW1hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzY2hlbWEuJGFzeW5jO1xuICAgICAgICB0aGlzLnJlZnMgPSB7fTtcbiAgICB9XG59XG5leHBvcnRzLlNjaGVtYUVudiA9IFNjaGVtYUVudjtcbi8vIGxldCBjb2RlU2l6ZSA9IDBcbi8vIGxldCBub2RlQ291bnQgPSAwXG4vLyBDb21waWxlcyBzY2hlbWEgaW4gU2NoZW1hRW52XG5mdW5jdGlvbiBjb21waWxlU2NoZW1hKHNjaCkge1xuICAgIC8vIFRPRE8gcmVmYWN0b3IgLSByZW1vdmUgY29tcGlsYXRpb25zXG4gICAgY29uc3QgX3NjaCA9IGdldENvbXBpbGluZ1NjaGVtYS5jYWxsKHRoaXMsIHNjaCk7XG4gICAgaWYgKF9zY2gpXG4gICAgICAgIHJldHVybiBfc2NoO1xuICAgIGNvbnN0IHJvb3RJZCA9ICgwLCByZXNvbHZlXzEuZ2V0RnVsbFBhdGgpKHRoaXMub3B0cy51cmlSZXNvbHZlciwgc2NoLnJvb3QuYmFzZUlkKTsgLy8gVE9ETyBpZiBnZXRGdWxsUGF0aCByZW1vdmVkIDEgdGVzdHMgZmFpbHNcbiAgICBjb25zdCB7IGVzNSwgbGluZXMgfSA9IHRoaXMub3B0cy5jb2RlO1xuICAgIGNvbnN0IHsgb3duUHJvcGVydGllcyB9ID0gdGhpcy5vcHRzO1xuICAgIGNvbnN0IGdlbiA9IG5ldyBjb2RlZ2VuXzEuQ29kZUdlbih0aGlzLnNjb3BlLCB7IGVzNSwgbGluZXMsIG93blByb3BlcnRpZXMgfSk7XG4gICAgbGV0IF9WYWxpZGF0aW9uRXJyb3I7XG4gICAgaWYgKHNjaC4kYXN5bmMpIHtcbiAgICAgICAgX1ZhbGlkYXRpb25FcnJvciA9IGdlbi5zY29wZVZhbHVlKFwiRXJyb3JcIiwge1xuICAgICAgICAgICAgcmVmOiB2YWxpZGF0aW9uX2Vycm9yXzEuZGVmYXVsdCxcbiAgICAgICAgICAgIGNvZGU6ICgwLCBjb2RlZ2VuXzEuXykgYHJlcXVpcmUoXCJhanYvZGlzdC9ydW50aW1lL3ZhbGlkYXRpb25fZXJyb3JcIikuZGVmYXVsdGAsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCB2YWxpZGF0ZU5hbWUgPSBnZW4uc2NvcGVOYW1lKFwidmFsaWRhdGVcIik7XG4gICAgc2NoLnZhbGlkYXRlTmFtZSA9IHZhbGlkYXRlTmFtZTtcbiAgICBjb25zdCBzY2hlbWFDeHQgPSB7XG4gICAgICAgIGdlbixcbiAgICAgICAgYWxsRXJyb3JzOiB0aGlzLm9wdHMuYWxsRXJyb3JzLFxuICAgICAgICBkYXRhOiBuYW1lc18xLmRlZmF1bHQuZGF0YSxcbiAgICAgICAgcGFyZW50RGF0YTogbmFtZXNfMS5kZWZhdWx0LnBhcmVudERhdGEsXG4gICAgICAgIHBhcmVudERhdGFQcm9wZXJ0eTogbmFtZXNfMS5kZWZhdWx0LnBhcmVudERhdGFQcm9wZXJ0eSxcbiAgICAgICAgZGF0YU5hbWVzOiBbbmFtZXNfMS5kZWZhdWx0LmRhdGFdLFxuICAgICAgICBkYXRhUGF0aEFycjogW2NvZGVnZW5fMS5uaWxdLCAvLyBUT0RPIGNhbiBpdHMgbGVuZ3RoIGJlIHVzZWQgYXMgZGF0YUxldmVsIGlmIG5pbCBpcyByZW1vdmVkP1xuICAgICAgICBkYXRhTGV2ZWw6IDAsXG4gICAgICAgIGRhdGFUeXBlczogW10sXG4gICAgICAgIGRlZmluZWRQcm9wZXJ0aWVzOiBuZXcgU2V0KCksXG4gICAgICAgIHRvcFNjaGVtYVJlZjogZ2VuLnNjb3BlVmFsdWUoXCJzY2hlbWFcIiwgdGhpcy5vcHRzLmNvZGUuc291cmNlID09PSB0cnVlXG4gICAgICAgICAgICA/IHsgcmVmOiBzY2guc2NoZW1hLCBjb2RlOiAoMCwgY29kZWdlbl8xLnN0cmluZ2lmeSkoc2NoLnNjaGVtYSkgfVxuICAgICAgICAgICAgOiB7IHJlZjogc2NoLnNjaGVtYSB9KSxcbiAgICAgICAgdmFsaWRhdGVOYW1lLFxuICAgICAgICBWYWxpZGF0aW9uRXJyb3I6IF9WYWxpZGF0aW9uRXJyb3IsXG4gICAgICAgIHNjaGVtYTogc2NoLnNjaGVtYSxcbiAgICAgICAgc2NoZW1hRW52OiBzY2gsXG4gICAgICAgIHJvb3RJZCxcbiAgICAgICAgYmFzZUlkOiBzY2guYmFzZUlkIHx8IHJvb3RJZCxcbiAgICAgICAgc2NoZW1hUGF0aDogY29kZWdlbl8xLm5pbCxcbiAgICAgICAgZXJyU2NoZW1hUGF0aDogc2NoLnNjaGVtYVBhdGggfHwgKHRoaXMub3B0cy5qdGQgPyBcIlwiIDogXCIjXCIpLFxuICAgICAgICBlcnJvclBhdGg6ICgwLCBjb2RlZ2VuXzEuXykgYFwiXCJgLFxuICAgICAgICBvcHRzOiB0aGlzLm9wdHMsXG4gICAgICAgIHNlbGY6IHRoaXMsXG4gICAgfTtcbiAgICBsZXQgc291cmNlQ29kZTtcbiAgICB0cnkge1xuICAgICAgICB0aGlzLl9jb21waWxhdGlvbnMuYWRkKHNjaCk7XG4gICAgICAgICgwLCB2YWxpZGF0ZV8xLnZhbGlkYXRlRnVuY3Rpb25Db2RlKShzY2hlbWFDeHQpO1xuICAgICAgICBnZW4ub3B0aW1pemUodGhpcy5vcHRzLmNvZGUub3B0aW1pemUpO1xuICAgICAgICAvLyBnZW4ub3B0aW1pemUoMSlcbiAgICAgICAgY29uc3QgdmFsaWRhdGVDb2RlID0gZ2VuLnRvU3RyaW5nKCk7XG4gICAgICAgIHNvdXJjZUNvZGUgPSBgJHtnZW4uc2NvcGVSZWZzKG5hbWVzXzEuZGVmYXVsdC5zY29wZSl9cmV0dXJuICR7dmFsaWRhdGVDb2RlfWA7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKChjb2RlU2l6ZSArPSBzb3VyY2VDb2RlLmxlbmd0aCksIChub2RlQ291bnQgKz0gZ2VuLm5vZGVDb3VudCkpXG4gICAgICAgIGlmICh0aGlzLm9wdHMuY29kZS5wcm9jZXNzKVxuICAgICAgICAgICAgc291cmNlQ29kZSA9IHRoaXMub3B0cy5jb2RlLnByb2Nlc3Moc291cmNlQ29kZSwgc2NoKTtcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJcXG5cXG5cXG4gKioqIFxcblwiLCBzb3VyY2VDb2RlKVxuICAgICAgICBjb25zdCBtYWtlVmFsaWRhdGUgPSBuZXcgRnVuY3Rpb24oYCR7bmFtZXNfMS5kZWZhdWx0LnNlbGZ9YCwgYCR7bmFtZXNfMS5kZWZhdWx0LnNjb3BlfWAsIHNvdXJjZUNvZGUpO1xuICAgICAgICBjb25zdCB2YWxpZGF0ZSA9IG1ha2VWYWxpZGF0ZSh0aGlzLCB0aGlzLnNjb3BlLmdldCgpKTtcbiAgICAgICAgdGhpcy5zY29wZS52YWx1ZSh2YWxpZGF0ZU5hbWUsIHsgcmVmOiB2YWxpZGF0ZSB9KTtcbiAgICAgICAgdmFsaWRhdGUuZXJyb3JzID0gbnVsbDtcbiAgICAgICAgdmFsaWRhdGUuc2NoZW1hID0gc2NoLnNjaGVtYTtcbiAgICAgICAgdmFsaWRhdGUuc2NoZW1hRW52ID0gc2NoO1xuICAgICAgICBpZiAoc2NoLiRhc3luYylcbiAgICAgICAgICAgIHZhbGlkYXRlLiRhc3luYyA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLm9wdHMuY29kZS5zb3VyY2UgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlLnNvdXJjZSA9IHsgdmFsaWRhdGVOYW1lLCB2YWxpZGF0ZUNvZGUsIHNjb3BlVmFsdWVzOiBnZW4uX3ZhbHVlcyB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdHMudW5ldmFsdWF0ZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcHJvcHMsIGl0ZW1zIH0gPSBzY2hlbWFDeHQ7XG4gICAgICAgICAgICB2YWxpZGF0ZS5ldmFsdWF0ZWQgPSB7XG4gICAgICAgICAgICAgICAgcHJvcHM6IHByb3BzIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWUgPyB1bmRlZmluZWQgOiBwcm9wcyxcbiAgICAgICAgICAgICAgICBpdGVtczogaXRlbXMgaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZSA/IHVuZGVmaW5lZCA6IGl0ZW1zLFxuICAgICAgICAgICAgICAgIGR5bmFtaWNQcm9wczogcHJvcHMgaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZSxcbiAgICAgICAgICAgICAgICBkeW5hbWljSXRlbXM6IGl0ZW1zIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHZhbGlkYXRlLnNvdXJjZSlcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZS5zb3VyY2UuZXZhbHVhdGVkID0gKDAsIGNvZGVnZW5fMS5zdHJpbmdpZnkpKHZhbGlkYXRlLmV2YWx1YXRlZCk7XG4gICAgICAgIH1cbiAgICAgICAgc2NoLnZhbGlkYXRlID0gdmFsaWRhdGU7XG4gICAgICAgIHJldHVybiBzY2g7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGRlbGV0ZSBzY2gudmFsaWRhdGU7XG4gICAgICAgIGRlbGV0ZSBzY2gudmFsaWRhdGVOYW1lO1xuICAgICAgICBpZiAoc291cmNlQ29kZSlcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFwiRXJyb3IgY29tcGlsaW5nIHNjaGVtYSwgZnVuY3Rpb24gY29kZTpcIiwgc291cmNlQ29kZSk7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwiXFxuXFxuXFxuICoqKiBcXG5cIiwgc291cmNlQ29kZSwgdGhpcy5vcHRzKVxuICAgICAgICB0aHJvdyBlO1xuICAgIH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy5fY29tcGlsYXRpb25zLmRlbGV0ZShzY2gpO1xuICAgIH1cbn1cbmV4cG9ydHMuY29tcGlsZVNjaGVtYSA9IGNvbXBpbGVTY2hlbWE7XG5mdW5jdGlvbiByZXNvbHZlUmVmKHJvb3QsIGJhc2VJZCwgcmVmKSB7XG4gICAgdmFyIF9hO1xuICAgIHJlZiA9ICgwLCByZXNvbHZlXzEucmVzb2x2ZVVybCkodGhpcy5vcHRzLnVyaVJlc29sdmVyLCBiYXNlSWQsIHJlZik7XG4gICAgY29uc3Qgc2NoT3JGdW5jID0gcm9vdC5yZWZzW3JlZl07XG4gICAgaWYgKHNjaE9yRnVuYylcbiAgICAgICAgcmV0dXJuIHNjaE9yRnVuYztcbiAgICBsZXQgX3NjaCA9IHJlc29sdmUuY2FsbCh0aGlzLCByb290LCByZWYpO1xuICAgIGlmIChfc2NoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3Qgc2NoZW1hID0gKF9hID0gcm9vdC5sb2NhbFJlZnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtyZWZdOyAvLyBUT0RPIG1heWJlIGxvY2FsUmVmcyBzaG91bGQgaG9sZCBTY2hlbWFFbnZcbiAgICAgICAgY29uc3QgeyBzY2hlbWFJZCB9ID0gdGhpcy5vcHRzO1xuICAgICAgICBpZiAoc2NoZW1hKVxuICAgICAgICAgICAgX3NjaCA9IG5ldyBTY2hlbWFFbnYoeyBzY2hlbWEsIHNjaGVtYUlkLCByb290LCBiYXNlSWQgfSk7XG4gICAgfVxuICAgIGlmIChfc2NoID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybjtcbiAgICByZXR1cm4gKHJvb3QucmVmc1tyZWZdID0gaW5saW5lT3JDb21waWxlLmNhbGwodGhpcywgX3NjaCkpO1xufVxuZXhwb3J0cy5yZXNvbHZlUmVmID0gcmVzb2x2ZVJlZjtcbmZ1bmN0aW9uIGlubGluZU9yQ29tcGlsZShzY2gpIHtcbiAgICBpZiAoKDAsIHJlc29sdmVfMS5pbmxpbmVSZWYpKHNjaC5zY2hlbWEsIHRoaXMub3B0cy5pbmxpbmVSZWZzKSlcbiAgICAgICAgcmV0dXJuIHNjaC5zY2hlbWE7XG4gICAgcmV0dXJuIHNjaC52YWxpZGF0ZSA/IHNjaCA6IGNvbXBpbGVTY2hlbWEuY2FsbCh0aGlzLCBzY2gpO1xufVxuLy8gSW5kZXggb2Ygc2NoZW1hIGNvbXBpbGF0aW9uIGluIHRoZSBjdXJyZW50bHkgY29tcGlsZWQgbGlzdFxuZnVuY3Rpb24gZ2V0Q29tcGlsaW5nU2NoZW1hKHNjaEVudikge1xuICAgIGZvciAoY29uc3Qgc2NoIG9mIHRoaXMuX2NvbXBpbGF0aW9ucykge1xuICAgICAgICBpZiAoc2FtZVNjaGVtYUVudihzY2gsIHNjaEVudikpXG4gICAgICAgICAgICByZXR1cm4gc2NoO1xuICAgIH1cbn1cbmV4cG9ydHMuZ2V0Q29tcGlsaW5nU2NoZW1hID0gZ2V0Q29tcGlsaW5nU2NoZW1hO1xuZnVuY3Rpb24gc2FtZVNjaGVtYUVudihzMSwgczIpIHtcbiAgICByZXR1cm4gczEuc2NoZW1hID09PSBzMi5zY2hlbWEgJiYgczEucm9vdCA9PT0gczIucm9vdCAmJiBzMS5iYXNlSWQgPT09IHMyLmJhc2VJZDtcbn1cbi8vIHJlc29sdmUgYW5kIGNvbXBpbGUgdGhlIHJlZmVyZW5jZXMgKCRyZWYpXG4vLyBUT0RPIHJldHVybnMgQW55U2NoZW1hT2JqZWN0IChpZiB0aGUgc2NoZW1hIGNhbiBiZSBpbmxpbmVkKSBvciB2YWxpZGF0aW9uIGZ1bmN0aW9uXG5mdW5jdGlvbiByZXNvbHZlKHJvb3QsIC8vIGluZm9ybWF0aW9uIGFib3V0IHRoZSByb290IHNjaGVtYSBmb3IgdGhlIGN1cnJlbnQgc2NoZW1hXG5yZWYgLy8gcmVmZXJlbmNlIHRvIHJlc29sdmVcbikge1xuICAgIGxldCBzY2g7XG4gICAgd2hpbGUgKHR5cGVvZiAoc2NoID0gdGhpcy5yZWZzW3JlZl0pID09IFwic3RyaW5nXCIpXG4gICAgICAgIHJlZiA9IHNjaDtcbiAgICByZXR1cm4gc2NoIHx8IHRoaXMuc2NoZW1hc1tyZWZdIHx8IHJlc29sdmVTY2hlbWEuY2FsbCh0aGlzLCByb290LCByZWYpO1xufVxuLy8gUmVzb2x2ZSBzY2hlbWEsIGl0cyByb290IGFuZCBiYXNlSWRcbmZ1bmN0aW9uIHJlc29sdmVTY2hlbWEocm9vdCwgLy8gcm9vdCBvYmplY3Qgd2l0aCBwcm9wZXJ0aWVzIHNjaGVtYSwgcmVmcyBUT0RPIGJlbG93IFNjaGVtYUVudiBpcyBhc3NpZ25lZCB0byBpdFxucmVmIC8vIHJlZmVyZW5jZSB0byByZXNvbHZlXG4pIHtcbiAgICBjb25zdCBwID0gdGhpcy5vcHRzLnVyaVJlc29sdmVyLnBhcnNlKHJlZik7XG4gICAgY29uc3QgcmVmUGF0aCA9ICgwLCByZXNvbHZlXzEuX2dldEZ1bGxQYXRoKSh0aGlzLm9wdHMudXJpUmVzb2x2ZXIsIHApO1xuICAgIGxldCBiYXNlSWQgPSAoMCwgcmVzb2x2ZV8xLmdldEZ1bGxQYXRoKSh0aGlzLm9wdHMudXJpUmVzb2x2ZXIsIHJvb3QuYmFzZUlkLCB1bmRlZmluZWQpO1xuICAgIC8vIFRPRE8gYE9iamVjdC5rZXlzKHJvb3Quc2NoZW1hKS5sZW5ndGggPiAwYCBzaG91bGQgbm90IGJlIG5lZWRlZCAtIGJ1dCByZW1vdmluZyBicmVha3MgMiB0ZXN0c1xuICAgIGlmIChPYmplY3Qua2V5cyhyb290LnNjaGVtYSkubGVuZ3RoID4gMCAmJiByZWZQYXRoID09PSBiYXNlSWQpIHtcbiAgICAgICAgcmV0dXJuIGdldEpzb25Qb2ludGVyLmNhbGwodGhpcywgcCwgcm9vdCk7XG4gICAgfVxuICAgIGNvbnN0IGlkID0gKDAsIHJlc29sdmVfMS5ub3JtYWxpemVJZCkocmVmUGF0aCk7XG4gICAgY29uc3Qgc2NoT3JSZWYgPSB0aGlzLnJlZnNbaWRdIHx8IHRoaXMuc2NoZW1hc1tpZF07XG4gICAgaWYgKHR5cGVvZiBzY2hPclJlZiA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGNvbnN0IHNjaCA9IHJlc29sdmVTY2hlbWEuY2FsbCh0aGlzLCByb290LCBzY2hPclJlZik7XG4gICAgICAgIGlmICh0eXBlb2YgKHNjaCA9PT0gbnVsbCB8fCBzY2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNjaC5zY2hlbWEpICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICByZXR1cm4gZ2V0SnNvblBvaW50ZXIuY2FsbCh0aGlzLCBwLCBzY2gpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIChzY2hPclJlZiA9PT0gbnVsbCB8fCBzY2hPclJlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2NoT3JSZWYuc2NoZW1hKSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICghc2NoT3JSZWYudmFsaWRhdGUpXG4gICAgICAgIGNvbXBpbGVTY2hlbWEuY2FsbCh0aGlzLCBzY2hPclJlZik7XG4gICAgaWYgKGlkID09PSAoMCwgcmVzb2x2ZV8xLm5vcm1hbGl6ZUlkKShyZWYpKSB7XG4gICAgICAgIGNvbnN0IHsgc2NoZW1hIH0gPSBzY2hPclJlZjtcbiAgICAgICAgY29uc3QgeyBzY2hlbWFJZCB9ID0gdGhpcy5vcHRzO1xuICAgICAgICBjb25zdCBzY2hJZCA9IHNjaGVtYVtzY2hlbWFJZF07XG4gICAgICAgIGlmIChzY2hJZClcbiAgICAgICAgICAgIGJhc2VJZCA9ICgwLCByZXNvbHZlXzEucmVzb2x2ZVVybCkodGhpcy5vcHRzLnVyaVJlc29sdmVyLCBiYXNlSWQsIHNjaElkKTtcbiAgICAgICAgcmV0dXJuIG5ldyBTY2hlbWFFbnYoeyBzY2hlbWEsIHNjaGVtYUlkLCByb290LCBiYXNlSWQgfSk7XG4gICAgfVxuICAgIHJldHVybiBnZXRKc29uUG9pbnRlci5jYWxsKHRoaXMsIHAsIHNjaE9yUmVmKTtcbn1cbmV4cG9ydHMucmVzb2x2ZVNjaGVtYSA9IHJlc29sdmVTY2hlbWE7XG5jb25zdCBQUkVWRU5UX1NDT1BFX0NIQU5HRSA9IG5ldyBTZXQoW1xuICAgIFwicHJvcGVydGllc1wiLFxuICAgIFwicGF0dGVyblByb3BlcnRpZXNcIixcbiAgICBcImVudW1cIixcbiAgICBcImRlcGVuZGVuY2llc1wiLFxuICAgIFwiZGVmaW5pdGlvbnNcIixcbl0pO1xuZnVuY3Rpb24gZ2V0SnNvblBvaW50ZXIocGFyc2VkUmVmLCB7IGJhc2VJZCwgc2NoZW1hLCByb290IH0pIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKCgoX2EgPSBwYXJzZWRSZWYuZnJhZ21lbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVswXSkgIT09IFwiL1wiKVxuICAgICAgICByZXR1cm47XG4gICAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcnNlZFJlZi5mcmFnbWVudC5zbGljZSgxKS5zcGxpdChcIi9cIikpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWEgPT09IFwiYm9vbGVhblwiKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBwYXJ0U2NoZW1hID0gc2NoZW1hWygwLCB1dGlsXzEudW5lc2NhcGVGcmFnbWVudCkocGFydCldO1xuICAgICAgICBpZiAocGFydFNjaGVtYSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBzY2hlbWEgPSBwYXJ0U2NoZW1hO1xuICAgICAgICAvLyBUT0RPIFBSRVZFTlRfU0NPUEVfQ0hBTkdFIGNvdWxkIGJlIGRlZmluZWQgaW4ga2V5d29yZCBkZWY/XG4gICAgICAgIGNvbnN0IHNjaElkID0gdHlwZW9mIHNjaGVtYSA9PT0gXCJvYmplY3RcIiAmJiBzY2hlbWFbdGhpcy5vcHRzLnNjaGVtYUlkXTtcbiAgICAgICAgaWYgKCFQUkVWRU5UX1NDT1BFX0NIQU5HRS5oYXMocGFydCkgJiYgc2NoSWQpIHtcbiAgICAgICAgICAgIGJhc2VJZCA9ICgwLCByZXNvbHZlXzEucmVzb2x2ZVVybCkodGhpcy5vcHRzLnVyaVJlc29sdmVyLCBiYXNlSWQsIHNjaElkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgZW52O1xuICAgIGlmICh0eXBlb2Ygc2NoZW1hICE9IFwiYm9vbGVhblwiICYmIHNjaGVtYS4kcmVmICYmICEoMCwgdXRpbF8xLnNjaGVtYUhhc1J1bGVzQnV0UmVmKShzY2hlbWEsIHRoaXMuUlVMRVMpKSB7XG4gICAgICAgIGNvbnN0ICRyZWYgPSAoMCwgcmVzb2x2ZV8xLnJlc29sdmVVcmwpKHRoaXMub3B0cy51cmlSZXNvbHZlciwgYmFzZUlkLCBzY2hlbWEuJHJlZik7XG4gICAgICAgIGVudiA9IHJlc29sdmVTY2hlbWEuY2FsbCh0aGlzLCByb290LCAkcmVmKTtcbiAgICB9XG4gICAgLy8gZXZlbiB0aG91Z2ggcmVzb2x1dGlvbiBmYWlsZWQgd2UgbmVlZCB0byByZXR1cm4gU2NoZW1hRW52IHRvIHRocm93IGV4Y2VwdGlvblxuICAgIC8vIHNvIHRoYXQgY29tcGlsZUFzeW5jIGxvYWRzIG1pc3Npbmcgc2NoZW1hLlxuICAgIGNvbnN0IHsgc2NoZW1hSWQgfSA9IHRoaXMub3B0cztcbiAgICBlbnYgPSBlbnYgfHwgbmV3IFNjaGVtYUVudih7IHNjaGVtYSwgc2NoZW1hSWQsIHJvb3QsIGJhc2VJZCB9KTtcbiAgICBpZiAoZW52LnNjaGVtYSAhPT0gZW52LnJvb3Quc2NoZW1hKVxuICAgICAgICByZXR1cm4gZW52O1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJ7XG4gIFwiJGlkXCI6IFwiaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2Fqdi12YWxpZGF0b3IvYWp2L21hc3Rlci9saWIvcmVmcy9kYXRhLmpzb24jXCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJNZXRhLXNjaGVtYSBmb3IgJGRhdGEgcmVmZXJlbmNlIChKU09OIEFueVNjaGVtYSBleHRlbnNpb24gcHJvcG9zYWwpXCIsXG4gIFwidHlwZVwiOiBcIm9iamVjdFwiLFxuICBcInJlcXVpcmVkXCI6IFtcIiRkYXRhXCJdLFxuICBcInByb3BlcnRpZXNcIjoge1xuICAgIFwiJGRhdGFcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImFueU9mXCI6IFt7XCJmb3JtYXRcIjogXCJyZWxhdGl2ZS1qc29uLXBvaW50ZXJcIn0sIHtcImZvcm1hdFwiOiBcImpzb24tcG9pbnRlclwifV1cbiAgICB9XG4gIH0sXG4gIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjogZmFsc2Vcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG4vKiogQHR5cGUgeyh2YWx1ZTogc3RyaW5nKSA9PiBib29sZWFufSAqL1xuY29uc3QgaXNVVUlEID0gUmVnRXhwLnByb3RvdHlwZS50ZXN0LmJpbmQoL15bXFxkYS1mXXs4fS1bXFxkYS1mXXs0fS1bXFxkYS1mXXs0fS1bXFxkYS1mXXs0fS1bXFxkYS1mXXsxMn0kL2l1KVxuXG4vKiogQHR5cGUgeyh2YWx1ZTogc3RyaW5nKSA9PiBib29sZWFufSAqL1xuY29uc3QgaXNJUHY0ID0gUmVnRXhwLnByb3RvdHlwZS50ZXN0LmJpbmQoL14oPzooPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkezJ9fFsxLTldXFxkfFxcZClcXC4pezN9KD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZHsyfXxbMS05XVxcZHxcXGQpJC91KVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gaW5wdXRcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHN0cmluZ0FycmF5VG9IZXhTdHJpcHBlZCAoaW5wdXQpIHtcbiAgbGV0IGFjYyA9ICcnXG4gIGxldCBjb2RlID0gMFxuICBsZXQgaSA9IDBcblxuICBmb3IgKGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICBjb2RlID0gaW5wdXRbaV0uY2hhckNvZGVBdCgwKVxuICAgIGlmIChjb2RlID09PSA0OCkge1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaWYgKCEoKGNvZGUgPj0gNDggJiYgY29kZSA8PSA1NykgfHwgKGNvZGUgPj0gNjUgJiYgY29kZSA8PSA3MCkgfHwgKGNvZGUgPj0gOTcgJiYgY29kZSA8PSAxMDIpKSkge1xuICAgICAgcmV0dXJuICcnXG4gICAgfVxuICAgIGFjYyArPSBpbnB1dFtpXVxuICAgIGJyZWFrXG4gIH1cblxuICBmb3IgKGkgKz0gMTsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgY29kZSA9IGlucHV0W2ldLmNoYXJDb2RlQXQoMClcbiAgICBpZiAoISgoY29kZSA+PSA0OCAmJiBjb2RlIDw9IDU3KSB8fCAoY29kZSA+PSA2NSAmJiBjb2RlIDw9IDcwKSB8fCAoY29kZSA+PSA5NyAmJiBjb2RlIDw9IDEwMikpKSB7XG4gICAgICByZXR1cm4gJydcbiAgICB9XG4gICAgYWNjICs9IGlucHV0W2ldXG4gIH1cbiAgcmV0dXJuIGFjY1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEdldElQVjZSZXN1bHRcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZXJyb3IgLSBJbmRpY2F0ZXMgaWYgdGhlcmUgd2FzIGFuIGVycm9yIHBhcnNpbmcgdGhlIElQdjYgYWRkcmVzcy5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBhZGRyZXNzIC0gVGhlIHBhcnNlZCBJUHY2IGFkZHJlc3MuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3pvbmVdIC0gVGhlIHpvbmUgaWRlbnRpZmllciwgaWYgcHJlc2VudC5cbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmNvbnN0IG5vblNpbXBsZURvbWFpbiA9IFJlZ0V4cC5wcm90b3R5cGUudGVzdC5iaW5kKC9bXiFcIiQmJygpKissXFwtLjs9X2BhLXp7fX5dL3UpXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBidWZmZXJcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBjb25zdW1lSXNab25lIChidWZmZXIpIHtcbiAgYnVmZmVyLmxlbmd0aCA9IDBcbiAgcmV0dXJuIHRydWVcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGJ1ZmZlclxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBhZGRyZXNzXG4gKiBAcGFyYW0ge0dldElQVjZSZXN1bHR9IG91dHB1dFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGNvbnN1bWVIZXh0ZXRzIChidWZmZXIsIGFkZHJlc3MsIG91dHB1dCkge1xuICBpZiAoYnVmZmVyLmxlbmd0aCkge1xuICAgIGNvbnN0IGhleCA9IHN0cmluZ0FycmF5VG9IZXhTdHJpcHBlZChidWZmZXIpXG4gICAgaWYgKGhleCAhPT0gJycpIHtcbiAgICAgIGFkZHJlc3MucHVzaChoZXgpXG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5lcnJvciA9IHRydWVcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBidWZmZXIubGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGlucHV0XG4gKiBAcmV0dXJucyB7R2V0SVBWNlJlc3VsdH1cbiAqL1xuZnVuY3Rpb24gZ2V0SVBWNiAoaW5wdXQpIHtcbiAgbGV0IHRva2VuQ291bnQgPSAwXG4gIGNvbnN0IG91dHB1dCA9IHsgZXJyb3I6IGZhbHNlLCBhZGRyZXNzOiAnJywgem9uZTogJycgfVxuICAvKiogQHR5cGUge0FycmF5PHN0cmluZz59ICovXG4gIGNvbnN0IGFkZHJlc3MgPSBbXVxuICAvKiogQHR5cGUge0FycmF5PHN0cmluZz59ICovXG4gIGNvbnN0IGJ1ZmZlciA9IFtdXG4gIGxldCBlbmRpcHY2RW5jb3VudGVyZWQgPSBmYWxzZVxuICBsZXQgZW5kSXB2NiA9IGZhbHNlXG5cbiAgbGV0IGNvbnN1bWUgPSBjb25zdW1lSGV4dGV0c1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjdXJzb3IgPSBpbnB1dFtpXVxuICAgIGlmIChjdXJzb3IgPT09ICdbJyB8fCBjdXJzb3IgPT09ICddJykgeyBjb250aW51ZSB9XG4gICAgaWYgKGN1cnNvciA9PT0gJzonKSB7XG4gICAgICBpZiAoZW5kaXB2NkVuY291bnRlcmVkID09PSB0cnVlKSB7XG4gICAgICAgIGVuZElwdjYgPSB0cnVlXG4gICAgICB9XG4gICAgICBpZiAoIWNvbnN1bWUoYnVmZmVyLCBhZGRyZXNzLCBvdXRwdXQpKSB7IGJyZWFrIH1cbiAgICAgIGlmICgrK3Rva2VuQ291bnQgPiA3KSB7XG4gICAgICAgIC8vIG5vdCB2YWxpZFxuICAgICAgICBvdXRwdXQuZXJyb3IgPSB0cnVlXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBpZiAoaSA+IDAgJiYgaW5wdXRbaSAtIDFdID09PSAnOicpIHtcbiAgICAgICAgZW5kaXB2NkVuY291bnRlcmVkID0gdHJ1ZVxuICAgICAgfVxuICAgICAgYWRkcmVzcy5wdXNoKCc6JylcbiAgICAgIGNvbnRpbnVlXG4gICAgfSBlbHNlIGlmIChjdXJzb3IgPT09ICclJykge1xuICAgICAgaWYgKCFjb25zdW1lKGJ1ZmZlciwgYWRkcmVzcywgb3V0cHV0KSkgeyBicmVhayB9XG4gICAgICAvLyBzd2l0Y2ggdG8gem9uZSBkZXRlY3Rpb25cbiAgICAgIGNvbnN1bWUgPSBjb25zdW1lSXNab25lXG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1ZmZlci5wdXNoKGN1cnNvcilcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICB9XG4gIGlmIChidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGNvbnN1bWUgPT09IGNvbnN1bWVJc1pvbmUpIHtcbiAgICAgIG91dHB1dC56b25lID0gYnVmZmVyLmpvaW4oJycpXG4gICAgfSBlbHNlIGlmIChlbmRJcHY2KSB7XG4gICAgICBhZGRyZXNzLnB1c2goYnVmZmVyLmpvaW4oJycpKVxuICAgIH0gZWxzZSB7XG4gICAgICBhZGRyZXNzLnB1c2goc3RyaW5nQXJyYXlUb0hleFN0cmlwcGVkKGJ1ZmZlcikpXG4gICAgfVxuICB9XG4gIG91dHB1dC5hZGRyZXNzID0gYWRkcmVzcy5qb2luKCcnKVxuICByZXR1cm4gb3V0cHV0XG59XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gTm9ybWFsaXplSVB2NlJlc3VsdFxuICogQHByb3BlcnR5IHtzdHJpbmd9IGhvc3QgLSBUaGUgbm9ybWFsaXplZCBob3N0LlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtlc2NhcGVkSG9zdF0gLSBUaGUgZXNjYXBlZCBob3N0LlxuICogQHByb3BlcnR5IHtib29sZWFufSBpc0lQVjYgLSBJbmRpY2F0ZXMgaWYgdGhlIGhvc3QgaXMgYW4gSVB2NiBhZGRyZXNzLlxuICovXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGhvc3RcbiAqIEByZXR1cm5zIHtOb3JtYWxpemVJUHY2UmVzdWx0fVxuICovXG5mdW5jdGlvbiBub3JtYWxpemVJUHY2IChob3N0KSB7XG4gIGlmIChmaW5kVG9rZW4oaG9zdCwgJzonKSA8IDIpIHsgcmV0dXJuIHsgaG9zdCwgaXNJUFY2OiBmYWxzZSB9IH1cbiAgY29uc3QgaXB2NiA9IGdldElQVjYoaG9zdClcblxuICBpZiAoIWlwdjYuZXJyb3IpIHtcbiAgICBsZXQgbmV3SG9zdCA9IGlwdjYuYWRkcmVzc1xuICAgIGxldCBlc2NhcGVkSG9zdCA9IGlwdjYuYWRkcmVzc1xuICAgIGlmIChpcHY2LnpvbmUpIHtcbiAgICAgIG5ld0hvc3QgKz0gJyUnICsgaXB2Ni56b25lXG4gICAgICBlc2NhcGVkSG9zdCArPSAnJTI1JyArIGlwdjYuem9uZVxuICAgIH1cbiAgICByZXR1cm4geyBob3N0OiBuZXdIb3N0LCBpc0lQVjY6IHRydWUsIGVzY2FwZWRIb3N0IH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geyBob3N0LCBpc0lQVjY6IGZhbHNlIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlblxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gZmluZFRva2VuIChzdHIsIHRva2VuKSB7XG4gIGxldCBpbmQgPSAwXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHN0cltpXSA9PT0gdG9rZW4pIGluZCsrXG4gIH1cbiAgcmV0dXJuIGluZFxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICpcbiAqIEBzZWUgaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmMzOTg2I3NlY3Rpb24tNS4yLjRcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlRG90U2VnbWVudHMgKHBhdGgpIHtcbiAgbGV0IGlucHV0ID0gcGF0aFxuICBjb25zdCBvdXRwdXQgPSBbXVxuICBsZXQgbmV4dFNsYXNoID0gLTFcbiAgbGV0IGxlbiA9IDBcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uZC1hc3NpZ25cbiAgd2hpbGUgKGxlbiA9IGlucHV0Lmxlbmd0aCkge1xuICAgIGlmIChsZW4gPT09IDEpIHtcbiAgICAgIGlmIChpbnB1dCA9PT0gJy4nKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9IGVsc2UgaWYgKGlucHV0ID09PSAnLycpIHtcbiAgICAgICAgb3V0cHV0LnB1c2goJy8nKVxuICAgICAgICBicmVha1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0cHV0LnB1c2goaW5wdXQpXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsZW4gPT09IDIpIHtcbiAgICAgIGlmIChpbnB1dFswXSA9PT0gJy4nKSB7XG4gICAgICAgIGlmIChpbnB1dFsxXSA9PT0gJy4nKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dFsxXSA9PT0gJy8nKSB7XG4gICAgICAgICAgaW5wdXQgPSBpbnB1dC5zbGljZSgyKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaW5wdXRbMF0gPT09ICcvJykge1xuICAgICAgICBpZiAoaW5wdXRbMV0gPT09ICcuJyB8fCBpbnB1dFsxXSA9PT0gJy8nKSB7XG4gICAgICAgICAgb3V0cHV0LnB1c2goJy8nKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGxlbiA9PT0gMykge1xuICAgICAgaWYgKGlucHV0ID09PSAnLy4uJykge1xuICAgICAgICBpZiAob3V0cHV0Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgIG91dHB1dC5wb3AoKVxuICAgICAgICB9XG4gICAgICAgIG91dHB1dC5wdXNoKCcvJylcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlucHV0WzBdID09PSAnLicpIHtcbiAgICAgIGlmIChpbnB1dFsxXSA9PT0gJy4nKSB7XG4gICAgICAgIGlmIChpbnB1dFsyXSA9PT0gJy8nKSB7XG4gICAgICAgICAgaW5wdXQgPSBpbnB1dC5zbGljZSgzKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaW5wdXRbMV0gPT09ICcvJykge1xuICAgICAgICBpbnB1dCA9IGlucHV0LnNsaWNlKDIpXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpbnB1dFswXSA9PT0gJy8nKSB7XG4gICAgICBpZiAoaW5wdXRbMV0gPT09ICcuJykge1xuICAgICAgICBpZiAoaW5wdXRbMl0gPT09ICcvJykge1xuICAgICAgICAgIGlucHV0ID0gaW5wdXQuc2xpY2UoMilcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGlucHV0WzJdID09PSAnLicpIHtcbiAgICAgICAgICBpZiAoaW5wdXRbM10gPT09ICcvJykge1xuICAgICAgICAgICAgaW5wdXQgPSBpbnB1dC5zbGljZSgzKVxuICAgICAgICAgICAgaWYgKG91dHB1dC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgb3V0cHV0LnBvcCgpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJ1bGUgMkU6IE1vdmUgbm9ybWFsIHBhdGggc2VnbWVudCB0byBvdXRwdXRcbiAgICBpZiAoKG5leHRTbGFzaCA9IGlucHV0LmluZGV4T2YoJy8nLCAxKSkgPT09IC0xKSB7XG4gICAgICBvdXRwdXQucHVzaChpbnB1dClcbiAgICAgIGJyZWFrXG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKGlucHV0LnNsaWNlKDAsIG5leHRTbGFzaCkpXG4gICAgICBpbnB1dCA9IGlucHV0LnNsaWNlKG5leHRTbGFzaClcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4uL3R5cGVzL2luZGV4JykuVVJJQ29tcG9uZW50fSBjb21wb25lbnRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZXNjXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuLi90eXBlcy9pbmRleCcpLlVSSUNvbXBvbmVudH1cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmcgKGNvbXBvbmVudCwgZXNjKSB7XG4gIGNvbnN0IGZ1bmMgPSBlc2MgIT09IHRydWUgPyBlc2NhcGUgOiB1bmVzY2FwZVxuICBpZiAoY29tcG9uZW50LnNjaGVtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29tcG9uZW50LnNjaGVtZSA9IGZ1bmMoY29tcG9uZW50LnNjaGVtZSlcbiAgfVxuICBpZiAoY29tcG9uZW50LnVzZXJpbmZvICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb21wb25lbnQudXNlcmluZm8gPSBmdW5jKGNvbXBvbmVudC51c2VyaW5mbylcbiAgfVxuICBpZiAoY29tcG9uZW50Lmhvc3QgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbXBvbmVudC5ob3N0ID0gZnVuYyhjb21wb25lbnQuaG9zdClcbiAgfVxuICBpZiAoY29tcG9uZW50LnBhdGggIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbXBvbmVudC5wYXRoID0gZnVuYyhjb21wb25lbnQucGF0aClcbiAgfVxuICBpZiAoY29tcG9uZW50LnF1ZXJ5ICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb21wb25lbnQucXVlcnkgPSBmdW5jKGNvbXBvbmVudC5xdWVyeSlcbiAgfVxuICBpZiAoY29tcG9uZW50LmZyYWdtZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb21wb25lbnQuZnJhZ21lbnQgPSBmdW5jKGNvbXBvbmVudC5mcmFnbWVudClcbiAgfVxuICByZXR1cm4gY29tcG9uZW50XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4uL3R5cGVzL2luZGV4JykuVVJJQ29tcG9uZW50fSBjb21wb25lbnRcbiAqIEByZXR1cm5zIHtzdHJpbmd8dW5kZWZpbmVkfVxuICovXG5mdW5jdGlvbiByZWNvbXBvc2VBdXRob3JpdHkgKGNvbXBvbmVudCkge1xuICBjb25zdCB1cmlUb2tlbnMgPSBbXVxuXG4gIGlmIChjb21wb25lbnQudXNlcmluZm8gIT09IHVuZGVmaW5lZCkge1xuICAgIHVyaVRva2Vucy5wdXNoKGNvbXBvbmVudC51c2VyaW5mbylcbiAgICB1cmlUb2tlbnMucHVzaCgnQCcpXG4gIH1cblxuICBpZiAoY29tcG9uZW50Lmhvc3QgIT09IHVuZGVmaW5lZCkge1xuICAgIGxldCBob3N0ID0gdW5lc2NhcGUoY29tcG9uZW50Lmhvc3QpXG4gICAgaWYgKCFpc0lQdjQoaG9zdCkpIHtcbiAgICAgIGNvbnN0IGlwVjZyZXMgPSBub3JtYWxpemVJUHY2KGhvc3QpXG4gICAgICBpZiAoaXBWNnJlcy5pc0lQVjYgPT09IHRydWUpIHtcbiAgICAgICAgaG9zdCA9IGBbJHtpcFY2cmVzLmVzY2FwZWRIb3N0fV1gXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBob3N0ID0gY29tcG9uZW50Lmhvc3RcbiAgICAgIH1cbiAgICB9XG4gICAgdXJpVG9rZW5zLnB1c2goaG9zdClcbiAgfVxuXG4gIGlmICh0eXBlb2YgY29tcG9uZW50LnBvcnQgPT09ICdudW1iZXInIHx8IHR5cGVvZiBjb21wb25lbnQucG9ydCA9PT0gJ3N0cmluZycpIHtcbiAgICB1cmlUb2tlbnMucHVzaCgnOicpXG4gICAgdXJpVG9rZW5zLnB1c2goU3RyaW5nKGNvbXBvbmVudC5wb3J0KSlcbiAgfVxuXG4gIHJldHVybiB1cmlUb2tlbnMubGVuZ3RoID8gdXJpVG9rZW5zLmpvaW4oJycpIDogdW5kZWZpbmVkXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbm9uU2ltcGxlRG9tYWluLFxuICByZWNvbXBvc2VBdXRob3JpdHksXG4gIG5vcm1hbGl6ZUNvbXBvbmVudEVuY29kaW5nLFxuICByZW1vdmVEb3RTZWdtZW50cyxcbiAgaXNJUHY0LFxuICBpc1VVSUQsXG4gIG5vcm1hbGl6ZUlQdjYsXG4gIHN0cmluZ0FycmF5VG9IZXhTdHJpcHBlZFxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgaXNVVUlEIH0gPSByZXF1aXJlKCcuL3V0aWxzJylcbmNvbnN0IFVSTl9SRUcgPSAvKFtcXGRhLXpdW1xcZFxcLWEtel17MCwzMX0pOigoPzpbXFx3ISQnKCkqKyxcXC0uOjs9QF18JVtcXGRhLWZdezJ9KSspL2l1XG5cbmNvbnN0IHN1cHBvcnRlZFNjaGVtZU5hbWVzID0gLyoqIEB0eXBlIHtjb25zdH0gKi8gKFsnaHR0cCcsICdodHRwcycsICd3cycsXG4gICd3c3MnLCAndXJuJywgJ3Vybjp1dWlkJ10pXG5cbi8qKiBAdHlwZWRlZiB7c3VwcG9ydGVkU2NoZW1lTmFtZXNbbnVtYmVyXX0gU2NoZW1lTmFtZSAqL1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7bmFtZSBpcyBTY2hlbWVOYW1lfVxuICovXG5mdW5jdGlvbiBpc1ZhbGlkU2NoZW1lTmFtZSAobmFtZSkge1xuICByZXR1cm4gc3VwcG9ydGVkU2NoZW1lTmFtZXMuaW5kZXhPZigvKiogQHR5cGUgeyp9ICovIChuYW1lKSkgIT09IC0xXG59XG5cbi8qKlxuICogQGNhbGxiYWNrIFNjaGVtZUZuXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vdHlwZXMvaW5kZXgnKS5VUklDb21wb25lbnR9IGNvbXBvbmVudFxuICogQHBhcmFtIHtpbXBvcnQoJy4uL3R5cGVzL2luZGV4JykuT3B0aW9uc30gb3B0aW9uc1xuICogQHJldHVybnMge2ltcG9ydCgnLi4vdHlwZXMvaW5kZXgnKS5VUklDb21wb25lbnR9XG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTY2hlbWVIYW5kbGVyXG4gKiBAcHJvcGVydHkge1NjaGVtZU5hbWV9IHNjaGVtZSAtIFRoZSBzY2hlbWUgbmFtZS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2RvbWFpbkhvc3RdIC0gSW5kaWNhdGVzIGlmIHRoZSBzY2hlbWUgc3VwcG9ydHMgZG9tYWluIGhvc3RzLlxuICogQHByb3BlcnR5IHtTY2hlbWVGbn0gcGFyc2UgLSBGdW5jdGlvbiB0byBwYXJzZSB0aGUgVVJJIGNvbXBvbmVudCBmb3IgdGhpcyBzY2hlbWUuXG4gKiBAcHJvcGVydHkge1NjaGVtZUZufSBzZXJpYWxpemUgLSBGdW5jdGlvbiB0byBzZXJpYWxpemUgdGhlIFVSSSBjb21wb25lbnQgZm9yIHRoaXMgc2NoZW1lLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbc2tpcE5vcm1hbGl6ZV0gLSBJbmRpY2F0ZXMgaWYgbm9ybWFsaXphdGlvbiBzaG91bGQgYmUgc2tpcHBlZCBmb3IgdGhpcyBzY2hlbWUuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFthYnNvbHV0ZVBhdGhdIC0gSW5kaWNhdGVzIGlmIHRoZSBzY2hlbWUgdXNlcyBhYnNvbHV0ZSBwYXRocy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3VuaWNvZGVTdXBwb3J0XSAtIEluZGljYXRlcyBpZiB0aGUgc2NoZW1lIHN1cHBvcnRzIFVuaWNvZGUuXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vdHlwZXMvaW5kZXgnKS5VUklDb21wb25lbnR9IHdzQ29tcG9uZW50XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gd3NJc1NlY3VyZSAod3NDb21wb25lbnQpIHtcbiAgaWYgKHdzQ29tcG9uZW50LnNlY3VyZSA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiB0cnVlXG4gIH0gZWxzZSBpZiAod3NDb21wb25lbnQuc2VjdXJlID09PSBmYWxzZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgaWYgKHdzQ29tcG9uZW50LnNjaGVtZSkge1xuICAgIHJldHVybiAoXG4gICAgICB3c0NvbXBvbmVudC5zY2hlbWUubGVuZ3RoID09PSAzICYmXG4gICAgICAod3NDb21wb25lbnQuc2NoZW1lWzBdID09PSAndycgfHwgd3NDb21wb25lbnQuc2NoZW1lWzBdID09PSAnVycpICYmXG4gICAgICAod3NDb21wb25lbnQuc2NoZW1lWzFdID09PSAncycgfHwgd3NDb21wb25lbnQuc2NoZW1lWzFdID09PSAnUycpICYmXG4gICAgICAod3NDb21wb25lbnQuc2NoZW1lWzJdID09PSAncycgfHwgd3NDb21wb25lbnQuc2NoZW1lWzJdID09PSAnUycpXG4gICAgKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbi8qKiBAdHlwZSB7U2NoZW1lRm59ICovXG5mdW5jdGlvbiBodHRwUGFyc2UgKGNvbXBvbmVudCkge1xuICBpZiAoIWNvbXBvbmVudC5ob3N0KSB7XG4gICAgY29tcG9uZW50LmVycm9yID0gY29tcG9uZW50LmVycm9yIHx8ICdIVFRQIFVSSXMgbXVzdCBoYXZlIGEgaG9zdC4nXG4gIH1cblxuICByZXR1cm4gY29tcG9uZW50XG59XG5cbi8qKiBAdHlwZSB7U2NoZW1lRm59ICovXG5mdW5jdGlvbiBodHRwU2VyaWFsaXplIChjb21wb25lbnQpIHtcbiAgY29uc3Qgc2VjdXJlID0gU3RyaW5nKGNvbXBvbmVudC5zY2hlbWUpLnRvTG93ZXJDYXNlKCkgPT09ICdodHRwcydcblxuICAvLyBub3JtYWxpemUgdGhlIGRlZmF1bHQgcG9ydFxuICBpZiAoY29tcG9uZW50LnBvcnQgPT09IChzZWN1cmUgPyA0NDMgOiA4MCkgfHwgY29tcG9uZW50LnBvcnQgPT09ICcnKSB7XG4gICAgY29tcG9uZW50LnBvcnQgPSB1bmRlZmluZWRcbiAgfVxuXG4gIC8vIG5vcm1hbGl6ZSB0aGUgZW1wdHkgcGF0aFxuICBpZiAoIWNvbXBvbmVudC5wYXRoKSB7XG4gICAgY29tcG9uZW50LnBhdGggPSAnLydcbiAgfVxuXG4gIC8vIE5PVEU6IFdlIGRvIG5vdCBwYXJzZSBxdWVyeSBzdHJpbmdzIGZvciBIVFRQIFVSSXNcbiAgLy8gYXMgV1dXIEZvcm0gVXJsIEVuY29kZWQgcXVlcnkgc3RyaW5ncyBhcmUgcGFydCBvZiB0aGUgSFRNTDQrIHNwZWMsXG4gIC8vIGFuZCBub3QgdGhlIEhUVFAgc3BlYy5cblxuICByZXR1cm4gY29tcG9uZW50XG59XG5cbi8qKiBAdHlwZSB7U2NoZW1lRm59ICovXG5mdW5jdGlvbiB3c1BhcnNlICh3c0NvbXBvbmVudCkge1xuLy8gaW5kaWNhdGUgaWYgdGhlIHNlY3VyZSBmbGFnIGlzIHNldFxuICB3c0NvbXBvbmVudC5zZWN1cmUgPSB3c0lzU2VjdXJlKHdzQ29tcG9uZW50KVxuXG4gIC8vIGNvbnN0cnVjdCByZXNvdWNlIG5hbWVcbiAgd3NDb21wb25lbnQucmVzb3VyY2VOYW1lID0gKHdzQ29tcG9uZW50LnBhdGggfHwgJy8nKSArICh3c0NvbXBvbmVudC5xdWVyeSA/ICc/JyArIHdzQ29tcG9uZW50LnF1ZXJ5IDogJycpXG4gIHdzQ29tcG9uZW50LnBhdGggPSB1bmRlZmluZWRcbiAgd3NDb21wb25lbnQucXVlcnkgPSB1bmRlZmluZWRcblxuICByZXR1cm4gd3NDb21wb25lbnRcbn1cblxuLyoqIEB0eXBlIHtTY2hlbWVGbn0gKi9cbmZ1bmN0aW9uIHdzU2VyaWFsaXplICh3c0NvbXBvbmVudCkge1xuLy8gbm9ybWFsaXplIHRoZSBkZWZhdWx0IHBvcnRcbiAgaWYgKHdzQ29tcG9uZW50LnBvcnQgPT09ICh3c0lzU2VjdXJlKHdzQ29tcG9uZW50KSA/IDQ0MyA6IDgwKSB8fCB3c0NvbXBvbmVudC5wb3J0ID09PSAnJykge1xuICAgIHdzQ29tcG9uZW50LnBvcnQgPSB1bmRlZmluZWRcbiAgfVxuXG4gIC8vIGVuc3VyZSBzY2hlbWUgbWF0Y2hlcyBzZWN1cmUgZmxhZ1xuICBpZiAodHlwZW9mIHdzQ29tcG9uZW50LnNlY3VyZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgd3NDb21wb25lbnQuc2NoZW1lID0gKHdzQ29tcG9uZW50LnNlY3VyZSA/ICd3c3MnIDogJ3dzJylcbiAgICB3c0NvbXBvbmVudC5zZWN1cmUgPSB1bmRlZmluZWRcbiAgfVxuXG4gIC8vIHJlY29uc3RydWN0IHBhdGggZnJvbSByZXNvdXJjZSBuYW1lXG4gIGlmICh3c0NvbXBvbmVudC5yZXNvdXJjZU5hbWUpIHtcbiAgICBjb25zdCBbcGF0aCwgcXVlcnldID0gd3NDb21wb25lbnQucmVzb3VyY2VOYW1lLnNwbGl0KCc/JylcbiAgICB3c0NvbXBvbmVudC5wYXRoID0gKHBhdGggJiYgcGF0aCAhPT0gJy8nID8gcGF0aCA6IHVuZGVmaW5lZClcbiAgICB3c0NvbXBvbmVudC5xdWVyeSA9IHF1ZXJ5XG4gICAgd3NDb21wb25lbnQucmVzb3VyY2VOYW1lID0gdW5kZWZpbmVkXG4gIH1cblxuICAvLyBmb3JiaWQgZnJhZ21lbnQgY29tcG9uZW50XG4gIHdzQ29tcG9uZW50LmZyYWdtZW50ID0gdW5kZWZpbmVkXG5cbiAgcmV0dXJuIHdzQ29tcG9uZW50XG59XG5cbi8qKiBAdHlwZSB7U2NoZW1lRm59ICovXG5mdW5jdGlvbiB1cm5QYXJzZSAodXJuQ29tcG9uZW50LCBvcHRpb25zKSB7XG4gIGlmICghdXJuQ29tcG9uZW50LnBhdGgpIHtcbiAgICB1cm5Db21wb25lbnQuZXJyb3IgPSAnVVJOIGNhbiBub3QgYmUgcGFyc2VkJ1xuICAgIHJldHVybiB1cm5Db21wb25lbnRcbiAgfVxuICBjb25zdCBtYXRjaGVzID0gdXJuQ29tcG9uZW50LnBhdGgubWF0Y2goVVJOX1JFRylcbiAgaWYgKG1hdGNoZXMpIHtcbiAgICBjb25zdCBzY2hlbWUgPSBvcHRpb25zLnNjaGVtZSB8fCB1cm5Db21wb25lbnQuc2NoZW1lIHx8ICd1cm4nXG4gICAgdXJuQ29tcG9uZW50Lm5pZCA9IG1hdGNoZXNbMV0udG9Mb3dlckNhc2UoKVxuICAgIHVybkNvbXBvbmVudC5uc3MgPSBtYXRjaGVzWzJdXG4gICAgY29uc3QgdXJuU2NoZW1lID0gYCR7c2NoZW1lfToke29wdGlvbnMubmlkIHx8IHVybkNvbXBvbmVudC5uaWR9YFxuICAgIGNvbnN0IHNjaGVtZUhhbmRsZXIgPSBnZXRTY2hlbWVIYW5kbGVyKHVyblNjaGVtZSlcbiAgICB1cm5Db21wb25lbnQucGF0aCA9IHVuZGVmaW5lZFxuXG4gICAgaWYgKHNjaGVtZUhhbmRsZXIpIHtcbiAgICAgIHVybkNvbXBvbmVudCA9IHNjaGVtZUhhbmRsZXIucGFyc2UodXJuQ29tcG9uZW50LCBvcHRpb25zKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB1cm5Db21wb25lbnQuZXJyb3IgPSB1cm5Db21wb25lbnQuZXJyb3IgfHwgJ1VSTiBjYW4gbm90IGJlIHBhcnNlZC4nXG4gIH1cblxuICByZXR1cm4gdXJuQ29tcG9uZW50XG59XG5cbi8qKiBAdHlwZSB7U2NoZW1lRm59ICovXG5mdW5jdGlvbiB1cm5TZXJpYWxpemUgKHVybkNvbXBvbmVudCwgb3B0aW9ucykge1xuICBpZiAodXJuQ29tcG9uZW50Lm5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVUk4gd2l0aG91dCBuaWQgY2Fubm90IGJlIHNlcmlhbGl6ZWQnKVxuICB9XG4gIGNvbnN0IHNjaGVtZSA9IG9wdGlvbnMuc2NoZW1lIHx8IHVybkNvbXBvbmVudC5zY2hlbWUgfHwgJ3VybidcbiAgY29uc3QgbmlkID0gdXJuQ29tcG9uZW50Lm5pZC50b0xvd2VyQ2FzZSgpXG4gIGNvbnN0IHVyblNjaGVtZSA9IGAke3NjaGVtZX06JHtvcHRpb25zLm5pZCB8fCBuaWR9YFxuICBjb25zdCBzY2hlbWVIYW5kbGVyID0gZ2V0U2NoZW1lSGFuZGxlcih1cm5TY2hlbWUpXG5cbiAgaWYgKHNjaGVtZUhhbmRsZXIpIHtcbiAgICB1cm5Db21wb25lbnQgPSBzY2hlbWVIYW5kbGVyLnNlcmlhbGl6ZSh1cm5Db21wb25lbnQsIG9wdGlvbnMpXG4gIH1cblxuICBjb25zdCB1cmlDb21wb25lbnQgPSB1cm5Db21wb25lbnRcbiAgY29uc3QgbnNzID0gdXJuQ29tcG9uZW50Lm5zc1xuICB1cmlDb21wb25lbnQucGF0aCA9IGAke25pZCB8fCBvcHRpb25zLm5pZH06JHtuc3N9YFxuXG4gIG9wdGlvbnMuc2tpcEVzY2FwZSA9IHRydWVcbiAgcmV0dXJuIHVyaUNvbXBvbmVudFxufVxuXG4vKiogQHR5cGUge1NjaGVtZUZufSAqL1xuZnVuY3Rpb24gdXJudXVpZFBhcnNlICh1cm5Db21wb25lbnQsIG9wdGlvbnMpIHtcbiAgY29uc3QgdXVpZENvbXBvbmVudCA9IHVybkNvbXBvbmVudFxuICB1dWlkQ29tcG9uZW50LnV1aWQgPSB1dWlkQ29tcG9uZW50Lm5zc1xuICB1dWlkQ29tcG9uZW50Lm5zcyA9IHVuZGVmaW5lZFxuXG4gIGlmICghb3B0aW9ucy50b2xlcmFudCAmJiAoIXV1aWRDb21wb25lbnQudXVpZCB8fCAhaXNVVUlEKHV1aWRDb21wb25lbnQudXVpZCkpKSB7XG4gICAgdXVpZENvbXBvbmVudC5lcnJvciA9IHV1aWRDb21wb25lbnQuZXJyb3IgfHwgJ1VVSUQgaXMgbm90IHZhbGlkLidcbiAgfVxuXG4gIHJldHVybiB1dWlkQ29tcG9uZW50XG59XG5cbi8qKiBAdHlwZSB7U2NoZW1lRm59ICovXG5mdW5jdGlvbiB1cm51dWlkU2VyaWFsaXplICh1dWlkQ29tcG9uZW50KSB7XG4gIGNvbnN0IHVybkNvbXBvbmVudCA9IHV1aWRDb21wb25lbnRcbiAgLy8gbm9ybWFsaXplIFVVSURcbiAgdXJuQ29tcG9uZW50Lm5zcyA9ICh1dWlkQ29tcG9uZW50LnV1aWQgfHwgJycpLnRvTG93ZXJDYXNlKClcbiAgcmV0dXJuIHVybkNvbXBvbmVudFxufVxuXG5jb25zdCBodHRwID0gLyoqIEB0eXBlIHtTY2hlbWVIYW5kbGVyfSAqLyAoe1xuICBzY2hlbWU6ICdodHRwJyxcbiAgZG9tYWluSG9zdDogdHJ1ZSxcbiAgcGFyc2U6IGh0dHBQYXJzZSxcbiAgc2VyaWFsaXplOiBodHRwU2VyaWFsaXplXG59KVxuXG5jb25zdCBodHRwcyA9IC8qKiBAdHlwZSB7U2NoZW1lSGFuZGxlcn0gKi8gKHtcbiAgc2NoZW1lOiAnaHR0cHMnLFxuICBkb21haW5Ib3N0OiBodHRwLmRvbWFpbkhvc3QsXG4gIHBhcnNlOiBodHRwUGFyc2UsXG4gIHNlcmlhbGl6ZTogaHR0cFNlcmlhbGl6ZVxufSlcblxuY29uc3Qgd3MgPSAvKiogQHR5cGUge1NjaGVtZUhhbmRsZXJ9ICovICh7XG4gIHNjaGVtZTogJ3dzJyxcbiAgZG9tYWluSG9zdDogdHJ1ZSxcbiAgcGFyc2U6IHdzUGFyc2UsXG4gIHNlcmlhbGl6ZTogd3NTZXJpYWxpemVcbn0pXG5cbmNvbnN0IHdzcyA9IC8qKiBAdHlwZSB7U2NoZW1lSGFuZGxlcn0gKi8gKHtcbiAgc2NoZW1lOiAnd3NzJyxcbiAgZG9tYWluSG9zdDogd3MuZG9tYWluSG9zdCxcbiAgcGFyc2U6IHdzLnBhcnNlLFxuICBzZXJpYWxpemU6IHdzLnNlcmlhbGl6ZVxufSlcblxuY29uc3QgdXJuID0gLyoqIEB0eXBlIHtTY2hlbWVIYW5kbGVyfSAqLyAoe1xuICBzY2hlbWU6ICd1cm4nLFxuICBwYXJzZTogdXJuUGFyc2UsXG4gIHNlcmlhbGl6ZTogdXJuU2VyaWFsaXplLFxuICBza2lwTm9ybWFsaXplOiB0cnVlXG59KVxuXG5jb25zdCB1cm51dWlkID0gLyoqIEB0eXBlIHtTY2hlbWVIYW5kbGVyfSAqLyAoe1xuICBzY2hlbWU6ICd1cm46dXVpZCcsXG4gIHBhcnNlOiB1cm51dWlkUGFyc2UsXG4gIHNlcmlhbGl6ZTogdXJudXVpZFNlcmlhbGl6ZSxcbiAgc2tpcE5vcm1hbGl6ZTogdHJ1ZVxufSlcblxuY29uc3QgU0NIRU1FUyA9IC8qKiBAdHlwZSB7UmVjb3JkPFNjaGVtZU5hbWUsIFNjaGVtZUhhbmRsZXI+fSAqLyAoe1xuICBodHRwLFxuICBodHRwcyxcbiAgd3MsXG4gIHdzcyxcbiAgdXJuLFxuICAndXJuOnV1aWQnOiB1cm51dWlkXG59KVxuXG5PYmplY3Quc2V0UHJvdG90eXBlT2YoU0NIRU1FUywgbnVsbClcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3x1bmRlZmluZWR9IHNjaGVtZVxuICogQHJldHVybnMge1NjaGVtZUhhbmRsZXJ8dW5kZWZpbmVkfVxuICovXG5mdW5jdGlvbiBnZXRTY2hlbWVIYW5kbGVyIChzY2hlbWUpIHtcbiAgcmV0dXJuIChcbiAgICBzY2hlbWUgJiYgKFxuICAgICAgU0NIRU1FU1svKiogQHR5cGUge1NjaGVtZU5hbWV9ICovIChzY2hlbWUpXSB8fFxuICAgICAgU0NIRU1FU1svKiogQHR5cGUge1NjaGVtZU5hbWV9ICovKHNjaGVtZS50b0xvd2VyQ2FzZSgpKV0pXG4gICkgfHxcbiAgICB1bmRlZmluZWRcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHdzSXNTZWN1cmUsXG4gIFNDSEVNRVMsXG4gIGlzVmFsaWRTY2hlbWVOYW1lLFxuICBnZXRTY2hlbWVIYW5kbGVyLFxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgbm9ybWFsaXplSVB2NiwgcmVtb3ZlRG90U2VnbWVudHMsIHJlY29tcG9zZUF1dGhvcml0eSwgbm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmcsIGlzSVB2NCwgbm9uU2ltcGxlRG9tYWluIH0gPSByZXF1aXJlKCcuL2xpYi91dGlscycpXG5jb25zdCB7IFNDSEVNRVMsIGdldFNjaGVtZUhhbmRsZXIgfSA9IHJlcXVpcmUoJy4vbGliL3NjaGVtZXMnKVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7aW1wb3J0KCcuL3R5cGVzL2luZGV4JykuVVJJQ29tcG9uZW50fHN0cmluZ30gVFxuICogQHBhcmFtIHtUfSB1cmlcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3R5cGVzL2luZGV4JykuT3B0aW9uc30gW29wdGlvbnNdXG4gKiBAcmV0dXJucyB7VH1cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplICh1cmksIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiB1cmkgPT09ICdzdHJpbmcnKSB7XG4gICAgdXJpID0gLyoqIEB0eXBlIHtUfSAqLyAoc2VyaWFsaXplKHBhcnNlKHVyaSwgb3B0aW9ucyksIG9wdGlvbnMpKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB1cmkgPT09ICdvYmplY3QnKSB7XG4gICAgdXJpID0gLyoqIEB0eXBlIHtUfSAqLyAocGFyc2Uoc2VyaWFsaXplKHVyaSwgb3B0aW9ucyksIG9wdGlvbnMpKVxuICB9XG4gIHJldHVybiB1cmlcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZVVSSVxuICogQHBhcmFtIHtzdHJpbmd9IHJlbGF0aXZlVVJJXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi90eXBlcy9pbmRleCcpLk9wdGlvbnN9IFtvcHRpb25zXVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZSAoYmFzZVVSSSwgcmVsYXRpdmVVUkksIG9wdGlvbnMpIHtcbiAgY29uc3Qgc2NoZW1lbGVzc09wdGlvbnMgPSBvcHRpb25zID8gT2JqZWN0LmFzc2lnbih7IHNjaGVtZTogJ251bGwnIH0sIG9wdGlvbnMpIDogeyBzY2hlbWU6ICdudWxsJyB9XG4gIGNvbnN0IHJlc29sdmVkID0gcmVzb2x2ZUNvbXBvbmVudChwYXJzZShiYXNlVVJJLCBzY2hlbWVsZXNzT3B0aW9ucyksIHBhcnNlKHJlbGF0aXZlVVJJLCBzY2hlbWVsZXNzT3B0aW9ucyksIHNjaGVtZWxlc3NPcHRpb25zLCB0cnVlKVxuICBzY2hlbWVsZXNzT3B0aW9ucy5za2lwRXNjYXBlID0gdHJ1ZVxuICByZXR1cm4gc2VyaWFsaXplKHJlc29sdmVkLCBzY2hlbWVsZXNzT3B0aW9ucylcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCAoJy4vdHlwZXMvaW5kZXgnKS5VUklDb21wb25lbnR9IGJhc2VcbiAqIEBwYXJhbSB7aW1wb3J0ICgnLi90eXBlcy9pbmRleCcpLlVSSUNvbXBvbmVudH0gcmVsYXRpdmVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3R5cGVzL2luZGV4JykuT3B0aW9uc30gW29wdGlvbnNdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtza2lwTm9ybWFsaXphdGlvbj1mYWxzZV1cbiAqIEByZXR1cm5zIHtpbXBvcnQgKCcuL3R5cGVzL2luZGV4JykuVVJJQ29tcG9uZW50fVxuICovXG5mdW5jdGlvbiByZXNvbHZlQ29tcG9uZW50IChiYXNlLCByZWxhdGl2ZSwgb3B0aW9ucywgc2tpcE5vcm1hbGl6YXRpb24pIHtcbiAgLyoqIEB0eXBlIHtpbXBvcnQoJy4vdHlwZXMvaW5kZXgnKS5VUklDb21wb25lbnR9ICovXG4gIGNvbnN0IHRhcmdldCA9IHt9XG4gIGlmICghc2tpcE5vcm1hbGl6YXRpb24pIHtcbiAgICBiYXNlID0gcGFyc2Uoc2VyaWFsaXplKGJhc2UsIG9wdGlvbnMpLCBvcHRpb25zKSAvLyBub3JtYWxpemUgYmFzZSBjb21wb25lbnRcbiAgICByZWxhdGl2ZSA9IHBhcnNlKHNlcmlhbGl6ZShyZWxhdGl2ZSwgb3B0aW9ucyksIG9wdGlvbnMpIC8vIG5vcm1hbGl6ZSByZWxhdGl2ZSBjb21wb25lbnRcbiAgfVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuXG4gIGlmICghb3B0aW9ucy50b2xlcmFudCAmJiByZWxhdGl2ZS5zY2hlbWUpIHtcbiAgICB0YXJnZXQuc2NoZW1lID0gcmVsYXRpdmUuc2NoZW1lXG4gICAgLy8gdGFyZ2V0LmF1dGhvcml0eSA9IHJlbGF0aXZlLmF1dGhvcml0eTtcbiAgICB0YXJnZXQudXNlcmluZm8gPSByZWxhdGl2ZS51c2VyaW5mb1xuICAgIHRhcmdldC5ob3N0ID0gcmVsYXRpdmUuaG9zdFxuICAgIHRhcmdldC5wb3J0ID0gcmVsYXRpdmUucG9ydFxuICAgIHRhcmdldC5wYXRoID0gcmVtb3ZlRG90U2VnbWVudHMocmVsYXRpdmUucGF0aCB8fCAnJylcbiAgICB0YXJnZXQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeVxuICB9IGVsc2Uge1xuICAgIGlmIChyZWxhdGl2ZS51c2VyaW5mbyAhPT0gdW5kZWZpbmVkIHx8IHJlbGF0aXZlLmhvc3QgIT09IHVuZGVmaW5lZCB8fCByZWxhdGl2ZS5wb3J0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIHRhcmdldC5hdXRob3JpdHkgPSByZWxhdGl2ZS5hdXRob3JpdHk7XG4gICAgICB0YXJnZXQudXNlcmluZm8gPSByZWxhdGl2ZS51c2VyaW5mb1xuICAgICAgdGFyZ2V0Lmhvc3QgPSByZWxhdGl2ZS5ob3N0XG4gICAgICB0YXJnZXQucG9ydCA9IHJlbGF0aXZlLnBvcnRcbiAgICAgIHRhcmdldC5wYXRoID0gcmVtb3ZlRG90U2VnbWVudHMocmVsYXRpdmUucGF0aCB8fCAnJylcbiAgICAgIHRhcmdldC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghcmVsYXRpdmUucGF0aCkge1xuICAgICAgICB0YXJnZXQucGF0aCA9IGJhc2UucGF0aFxuICAgICAgICBpZiAocmVsYXRpdmUucXVlcnkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRhcmdldC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFyZ2V0LnF1ZXJ5ID0gYmFzZS5xdWVyeVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocmVsYXRpdmUucGF0aFswXSA9PT0gJy8nKSB7XG4gICAgICAgICAgdGFyZ2V0LnBhdGggPSByZW1vdmVEb3RTZWdtZW50cyhyZWxhdGl2ZS5wYXRoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICgoYmFzZS51c2VyaW5mbyAhPT0gdW5kZWZpbmVkIHx8IGJhc2UuaG9zdCAhPT0gdW5kZWZpbmVkIHx8IGJhc2UucG9ydCAhPT0gdW5kZWZpbmVkKSAmJiAhYmFzZS5wYXRoKSB7XG4gICAgICAgICAgICB0YXJnZXQucGF0aCA9ICcvJyArIHJlbGF0aXZlLnBhdGhcbiAgICAgICAgICB9IGVsc2UgaWYgKCFiYXNlLnBhdGgpIHtcbiAgICAgICAgICAgIHRhcmdldC5wYXRoID0gcmVsYXRpdmUucGF0aFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0YXJnZXQucGF0aCA9IGJhc2UucGF0aC5zbGljZSgwLCBiYXNlLnBhdGgubGFzdEluZGV4T2YoJy8nKSArIDEpICsgcmVsYXRpdmUucGF0aFxuICAgICAgICAgIH1cbiAgICAgICAgICB0YXJnZXQucGF0aCA9IHJlbW92ZURvdFNlZ21lbnRzKHRhcmdldC5wYXRoKVxuICAgICAgICB9XG4gICAgICAgIHRhcmdldC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5XG4gICAgICB9XG4gICAgICAvLyB0YXJnZXQuYXV0aG9yaXR5ID0gYmFzZS5hdXRob3JpdHk7XG4gICAgICB0YXJnZXQudXNlcmluZm8gPSBiYXNlLnVzZXJpbmZvXG4gICAgICB0YXJnZXQuaG9zdCA9IGJhc2UuaG9zdFxuICAgICAgdGFyZ2V0LnBvcnQgPSBiYXNlLnBvcnRcbiAgICB9XG4gICAgdGFyZ2V0LnNjaGVtZSA9IGJhc2Uuc2NoZW1lXG4gIH1cblxuICB0YXJnZXQuZnJhZ21lbnQgPSByZWxhdGl2ZS5mcmFnbWVudFxuXG4gIHJldHVybiB0YXJnZXRcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCAoJy4vdHlwZXMvaW5kZXgnKS5VUklDb21wb25lbnR8c3RyaW5nfSB1cmlBXG4gKiBAcGFyYW0ge2ltcG9ydCAoJy4vdHlwZXMvaW5kZXgnKS5VUklDb21wb25lbnR8c3RyaW5nfSB1cmlCXG4gKiBAcGFyYW0ge2ltcG9ydCAoJy4vdHlwZXMvaW5kZXgnKS5PcHRpb25zfSBvcHRpb25zXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gZXF1YWwgKHVyaUEsIHVyaUIsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiB1cmlBID09PSAnc3RyaW5nJykge1xuICAgIHVyaUEgPSB1bmVzY2FwZSh1cmlBKVxuICAgIHVyaUEgPSBzZXJpYWxpemUobm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmcocGFyc2UodXJpQSwgb3B0aW9ucyksIHRydWUpLCB7IC4uLm9wdGlvbnMsIHNraXBFc2NhcGU6IHRydWUgfSlcbiAgfSBlbHNlIGlmICh0eXBlb2YgdXJpQSA9PT0gJ29iamVjdCcpIHtcbiAgICB1cmlBID0gc2VyaWFsaXplKG5vcm1hbGl6ZUNvbXBvbmVudEVuY29kaW5nKHVyaUEsIHRydWUpLCB7IC4uLm9wdGlvbnMsIHNraXBFc2NhcGU6IHRydWUgfSlcbiAgfVxuXG4gIGlmICh0eXBlb2YgdXJpQiA9PT0gJ3N0cmluZycpIHtcbiAgICB1cmlCID0gdW5lc2NhcGUodXJpQilcbiAgICB1cmlCID0gc2VyaWFsaXplKG5vcm1hbGl6ZUNvbXBvbmVudEVuY29kaW5nKHBhcnNlKHVyaUIsIG9wdGlvbnMpLCB0cnVlKSwgeyAuLi5vcHRpb25zLCBza2lwRXNjYXBlOiB0cnVlIH0pXG4gIH0gZWxzZSBpZiAodHlwZW9mIHVyaUIgPT09ICdvYmplY3QnKSB7XG4gICAgdXJpQiA9IHNlcmlhbGl6ZShub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyh1cmlCLCB0cnVlKSwgeyAuLi5vcHRpb25zLCBza2lwRXNjYXBlOiB0cnVlIH0pXG4gIH1cblxuICByZXR1cm4gdXJpQS50b0xvd2VyQ2FzZSgpID09PSB1cmlCLnRvTG93ZXJDYXNlKClcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlYWRvbmx5PGltcG9ydCgnLi90eXBlcy9pbmRleCcpLlVSSUNvbXBvbmVudD59IGNtcHRzXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi90eXBlcy9pbmRleCcpLk9wdGlvbnN9IFtvcHRzXVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gc2VyaWFsaXplIChjbXB0cywgb3B0cykge1xuICBjb25zdCBjb21wb25lbnQgPSB7XG4gICAgaG9zdDogY21wdHMuaG9zdCxcbiAgICBzY2hlbWU6IGNtcHRzLnNjaGVtZSxcbiAgICB1c2VyaW5mbzogY21wdHMudXNlcmluZm8sXG4gICAgcG9ydDogY21wdHMucG9ydCxcbiAgICBwYXRoOiBjbXB0cy5wYXRoLFxuICAgIHF1ZXJ5OiBjbXB0cy5xdWVyeSxcbiAgICBuaWQ6IGNtcHRzLm5pZCxcbiAgICBuc3M6IGNtcHRzLm5zcyxcbiAgICB1dWlkOiBjbXB0cy51dWlkLFxuICAgIGZyYWdtZW50OiBjbXB0cy5mcmFnbWVudCxcbiAgICByZWZlcmVuY2U6IGNtcHRzLnJlZmVyZW5jZSxcbiAgICByZXNvdXJjZU5hbWU6IGNtcHRzLnJlc291cmNlTmFtZSxcbiAgICBzZWN1cmU6IGNtcHRzLnNlY3VyZSxcbiAgICBlcnJvcjogJydcbiAgfVxuICBjb25zdCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0cylcbiAgY29uc3QgdXJpVG9rZW5zID0gW11cblxuICAvLyBmaW5kIHNjaGVtZSBoYW5kbGVyXG4gIGNvbnN0IHNjaGVtZUhhbmRsZXIgPSBnZXRTY2hlbWVIYW5kbGVyKG9wdGlvbnMuc2NoZW1lIHx8IGNvbXBvbmVudC5zY2hlbWUpXG5cbiAgLy8gcGVyZm9ybSBzY2hlbWUgc3BlY2lmaWMgc2VyaWFsaXphdGlvblxuICBpZiAoc2NoZW1lSGFuZGxlciAmJiBzY2hlbWVIYW5kbGVyLnNlcmlhbGl6ZSkgc2NoZW1lSGFuZGxlci5zZXJpYWxpemUoY29tcG9uZW50LCBvcHRpb25zKVxuXG4gIGlmIChjb21wb25lbnQucGF0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKCFvcHRpb25zLnNraXBFc2NhcGUpIHtcbiAgICAgIGNvbXBvbmVudC5wYXRoID0gZXNjYXBlKGNvbXBvbmVudC5wYXRoKVxuXG4gICAgICBpZiAoY29tcG9uZW50LnNjaGVtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbXBvbmVudC5wYXRoID0gY29tcG9uZW50LnBhdGguc3BsaXQoJyUzQScpLmpvaW4oJzonKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb21wb25lbnQucGF0aCA9IHVuZXNjYXBlKGNvbXBvbmVudC5wYXRoKVxuICAgIH1cbiAgfVxuXG4gIGlmIChvcHRpb25zLnJlZmVyZW5jZSAhPT0gJ3N1ZmZpeCcgJiYgY29tcG9uZW50LnNjaGVtZSkge1xuICAgIHVyaVRva2Vucy5wdXNoKGNvbXBvbmVudC5zY2hlbWUsICc6JylcbiAgfVxuXG4gIGNvbnN0IGF1dGhvcml0eSA9IHJlY29tcG9zZUF1dGhvcml0eShjb21wb25lbnQpXG4gIGlmIChhdXRob3JpdHkgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChvcHRpb25zLnJlZmVyZW5jZSAhPT0gJ3N1ZmZpeCcpIHtcbiAgICAgIHVyaVRva2Vucy5wdXNoKCcvLycpXG4gICAgfVxuXG4gICAgdXJpVG9rZW5zLnB1c2goYXV0aG9yaXR5KVxuXG4gICAgaWYgKGNvbXBvbmVudC5wYXRoICYmIGNvbXBvbmVudC5wYXRoWzBdICE9PSAnLycpIHtcbiAgICAgIHVyaVRva2Vucy5wdXNoKCcvJylcbiAgICB9XG4gIH1cbiAgaWYgKGNvbXBvbmVudC5wYXRoICE9PSB1bmRlZmluZWQpIHtcbiAgICBsZXQgcyA9IGNvbXBvbmVudC5wYXRoXG5cbiAgICBpZiAoIW9wdGlvbnMuYWJzb2x1dGVQYXRoICYmICghc2NoZW1lSGFuZGxlciB8fCAhc2NoZW1lSGFuZGxlci5hYnNvbHV0ZVBhdGgpKSB7XG4gICAgICBzID0gcmVtb3ZlRG90U2VnbWVudHMocylcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBhdXRob3JpdHkgPT09IHVuZGVmaW5lZCAmJlxuICAgICAgc1swXSA9PT0gJy8nICYmXG4gICAgICBzWzFdID09PSAnLydcbiAgICApIHtcbiAgICAgIC8vIGRvbid0IGFsbG93IHRoZSBwYXRoIHRvIHN0YXJ0IHdpdGggXCIvL1wiXG4gICAgICBzID0gJy8lMkYnICsgcy5zbGljZSgyKVxuICAgIH1cblxuICAgIHVyaVRva2Vucy5wdXNoKHMpXG4gIH1cblxuICBpZiAoY29tcG9uZW50LnF1ZXJ5ICE9PSB1bmRlZmluZWQpIHtcbiAgICB1cmlUb2tlbnMucHVzaCgnPycsIGNvbXBvbmVudC5xdWVyeSlcbiAgfVxuXG4gIGlmIChjb21wb25lbnQuZnJhZ21lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgIHVyaVRva2Vucy5wdXNoKCcjJywgY29tcG9uZW50LmZyYWdtZW50KVxuICB9XG4gIHJldHVybiB1cmlUb2tlbnMuam9pbignJylcbn1cblxuY29uc3QgVVJJX1BBUlNFID0gL14oPzooW14jLzo/XSspOik/KD86XFwvXFwvKCg/OihbXiMvP0BdKilAKT8oXFxbW14jLz9cXF1dK1xcXXxbXiMvOj9dKikoPzo6KFxcZCopKT8pKT8oW14jP10qKSg/OlxcPyhbXiNdKikpPyg/OiMoKD86LnxbXFxuXFxyXSkqKSk/L3VcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJpXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi90eXBlcy9pbmRleCcpLk9wdGlvbnN9IFtvcHRzXVxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gcGFyc2UgKHVyaSwgb3B0cykge1xuICBjb25zdCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0cylcbiAgLyoqIEB0eXBlIHtpbXBvcnQoJy4vdHlwZXMvaW5kZXgnKS5VUklDb21wb25lbnR9ICovXG4gIGNvbnN0IHBhcnNlZCA9IHtcbiAgICBzY2hlbWU6IHVuZGVmaW5lZCxcbiAgICB1c2VyaW5mbzogdW5kZWZpbmVkLFxuICAgIGhvc3Q6ICcnLFxuICAgIHBvcnQ6IHVuZGVmaW5lZCxcbiAgICBwYXRoOiAnJyxcbiAgICBxdWVyeTogdW5kZWZpbmVkLFxuICAgIGZyYWdtZW50OiB1bmRlZmluZWRcbiAgfVxuXG4gIGxldCBpc0lQID0gZmFsc2VcbiAgaWYgKG9wdGlvbnMucmVmZXJlbmNlID09PSAnc3VmZml4Jykge1xuICAgIGlmIChvcHRpb25zLnNjaGVtZSkge1xuICAgICAgdXJpID0gb3B0aW9ucy5zY2hlbWUgKyAnOicgKyB1cmlcbiAgICB9IGVsc2Uge1xuICAgICAgdXJpID0gJy8vJyArIHVyaVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IG1hdGNoZXMgPSB1cmkubWF0Y2goVVJJX1BBUlNFKVxuXG4gIGlmIChtYXRjaGVzKSB7XG4gICAgLy8gc3RvcmUgZWFjaCBjb21wb25lbnRcbiAgICBwYXJzZWQuc2NoZW1lID0gbWF0Y2hlc1sxXVxuICAgIHBhcnNlZC51c2VyaW5mbyA9IG1hdGNoZXNbM11cbiAgICBwYXJzZWQuaG9zdCA9IG1hdGNoZXNbNF1cbiAgICBwYXJzZWQucG9ydCA9IHBhcnNlSW50KG1hdGNoZXNbNV0sIDEwKVxuICAgIHBhcnNlZC5wYXRoID0gbWF0Y2hlc1s2XSB8fCAnJ1xuICAgIHBhcnNlZC5xdWVyeSA9IG1hdGNoZXNbN11cbiAgICBwYXJzZWQuZnJhZ21lbnQgPSBtYXRjaGVzWzhdXG5cbiAgICAvLyBmaXggcG9ydCBudW1iZXJcbiAgICBpZiAoaXNOYU4ocGFyc2VkLnBvcnQpKSB7XG4gICAgICBwYXJzZWQucG9ydCA9IG1hdGNoZXNbNV1cbiAgICB9XG4gICAgaWYgKHBhcnNlZC5ob3N0KSB7XG4gICAgICBjb25zdCBpcHY0cmVzdWx0ID0gaXNJUHY0KHBhcnNlZC5ob3N0KVxuICAgICAgaWYgKGlwdjRyZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IGlwdjZyZXN1bHQgPSBub3JtYWxpemVJUHY2KHBhcnNlZC5ob3N0KVxuICAgICAgICBwYXJzZWQuaG9zdCA9IGlwdjZyZXN1bHQuaG9zdC50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGlzSVAgPSBpcHY2cmVzdWx0LmlzSVBWNlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXNJUCA9IHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBhcnNlZC5zY2hlbWUgPT09IHVuZGVmaW5lZCAmJiBwYXJzZWQudXNlcmluZm8gPT09IHVuZGVmaW5lZCAmJiBwYXJzZWQuaG9zdCA9PT0gdW5kZWZpbmVkICYmIHBhcnNlZC5wb3J0ID09PSB1bmRlZmluZWQgJiYgcGFyc2VkLnF1ZXJ5ID09PSB1bmRlZmluZWQgJiYgIXBhcnNlZC5wYXRoKSB7XG4gICAgICBwYXJzZWQucmVmZXJlbmNlID0gJ3NhbWUtZG9jdW1lbnQnXG4gICAgfSBlbHNlIGlmIChwYXJzZWQuc2NoZW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHBhcnNlZC5yZWZlcmVuY2UgPSAncmVsYXRpdmUnXG4gICAgfSBlbHNlIGlmIChwYXJzZWQuZnJhZ21lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcGFyc2VkLnJlZmVyZW5jZSA9ICdhYnNvbHV0ZSdcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyc2VkLnJlZmVyZW5jZSA9ICd1cmknXG4gICAgfVxuXG4gICAgLy8gY2hlY2sgZm9yIHJlZmVyZW5jZSBlcnJvcnNcbiAgICBpZiAob3B0aW9ucy5yZWZlcmVuY2UgJiYgb3B0aW9ucy5yZWZlcmVuY2UgIT09ICdzdWZmaXgnICYmIG9wdGlvbnMucmVmZXJlbmNlICE9PSBwYXJzZWQucmVmZXJlbmNlKSB7XG4gICAgICBwYXJzZWQuZXJyb3IgPSBwYXJzZWQuZXJyb3IgfHwgJ1VSSSBpcyBub3QgYSAnICsgb3B0aW9ucy5yZWZlcmVuY2UgKyAnIHJlZmVyZW5jZS4nXG4gICAgfVxuXG4gICAgLy8gZmluZCBzY2hlbWUgaGFuZGxlclxuICAgIGNvbnN0IHNjaGVtZUhhbmRsZXIgPSBnZXRTY2hlbWVIYW5kbGVyKG9wdGlvbnMuc2NoZW1lIHx8IHBhcnNlZC5zY2hlbWUpXG5cbiAgICAvLyBjaGVjayBpZiBzY2hlbWUgY2FuJ3QgaGFuZGxlIElSSXNcbiAgICBpZiAoIW9wdGlvbnMudW5pY29kZVN1cHBvcnQgJiYgKCFzY2hlbWVIYW5kbGVyIHx8ICFzY2hlbWVIYW5kbGVyLnVuaWNvZGVTdXBwb3J0KSkge1xuICAgICAgLy8gaWYgaG9zdCBjb21wb25lbnQgaXMgYSBkb21haW4gbmFtZVxuICAgICAgaWYgKHBhcnNlZC5ob3N0ICYmIChvcHRpb25zLmRvbWFpbkhvc3QgfHwgKHNjaGVtZUhhbmRsZXIgJiYgc2NoZW1lSGFuZGxlci5kb21haW5Ib3N0KSkgJiYgaXNJUCA9PT0gZmFsc2UgJiYgbm9uU2ltcGxlRG9tYWluKHBhcnNlZC5ob3N0KSkge1xuICAgICAgICAvLyBjb252ZXJ0IFVuaWNvZGUgSUROIC0+IEFTQ0lJIElETlxuICAgICAgICB0cnkge1xuICAgICAgICAgIHBhcnNlZC5ob3N0ID0gVVJMLmRvbWFpblRvQVNDSUkocGFyc2VkLmhvc3QudG9Mb3dlckNhc2UoKSlcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHBhcnNlZC5lcnJvciA9IHBhcnNlZC5lcnJvciB8fCBcIkhvc3QncyBkb21haW4gbmFtZSBjYW4gbm90IGJlIGNvbnZlcnRlZCB0byBBU0NJSTogXCIgKyBlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGNvbnZlcnQgSVJJIC0+IFVSSVxuICAgIH1cblxuICAgIGlmICghc2NoZW1lSGFuZGxlciB8fCAoc2NoZW1lSGFuZGxlciAmJiAhc2NoZW1lSGFuZGxlci5za2lwTm9ybWFsaXplKSkge1xuICAgICAgaWYgKHVyaS5pbmRleE9mKCclJykgIT09IC0xKSB7XG4gICAgICAgIGlmIChwYXJzZWQuc2NoZW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwYXJzZWQuc2NoZW1lID0gdW5lc2NhcGUocGFyc2VkLnNjaGVtZSlcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyc2VkLmhvc3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHBhcnNlZC5ob3N0ID0gdW5lc2NhcGUocGFyc2VkLmhvc3QpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwYXJzZWQucGF0aCkge1xuICAgICAgICBwYXJzZWQucGF0aCA9IGVzY2FwZSh1bmVzY2FwZShwYXJzZWQucGF0aCkpXG4gICAgICB9XG4gICAgICBpZiAocGFyc2VkLmZyYWdtZW50KSB7XG4gICAgICAgIHBhcnNlZC5mcmFnbWVudCA9IGVuY29kZVVSSShkZWNvZGVVUklDb21wb25lbnQocGFyc2VkLmZyYWdtZW50KSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBwZXJmb3JtIHNjaGVtZSBzcGVjaWZpYyBwYXJzaW5nXG4gICAgaWYgKHNjaGVtZUhhbmRsZXIgJiYgc2NoZW1lSGFuZGxlci5wYXJzZSkge1xuICAgICAgc2NoZW1lSGFuZGxlci5wYXJzZShwYXJzZWQsIG9wdGlvbnMpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHBhcnNlZC5lcnJvciA9IHBhcnNlZC5lcnJvciB8fCAnVVJJIGNhbiBub3QgYmUgcGFyc2VkLidcbiAgfVxuICByZXR1cm4gcGFyc2VkXG59XG5cbmNvbnN0IGZhc3RVcmkgPSB7XG4gIFNDSEVNRVMsXG4gIG5vcm1hbGl6ZSxcbiAgcmVzb2x2ZSxcbiAgcmVzb2x2ZUNvbXBvbmVudCxcbiAgZXF1YWwsXG4gIHNlcmlhbGl6ZSxcbiAgcGFyc2Vcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmYXN0VXJpXG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZmFzdFVyaVxubW9kdWxlLmV4cG9ydHMuZmFzdFVyaSA9IGZhc3RVcmlcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgdXJpID0gcmVxdWlyZShcImZhc3QtdXJpXCIpO1xudXJpLmNvZGUgPSAncmVxdWlyZShcImFqdi9kaXN0L3J1bnRpbWUvdXJpXCIpLmRlZmF1bHQnO1xuZXhwb3J0cy5kZWZhdWx0ID0gdXJpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXJpLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db2RlR2VuID0gZXhwb3J0cy5OYW1lID0gZXhwb3J0cy5uaWwgPSBleHBvcnRzLnN0cmluZ2lmeSA9IGV4cG9ydHMuc3RyID0gZXhwb3J0cy5fID0gZXhwb3J0cy5LZXl3b3JkQ3h0ID0gdm9pZCAwO1xudmFyIHZhbGlkYXRlXzEgPSByZXF1aXJlKFwiLi9jb21waWxlL3ZhbGlkYXRlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiS2V5d29yZEN4dFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsaWRhdGVfMS5LZXl3b3JkQ3h0OyB9IH0pO1xudmFyIGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuL2NvbXBpbGUvY29kZWdlblwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVnZW5fMS5fOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3RyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEuc3RyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3RyaW5naWZ5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEuc3RyaW5naWZ5OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibmlsXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEubmlsOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTmFtZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLk5hbWU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb2RlR2VuXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEuQ29kZUdlbjsgfSB9KTtcbmNvbnN0IHZhbGlkYXRpb25fZXJyb3JfMSA9IHJlcXVpcmUoXCIuL3J1bnRpbWUvdmFsaWRhdGlvbl9lcnJvclwiKTtcbmNvbnN0IHJlZl9lcnJvcl8xID0gcmVxdWlyZShcIi4vY29tcGlsZS9yZWZfZXJyb3JcIik7XG5jb25zdCBydWxlc18xID0gcmVxdWlyZShcIi4vY29tcGlsZS9ydWxlc1wiKTtcbmNvbnN0IGNvbXBpbGVfMSA9IHJlcXVpcmUoXCIuL2NvbXBpbGVcIik7XG5jb25zdCBjb2RlZ2VuXzIgPSByZXF1aXJlKFwiLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCByZXNvbHZlXzEgPSByZXF1aXJlKFwiLi9jb21waWxlL3Jlc29sdmVcIik7XG5jb25zdCBkYXRhVHlwZV8xID0gcmVxdWlyZShcIi4vY29tcGlsZS92YWxpZGF0ZS9kYXRhVHlwZVwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0ICRkYXRhUmVmU2NoZW1hID0gcmVxdWlyZShcIi4vcmVmcy9kYXRhLmpzb25cIik7XG5jb25zdCB1cmlfMSA9IHJlcXVpcmUoXCIuL3J1bnRpbWUvdXJpXCIpO1xuY29uc3QgZGVmYXVsdFJlZ0V4cCA9IChzdHIsIGZsYWdzKSA9PiBuZXcgUmVnRXhwKHN0ciwgZmxhZ3MpO1xuZGVmYXVsdFJlZ0V4cC5jb2RlID0gXCJuZXcgUmVnRXhwXCI7XG5jb25zdCBNRVRBX0lHTk9SRV9PUFRJT05TID0gW1wicmVtb3ZlQWRkaXRpb25hbFwiLCBcInVzZURlZmF1bHRzXCIsIFwiY29lcmNlVHlwZXNcIl07XG5jb25zdCBFWFRfU0NPUEVfTkFNRVMgPSBuZXcgU2V0KFtcbiAgICBcInZhbGlkYXRlXCIsXG4gICAgXCJzZXJpYWxpemVcIixcbiAgICBcInBhcnNlXCIsXG4gICAgXCJ3cmFwcGVyXCIsXG4gICAgXCJyb290XCIsXG4gICAgXCJzY2hlbWFcIixcbiAgICBcImtleXdvcmRcIixcbiAgICBcInBhdHRlcm5cIixcbiAgICBcImZvcm1hdHNcIixcbiAgICBcInZhbGlkYXRlJGRhdGFcIixcbiAgICBcImZ1bmNcIixcbiAgICBcIm9ialwiLFxuICAgIFwiRXJyb3JcIixcbl0pO1xuY29uc3QgcmVtb3ZlZE9wdGlvbnMgPSB7XG4gICAgZXJyb3JEYXRhUGF0aDogXCJcIixcbiAgICBmb3JtYXQ6IFwiYHZhbGlkYXRlRm9ybWF0czogZmFsc2VgIGNhbiBiZSB1c2VkIGluc3RlYWQuXCIsXG4gICAgbnVsbGFibGU6ICdcIm51bGxhYmxlXCIga2V5d29yZCBpcyBzdXBwb3J0ZWQgYnkgZGVmYXVsdC4nLFxuICAgIGpzb25Qb2ludGVyczogXCJEZXByZWNhdGVkIGpzUHJvcGVydHlTeW50YXggY2FuIGJlIHVzZWQgaW5zdGVhZC5cIixcbiAgICBleHRlbmRSZWZzOiBcIkRlcHJlY2F0ZWQgaWdub3JlS2V5d29yZHNXaXRoUmVmIGNhbiBiZSB1c2VkIGluc3RlYWQuXCIsXG4gICAgbWlzc2luZ1JlZnM6IFwiUGFzcyBlbXB0eSBzY2hlbWEgd2l0aCAkaWQgdGhhdCBzaG91bGQgYmUgaWdub3JlZCB0byBhanYuYWRkU2NoZW1hLlwiLFxuICAgIHByb2Nlc3NDb2RlOiBcIlVzZSBvcHRpb24gYGNvZGU6IHtwcm9jZXNzOiAoY29kZSwgc2NoZW1hRW52OiBvYmplY3QpID0+IHN0cmluZ31gXCIsXG4gICAgc291cmNlQ29kZTogXCJVc2Ugb3B0aW9uIGBjb2RlOiB7c291cmNlOiB0cnVlfWBcIixcbiAgICBzdHJpY3REZWZhdWx0czogXCJJdCBpcyBkZWZhdWx0IG5vdywgc2VlIG9wdGlvbiBgc3RyaWN0YC5cIixcbiAgICBzdHJpY3RLZXl3b3JkczogXCJJdCBpcyBkZWZhdWx0IG5vdywgc2VlIG9wdGlvbiBgc3RyaWN0YC5cIixcbiAgICB1bmlxdWVJdGVtczogJ1widW5pcXVlSXRlbXNcIiBrZXl3b3JkIGlzIGFsd2F5cyB2YWxpZGF0ZWQuJyxcbiAgICB1bmtub3duRm9ybWF0czogXCJEaXNhYmxlIHN0cmljdCBtb2RlIG9yIHBhc3MgYHRydWVgIHRvIGBhanYuYWRkRm9ybWF0YCAob3IgYGZvcm1hdHNgIG9wdGlvbikuXCIsXG4gICAgY2FjaGU6IFwiTWFwIGlzIHVzZWQgYXMgY2FjaGUsIHNjaGVtYSBvYmplY3QgYXMga2V5LlwiLFxuICAgIHNlcmlhbGl6ZTogXCJNYXAgaXMgdXNlZCBhcyBjYWNoZSwgc2NoZW1hIG9iamVjdCBhcyBrZXkuXCIsXG4gICAgYWp2RXJyb3JzOiBcIkl0IGlzIGRlZmF1bHQgbm93LlwiLFxufTtcbmNvbnN0IGRlcHJlY2F0ZWRPcHRpb25zID0ge1xuICAgIGlnbm9yZUtleXdvcmRzV2l0aFJlZjogXCJcIixcbiAgICBqc1Byb3BlcnR5U3ludGF4OiBcIlwiLFxuICAgIHVuaWNvZGU6ICdcIm1pbkxlbmd0aFwiL1wibWF4TGVuZ3RoXCIgYWNjb3VudCBmb3IgdW5pY29kZSBjaGFyYWN0ZXJzIGJ5IGRlZmF1bHQuJyxcbn07XG5jb25zdCBNQVhfRVhQUkVTU0lPTiA9IDIwMDtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5mdW5jdGlvbiByZXF1aXJlZE9wdGlvbnMobykge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9qLCBfaywgX2wsIF9tLCBfbywgX3AsIF9xLCBfciwgX3MsIF90LCBfdSwgX3YsIF93LCBfeCwgX3ksIF96LCBfMDtcbiAgICBjb25zdCBzID0gby5zdHJpY3Q7XG4gICAgY29uc3QgX29wdHogPSAoX2EgPSBvLmNvZGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vcHRpbWl6ZTtcbiAgICBjb25zdCBvcHRpbWl6ZSA9IF9vcHR6ID09PSB0cnVlIHx8IF9vcHR6ID09PSB1bmRlZmluZWQgPyAxIDogX29wdHogfHwgMDtcbiAgICBjb25zdCByZWdFeHAgPSAoX2MgPSAoX2IgPSBvLmNvZGUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5yZWdFeHApICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IGRlZmF1bHRSZWdFeHA7XG4gICAgY29uc3QgdXJpUmVzb2x2ZXIgPSAoX2QgPSBvLnVyaVJlc29sdmVyKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiB1cmlfMS5kZWZhdWx0O1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0cmljdFNjaGVtYTogKF9mID0gKF9lID0gby5zdHJpY3RTY2hlbWEpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IHMpICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IHRydWUsXG4gICAgICAgIHN0cmljdE51bWJlcnM6IChfaCA9IChfZyA9IG8uc3RyaWN0TnVtYmVycykgIT09IG51bGwgJiYgX2cgIT09IHZvaWQgMCA/IF9nIDogcykgIT09IG51bGwgJiYgX2ggIT09IHZvaWQgMCA/IF9oIDogdHJ1ZSxcbiAgICAgICAgc3RyaWN0VHlwZXM6IChfayA9IChfaiA9IG8uc3RyaWN0VHlwZXMpICE9PSBudWxsICYmIF9qICE9PSB2b2lkIDAgPyBfaiA6IHMpICE9PSBudWxsICYmIF9rICE9PSB2b2lkIDAgPyBfayA6IFwibG9nXCIsXG4gICAgICAgIHN0cmljdFR1cGxlczogKF9tID0gKF9sID0gby5zdHJpY3RUdXBsZXMpICE9PSBudWxsICYmIF9sICE9PSB2b2lkIDAgPyBfbCA6IHMpICE9PSBudWxsICYmIF9tICE9PSB2b2lkIDAgPyBfbSA6IFwibG9nXCIsXG4gICAgICAgIHN0cmljdFJlcXVpcmVkOiAoX3AgPSAoX28gPSBvLnN0cmljdFJlcXVpcmVkKSAhPT0gbnVsbCAmJiBfbyAhPT0gdm9pZCAwID8gX28gOiBzKSAhPT0gbnVsbCAmJiBfcCAhPT0gdm9pZCAwID8gX3AgOiBmYWxzZSxcbiAgICAgICAgY29kZTogby5jb2RlID8geyAuLi5vLmNvZGUsIG9wdGltaXplLCByZWdFeHAgfSA6IHsgb3B0aW1pemUsIHJlZ0V4cCB9LFxuICAgICAgICBsb29wUmVxdWlyZWQ6IChfcSA9IG8ubG9vcFJlcXVpcmVkKSAhPT0gbnVsbCAmJiBfcSAhPT0gdm9pZCAwID8gX3EgOiBNQVhfRVhQUkVTU0lPTixcbiAgICAgICAgbG9vcEVudW06IChfciA9IG8ubG9vcEVudW0pICE9PSBudWxsICYmIF9yICE9PSB2b2lkIDAgPyBfciA6IE1BWF9FWFBSRVNTSU9OLFxuICAgICAgICBtZXRhOiAoX3MgPSBvLm1ldGEpICE9PSBudWxsICYmIF9zICE9PSB2b2lkIDAgPyBfcyA6IHRydWUsXG4gICAgICAgIG1lc3NhZ2VzOiAoX3QgPSBvLm1lc3NhZ2VzKSAhPT0gbnVsbCAmJiBfdCAhPT0gdm9pZCAwID8gX3QgOiB0cnVlLFxuICAgICAgICBpbmxpbmVSZWZzOiAoX3UgPSBvLmlubGluZVJlZnMpICE9PSBudWxsICYmIF91ICE9PSB2b2lkIDAgPyBfdSA6IHRydWUsXG4gICAgICAgIHNjaGVtYUlkOiAoX3YgPSBvLnNjaGVtYUlkKSAhPT0gbnVsbCAmJiBfdiAhPT0gdm9pZCAwID8gX3YgOiBcIiRpZFwiLFxuICAgICAgICBhZGRVc2VkU2NoZW1hOiAoX3cgPSBvLmFkZFVzZWRTY2hlbWEpICE9PSBudWxsICYmIF93ICE9PSB2b2lkIDAgPyBfdyA6IHRydWUsXG4gICAgICAgIHZhbGlkYXRlU2NoZW1hOiAoX3ggPSBvLnZhbGlkYXRlU2NoZW1hKSAhPT0gbnVsbCAmJiBfeCAhPT0gdm9pZCAwID8gX3ggOiB0cnVlLFxuICAgICAgICB2YWxpZGF0ZUZvcm1hdHM6IChfeSA9IG8udmFsaWRhdGVGb3JtYXRzKSAhPT0gbnVsbCAmJiBfeSAhPT0gdm9pZCAwID8gX3kgOiB0cnVlLFxuICAgICAgICB1bmljb2RlUmVnRXhwOiAoX3ogPSBvLnVuaWNvZGVSZWdFeHApICE9PSBudWxsICYmIF96ICE9PSB2b2lkIDAgPyBfeiA6IHRydWUsXG4gICAgICAgIGludDMycmFuZ2U6IChfMCA9IG8uaW50MzJyYW5nZSkgIT09IG51bGwgJiYgXzAgIT09IHZvaWQgMCA/IF8wIDogdHJ1ZSxcbiAgICAgICAgdXJpUmVzb2x2ZXI6IHVyaVJlc29sdmVyLFxuICAgIH07XG59XG5jbGFzcyBBanYge1xuICAgIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuICAgICAgICB0aGlzLnNjaGVtYXMgPSB7fTtcbiAgICAgICAgdGhpcy5yZWZzID0ge307XG4gICAgICAgIHRoaXMuZm9ybWF0cyA9IHt9O1xuICAgICAgICB0aGlzLl9jb21waWxhdGlvbnMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuX2xvYWRpbmcgPSB7fTtcbiAgICAgICAgdGhpcy5fY2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIG9wdHMgPSB0aGlzLm9wdHMgPSB7IC4uLm9wdHMsIC4uLnJlcXVpcmVkT3B0aW9ucyhvcHRzKSB9O1xuICAgICAgICBjb25zdCB7IGVzNSwgbGluZXMgfSA9IHRoaXMub3B0cy5jb2RlO1xuICAgICAgICB0aGlzLnNjb3BlID0gbmV3IGNvZGVnZW5fMi5WYWx1ZVNjb3BlKHsgc2NvcGU6IHt9LCBwcmVmaXhlczogRVhUX1NDT1BFX05BTUVTLCBlczUsIGxpbmVzIH0pO1xuICAgICAgICB0aGlzLmxvZ2dlciA9IGdldExvZ2dlcihvcHRzLmxvZ2dlcik7XG4gICAgICAgIGNvbnN0IGZvcm1hdE9wdCA9IG9wdHMudmFsaWRhdGVGb3JtYXRzO1xuICAgICAgICBvcHRzLnZhbGlkYXRlRm9ybWF0cyA9IGZhbHNlO1xuICAgICAgICB0aGlzLlJVTEVTID0gKDAsIHJ1bGVzXzEuZ2V0UnVsZXMpKCk7XG4gICAgICAgIGNoZWNrT3B0aW9ucy5jYWxsKHRoaXMsIHJlbW92ZWRPcHRpb25zLCBvcHRzLCBcIk5PVCBTVVBQT1JURURcIik7XG4gICAgICAgIGNoZWNrT3B0aW9ucy5jYWxsKHRoaXMsIGRlcHJlY2F0ZWRPcHRpb25zLCBvcHRzLCBcIkRFUFJFQ0FURURcIiwgXCJ3YXJuXCIpO1xuICAgICAgICB0aGlzLl9tZXRhT3B0cyA9IGdldE1ldGFTY2hlbWFPcHRpb25zLmNhbGwodGhpcyk7XG4gICAgICAgIGlmIChvcHRzLmZvcm1hdHMpXG4gICAgICAgICAgICBhZGRJbml0aWFsRm9ybWF0cy5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLl9hZGRWb2NhYnVsYXJpZXMoKTtcbiAgICAgICAgdGhpcy5fYWRkRGVmYXVsdE1ldGFTY2hlbWEoKTtcbiAgICAgICAgaWYgKG9wdHMua2V5d29yZHMpXG4gICAgICAgICAgICBhZGRJbml0aWFsS2V5d29yZHMuY2FsbCh0aGlzLCBvcHRzLmtleXdvcmRzKTtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRzLm1ldGEgPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgIHRoaXMuYWRkTWV0YVNjaGVtYShvcHRzLm1ldGEpO1xuICAgICAgICBhZGRJbml0aWFsU2NoZW1hcy5jYWxsKHRoaXMpO1xuICAgICAgICBvcHRzLnZhbGlkYXRlRm9ybWF0cyA9IGZvcm1hdE9wdDtcbiAgICB9XG4gICAgX2FkZFZvY2FidWxhcmllcygpIHtcbiAgICAgICAgdGhpcy5hZGRLZXl3b3JkKFwiJGFzeW5jXCIpO1xuICAgIH1cbiAgICBfYWRkRGVmYXVsdE1ldGFTY2hlbWEoKSB7XG4gICAgICAgIGNvbnN0IHsgJGRhdGEsIG1ldGEsIHNjaGVtYUlkIH0gPSB0aGlzLm9wdHM7XG4gICAgICAgIGxldCBfZGF0YVJlZlNjaGVtYSA9ICRkYXRhUmVmU2NoZW1hO1xuICAgICAgICBpZiAoc2NoZW1hSWQgPT09IFwiaWRcIikge1xuICAgICAgICAgICAgX2RhdGFSZWZTY2hlbWEgPSB7IC4uLiRkYXRhUmVmU2NoZW1hIH07XG4gICAgICAgICAgICBfZGF0YVJlZlNjaGVtYS5pZCA9IF9kYXRhUmVmU2NoZW1hLiRpZDtcbiAgICAgICAgICAgIGRlbGV0ZSBfZGF0YVJlZlNjaGVtYS4kaWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGEgJiYgJGRhdGEpXG4gICAgICAgICAgICB0aGlzLmFkZE1ldGFTY2hlbWEoX2RhdGFSZWZTY2hlbWEsIF9kYXRhUmVmU2NoZW1hW3NjaGVtYUlkXSwgZmFsc2UpO1xuICAgIH1cbiAgICBkZWZhdWx0TWV0YSgpIHtcbiAgICAgICAgY29uc3QgeyBtZXRhLCBzY2hlbWFJZCB9ID0gdGhpcy5vcHRzO1xuICAgICAgICByZXR1cm4gKHRoaXMub3B0cy5kZWZhdWx0TWV0YSA9IHR5cGVvZiBtZXRhID09IFwib2JqZWN0XCIgPyBtZXRhW3NjaGVtYUlkXSB8fCBtZXRhIDogdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgdmFsaWRhdGUoc2NoZW1hS2V5UmVmLCAvLyBrZXksIHJlZiBvciBzY2hlbWEgb2JqZWN0XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZWR1bmRhbnQtdHlwZS1jb25zdGl0dWVudHNcbiAgICBkYXRhIC8vIHRvIGJlIHZhbGlkYXRlZFxuICAgICkge1xuICAgICAgICBsZXQgdjtcbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWFLZXlSZWYgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdiA9IHRoaXMuZ2V0U2NoZW1hKHNjaGVtYUtleVJlZik7XG4gICAgICAgICAgICBpZiAoIXYpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBubyBzY2hlbWEgd2l0aCBrZXkgb3IgcmVmIFwiJHtzY2hlbWFLZXlSZWZ9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHYgPSB0aGlzLmNvbXBpbGUoc2NoZW1hS2V5UmVmKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWxpZCA9IHYoZGF0YSk7XG4gICAgICAgIGlmICghKFwiJGFzeW5jXCIgaW4gdikpXG4gICAgICAgICAgICB0aGlzLmVycm9ycyA9IHYuZXJyb3JzO1xuICAgICAgICByZXR1cm4gdmFsaWQ7XG4gICAgfVxuICAgIGNvbXBpbGUoc2NoZW1hLCBfbWV0YSkge1xuICAgICAgICBjb25zdCBzY2ggPSB0aGlzLl9hZGRTY2hlbWEoc2NoZW1hLCBfbWV0YSk7XG4gICAgICAgIHJldHVybiAoc2NoLnZhbGlkYXRlIHx8IHRoaXMuX2NvbXBpbGVTY2hlbWFFbnYoc2NoKSk7XG4gICAgfVxuICAgIGNvbXBpbGVBc3luYyhzY2hlbWEsIG1ldGEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdHMubG9hZFNjaGVtYSAhPSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm9wdGlvbnMubG9hZFNjaGVtYSBzaG91bGQgYmUgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGxvYWRTY2hlbWEgfSA9IHRoaXMub3B0cztcbiAgICAgICAgcmV0dXJuIHJ1bkNvbXBpbGVBc3luYy5jYWxsKHRoaXMsIHNjaGVtYSwgbWV0YSk7XG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIHJ1bkNvbXBpbGVBc3luYyhfc2NoZW1hLCBfbWV0YSkge1xuICAgICAgICAgICAgYXdhaXQgbG9hZE1ldGFTY2hlbWEuY2FsbCh0aGlzLCBfc2NoZW1hLiRzY2hlbWEpO1xuICAgICAgICAgICAgY29uc3Qgc2NoID0gdGhpcy5fYWRkU2NoZW1hKF9zY2hlbWEsIF9tZXRhKTtcbiAgICAgICAgICAgIHJldHVybiBzY2gudmFsaWRhdGUgfHwgX2NvbXBpbGVBc3luYy5jYWxsKHRoaXMsIHNjaCk7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gbG9hZE1ldGFTY2hlbWEoJHJlZikge1xuICAgICAgICAgICAgaWYgKCRyZWYgJiYgIXRoaXMuZ2V0U2NoZW1hKCRyZWYpKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgcnVuQ29tcGlsZUFzeW5jLmNhbGwodGhpcywgeyAkcmVmIH0sIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIF9jb21waWxlQXN5bmMoc2NoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb21waWxlU2NoZW1hRW52KHNjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmICghKGUgaW5zdGFuY2VvZiByZWZfZXJyb3JfMS5kZWZhdWx0KSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICBjaGVja0xvYWRlZC5jYWxsKHRoaXMsIGUpO1xuICAgICAgICAgICAgICAgIGF3YWl0IGxvYWRNaXNzaW5nU2NoZW1hLmNhbGwodGhpcywgZS5taXNzaW5nU2NoZW1hKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbXBpbGVBc3luYy5jYWxsKHRoaXMsIHNjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2hlY2tMb2FkZWQoeyBtaXNzaW5nU2NoZW1hOiByZWYsIG1pc3NpbmdSZWYgfSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVmc1tyZWZdKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBbnlTY2hlbWEgJHtyZWZ9IGlzIGxvYWRlZCBidXQgJHttaXNzaW5nUmVmfSBjYW5ub3QgYmUgcmVzb2x2ZWRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhc3luYyBmdW5jdGlvbiBsb2FkTWlzc2luZ1NjaGVtYShyZWYpIHtcbiAgICAgICAgICAgIGNvbnN0IF9zY2hlbWEgPSBhd2FpdCBfbG9hZFNjaGVtYS5jYWxsKHRoaXMsIHJlZik7XG4gICAgICAgICAgICBpZiAoIXRoaXMucmVmc1tyZWZdKVxuICAgICAgICAgICAgICAgIGF3YWl0IGxvYWRNZXRhU2NoZW1hLmNhbGwodGhpcywgX3NjaGVtYS4kc2NoZW1hKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5yZWZzW3JlZl0pXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRTY2hlbWEoX3NjaGVtYSwgcmVmLCBtZXRhKTtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyBmdW5jdGlvbiBfbG9hZFNjaGVtYShyZWYpIHtcbiAgICAgICAgICAgIGNvbnN0IHAgPSB0aGlzLl9sb2FkaW5nW3JlZl07XG4gICAgICAgICAgICBpZiAocClcbiAgICAgICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0ICh0aGlzLl9sb2FkaW5nW3JlZl0gPSBsb2FkU2NoZW1hKHJlZikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2xvYWRpbmdbcmVmXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBBZGRzIHNjaGVtYSB0byB0aGUgaW5zdGFuY2VcbiAgICBhZGRTY2hlbWEoc2NoZW1hLCAvLyBJZiBhcnJheSBpcyBwYXNzZWQsIGBrZXlgIHdpbGwgYmUgaWdub3JlZFxuICAgIGtleSwgLy8gT3B0aW9uYWwgc2NoZW1hIGtleS4gQ2FuIGJlIHBhc3NlZCB0byBgdmFsaWRhdGVgIG1ldGhvZCBpbnN0ZWFkIG9mIHNjaGVtYSBvYmplY3Qgb3IgaWQvcmVmLiBPbmUgc2NoZW1hIHBlciBpbnN0YW5jZSBjYW4gaGF2ZSBlbXB0eSBgaWRgIGFuZCBga2V5YC5cbiAgICBfbWV0YSwgLy8gdHJ1ZSBpZiBzY2hlbWEgaXMgYSBtZXRhLXNjaGVtYS4gVXNlZCBpbnRlcm5hbGx5LCBhZGRNZXRhU2NoZW1hIHNob3VsZCBiZSB1c2VkIGluc3RlYWQuXG4gICAgX3ZhbGlkYXRlU2NoZW1hID0gdGhpcy5vcHRzLnZhbGlkYXRlU2NoZW1hIC8vIGZhbHNlIHRvIHNraXAgc2NoZW1hIHZhbGlkYXRpb24uIFVzZWQgaW50ZXJuYWxseSwgb3B0aW9uIHZhbGlkYXRlU2NoZW1hIHNob3VsZCBiZSB1c2VkIGluc3RlYWQuXG4gICAgKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYSkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc2NoIG9mIHNjaGVtYSlcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFNjaGVtYShzY2gsIHVuZGVmaW5lZCwgX21ldGEsIF92YWxpZGF0ZVNjaGVtYSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBsZXQgaWQ7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBjb25zdCB7IHNjaGVtYUlkIH0gPSB0aGlzLm9wdHM7XG4gICAgICAgICAgICBpZCA9IHNjaGVtYVtzY2hlbWFJZF07XG4gICAgICAgICAgICBpZiAoaWQgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgaWQgIT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgc2NoZW1hICR7c2NoZW1hSWR9IG11c3QgYmUgc3RyaW5nYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAga2V5ID0gKDAsIHJlc29sdmVfMS5ub3JtYWxpemVJZCkoa2V5IHx8IGlkKTtcbiAgICAgICAgdGhpcy5fY2hlY2tVbmlxdWUoa2V5KTtcbiAgICAgICAgdGhpcy5zY2hlbWFzW2tleV0gPSB0aGlzLl9hZGRTY2hlbWEoc2NoZW1hLCBfbWV0YSwga2V5LCBfdmFsaWRhdGVTY2hlbWEsIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gQWRkIHNjaGVtYSB0aGF0IHdpbGwgYmUgdXNlZCB0byB2YWxpZGF0ZSBvdGhlciBzY2hlbWFzXG4gICAgLy8gb3B0aW9ucyBpbiBNRVRBX0lHTk9SRV9PUFRJT05TIGFyZSBhbHdheSBzZXQgdG8gZmFsc2VcbiAgICBhZGRNZXRhU2NoZW1hKHNjaGVtYSwga2V5LCAvLyBzY2hlbWEga2V5XG4gICAgX3ZhbGlkYXRlU2NoZW1hID0gdGhpcy5vcHRzLnZhbGlkYXRlU2NoZW1hIC8vIGZhbHNlIHRvIHNraXAgc2NoZW1hIHZhbGlkYXRpb24sIGNhbiBiZSB1c2VkIHRvIG92ZXJyaWRlIHZhbGlkYXRlU2NoZW1hIG9wdGlvbiBmb3IgbWV0YS1zY2hlbWFcbiAgICApIHtcbiAgICAgICAgdGhpcy5hZGRTY2hlbWEoc2NoZW1hLCBrZXksIHRydWUsIF92YWxpZGF0ZVNjaGVtYSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyAgVmFsaWRhdGUgc2NoZW1hIGFnYWluc3QgaXRzIG1ldGEtc2NoZW1hXG4gICAgdmFsaWRhdGVTY2hlbWEoc2NoZW1hLCB0aHJvd09yTG9nRXJyb3IpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJib29sZWFuXCIpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgbGV0ICRzY2hlbWE7XG4gICAgICAgICRzY2hlbWEgPSBzY2hlbWEuJHNjaGVtYTtcbiAgICAgICAgaWYgKCRzY2hlbWEgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgJHNjaGVtYSAhPSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCIkc2NoZW1hIG11c3QgYmUgYSBzdHJpbmdcIik7XG4gICAgICAgIH1cbiAgICAgICAgJHNjaGVtYSA9ICRzY2hlbWEgfHwgdGhpcy5vcHRzLmRlZmF1bHRNZXRhIHx8IHRoaXMuZGVmYXVsdE1ldGEoKTtcbiAgICAgICAgaWYgKCEkc2NoZW1hKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwibWV0YS1zY2hlbWEgbm90IGF2YWlsYWJsZVwiKTtcbiAgICAgICAgICAgIHRoaXMuZXJyb3JzID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbGlkID0gdGhpcy52YWxpZGF0ZSgkc2NoZW1hLCBzY2hlbWEpO1xuICAgICAgICBpZiAoIXZhbGlkICYmIHRocm93T3JMb2dFcnJvcikge1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IFwic2NoZW1hIGlzIGludmFsaWQ6IFwiICsgdGhpcy5lcnJvcnNUZXh0KCk7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRzLnZhbGlkYXRlU2NoZW1hID09PSBcImxvZ1wiKVxuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsaWQ7XG4gICAgfVxuICAgIC8vIEdldCBjb21waWxlZCBzY2hlbWEgYnkgYGtleWAgb3IgYHJlZmAuXG4gICAgLy8gKGBrZXlgIHRoYXQgd2FzIHBhc3NlZCB0byBgYWRkU2NoZW1hYCBvciBmdWxsIHNjaGVtYSByZWZlcmVuY2UgLSBgc2NoZW1hLiRpZGAgb3IgcmVzb2x2ZWQgaWQpXG4gICAgZ2V0U2NoZW1hKGtleVJlZikge1xuICAgICAgICBsZXQgc2NoO1xuICAgICAgICB3aGlsZSAodHlwZW9mIChzY2ggPSBnZXRTY2hFbnYuY2FsbCh0aGlzLCBrZXlSZWYpKSA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAga2V5UmVmID0gc2NoO1xuICAgICAgICBpZiAoc2NoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgc2NoZW1hSWQgfSA9IHRoaXMub3B0cztcbiAgICAgICAgICAgIGNvbnN0IHJvb3QgPSBuZXcgY29tcGlsZV8xLlNjaGVtYUVudih7IHNjaGVtYToge30sIHNjaGVtYUlkIH0pO1xuICAgICAgICAgICAgc2NoID0gY29tcGlsZV8xLnJlc29sdmVTY2hlbWEuY2FsbCh0aGlzLCByb290LCBrZXlSZWYpO1xuICAgICAgICAgICAgaWYgKCFzY2gpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5yZWZzW2tleVJlZl0gPSBzY2g7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChzY2gudmFsaWRhdGUgfHwgdGhpcy5fY29tcGlsZVNjaGVtYUVudihzY2gpKTtcbiAgICB9XG4gICAgLy8gUmVtb3ZlIGNhY2hlZCBzY2hlbWEocykuXG4gICAgLy8gSWYgbm8gcGFyYW1ldGVyIGlzIHBhc3NlZCBhbGwgc2NoZW1hcyBidXQgbWV0YS1zY2hlbWFzIGFyZSByZW1vdmVkLlxuICAgIC8vIElmIFJlZ0V4cCBpcyBwYXNzZWQgYWxsIHNjaGVtYXMgd2l0aCBrZXkvaWQgbWF0Y2hpbmcgcGF0dGVybiBidXQgbWV0YS1zY2hlbWFzIGFyZSByZW1vdmVkLlxuICAgIC8vIEV2ZW4gaWYgc2NoZW1hIGlzIHJlZmVyZW5jZWQgYnkgb3RoZXIgc2NoZW1hcyBpdCBzdGlsbCBjYW4gYmUgcmVtb3ZlZCBhcyBvdGhlciBzY2hlbWFzIGhhdmUgbG9jYWwgcmVmZXJlbmNlcy5cbiAgICByZW1vdmVTY2hlbWEoc2NoZW1hS2V5UmVmKSB7XG4gICAgICAgIGlmIChzY2hlbWFLZXlSZWYgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZUFsbFNjaGVtYXModGhpcy5zY2hlbWFzLCBzY2hlbWFLZXlSZWYpO1xuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlQWxsU2NoZW1hcyh0aGlzLnJlZnMsIHNjaGVtYUtleVJlZik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHR5cGVvZiBzY2hlbWFLZXlSZWYpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ1bmRlZmluZWRcIjpcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVBbGxTY2hlbWFzKHRoaXMuc2NoZW1hcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlQWxsU2NoZW1hcyh0aGlzLnJlZnMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzY2ggPSBnZXRTY2hFbnYuY2FsbCh0aGlzLCBzY2hlbWFLZXlSZWYpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NoID09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlLmRlbGV0ZShzY2guc2NoZW1hKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5zY2hlbWFzW3NjaGVtYUtleVJlZl07XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMucmVmc1tzY2hlbWFLZXlSZWZdO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcIm9iamVjdFwiOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FjaGVLZXkgPSBzY2hlbWFLZXlSZWY7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FjaGUuZGVsZXRlKGNhY2hlS2V5KTtcbiAgICAgICAgICAgICAgICBsZXQgaWQgPSBzY2hlbWFLZXlSZWZbdGhpcy5vcHRzLnNjaGVtYUlkXTtcbiAgICAgICAgICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWQgPSAoMCwgcmVzb2x2ZV8xLm5vcm1hbGl6ZUlkKShpZCk7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnNjaGVtYXNbaWRdO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5yZWZzW2lkXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFqdi5yZW1vdmVTY2hlbWE6IGludmFsaWQgcGFyYW1ldGVyXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGFkZCBcInZvY2FidWxhcnlcIiAtIGEgY29sbGVjdGlvbiBvZiBrZXl3b3Jkc1xuICAgIGFkZFZvY2FidWxhcnkoZGVmaW5pdGlvbnMpIHtcbiAgICAgICAgZm9yIChjb25zdCBkZWYgb2YgZGVmaW5pdGlvbnMpXG4gICAgICAgICAgICB0aGlzLmFkZEtleXdvcmQoZGVmKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGFkZEtleXdvcmQoa3dkT3JEZWYsIGRlZiAvLyBkZXByZWNhdGVkXG4gICAgKSB7XG4gICAgICAgIGxldCBrZXl3b3JkO1xuICAgICAgICBpZiAodHlwZW9mIGt3ZE9yRGVmID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGtleXdvcmQgPSBrd2RPckRlZjtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGVmID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwidGhlc2UgcGFyYW1ldGVycyBhcmUgZGVwcmVjYXRlZCwgc2VlIGRvY3MgZm9yIGFkZEtleXdvcmRcIik7XG4gICAgICAgICAgICAgICAgZGVmLmtleXdvcmQgPSBrZXl3b3JkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBrd2RPckRlZiA9PSBcIm9iamVjdFwiICYmIGRlZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkZWYgPSBrd2RPckRlZjtcbiAgICAgICAgICAgIGtleXdvcmQgPSBkZWYua2V5d29yZDtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGtleXdvcmQpICYmICFrZXl3b3JkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFkZEtleXdvcmRzOiBrZXl3b3JkIG11c3QgYmUgc3RyaW5nIG9yIG5vbi1lbXB0eSBhcnJheVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYWRkS2V5d29yZHMgcGFyYW1ldGVyc1wiKTtcbiAgICAgICAgfVxuICAgICAgICBjaGVja0tleXdvcmQuY2FsbCh0aGlzLCBrZXl3b3JkLCBkZWYpO1xuICAgICAgICBpZiAoIWRlZikge1xuICAgICAgICAgICAgKDAsIHV0aWxfMS5lYWNoSXRlbSkoa2V5d29yZCwgKGt3ZCkgPT4gYWRkUnVsZS5jYWxsKHRoaXMsIGt3ZCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAga2V5d29yZE1ldGFzY2hlbWEuY2FsbCh0aGlzLCBkZWYpO1xuICAgICAgICBjb25zdCBkZWZpbml0aW9uID0ge1xuICAgICAgICAgICAgLi4uZGVmLFxuICAgICAgICAgICAgdHlwZTogKDAsIGRhdGFUeXBlXzEuZ2V0SlNPTlR5cGVzKShkZWYudHlwZSksXG4gICAgICAgICAgICBzY2hlbWFUeXBlOiAoMCwgZGF0YVR5cGVfMS5nZXRKU09OVHlwZXMpKGRlZi5zY2hlbWFUeXBlKSxcbiAgICAgICAgfTtcbiAgICAgICAgKDAsIHV0aWxfMS5lYWNoSXRlbSkoa2V5d29yZCwgZGVmaW5pdGlvbi50eXBlLmxlbmd0aCA9PT0gMFxuICAgICAgICAgICAgPyAoaykgPT4gYWRkUnVsZS5jYWxsKHRoaXMsIGssIGRlZmluaXRpb24pXG4gICAgICAgICAgICA6IChrKSA9PiBkZWZpbml0aW9uLnR5cGUuZm9yRWFjaCgodCkgPT4gYWRkUnVsZS5jYWxsKHRoaXMsIGssIGRlZmluaXRpb24sIHQpKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXRLZXl3b3JkKGtleXdvcmQpIHtcbiAgICAgICAgY29uc3QgcnVsZSA9IHRoaXMuUlVMRVMuYWxsW2tleXdvcmRdO1xuICAgICAgICByZXR1cm4gdHlwZW9mIHJ1bGUgPT0gXCJvYmplY3RcIiA/IHJ1bGUuZGVmaW5pdGlvbiA6ICEhcnVsZTtcbiAgICB9XG4gICAgLy8gUmVtb3ZlIGtleXdvcmRcbiAgICByZW1vdmVLZXl3b3JkKGtleXdvcmQpIHtcbiAgICAgICAgLy8gVE9ETyByZXR1cm4gdHlwZSBzaG91bGQgYmUgQWp2XG4gICAgICAgIGNvbnN0IHsgUlVMRVMgfSA9IHRoaXM7XG4gICAgICAgIGRlbGV0ZSBSVUxFUy5rZXl3b3Jkc1trZXl3b3JkXTtcbiAgICAgICAgZGVsZXRlIFJVTEVTLmFsbFtrZXl3b3JkXTtcbiAgICAgICAgZm9yIChjb25zdCBncm91cCBvZiBSVUxFUy5ydWxlcykge1xuICAgICAgICAgICAgY29uc3QgaSA9IGdyb3VwLnJ1bGVzLmZpbmRJbmRleCgocnVsZSkgPT4gcnVsZS5rZXl3b3JkID09PSBrZXl3b3JkKTtcbiAgICAgICAgICAgIGlmIChpID49IDApXG4gICAgICAgICAgICAgICAgZ3JvdXAucnVsZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBBZGQgZm9ybWF0XG4gICAgYWRkRm9ybWF0KG5hbWUsIGZvcm1hdCkge1xuICAgICAgICBpZiAodHlwZW9mIGZvcm1hdCA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgZm9ybWF0ID0gbmV3IFJlZ0V4cChmb3JtYXQpO1xuICAgICAgICB0aGlzLmZvcm1hdHNbbmFtZV0gPSBmb3JtYXQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBlcnJvcnNUZXh0KGVycm9ycyA9IHRoaXMuZXJyb3JzLCAvLyBvcHRpb25hbCBhcnJheSBvZiB2YWxpZGF0aW9uIGVycm9yc1xuICAgIHsgc2VwYXJhdG9yID0gXCIsIFwiLCBkYXRhVmFyID0gXCJkYXRhXCIgfSA9IHt9IC8vIG9wdGlvbmFsIG9wdGlvbnMgd2l0aCBwcm9wZXJ0aWVzIGBzZXBhcmF0b3JgIGFuZCBgZGF0YVZhcmBcbiAgICApIHtcbiAgICAgICAgaWYgKCFlcnJvcnMgfHwgZXJyb3JzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiBcIk5vIGVycm9yc1wiO1xuICAgICAgICByZXR1cm4gZXJyb3JzXG4gICAgICAgICAgICAubWFwKChlKSA9PiBgJHtkYXRhVmFyfSR7ZS5pbnN0YW5jZVBhdGh9ICR7ZS5tZXNzYWdlfWApXG4gICAgICAgICAgICAucmVkdWNlKCh0ZXh0LCBtc2cpID0+IHRleHQgKyBzZXBhcmF0b3IgKyBtc2cpO1xuICAgIH1cbiAgICAkZGF0YU1ldGFTY2hlbWEobWV0YVNjaGVtYSwga2V5d29yZHNKc29uUG9pbnRlcnMpIHtcbiAgICAgICAgY29uc3QgcnVsZXMgPSB0aGlzLlJVTEVTLmFsbDtcbiAgICAgICAgbWV0YVNjaGVtYSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkobWV0YVNjaGVtYSkpO1xuICAgICAgICBmb3IgKGNvbnN0IGpzb25Qb2ludGVyIG9mIGtleXdvcmRzSnNvblBvaW50ZXJzKSB7XG4gICAgICAgICAgICBjb25zdCBzZWdtZW50cyA9IGpzb25Qb2ludGVyLnNwbGl0KFwiL1wiKS5zbGljZSgxKTsgLy8gZmlyc3Qgc2VnbWVudCBpcyBhbiBlbXB0eSBzdHJpbmdcbiAgICAgICAgICAgIGxldCBrZXl3b3JkcyA9IG1ldGFTY2hlbWE7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHNlZyBvZiBzZWdtZW50cylcbiAgICAgICAgICAgICAgICBrZXl3b3JkcyA9IGtleXdvcmRzW3NlZ107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBydWxlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJ1bGUgPSBydWxlc1trZXldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcnVsZSAhPSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjb25zdCB7ICRkYXRhIH0gPSBydWxlLmRlZmluaXRpb247XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NoZW1hID0ga2V5d29yZHNba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoJGRhdGEgJiYgc2NoZW1hKVxuICAgICAgICAgICAgICAgICAgICBrZXl3b3Jkc1trZXldID0gc2NoZW1hT3JEYXRhKHNjaGVtYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1ldGFTY2hlbWE7XG4gICAgfVxuICAgIF9yZW1vdmVBbGxTY2hlbWFzKHNjaGVtYXMsIHJlZ2V4KSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5UmVmIGluIHNjaGVtYXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHNjaCA9IHNjaGVtYXNba2V5UmVmXTtcbiAgICAgICAgICAgIGlmICghcmVnZXggfHwgcmVnZXgudGVzdChrZXlSZWYpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzY2ggPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgc2NoZW1hc1trZXlSZWZdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzY2ggJiYgIXNjaC5tZXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlLmRlbGV0ZShzY2guc2NoZW1hKTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHNjaGVtYXNba2V5UmVmXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2FkZFNjaGVtYShzY2hlbWEsIG1ldGEsIGJhc2VJZCwgdmFsaWRhdGVTY2hlbWEgPSB0aGlzLm9wdHMudmFsaWRhdGVTY2hlbWEsIGFkZFNjaGVtYSA9IHRoaXMub3B0cy5hZGRVc2VkU2NoZW1hKSB7XG4gICAgICAgIGxldCBpZDtcbiAgICAgICAgY29uc3QgeyBzY2hlbWFJZCB9ID0gdGhpcy5vcHRzO1xuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBpZCA9IHNjaGVtYVtzY2hlbWFJZF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRzLmp0ZClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzY2hlbWEgbXVzdCBiZSBvYmplY3RcIik7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc2NoZW1hICE9IFwiYm9vbGVhblwiKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInNjaGVtYSBtdXN0IGJlIG9iamVjdCBvciBib29sZWFuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzY2ggPSB0aGlzLl9jYWNoZS5nZXQoc2NoZW1hKTtcbiAgICAgICAgaWYgKHNjaCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIHNjaDtcbiAgICAgICAgYmFzZUlkID0gKDAsIHJlc29sdmVfMS5ub3JtYWxpemVJZCkoaWQgfHwgYmFzZUlkKTtcbiAgICAgICAgY29uc3QgbG9jYWxSZWZzID0gcmVzb2x2ZV8xLmdldFNjaGVtYVJlZnMuY2FsbCh0aGlzLCBzY2hlbWEsIGJhc2VJZCk7XG4gICAgICAgIHNjaCA9IG5ldyBjb21waWxlXzEuU2NoZW1hRW52KHsgc2NoZW1hLCBzY2hlbWFJZCwgbWV0YSwgYmFzZUlkLCBsb2NhbFJlZnMgfSk7XG4gICAgICAgIHRoaXMuX2NhY2hlLnNldChzY2guc2NoZW1hLCBzY2gpO1xuICAgICAgICBpZiAoYWRkU2NoZW1hICYmICFiYXNlSWQuc3RhcnRzV2l0aChcIiNcIikpIHtcbiAgICAgICAgICAgIC8vIFRPRE8gYXRtIGl0IGlzIGFsbG93ZWQgdG8gb3ZlcndyaXRlIHNjaGVtYXMgd2l0aG91dCBpZCAoaW5zdGVhZCBvZiBub3QgYWRkaW5nIHRoZW0pXG4gICAgICAgICAgICBpZiAoYmFzZUlkKVxuICAgICAgICAgICAgICAgIHRoaXMuX2NoZWNrVW5pcXVlKGJhc2VJZCk7XG4gICAgICAgICAgICB0aGlzLnJlZnNbYmFzZUlkXSA9IHNjaDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsaWRhdGVTY2hlbWEpXG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlU2NoZW1hKHNjaGVtYSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBzY2g7XG4gICAgfVxuICAgIF9jaGVja1VuaXF1ZShpZCkge1xuICAgICAgICBpZiAodGhpcy5zY2hlbWFzW2lkXSB8fCB0aGlzLnJlZnNbaWRdKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHNjaGVtYSB3aXRoIGtleSBvciBpZCBcIiR7aWR9XCIgYWxyZWFkeSBleGlzdHNgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfY29tcGlsZVNjaGVtYUVudihzY2gpIHtcbiAgICAgICAgaWYgKHNjaC5tZXRhKVxuICAgICAgICAgICAgdGhpcy5fY29tcGlsZU1ldGFTY2hlbWEoc2NoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgY29tcGlsZV8xLmNvbXBpbGVTY2hlbWEuY2FsbCh0aGlzLCBzY2gpO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFzY2gudmFsaWRhdGUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhanYgaW1wbGVtZW50YXRpb24gZXJyb3JcIik7XG4gICAgICAgIHJldHVybiBzY2gudmFsaWRhdGU7XG4gICAgfVxuICAgIF9jb21waWxlTWV0YVNjaGVtYShzY2gpIHtcbiAgICAgICAgY29uc3QgY3VycmVudE9wdHMgPSB0aGlzLm9wdHM7XG4gICAgICAgIHRoaXMub3B0cyA9IHRoaXMuX21ldGFPcHRzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29tcGlsZV8xLmNvbXBpbGVTY2hlbWEuY2FsbCh0aGlzLCBzY2gpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5vcHRzID0gY3VycmVudE9wdHM7XG4gICAgICAgIH1cbiAgICB9XG59XG5BanYuVmFsaWRhdGlvbkVycm9yID0gdmFsaWRhdGlvbl9lcnJvcl8xLmRlZmF1bHQ7XG5BanYuTWlzc2luZ1JlZkVycm9yID0gcmVmX2Vycm9yXzEuZGVmYXVsdDtcbmV4cG9ydHMuZGVmYXVsdCA9IEFqdjtcbmZ1bmN0aW9uIGNoZWNrT3B0aW9ucyhjaGVja09wdHMsIG9wdGlvbnMsIG1zZywgbG9nID0gXCJlcnJvclwiKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gY2hlY2tPcHRzKSB7XG4gICAgICAgIGNvbnN0IG9wdCA9IGtleTtcbiAgICAgICAgaWYgKG9wdCBpbiBvcHRpb25zKVxuICAgICAgICAgICAgdGhpcy5sb2dnZXJbbG9nXShgJHttc2d9OiBvcHRpb24gJHtrZXl9LiAke2NoZWNrT3B0c1tvcHRdfWApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFNjaEVudihrZXlSZWYpIHtcbiAgICBrZXlSZWYgPSAoMCwgcmVzb2x2ZV8xLm5vcm1hbGl6ZUlkKShrZXlSZWYpOyAvLyBUT0RPIHRlc3RzIGZhaWwgd2l0aG91dCB0aGlzIGxpbmVcbiAgICByZXR1cm4gdGhpcy5zY2hlbWFzW2tleVJlZl0gfHwgdGhpcy5yZWZzW2tleVJlZl07XG59XG5mdW5jdGlvbiBhZGRJbml0aWFsU2NoZW1hcygpIHtcbiAgICBjb25zdCBvcHRzU2NoZW1hcyA9IHRoaXMub3B0cy5zY2hlbWFzO1xuICAgIGlmICghb3B0c1NjaGVtYXMpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRzU2NoZW1hcykpXG4gICAgICAgIHRoaXMuYWRkU2NoZW1hKG9wdHNTY2hlbWFzKTtcbiAgICBlbHNlXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9wdHNTY2hlbWFzKVxuICAgICAgICAgICAgdGhpcy5hZGRTY2hlbWEob3B0c1NjaGVtYXNba2V5XSwga2V5KTtcbn1cbmZ1bmN0aW9uIGFkZEluaXRpYWxGb3JtYXRzKCkge1xuICAgIGZvciAoY29uc3QgbmFtZSBpbiB0aGlzLm9wdHMuZm9ybWF0cykge1xuICAgICAgICBjb25zdCBmb3JtYXQgPSB0aGlzLm9wdHMuZm9ybWF0c1tuYW1lXTtcbiAgICAgICAgaWYgKGZvcm1hdClcbiAgICAgICAgICAgIHRoaXMuYWRkRm9ybWF0KG5hbWUsIGZvcm1hdCk7XG4gICAgfVxufVxuZnVuY3Rpb24gYWRkSW5pdGlhbEtleXdvcmRzKGRlZnMpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShkZWZzKSkge1xuICAgICAgICB0aGlzLmFkZFZvY2FidWxhcnkoZGVmcyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5sb2dnZXIud2FybihcImtleXdvcmRzIG9wdGlvbiBhcyBtYXAgaXMgZGVwcmVjYXRlZCwgcGFzcyBhcnJheVwiKTtcbiAgICBmb3IgKGNvbnN0IGtleXdvcmQgaW4gZGVmcykge1xuICAgICAgICBjb25zdCBkZWYgPSBkZWZzW2tleXdvcmRdO1xuICAgICAgICBpZiAoIWRlZi5rZXl3b3JkKVxuICAgICAgICAgICAgZGVmLmtleXdvcmQgPSBrZXl3b3JkO1xuICAgICAgICB0aGlzLmFkZEtleXdvcmQoZGVmKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRNZXRhU2NoZW1hT3B0aW9ucygpIHtcbiAgICBjb25zdCBtZXRhT3B0cyA9IHsgLi4udGhpcy5vcHRzIH07XG4gICAgZm9yIChjb25zdCBvcHQgb2YgTUVUQV9JR05PUkVfT1BUSU9OUylcbiAgICAgICAgZGVsZXRlIG1ldGFPcHRzW29wdF07XG4gICAgcmV0dXJuIG1ldGFPcHRzO1xufVxuY29uc3Qgbm9Mb2dzID0geyBsb2coKSB7IH0sIHdhcm4oKSB7IH0sIGVycm9yKCkgeyB9IH07XG5mdW5jdGlvbiBnZXRMb2dnZXIobG9nZ2VyKSB7XG4gICAgaWYgKGxvZ2dlciA9PT0gZmFsc2UpXG4gICAgICAgIHJldHVybiBub0xvZ3M7XG4gICAgaWYgKGxvZ2dlciA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gY29uc29sZTtcbiAgICBpZiAobG9nZ2VyLmxvZyAmJiBsb2dnZXIud2FybiAmJiBsb2dnZXIuZXJyb3IpXG4gICAgICAgIHJldHVybiBsb2dnZXI7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwibG9nZ2VyIG11c3QgaW1wbGVtZW50IGxvZywgd2FybiBhbmQgZXJyb3IgbWV0aG9kc1wiKTtcbn1cbmNvbnN0IEtFWVdPUkRfTkFNRSA9IC9eW2Etel8kXVthLXowLTlfJDotXSokL2k7XG5mdW5jdGlvbiBjaGVja0tleXdvcmQoa2V5d29yZCwgZGVmKSB7XG4gICAgY29uc3QgeyBSVUxFUyB9ID0gdGhpcztcbiAgICAoMCwgdXRpbF8xLmVhY2hJdGVtKShrZXl3b3JkLCAoa3dkKSA9PiB7XG4gICAgICAgIGlmIChSVUxFUy5rZXl3b3Jkc1trd2RdKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBLZXl3b3JkICR7a3dkfSBpcyBhbHJlYWR5IGRlZmluZWRgKTtcbiAgICAgICAgaWYgKCFLRVlXT1JEX05BTUUudGVzdChrd2QpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBLZXl3b3JkICR7a3dkfSBoYXMgaW52YWxpZCBuYW1lYCk7XG4gICAgfSk7XG4gICAgaWYgKCFkZWYpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoZGVmLiRkYXRhICYmICEoXCJjb2RlXCIgaW4gZGVmIHx8IFwidmFsaWRhdGVcIiBpbiBkZWYpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignJGRhdGEga2V5d29yZCBtdXN0IGhhdmUgXCJjb2RlXCIgb3IgXCJ2YWxpZGF0ZVwiIGZ1bmN0aW9uJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gYWRkUnVsZShrZXl3b3JkLCBkZWZpbml0aW9uLCBkYXRhVHlwZSkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBwb3N0ID0gZGVmaW5pdGlvbiA9PT0gbnVsbCB8fCBkZWZpbml0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkZWZpbml0aW9uLnBvc3Q7XG4gICAgaWYgKGRhdGFUeXBlICYmIHBvc3QpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigna2V5d29yZCB3aXRoIFwicG9zdFwiIGZsYWcgY2Fubm90IGhhdmUgXCJ0eXBlXCInKTtcbiAgICBjb25zdCB7IFJVTEVTIH0gPSB0aGlzO1xuICAgIGxldCBydWxlR3JvdXAgPSBwb3N0ID8gUlVMRVMucG9zdCA6IFJVTEVTLnJ1bGVzLmZpbmQoKHsgdHlwZTogdCB9KSA9PiB0ID09PSBkYXRhVHlwZSk7XG4gICAgaWYgKCFydWxlR3JvdXApIHtcbiAgICAgICAgcnVsZUdyb3VwID0geyB0eXBlOiBkYXRhVHlwZSwgcnVsZXM6IFtdIH07XG4gICAgICAgIFJVTEVTLnJ1bGVzLnB1c2gocnVsZUdyb3VwKTtcbiAgICB9XG4gICAgUlVMRVMua2V5d29yZHNba2V5d29yZF0gPSB0cnVlO1xuICAgIGlmICghZGVmaW5pdGlvbilcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHJ1bGUgPSB7XG4gICAgICAgIGtleXdvcmQsXG4gICAgICAgIGRlZmluaXRpb246IHtcbiAgICAgICAgICAgIC4uLmRlZmluaXRpb24sXG4gICAgICAgICAgICB0eXBlOiAoMCwgZGF0YVR5cGVfMS5nZXRKU09OVHlwZXMpKGRlZmluaXRpb24udHlwZSksXG4gICAgICAgICAgICBzY2hlbWFUeXBlOiAoMCwgZGF0YVR5cGVfMS5nZXRKU09OVHlwZXMpKGRlZmluaXRpb24uc2NoZW1hVHlwZSksXG4gICAgICAgIH0sXG4gICAgfTtcbiAgICBpZiAoZGVmaW5pdGlvbi5iZWZvcmUpXG4gICAgICAgIGFkZEJlZm9yZVJ1bGUuY2FsbCh0aGlzLCBydWxlR3JvdXAsIHJ1bGUsIGRlZmluaXRpb24uYmVmb3JlKTtcbiAgICBlbHNlXG4gICAgICAgIHJ1bGVHcm91cC5ydWxlcy5wdXNoKHJ1bGUpO1xuICAgIFJVTEVTLmFsbFtrZXl3b3JkXSA9IHJ1bGU7XG4gICAgKF9hID0gZGVmaW5pdGlvbi5pbXBsZW1lbnRzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZm9yRWFjaCgoa3dkKSA9PiB0aGlzLmFkZEtleXdvcmQoa3dkKSk7XG59XG5mdW5jdGlvbiBhZGRCZWZvcmVSdWxlKHJ1bGVHcm91cCwgcnVsZSwgYmVmb3JlKSB7XG4gICAgY29uc3QgaSA9IHJ1bGVHcm91cC5ydWxlcy5maW5kSW5kZXgoKF9ydWxlKSA9PiBfcnVsZS5rZXl3b3JkID09PSBiZWZvcmUpO1xuICAgIGlmIChpID49IDApIHtcbiAgICAgICAgcnVsZUdyb3VwLnJ1bGVzLnNwbGljZShpLCAwLCBydWxlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJ1bGVHcm91cC5ydWxlcy5wdXNoKHJ1bGUpO1xuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKGBydWxlICR7YmVmb3JlfSBpcyBub3QgZGVmaW5lZGApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGtleXdvcmRNZXRhc2NoZW1hKGRlZikge1xuICAgIGxldCB7IG1ldGFTY2hlbWEgfSA9IGRlZjtcbiAgICBpZiAobWV0YVNjaGVtYSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKGRlZi4kZGF0YSAmJiB0aGlzLm9wdHMuJGRhdGEpXG4gICAgICAgIG1ldGFTY2hlbWEgPSBzY2hlbWFPckRhdGEobWV0YVNjaGVtYSk7XG4gICAgZGVmLnZhbGlkYXRlU2NoZW1hID0gdGhpcy5jb21waWxlKG1ldGFTY2hlbWEsIHRydWUpO1xufVxuY29uc3QgJGRhdGFSZWYgPSB7XG4gICAgJHJlZjogXCJodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vYWp2LXZhbGlkYXRvci9hanYvbWFzdGVyL2xpYi9yZWZzL2RhdGEuanNvbiNcIixcbn07XG5mdW5jdGlvbiBzY2hlbWFPckRhdGEoc2NoZW1hKSB7XG4gICAgcmV0dXJuIHsgYW55T2Y6IFtzY2hlbWEsICRkYXRhUmVmXSB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29yZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcImlkXCIsXG4gICAgY29kZSgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOT1QgU1VQUE9SVEVEOiBrZXl3b3JkIFwiaWRcIiwgdXNlIFwiJGlkXCIgZm9yIHNjaGVtYSBJRCcpO1xuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aWQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNhbGxSZWYgPSBleHBvcnRzLmdldFZhbGlkYXRlID0gdm9pZCAwO1xuY29uc3QgcmVmX2Vycm9yXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9yZWZfZXJyb3JcIik7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi4vY29kZVwiKTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCBuYW1lc18xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvbmFtZXNcIik7XG5jb25zdCBjb21waWxlXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZVwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCIkcmVmXCIsXG4gICAgc2NoZW1hVHlwZTogXCJzdHJpbmdcIixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgc2NoZW1hOiAkcmVmLCBpdCB9ID0gY3h0O1xuICAgICAgICBjb25zdCB7IGJhc2VJZCwgc2NoZW1hRW52OiBlbnYsIHZhbGlkYXRlTmFtZSwgb3B0cywgc2VsZiB9ID0gaXQ7XG4gICAgICAgIGNvbnN0IHsgcm9vdCB9ID0gZW52O1xuICAgICAgICBpZiAoKCRyZWYgPT09IFwiI1wiIHx8ICRyZWYgPT09IFwiIy9cIikgJiYgYmFzZUlkID09PSByb290LmJhc2VJZClcbiAgICAgICAgICAgIHJldHVybiBjYWxsUm9vdFJlZigpO1xuICAgICAgICBjb25zdCBzY2hPckVudiA9IGNvbXBpbGVfMS5yZXNvbHZlUmVmLmNhbGwoc2VsZiwgcm9vdCwgYmFzZUlkLCAkcmVmKTtcbiAgICAgICAgaWYgKHNjaE9yRW52ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgcmVmX2Vycm9yXzEuZGVmYXVsdChpdC5vcHRzLnVyaVJlc29sdmVyLCBiYXNlSWQsICRyZWYpO1xuICAgICAgICBpZiAoc2NoT3JFbnYgaW5zdGFuY2VvZiBjb21waWxlXzEuU2NoZW1hRW52KVxuICAgICAgICAgICAgcmV0dXJuIGNhbGxWYWxpZGF0ZShzY2hPckVudik7XG4gICAgICAgIHJldHVybiBpbmxpbmVSZWZTY2hlbWEoc2NoT3JFbnYpO1xuICAgICAgICBmdW5jdGlvbiBjYWxsUm9vdFJlZigpIHtcbiAgICAgICAgICAgIGlmIChlbnYgPT09IHJvb3QpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxSZWYoY3h0LCB2YWxpZGF0ZU5hbWUsIGVudiwgZW52LiRhc3luYyk7XG4gICAgICAgICAgICBjb25zdCByb290TmFtZSA9IGdlbi5zY29wZVZhbHVlKFwicm9vdFwiLCB7IHJlZjogcm9vdCB9KTtcbiAgICAgICAgICAgIHJldHVybiBjYWxsUmVmKGN4dCwgKDAsIGNvZGVnZW5fMS5fKSBgJHtyb290TmFtZX0udmFsaWRhdGVgLCByb290LCByb290LiRhc3luYyk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2FsbFZhbGlkYXRlKHNjaCkge1xuICAgICAgICAgICAgY29uc3QgdiA9IGdldFZhbGlkYXRlKGN4dCwgc2NoKTtcbiAgICAgICAgICAgIGNhbGxSZWYoY3h0LCB2LCBzY2gsIHNjaC4kYXN5bmMpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlubGluZVJlZlNjaGVtYShzY2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHNjaE5hbWUgPSBnZW4uc2NvcGVWYWx1ZShcInNjaGVtYVwiLCBvcHRzLmNvZGUuc291cmNlID09PSB0cnVlID8geyByZWY6IHNjaCwgY29kZTogKDAsIGNvZGVnZW5fMS5zdHJpbmdpZnkpKHNjaCkgfSA6IHsgcmVmOiBzY2ggfSk7XG4gICAgICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIik7XG4gICAgICAgICAgICBjb25zdCBzY2hDeHQgPSBjeHQuc3Vic2NoZW1hKHtcbiAgICAgICAgICAgICAgICBzY2hlbWE6IHNjaCxcbiAgICAgICAgICAgICAgICBkYXRhVHlwZXM6IFtdLFxuICAgICAgICAgICAgICAgIHNjaGVtYVBhdGg6IGNvZGVnZW5fMS5uaWwsXG4gICAgICAgICAgICAgICAgdG9wU2NoZW1hUmVmOiBzY2hOYW1lLFxuICAgICAgICAgICAgICAgIGVyclNjaGVtYVBhdGg6ICRyZWYsXG4gICAgICAgICAgICB9LCB2YWxpZCk7XG4gICAgICAgICAgICBjeHQubWVyZ2VFdmFsdWF0ZWQoc2NoQ3h0KTtcbiAgICAgICAgICAgIGN4dC5vayh2YWxpZCk7XG4gICAgICAgIH1cbiAgICB9LFxufTtcbmZ1bmN0aW9uIGdldFZhbGlkYXRlKGN4dCwgc2NoKSB7XG4gICAgY29uc3QgeyBnZW4gfSA9IGN4dDtcbiAgICByZXR1cm4gc2NoLnZhbGlkYXRlXG4gICAgICAgID8gZ2VuLnNjb3BlVmFsdWUoXCJ2YWxpZGF0ZVwiLCB7IHJlZjogc2NoLnZhbGlkYXRlIH0pXG4gICAgICAgIDogKDAsIGNvZGVnZW5fMS5fKSBgJHtnZW4uc2NvcGVWYWx1ZShcIndyYXBwZXJcIiwgeyByZWY6IHNjaCB9KX0udmFsaWRhdGVgO1xufVxuZXhwb3J0cy5nZXRWYWxpZGF0ZSA9IGdldFZhbGlkYXRlO1xuZnVuY3Rpb24gY2FsbFJlZihjeHQsIHYsIHNjaCwgJGFzeW5jKSB7XG4gICAgY29uc3QgeyBnZW4sIGl0IH0gPSBjeHQ7XG4gICAgY29uc3QgeyBhbGxFcnJvcnMsIHNjaGVtYUVudjogZW52LCBvcHRzIH0gPSBpdDtcbiAgICBjb25zdCBwYXNzQ3h0ID0gb3B0cy5wYXNzQ29udGV4dCA/IG5hbWVzXzEuZGVmYXVsdC50aGlzIDogY29kZWdlbl8xLm5pbDtcbiAgICBpZiAoJGFzeW5jKVxuICAgICAgICBjYWxsQXN5bmNSZWYoKTtcbiAgICBlbHNlXG4gICAgICAgIGNhbGxTeW5jUmVmKCk7XG4gICAgZnVuY3Rpb24gY2FsbEFzeW5jUmVmKCkge1xuICAgICAgICBpZiAoIWVudi4kYXN5bmMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhc3luYyBzY2hlbWEgcmVmZXJlbmNlZCBieSBzeW5jIHNjaGVtYVwiKTtcbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubGV0KFwidmFsaWRcIik7XG4gICAgICAgIGdlbi50cnkoKCkgPT4ge1xuICAgICAgICAgICAgZ2VuLmNvZGUoKDAsIGNvZGVnZW5fMS5fKSBgYXdhaXQgJHsoMCwgY29kZV8xLmNhbGxWYWxpZGF0ZUNvZGUpKGN4dCwgdiwgcGFzc0N4dCl9YCk7XG4gICAgICAgICAgICBhZGRFdmFsdWF0ZWRGcm9tKHYpOyAvLyBUT0RPIHdpbGwgbm90IHdvcmsgd2l0aCBhc3luYywgaXQgaGFzIHRvIGJlIHJldHVybmVkIHdpdGggdGhlIHJlc3VsdFxuICAgICAgICAgICAgaWYgKCFhbGxFcnJvcnMpXG4gICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgdHJ1ZSk7XG4gICAgICAgIH0sIChlKSA9PiB7XG4gICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgISgke2V9IGluc3RhbmNlb2YgJHtpdC5WYWxpZGF0aW9uRXJyb3J9KWAsICgpID0+IGdlbi50aHJvdyhlKSk7XG4gICAgICAgICAgICBhZGRFcnJvcnNGcm9tKGUpO1xuICAgICAgICAgICAgaWYgKCFhbGxFcnJvcnMpXG4gICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICAgICAgY3h0Lm9rKHZhbGlkKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2FsbFN5bmNSZWYoKSB7XG4gICAgICAgIGN4dC5yZXN1bHQoKDAsIGNvZGVfMS5jYWxsVmFsaWRhdGVDb2RlKShjeHQsIHYsIHBhc3NDeHQpLCAoKSA9PiBhZGRFdmFsdWF0ZWRGcm9tKHYpLCAoKSA9PiBhZGRFcnJvcnNGcm9tKHYpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWRkRXJyb3JzRnJvbShzb3VyY2UpIHtcbiAgICAgICAgY29uc3QgZXJycyA9ICgwLCBjb2RlZ2VuXzEuXykgYCR7c291cmNlfS5lcnJvcnNgO1xuICAgICAgICBnZW4uYXNzaWduKG5hbWVzXzEuZGVmYXVsdC52RXJyb3JzLCAoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC52RXJyb3JzfSA9PT0gbnVsbCA/ICR7ZXJyc30gOiAke25hbWVzXzEuZGVmYXVsdC52RXJyb3JzfS5jb25jYXQoJHtlcnJzfSlgKTsgLy8gVE9ETyB0YWdnZWRcbiAgICAgICAgZ2VuLmFzc2lnbihuYW1lc18xLmRlZmF1bHQuZXJyb3JzLCAoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC52RXJyb3JzfS5sZW5ndGhgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWRkRXZhbHVhdGVkRnJvbShzb3VyY2UpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIWl0Lm9wdHMudW5ldmFsdWF0ZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHNjaEV2YWx1YXRlZCA9IChfYSA9IHNjaCA9PT0gbnVsbCB8fCBzY2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNjaC52YWxpZGF0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmV2YWx1YXRlZDtcbiAgICAgICAgLy8gVE9ETyByZWZhY3RvclxuICAgICAgICBpZiAoaXQucHJvcHMgIT09IHRydWUpIHtcbiAgICAgICAgICAgIGlmIChzY2hFdmFsdWF0ZWQgJiYgIXNjaEV2YWx1YXRlZC5keW5hbWljUHJvcHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2NoRXZhbHVhdGVkLnByb3BzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaXQucHJvcHMgPSB1dGlsXzEubWVyZ2VFdmFsdWF0ZWQucHJvcHMoZ2VuLCBzY2hFdmFsdWF0ZWQucHJvcHMsIGl0LnByb3BzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wcyA9IGdlbi52YXIoXCJwcm9wc1wiLCAoMCwgY29kZWdlbl8xLl8pIGAke3NvdXJjZX0uZXZhbHVhdGVkLnByb3BzYCk7XG4gICAgICAgICAgICAgICAgaXQucHJvcHMgPSB1dGlsXzEubWVyZ2VFdmFsdWF0ZWQucHJvcHMoZ2VuLCBwcm9wcywgaXQucHJvcHMsIGNvZGVnZW5fMS5OYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXQuaXRlbXMgIT09IHRydWUpIHtcbiAgICAgICAgICAgIGlmIChzY2hFdmFsdWF0ZWQgJiYgIXNjaEV2YWx1YXRlZC5keW5hbWljSXRlbXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2NoRXZhbHVhdGVkLml0ZW1zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaXQuaXRlbXMgPSB1dGlsXzEubWVyZ2VFdmFsdWF0ZWQuaXRlbXMoZ2VuLCBzY2hFdmFsdWF0ZWQuaXRlbXMsIGl0Lml0ZW1zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtcyA9IGdlbi52YXIoXCJpdGVtc1wiLCAoMCwgY29kZWdlbl8xLl8pIGAke3NvdXJjZX0uZXZhbHVhdGVkLml0ZW1zYCk7XG4gICAgICAgICAgICAgICAgaXQuaXRlbXMgPSB1dGlsXzEubWVyZ2VFdmFsdWF0ZWQuaXRlbXMoZ2VuLCBpdGVtcywgaXQuaXRlbXMsIGNvZGVnZW5fMS5OYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuY2FsbFJlZiA9IGNhbGxSZWY7XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWYuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBpZF8xID0gcmVxdWlyZShcIi4vaWRcIik7XG5jb25zdCByZWZfMSA9IHJlcXVpcmUoXCIuL3JlZlwiKTtcbmNvbnN0IGNvcmUgPSBbXG4gICAgXCIkc2NoZW1hXCIsXG4gICAgXCIkaWRcIixcbiAgICBcIiRkZWZzXCIsXG4gICAgXCIkdm9jYWJ1bGFyeVwiLFxuICAgIHsga2V5d29yZDogXCIkY29tbWVudFwiIH0sXG4gICAgXCJkZWZpbml0aW9uc1wiLFxuICAgIGlkXzEuZGVmYXVsdCxcbiAgICByZWZfMS5kZWZhdWx0LFxuXTtcbmV4cG9ydHMuZGVmYXVsdCA9IGNvcmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCBvcHMgPSBjb2RlZ2VuXzEub3BlcmF0b3JzO1xuY29uc3QgS1dEcyA9IHtcbiAgICBtYXhpbXVtOiB7IG9rU3RyOiBcIjw9XCIsIG9rOiBvcHMuTFRFLCBmYWlsOiBvcHMuR1QgfSxcbiAgICBtaW5pbXVtOiB7IG9rU3RyOiBcIj49XCIsIG9rOiBvcHMuR1RFLCBmYWlsOiBvcHMuTFQgfSxcbiAgICBleGNsdXNpdmVNYXhpbXVtOiB7IG9rU3RyOiBcIjxcIiwgb2s6IG9wcy5MVCwgZmFpbDogb3BzLkdURSB9LFxuICAgIGV4Y2x1c2l2ZU1pbmltdW06IHsgb2tTdHI6IFwiPlwiLCBvazogb3BzLkdULCBmYWlsOiBvcHMuTFRFIH0sXG59O1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsga2V5d29yZCwgc2NoZW1hQ29kZSB9KSA9PiAoMCwgY29kZWdlbl8xLnN0cikgYG11c3QgYmUgJHtLV0RzW2tleXdvcmRdLm9rU3RyfSAke3NjaGVtYUNvZGV9YCxcbiAgICBwYXJhbXM6ICh7IGtleXdvcmQsIHNjaGVtYUNvZGUgfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge2NvbXBhcmlzb246ICR7S1dEc1trZXl3b3JkXS5va1N0cn0sIGxpbWl0OiAke3NjaGVtYUNvZGV9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IE9iamVjdC5rZXlzKEtXRHMpLFxuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgc2NoZW1hVHlwZTogXCJudW1iZXJcIixcbiAgICAkZGF0YTogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGtleXdvcmQsIGRhdGEsIHNjaGVtYUNvZGUgfSA9IGN4dDtcbiAgICAgICAgY3h0LmZhaWwkZGF0YSgoMCwgY29kZWdlbl8xLl8pIGAke2RhdGF9ICR7S1dEc1trZXl3b3JkXS5mYWlsfSAke3NjaGVtYUNvZGV9IHx8IGlzTmFOKCR7ZGF0YX0pYCk7XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1saW1pdE51bWJlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBzY2hlbWFDb2RlIH0pID0+ICgwLCBjb2RlZ2VuXzEuc3RyKSBgbXVzdCBiZSBtdWx0aXBsZSBvZiAke3NjaGVtYUNvZGV9YCxcbiAgICBwYXJhbXM6ICh7IHNjaGVtYUNvZGUgfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge211bHRpcGxlT2Y6ICR7c2NoZW1hQ29kZX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJtdWx0aXBsZU9mXCIsXG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBzY2hlbWFUeXBlOiBcIm51bWJlclwiLFxuICAgICRkYXRhOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCBzY2hlbWFDb2RlLCBpdCB9ID0gY3h0O1xuICAgICAgICAvLyBjb25zdCBiZHQgPSBiYWQkRGF0YVR5cGUoc2NoZW1hQ29kZSwgPHN0cmluZz5kZWYuc2NoZW1hVHlwZSwgJGRhdGEpXG4gICAgICAgIGNvbnN0IHByZWMgPSBpdC5vcHRzLm11bHRpcGxlT2ZQcmVjaXNpb247XG4gICAgICAgIGNvbnN0IHJlcyA9IGdlbi5sZXQoXCJyZXNcIik7XG4gICAgICAgIGNvbnN0IGludmFsaWQgPSBwcmVjXG4gICAgICAgICAgICA/ICgwLCBjb2RlZ2VuXzEuXykgYE1hdGguYWJzKE1hdGgucm91bmQoJHtyZXN9KSAtICR7cmVzfSkgPiAxZS0ke3ByZWN9YFxuICAgICAgICAgICAgOiAoMCwgY29kZWdlbl8xLl8pIGAke3Jlc30gIT09IHBhcnNlSW50KCR7cmVzfSlgO1xuICAgICAgICBjeHQuZmFpbCRkYXRhKCgwLCBjb2RlZ2VuXzEuXykgYCgke3NjaGVtYUNvZGV9ID09PSAwIHx8ICgke3Jlc30gPSAke2RhdGF9LyR7c2NoZW1hQ29kZX0sICR7aW52YWxpZH0pKWApO1xuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bXVsdGlwbGVPZi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nXG4vLyBodHRwczovL2dpdGh1Yi5jb20vYmVzdGllanMvcHVueWNvZGUuanMgLSBwdW55Y29kZS51Y3MyLmRlY29kZVxuZnVuY3Rpb24gdWNzMmxlbmd0aChzdHIpIHtcbiAgICBjb25zdCBsZW4gPSBzdHIubGVuZ3RoO1xuICAgIGxldCBsZW5ndGggPSAwO1xuICAgIGxldCBwb3MgPSAwO1xuICAgIGxldCB2YWx1ZTtcbiAgICB3aGlsZSAocG9zIDwgbGVuKSB7XG4gICAgICAgIGxlbmd0aCsrO1xuICAgICAgICB2YWx1ZSA9IHN0ci5jaGFyQ29kZUF0KHBvcysrKTtcbiAgICAgICAgaWYgKHZhbHVlID49IDB4ZDgwMCAmJiB2YWx1ZSA8PSAweGRiZmYgJiYgcG9zIDwgbGVuKSB7XG4gICAgICAgICAgICAvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcbiAgICAgICAgICAgIHZhbHVlID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgICAgICAgIGlmICgodmFsdWUgJiAweGZjMDApID09PSAweGRjMDApXG4gICAgICAgICAgICAgICAgcG9zKys7IC8vIGxvdyBzdXJyb2dhdGVcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGVuZ3RoO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gdWNzMmxlbmd0aDtcbnVjczJsZW5ndGguY29kZSA9ICdyZXF1aXJlKFwiYWp2L2Rpc3QvcnVudGltZS91Y3MybGVuZ3RoXCIpLmRlZmF1bHQnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dWNzMmxlbmd0aC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgdWNzMmxlbmd0aF8xID0gcmVxdWlyZShcIi4uLy4uL3J1bnRpbWUvdWNzMmxlbmd0aFwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2UoeyBrZXl3b3JkLCBzY2hlbWFDb2RlIH0pIHtcbiAgICAgICAgY29uc3QgY29tcCA9IGtleXdvcmQgPT09IFwibWF4TGVuZ3RoXCIgPyBcIm1vcmVcIiA6IFwiZmV3ZXJcIjtcbiAgICAgICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEuc3RyKSBgbXVzdCBOT1QgaGF2ZSAke2NvbXB9IHRoYW4gJHtzY2hlbWFDb2RlfSBjaGFyYWN0ZXJzYDtcbiAgICB9LFxuICAgIHBhcmFtczogKHsgc2NoZW1hQ29kZSB9KSA9PiAoMCwgY29kZWdlbl8xLl8pIGB7bGltaXQ6ICR7c2NoZW1hQ29kZX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogW1wibWF4TGVuZ3RoXCIsIFwibWluTGVuZ3RoXCJdLFxuICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgc2NoZW1hVHlwZTogXCJudW1iZXJcIixcbiAgICAkZGF0YTogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGtleXdvcmQsIGRhdGEsIHNjaGVtYUNvZGUsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGNvbnN0IG9wID0ga2V5d29yZCA9PT0gXCJtYXhMZW5ndGhcIiA/IGNvZGVnZW5fMS5vcGVyYXRvcnMuR1QgOiBjb2RlZ2VuXzEub3BlcmF0b3JzLkxUO1xuICAgICAgICBjb25zdCBsZW4gPSBpdC5vcHRzLnVuaWNvZGUgPT09IGZhbHNlID8gKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfS5sZW5ndGhgIDogKDAsIGNvZGVnZW5fMS5fKSBgJHsoMCwgdXRpbF8xLnVzZUZ1bmMpKGN4dC5nZW4sIHVjczJsZW5ndGhfMS5kZWZhdWx0KX0oJHtkYXRhfSlgO1xuICAgICAgICBjeHQuZmFpbCRkYXRhKCgwLCBjb2RlZ2VuXzEuXykgYCR7bGVufSAke29wfSAke3NjaGVtYUNvZGV9YCk7XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1saW1pdExlbmd0aC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuLi9jb2RlXCIpO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IHNjaGVtYUNvZGUgfSkgPT4gKDAsIGNvZGVnZW5fMS5zdHIpIGBtdXN0IG1hdGNoIHBhdHRlcm4gXCIke3NjaGVtYUNvZGV9XCJgLFxuICAgIHBhcmFtczogKHsgc2NoZW1hQ29kZSB9KSA9PiAoMCwgY29kZWdlbl8xLl8pIGB7cGF0dGVybjogJHtzY2hlbWFDb2RlfX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcInBhdHRlcm5cIixcbiAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgIHNjaGVtYVR5cGU6IFwic3RyaW5nXCIsXG4gICAgJGRhdGE6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBkYXRhLCAkZGF0YSwgc2NoZW1hLCBzY2hlbWFDb2RlLCBpdCB9ID0gY3h0O1xuICAgICAgICAvLyBUT0RPIHJlZ2V4cCBzaG91bGQgYmUgd3JhcHBlZCBpbiB0cnkvY2F0Y2hzXG4gICAgICAgIGNvbnN0IHUgPSBpdC5vcHRzLnVuaWNvZGVSZWdFeHAgPyBcInVcIiA6IFwiXCI7XG4gICAgICAgIGNvbnN0IHJlZ0V4cCA9ICRkYXRhID8gKDAsIGNvZGVnZW5fMS5fKSBgKG5ldyBSZWdFeHAoJHtzY2hlbWFDb2RlfSwgJHt1fSkpYCA6ICgwLCBjb2RlXzEudXNlUGF0dGVybikoY3h0LCBzY2hlbWEpO1xuICAgICAgICBjeHQuZmFpbCRkYXRhKCgwLCBjb2RlZ2VuXzEuXykgYCEke3JlZ0V4cH0udGVzdCgke2RhdGF9KWApO1xuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGF0dGVybi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlKHsga2V5d29yZCwgc2NoZW1hQ29kZSB9KSB7XG4gICAgICAgIGNvbnN0IGNvbXAgPSBrZXl3b3JkID09PSBcIm1heFByb3BlcnRpZXNcIiA/IFwibW9yZVwiIDogXCJmZXdlclwiO1xuICAgICAgICByZXR1cm4gKDAsIGNvZGVnZW5fMS5zdHIpIGBtdXN0IE5PVCBoYXZlICR7Y29tcH0gdGhhbiAke3NjaGVtYUNvZGV9IHByb3BlcnRpZXNgO1xuICAgIH0sXG4gICAgcGFyYW1zOiAoeyBzY2hlbWFDb2RlIH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHtsaW1pdDogJHtzY2hlbWFDb2RlfX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBbXCJtYXhQcm9wZXJ0aWVzXCIsIFwibWluUHJvcGVydGllc1wiXSxcbiAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgIHNjaGVtYVR5cGU6IFwibnVtYmVyXCIsXG4gICAgJGRhdGE6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBrZXl3b3JkLCBkYXRhLCBzY2hlbWFDb2RlIH0gPSBjeHQ7XG4gICAgICAgIGNvbnN0IG9wID0ga2V5d29yZCA9PT0gXCJtYXhQcm9wZXJ0aWVzXCIgPyBjb2RlZ2VuXzEub3BlcmF0b3JzLkdUIDogY29kZWdlbl8xLm9wZXJhdG9ycy5MVDtcbiAgICAgICAgY3h0LmZhaWwkZGF0YSgoMCwgY29kZWdlbl8xLl8pIGBPYmplY3Qua2V5cygke2RhdGF9KS5sZW5ndGggJHtvcH0gJHtzY2hlbWFDb2RlfWApO1xuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGltaXRQcm9wZXJ0aWVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZV8xID0gcmVxdWlyZShcIi4uL2NvZGVcIik7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IHBhcmFtczogeyBtaXNzaW5nUHJvcGVydHkgfSB9KSA9PiAoMCwgY29kZWdlbl8xLnN0cikgYG11c3QgaGF2ZSByZXF1aXJlZCBwcm9wZXJ0eSAnJHttaXNzaW5nUHJvcGVydHl9J2AsXG4gICAgcGFyYW1zOiAoeyBwYXJhbXM6IHsgbWlzc2luZ1Byb3BlcnR5IH0gfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge21pc3NpbmdQcm9wZXJ0eTogJHttaXNzaW5nUHJvcGVydHl9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwicmVxdWlyZWRcIixcbiAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgIHNjaGVtYVR5cGU6IFwiYXJyYXlcIixcbiAgICAkZGF0YTogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgc2NoZW1hLCBzY2hlbWFDb2RlLCBkYXRhLCAkZGF0YSwgaXQgfSA9IGN4dDtcbiAgICAgICAgY29uc3QgeyBvcHRzIH0gPSBpdDtcbiAgICAgICAgaWYgKCEkZGF0YSAmJiBzY2hlbWEubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB1c2VMb29wID0gc2NoZW1hLmxlbmd0aCA+PSBvcHRzLmxvb3BSZXF1aXJlZDtcbiAgICAgICAgaWYgKGl0LmFsbEVycm9ycylcbiAgICAgICAgICAgIGFsbEVycm9yc01vZGUoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgZXhpdE9uRXJyb3JNb2RlKCk7XG4gICAgICAgIGlmIChvcHRzLnN0cmljdFJlcXVpcmVkKSB7XG4gICAgICAgICAgICBjb25zdCBwcm9wcyA9IGN4dC5wYXJlbnRTY2hlbWEucHJvcGVydGllcztcbiAgICAgICAgICAgIGNvbnN0IHsgZGVmaW5lZFByb3BlcnRpZXMgfSA9IGN4dC5pdDtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVxdWlyZWRLZXkgb2Ygc2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgaWYgKChwcm9wcyA9PT0gbnVsbCB8fCBwcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvcHNbcmVxdWlyZWRLZXldKSA9PT0gdW5kZWZpbmVkICYmICFkZWZpbmVkUHJvcGVydGllcy5oYXMocmVxdWlyZWRLZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNjaGVtYVBhdGggPSBpdC5zY2hlbWFFbnYuYmFzZUlkICsgaXQuZXJyU2NoZW1hUGF0aDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbXNnID0gYHJlcXVpcmVkIHByb3BlcnR5IFwiJHtyZXF1aXJlZEtleX1cIiBpcyBub3QgZGVmaW5lZCBhdCBcIiR7c2NoZW1hUGF0aH1cIiAoc3RyaWN0UmVxdWlyZWQpYDtcbiAgICAgICAgICAgICAgICAgICAgKDAsIHV0aWxfMS5jaGVja1N0cmljdE1vZGUpKGl0LCBtc2csIGl0Lm9wdHMuc3RyaWN0UmVxdWlyZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhbGxFcnJvcnNNb2RlKCkge1xuICAgICAgICAgICAgaWYgKHVzZUxvb3AgfHwgJGRhdGEpIHtcbiAgICAgICAgICAgICAgICBjeHQuYmxvY2skZGF0YShjb2RlZ2VuXzEubmlsLCBsb29wQWxsUmVxdWlyZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwcm9wIG9mIHNjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICAoMCwgY29kZV8xLmNoZWNrUmVwb3J0TWlzc2luZ1Byb3ApKGN4dCwgcHJvcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGV4aXRPbkVycm9yTW9kZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IG1pc3NpbmcgPSBnZW4ubGV0KFwibWlzc2luZ1wiKTtcbiAgICAgICAgICAgIGlmICh1c2VMb29wIHx8ICRkYXRhKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubGV0KFwidmFsaWRcIiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgY3h0LmJsb2NrJGRhdGEodmFsaWQsICgpID0+IGxvb3BVbnRpbE1pc3NpbmcobWlzc2luZywgdmFsaWQpKTtcbiAgICAgICAgICAgICAgICBjeHQub2sodmFsaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlXzEuY2hlY2tNaXNzaW5nUHJvcCkoY3h0LCBzY2hlbWEsIG1pc3NpbmcpKTtcbiAgICAgICAgICAgICAgICAoMCwgY29kZV8xLnJlcG9ydE1pc3NpbmdQcm9wKShjeHQsIG1pc3NpbmcpO1xuICAgICAgICAgICAgICAgIGdlbi5lbHNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbG9vcEFsbFJlcXVpcmVkKCkge1xuICAgICAgICAgICAgZ2VuLmZvck9mKFwicHJvcFwiLCBzY2hlbWFDb2RlLCAocHJvcCkgPT4ge1xuICAgICAgICAgICAgICAgIGN4dC5zZXRQYXJhbXMoeyBtaXNzaW5nUHJvcGVydHk6IHByb3AgfSk7XG4gICAgICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlXzEubm9Qcm9wZXJ0eUluRGF0YSkoZ2VuLCBkYXRhLCBwcm9wLCBvcHRzLm93blByb3BlcnRpZXMpLCAoKSA9PiBjeHQuZXJyb3IoKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBsb29wVW50aWxNaXNzaW5nKG1pc3NpbmcsIHZhbGlkKSB7XG4gICAgICAgICAgICBjeHQuc2V0UGFyYW1zKHsgbWlzc2luZ1Byb3BlcnR5OiBtaXNzaW5nIH0pO1xuICAgICAgICAgICAgZ2VuLmZvck9mKG1pc3NpbmcsIHNjaGVtYUNvZGUsICgpID0+IHtcbiAgICAgICAgICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCAoMCwgY29kZV8xLnByb3BlcnR5SW5EYXRhKShnZW4sIGRhdGEsIG1pc3NpbmcsIG9wdHMub3duUHJvcGVydGllcykpO1xuICAgICAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLm5vdCkodmFsaWQpLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGN4dC5lcnJvcigpO1xuICAgICAgICAgICAgICAgICAgICBnZW4uYnJlYWsoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIGNvZGVnZW5fMS5uaWwpO1xuICAgICAgICB9XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXF1aXJlZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlKHsga2V5d29yZCwgc2NoZW1hQ29kZSB9KSB7XG4gICAgICAgIGNvbnN0IGNvbXAgPSBrZXl3b3JkID09PSBcIm1heEl0ZW1zXCIgPyBcIm1vcmVcIiA6IFwiZmV3ZXJcIjtcbiAgICAgICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEuc3RyKSBgbXVzdCBOT1QgaGF2ZSAke2NvbXB9IHRoYW4gJHtzY2hlbWFDb2RlfSBpdGVtc2A7XG4gICAgfSxcbiAgICBwYXJhbXM6ICh7IHNjaGVtYUNvZGUgfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge2xpbWl0OiAke3NjaGVtYUNvZGV9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFtcIm1heEl0ZW1zXCIsIFwibWluSXRlbXNcIl0sXG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIHNjaGVtYVR5cGU6IFwibnVtYmVyXCIsXG4gICAgJGRhdGE6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBrZXl3b3JkLCBkYXRhLCBzY2hlbWFDb2RlIH0gPSBjeHQ7XG4gICAgICAgIGNvbnN0IG9wID0ga2V5d29yZCA9PT0gXCJtYXhJdGVtc1wiID8gY29kZWdlbl8xLm9wZXJhdG9ycy5HVCA6IGNvZGVnZW5fMS5vcGVyYXRvcnMuTFQ7XG4gICAgICAgIGN4dC5mYWlsJGRhdGEoKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfS5sZW5ndGggJHtvcH0gJHtzY2hlbWFDb2RlfWApO1xuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGltaXRJdGVtcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hanYtdmFsaWRhdG9yL2Fqdi9pc3N1ZXMvODg5XG5jb25zdCBlcXVhbCA9IHJlcXVpcmUoXCJmYXN0LWRlZXAtZXF1YWxcIik7XG5lcXVhbC5jb2RlID0gJ3JlcXVpcmUoXCJhanYvZGlzdC9ydW50aW1lL2VxdWFsXCIpLmRlZmF1bHQnO1xuZXhwb3J0cy5kZWZhdWx0ID0gZXF1YWw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcXVhbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGRhdGFUeXBlXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS92YWxpZGF0ZS9kYXRhVHlwZVwiKTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZXF1YWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9ydW50aW1lL2VxdWFsXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsgcGFyYW1zOiB7IGksIGogfSB9KSA9PiAoMCwgY29kZWdlbl8xLnN0cikgYG11c3QgTk9UIGhhdmUgZHVwbGljYXRlIGl0ZW1zIChpdGVtcyAjIyAke2p9IGFuZCAke2l9IGFyZSBpZGVudGljYWwpYCxcbiAgICBwYXJhbXM6ICh7IHBhcmFtczogeyBpLCBqIH0gfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge2k6ICR7aX0sIGo6ICR7an19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJ1bmlxdWVJdGVtc1wiLFxuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICBzY2hlbWFUeXBlOiBcImJvb2xlYW5cIixcbiAgICAkZGF0YTogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgZGF0YSwgJGRhdGEsIHNjaGVtYSwgcGFyZW50U2NoZW1hLCBzY2hlbWFDb2RlLCBpdCB9ID0gY3h0O1xuICAgICAgICBpZiAoISRkYXRhICYmICFzY2hlbWEpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIpO1xuICAgICAgICBjb25zdCBpdGVtVHlwZXMgPSBwYXJlbnRTY2hlbWEuaXRlbXMgPyAoMCwgZGF0YVR5cGVfMS5nZXRTY2hlbWFUeXBlcykocGFyZW50U2NoZW1hLml0ZW1zKSA6IFtdO1xuICAgICAgICBjeHQuYmxvY2skZGF0YSh2YWxpZCwgdmFsaWRhdGVVbmlxdWVJdGVtcywgKDAsIGNvZGVnZW5fMS5fKSBgJHtzY2hlbWFDb2RlfSA9PT0gZmFsc2VgKTtcbiAgICAgICAgY3h0Lm9rKHZhbGlkKTtcbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGVVbmlxdWVJdGVtcygpIHtcbiAgICAgICAgICAgIGNvbnN0IGkgPSBnZW4ubGV0KFwiaVwiLCAoMCwgY29kZWdlbl8xLl8pIGAke2RhdGF9Lmxlbmd0aGApO1xuICAgICAgICAgICAgY29uc3QgaiA9IGdlbi5sZXQoXCJqXCIpO1xuICAgICAgICAgICAgY3h0LnNldFBhcmFtcyh7IGksIGogfSk7XG4gICAgICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCB0cnVlKTtcbiAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke2l9ID4gMWAsICgpID0+IChjYW5PcHRpbWl6ZSgpID8gbG9vcE4gOiBsb29wTjIpKGksIGopKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjYW5PcHRpbWl6ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtVHlwZXMubGVuZ3RoID4gMCAmJiAhaXRlbVR5cGVzLnNvbWUoKHQpID0+IHQgPT09IFwib2JqZWN0XCIgfHwgdCA9PT0gXCJhcnJheVwiKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBsb29wTihpLCBqKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gZ2VuLm5hbWUoXCJpdGVtXCIpO1xuICAgICAgICAgICAgY29uc3Qgd3JvbmdUeXBlID0gKDAsIGRhdGFUeXBlXzEuY2hlY2tEYXRhVHlwZXMpKGl0ZW1UeXBlcywgaXRlbSwgaXQub3B0cy5zdHJpY3ROdW1iZXJzLCBkYXRhVHlwZV8xLkRhdGFUeXBlLldyb25nKTtcbiAgICAgICAgICAgIGNvbnN0IGluZGljZXMgPSBnZW4uY29uc3QoXCJpbmRpY2VzXCIsICgwLCBjb2RlZ2VuXzEuXykgYHt9YCk7XG4gICAgICAgICAgICBnZW4uZm9yKCgwLCBjb2RlZ2VuXzEuXykgYDske2l9LS07YCwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGdlbi5sZXQoaXRlbSwgKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfVske2l9XWApO1xuICAgICAgICAgICAgICAgIGdlbi5pZih3cm9uZ1R5cGUsICgwLCBjb2RlZ2VuXzEuXykgYGNvbnRpbnVlYCk7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW1UeXBlcy5sZW5ndGggPiAxKVxuICAgICAgICAgICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgdHlwZW9mICR7aXRlbX0gPT0gXCJzdHJpbmdcImAsICgwLCBjb2RlZ2VuXzEuXykgYCR7aXRlbX0gKz0gXCJfXCJgKTtcbiAgICAgICAgICAgICAgICBnZW5cbiAgICAgICAgICAgICAgICAgICAgLmlmKCgwLCBjb2RlZ2VuXzEuXykgYHR5cGVvZiAke2luZGljZXN9WyR7aXRlbX1dID09IFwibnVtYmVyXCJgLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24oaiwgKDAsIGNvZGVnZW5fMS5fKSBgJHtpbmRpY2VzfVske2l0ZW19XWApO1xuICAgICAgICAgICAgICAgICAgICBjeHQuZXJyb3IoKTtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgZmFsc2UpLmJyZWFrKCk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmNvZGUoKDAsIGNvZGVnZW5fMS5fKSBgJHtpbmRpY2VzfVske2l0ZW19XSA9ICR7aX1gKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGxvb3BOMihpLCBqKSB7XG4gICAgICAgICAgICBjb25zdCBlcWwgPSAoMCwgdXRpbF8xLnVzZUZ1bmMpKGdlbiwgZXF1YWxfMS5kZWZhdWx0KTtcbiAgICAgICAgICAgIGNvbnN0IG91dGVyID0gZ2VuLm5hbWUoXCJvdXRlclwiKTtcbiAgICAgICAgICAgIGdlbi5sYWJlbChvdXRlcikuZm9yKCgwLCBjb2RlZ2VuXzEuXykgYDske2l9LS07YCwgKCkgPT4gZ2VuLmZvcigoMCwgY29kZWdlbl8xLl8pIGAke2p9ID0gJHtpfTsgJHtqfS0tO2AsICgpID0+IGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke2VxbH0oJHtkYXRhfVske2l9XSwgJHtkYXRhfVske2p9XSlgLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY3h0LmVycm9yKCk7XG4gICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgZmFsc2UpLmJyZWFrKG91dGVyKTtcbiAgICAgICAgICAgIH0pKSk7XG4gICAgICAgIH1cbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVuaXF1ZUl0ZW1zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBlcXVhbF8xID0gcmVxdWlyZShcIi4uLy4uL3J1bnRpbWUvZXF1YWxcIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiBcIm11c3QgYmUgZXF1YWwgdG8gY29uc3RhbnRcIixcbiAgICBwYXJhbXM6ICh7IHNjaGVtYUNvZGUgfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge2FsbG93ZWRWYWx1ZTogJHtzY2hlbWFDb2RlfX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcImNvbnN0XCIsXG4gICAgJGRhdGE6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIGRhdGEsICRkYXRhLCBzY2hlbWFDb2RlLCBzY2hlbWEgfSA9IGN4dDtcbiAgICAgICAgaWYgKCRkYXRhIHx8IChzY2hlbWEgJiYgdHlwZW9mIHNjaGVtYSA9PSBcIm9iamVjdFwiKSkge1xuICAgICAgICAgICAgY3h0LmZhaWwkZGF0YSgoMCwgY29kZWdlbl8xLl8pIGAhJHsoMCwgdXRpbF8xLnVzZUZ1bmMpKGdlbiwgZXF1YWxfMS5kZWZhdWx0KX0oJHtkYXRhfSwgJHtzY2hlbWFDb2RlfSlgKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGN4dC5mYWlsKCgwLCBjb2RlZ2VuXzEuXykgYCR7c2NoZW1hfSAhPT0gJHtkYXRhfWApO1xuICAgICAgICB9XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZXF1YWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9ydW50aW1lL2VxdWFsXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogXCJtdXN0IGJlIGVxdWFsIHRvIG9uZSBvZiB0aGUgYWxsb3dlZCB2YWx1ZXNcIixcbiAgICBwYXJhbXM6ICh7IHNjaGVtYUNvZGUgfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge2FsbG93ZWRWYWx1ZXM6ICR7c2NoZW1hQ29kZX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJlbnVtXCIsXG4gICAgc2NoZW1hVHlwZTogXCJhcnJheVwiLFxuICAgICRkYXRhOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCAkZGF0YSwgc2NoZW1hLCBzY2hlbWFDb2RlLCBpdCB9ID0gY3h0O1xuICAgICAgICBpZiAoISRkYXRhICYmIHNjaGVtYS5sZW5ndGggPT09IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJlbnVtIG11c3QgaGF2ZSBub24tZW1wdHkgYXJyYXlcIik7XG4gICAgICAgIGNvbnN0IHVzZUxvb3AgPSBzY2hlbWEubGVuZ3RoID49IGl0Lm9wdHMubG9vcEVudW07XG4gICAgICAgIGxldCBlcWw7XG4gICAgICAgIGNvbnN0IGdldEVxbCA9ICgpID0+IChlcWwgIT09IG51bGwgJiYgZXFsICE9PSB2b2lkIDAgPyBlcWwgOiAoZXFsID0gKDAsIHV0aWxfMS51c2VGdW5jKShnZW4sIGVxdWFsXzEuZGVmYXVsdCkpKTtcbiAgICAgICAgbGV0IHZhbGlkO1xuICAgICAgICBpZiAodXNlTG9vcCB8fCAkZGF0YSkge1xuICAgICAgICAgICAgdmFsaWQgPSBnZW4ubGV0KFwidmFsaWRcIik7XG4gICAgICAgICAgICBjeHQuYmxvY2skZGF0YSh2YWxpZCwgbG9vcEVudW0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2NoZW1hKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhanYgaW1wbGVtZW50YXRpb24gZXJyb3JcIik7XG4gICAgICAgICAgICBjb25zdCB2U2NoZW1hID0gZ2VuLmNvbnN0KFwidlNjaGVtYVwiLCBzY2hlbWFDb2RlKTtcbiAgICAgICAgICAgIHZhbGlkID0gKDAsIGNvZGVnZW5fMS5vcikoLi4uc2NoZW1hLm1hcCgoX3gsIGkpID0+IGVxdWFsQ29kZSh2U2NoZW1hLCBpKSkpO1xuICAgICAgICB9XG4gICAgICAgIGN4dC5wYXNzKHZhbGlkKTtcbiAgICAgICAgZnVuY3Rpb24gbG9vcEVudW0oKSB7XG4gICAgICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCBmYWxzZSk7XG4gICAgICAgICAgICBnZW4uZm9yT2YoXCJ2XCIsIHNjaGVtYUNvZGUsICh2KSA9PiBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtnZXRFcWwoKX0oJHtkYXRhfSwgJHt2fSlgLCAoKSA9PiBnZW4uYXNzaWduKHZhbGlkLCB0cnVlKS5icmVhaygpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZXF1YWxDb2RlKHZTY2hlbWEsIGkpIHtcbiAgICAgICAgICAgIGNvbnN0IHNjaCA9IHNjaGVtYVtpXTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2Ygc2NoID09PSBcIm9iamVjdFwiICYmIHNjaCAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gKDAsIGNvZGVnZW5fMS5fKSBgJHtnZXRFcWwoKX0oJHtkYXRhfSwgJHt2U2NoZW1hfVske2l9XSlgXG4gICAgICAgICAgICAgICAgOiAoMCwgY29kZWdlbl8xLl8pIGAke2RhdGF9ID09PSAke3NjaH1gO1xuICAgICAgICB9XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbnVtLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgbGltaXROdW1iZXJfMSA9IHJlcXVpcmUoXCIuL2xpbWl0TnVtYmVyXCIpO1xuY29uc3QgbXVsdGlwbGVPZl8xID0gcmVxdWlyZShcIi4vbXVsdGlwbGVPZlwiKTtcbmNvbnN0IGxpbWl0TGVuZ3RoXzEgPSByZXF1aXJlKFwiLi9saW1pdExlbmd0aFwiKTtcbmNvbnN0IHBhdHRlcm5fMSA9IHJlcXVpcmUoXCIuL3BhdHRlcm5cIik7XG5jb25zdCBsaW1pdFByb3BlcnRpZXNfMSA9IHJlcXVpcmUoXCIuL2xpbWl0UHJvcGVydGllc1wiKTtcbmNvbnN0IHJlcXVpcmVkXzEgPSByZXF1aXJlKFwiLi9yZXF1aXJlZFwiKTtcbmNvbnN0IGxpbWl0SXRlbXNfMSA9IHJlcXVpcmUoXCIuL2xpbWl0SXRlbXNcIik7XG5jb25zdCB1bmlxdWVJdGVtc18xID0gcmVxdWlyZShcIi4vdW5pcXVlSXRlbXNcIik7XG5jb25zdCBjb25zdF8xID0gcmVxdWlyZShcIi4vY29uc3RcIik7XG5jb25zdCBlbnVtXzEgPSByZXF1aXJlKFwiLi9lbnVtXCIpO1xuY29uc3QgdmFsaWRhdGlvbiA9IFtcbiAgICAvLyBudW1iZXJcbiAgICBsaW1pdE51bWJlcl8xLmRlZmF1bHQsXG4gICAgbXVsdGlwbGVPZl8xLmRlZmF1bHQsXG4gICAgLy8gc3RyaW5nXG4gICAgbGltaXRMZW5ndGhfMS5kZWZhdWx0LFxuICAgIHBhdHRlcm5fMS5kZWZhdWx0LFxuICAgIC8vIG9iamVjdFxuICAgIGxpbWl0UHJvcGVydGllc18xLmRlZmF1bHQsXG4gICAgcmVxdWlyZWRfMS5kZWZhdWx0LFxuICAgIC8vIGFycmF5XG4gICAgbGltaXRJdGVtc18xLmRlZmF1bHQsXG4gICAgdW5pcXVlSXRlbXNfMS5kZWZhdWx0LFxuICAgIC8vIGFueVxuICAgIHsga2V5d29yZDogXCJ0eXBlXCIsIHNjaGVtYVR5cGU6IFtcInN0cmluZ1wiLCBcImFycmF5XCJdIH0sXG4gICAgeyBrZXl3b3JkOiBcIm51bGxhYmxlXCIsIHNjaGVtYVR5cGU6IFwiYm9vbGVhblwiIH0sXG4gICAgY29uc3RfMS5kZWZhdWx0LFxuICAgIGVudW1fMS5kZWZhdWx0LFxuXTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZhbGlkYXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudmFsaWRhdGVBZGRpdGlvbmFsSXRlbXMgPSB2b2lkIDA7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IHBhcmFtczogeyBsZW4gfSB9KSA9PiAoMCwgY29kZWdlbl8xLnN0cikgYG11c3QgTk9UIGhhdmUgbW9yZSB0aGFuICR7bGVufSBpdGVtc2AsXG4gICAgcGFyYW1zOiAoeyBwYXJhbXM6IHsgbGVuIH0gfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge2xpbWl0OiAke2xlbn19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJhZGRpdGlvbmFsSXRlbXNcIixcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgc2NoZW1hVHlwZTogW1wiYm9vbGVhblwiLCBcIm9iamVjdFwiXSxcbiAgICBiZWZvcmU6IFwidW5pcXVlSXRlbXNcIixcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IHBhcmVudFNjaGVtYSwgaXQgfSA9IGN4dDtcbiAgICAgICAgY29uc3QgeyBpdGVtcyB9ID0gcGFyZW50U2NoZW1hO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaXRlbXMpKSB7XG4gICAgICAgICAgICAoMCwgdXRpbF8xLmNoZWNrU3RyaWN0TW9kZSkoaXQsICdcImFkZGl0aW9uYWxJdGVtc1wiIGlzIGlnbm9yZWQgd2hlbiBcIml0ZW1zXCIgaXMgbm90IGFuIGFycmF5IG9mIHNjaGVtYXMnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YWxpZGF0ZUFkZGl0aW9uYWxJdGVtcyhjeHQsIGl0ZW1zKTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIHZhbGlkYXRlQWRkaXRpb25hbEl0ZW1zKGN4dCwgaXRlbXMpIHtcbiAgICBjb25zdCB7IGdlbiwgc2NoZW1hLCBkYXRhLCBrZXl3b3JkLCBpdCB9ID0gY3h0O1xuICAgIGl0Lml0ZW1zID0gdHJ1ZTtcbiAgICBjb25zdCBsZW4gPSBnZW4uY29uc3QoXCJsZW5cIiwgKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfS5sZW5ndGhgKTtcbiAgICBpZiAoc2NoZW1hID09PSBmYWxzZSkge1xuICAgICAgICBjeHQuc2V0UGFyYW1zKHsgbGVuOiBpdGVtcy5sZW5ndGggfSk7XG4gICAgICAgIGN4dC5wYXNzKCgwLCBjb2RlZ2VuXzEuXykgYCR7bGVufSA8PSAke2l0ZW1zLmxlbmd0aH1gKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHNjaGVtYSA9PSBcIm9iamVjdFwiICYmICEoMCwgdXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKShpdCwgc2NoZW1hKSkge1xuICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi52YXIoXCJ2YWxpZFwiLCAoMCwgY29kZWdlbl8xLl8pIGAke2xlbn0gPD0gJHtpdGVtcy5sZW5ndGh9YCk7IC8vIFRPRE8gdmFyXG4gICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLm5vdCkodmFsaWQpLCAoKSA9PiB2YWxpZGF0ZUl0ZW1zKHZhbGlkKSk7XG4gICAgICAgIGN4dC5vayh2YWxpZCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlSXRlbXModmFsaWQpIHtcbiAgICAgICAgZ2VuLmZvclJhbmdlKFwiaVwiLCBpdGVtcy5sZW5ndGgsIGxlbiwgKGkpID0+IHtcbiAgICAgICAgICAgIGN4dC5zdWJzY2hlbWEoeyBrZXl3b3JkLCBkYXRhUHJvcDogaSwgZGF0YVByb3BUeXBlOiB1dGlsXzEuVHlwZS5OdW0gfSwgdmFsaWQpO1xuICAgICAgICAgICAgaWYgKCFpdC5hbGxFcnJvcnMpXG4gICAgICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEubm90KSh2YWxpZCksICgpID0+IGdlbi5icmVhaygpKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZUFkZGl0aW9uYWxJdGVtcyA9IHZhbGlkYXRlQWRkaXRpb25hbEl0ZW1zO1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRkaXRpb25hbEl0ZW1zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy52YWxpZGF0ZVR1cGxlID0gdm9pZCAwO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi4vY29kZVwiKTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcIml0ZW1zXCIsXG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIHNjaGVtYVR5cGU6IFtcIm9iamVjdFwiLCBcImFycmF5XCIsIFwiYm9vbGVhblwiXSxcbiAgICBiZWZvcmU6IFwidW5pcXVlSXRlbXNcIixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IHNjaGVtYSwgaXQgfSA9IGN4dDtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hKSlcbiAgICAgICAgICAgIHJldHVybiB2YWxpZGF0ZVR1cGxlKGN4dCwgXCJhZGRpdGlvbmFsSXRlbXNcIiwgc2NoZW1hKTtcbiAgICAgICAgaXQuaXRlbXMgPSB0cnVlO1xuICAgICAgICBpZiAoKDAsIHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYSkoaXQsIHNjaGVtYSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGN4dC5vaygoMCwgY29kZV8xLnZhbGlkYXRlQXJyYXkpKGN4dCkpO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gdmFsaWRhdGVUdXBsZShjeHQsIGV4dHJhSXRlbXMsIHNjaEFyciA9IGN4dC5zY2hlbWEpIHtcbiAgICBjb25zdCB7IGdlbiwgcGFyZW50U2NoZW1hLCBkYXRhLCBrZXl3b3JkLCBpdCB9ID0gY3h0O1xuICAgIGNoZWNrU3RyaWN0VHVwbGUocGFyZW50U2NoZW1hKTtcbiAgICBpZiAoaXQub3B0cy51bmV2YWx1YXRlZCAmJiBzY2hBcnIubGVuZ3RoICYmIGl0Lml0ZW1zICE9PSB0cnVlKSB7XG4gICAgICAgIGl0Lml0ZW1zID0gdXRpbF8xLm1lcmdlRXZhbHVhdGVkLml0ZW1zKGdlbiwgc2NoQXJyLmxlbmd0aCwgaXQuaXRlbXMpO1xuICAgIH1cbiAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIik7XG4gICAgY29uc3QgbGVuID0gZ2VuLmNvbnN0KFwibGVuXCIsICgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0ubGVuZ3RoYCk7XG4gICAgc2NoQXJyLmZvckVhY2goKHNjaCwgaSkgPT4ge1xuICAgICAgICBpZiAoKDAsIHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYSkoaXQsIHNjaCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke2xlbn0gPiAke2l9YCwgKCkgPT4gY3h0LnN1YnNjaGVtYSh7XG4gICAgICAgICAgICBrZXl3b3JkLFxuICAgICAgICAgICAgc2NoZW1hUHJvcDogaSxcbiAgICAgICAgICAgIGRhdGFQcm9wOiBpLFxuICAgICAgICB9LCB2YWxpZCkpO1xuICAgICAgICBjeHQub2sodmFsaWQpO1xuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGNoZWNrU3RyaWN0VHVwbGUoc2NoKSB7XG4gICAgICAgIGNvbnN0IHsgb3B0cywgZXJyU2NoZW1hUGF0aCB9ID0gaXQ7XG4gICAgICAgIGNvbnN0IGwgPSBzY2hBcnIubGVuZ3RoO1xuICAgICAgICBjb25zdCBmdWxsVHVwbGUgPSBsID09PSBzY2gubWluSXRlbXMgJiYgKGwgPT09IHNjaC5tYXhJdGVtcyB8fCBzY2hbZXh0cmFJdGVtc10gPT09IGZhbHNlKTtcbiAgICAgICAgaWYgKG9wdHMuc3RyaWN0VHVwbGVzICYmICFmdWxsVHVwbGUpIHtcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9IGBcIiR7a2V5d29yZH1cIiBpcyAke2x9LXR1cGxlLCBidXQgbWluSXRlbXMgb3IgbWF4SXRlbXMvJHtleHRyYUl0ZW1zfSBhcmUgbm90IHNwZWNpZmllZCBvciBkaWZmZXJlbnQgYXQgcGF0aCBcIiR7ZXJyU2NoZW1hUGF0aH1cImA7XG4gICAgICAgICAgICAoMCwgdXRpbF8xLmNoZWNrU3RyaWN0TW9kZSkoaXQsIG1zZywgb3B0cy5zdHJpY3RUdXBsZXMpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZVR1cGxlID0gdmFsaWRhdGVUdXBsZTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWl0ZW1zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgaXRlbXNfMSA9IHJlcXVpcmUoXCIuL2l0ZW1zXCIpO1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwicHJlZml4SXRlbXNcIixcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgc2NoZW1hVHlwZTogW1wiYXJyYXlcIl0sXG4gICAgYmVmb3JlOiBcInVuaXF1ZUl0ZW1zXCIsXG4gICAgY29kZTogKGN4dCkgPT4gKDAsIGl0ZW1zXzEudmFsaWRhdGVUdXBsZSkoY3h0LCBcIml0ZW1zXCIpLFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByZWZpeEl0ZW1zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi4vY29kZVwiKTtcbmNvbnN0IGFkZGl0aW9uYWxJdGVtc18xID0gcmVxdWlyZShcIi4vYWRkaXRpb25hbEl0ZW1zXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsgcGFyYW1zOiB7IGxlbiB9IH0pID0+ICgwLCBjb2RlZ2VuXzEuc3RyKSBgbXVzdCBOT1QgaGF2ZSBtb3JlIHRoYW4gJHtsZW59IGl0ZW1zYCxcbiAgICBwYXJhbXM6ICh7IHBhcmFtczogeyBsZW4gfSB9KSA9PiAoMCwgY29kZWdlbl8xLl8pIGB7bGltaXQ6ICR7bGVufX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcIml0ZW1zXCIsXG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIHNjaGVtYVR5cGU6IFtcIm9iamVjdFwiLCBcImJvb2xlYW5cIl0sXG4gICAgYmVmb3JlOiBcInVuaXF1ZUl0ZW1zXCIsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBzY2hlbWEsIHBhcmVudFNjaGVtYSwgaXQgfSA9IGN4dDtcbiAgICAgICAgY29uc3QgeyBwcmVmaXhJdGVtcyB9ID0gcGFyZW50U2NoZW1hO1xuICAgICAgICBpdC5pdGVtcyA9IHRydWU7XG4gICAgICAgIGlmICgoMCwgdXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKShpdCwgc2NoZW1hKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHByZWZpeEl0ZW1zKVxuICAgICAgICAgICAgKDAsIGFkZGl0aW9uYWxJdGVtc18xLnZhbGlkYXRlQWRkaXRpb25hbEl0ZW1zKShjeHQsIHByZWZpeEl0ZW1zKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgY3h0Lm9rKCgwLCBjb2RlXzEudmFsaWRhdGVBcnJheSkoY3h0KSk7XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pdGVtczIwMjAuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IHBhcmFtczogeyBtaW4sIG1heCB9IH0pID0+IG1heCA9PT0gdW5kZWZpbmVkXG4gICAgICAgID8gKDAsIGNvZGVnZW5fMS5zdHIpIGBtdXN0IGNvbnRhaW4gYXQgbGVhc3QgJHttaW59IHZhbGlkIGl0ZW0ocylgXG4gICAgICAgIDogKDAsIGNvZGVnZW5fMS5zdHIpIGBtdXN0IGNvbnRhaW4gYXQgbGVhc3QgJHttaW59IGFuZCBubyBtb3JlIHRoYW4gJHttYXh9IHZhbGlkIGl0ZW0ocylgLFxuICAgIHBhcmFtczogKHsgcGFyYW1zOiB7IG1pbiwgbWF4IH0gfSkgPT4gbWF4ID09PSB1bmRlZmluZWQgPyAoMCwgY29kZWdlbl8xLl8pIGB7bWluQ29udGFpbnM6ICR7bWlufX1gIDogKDAsIGNvZGVnZW5fMS5fKSBge21pbkNvbnRhaW5zOiAke21pbn0sIG1heENvbnRhaW5zOiAke21heH19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJjb250YWluc1wiLFxuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICBzY2hlbWFUeXBlOiBbXCJvYmplY3RcIiwgXCJib29sZWFuXCJdLFxuICAgIGJlZm9yZTogXCJ1bmlxdWVJdGVtc1wiLFxuICAgIHRyYWNrRXJyb3JzOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgZGF0YSwgaXQgfSA9IGN4dDtcbiAgICAgICAgbGV0IG1pbjtcbiAgICAgICAgbGV0IG1heDtcbiAgICAgICAgY29uc3QgeyBtaW5Db250YWlucywgbWF4Q29udGFpbnMgfSA9IHBhcmVudFNjaGVtYTtcbiAgICAgICAgaWYgKGl0Lm9wdHMubmV4dCkge1xuICAgICAgICAgICAgbWluID0gbWluQ29udGFpbnMgPT09IHVuZGVmaW5lZCA/IDEgOiBtaW5Db250YWlucztcbiAgICAgICAgICAgIG1heCA9IG1heENvbnRhaW5zO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWluID0gMTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsZW4gPSBnZW4uY29uc3QoXCJsZW5cIiwgKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfS5sZW5ndGhgKTtcbiAgICAgICAgY3h0LnNldFBhcmFtcyh7IG1pbiwgbWF4IH0pO1xuICAgICAgICBpZiAobWF4ID09PSB1bmRlZmluZWQgJiYgbWluID09PSAwKSB7XG4gICAgICAgICAgICAoMCwgdXRpbF8xLmNoZWNrU3RyaWN0TW9kZSkoaXQsIGBcIm1pbkNvbnRhaW5zXCIgPT0gMCB3aXRob3V0IFwibWF4Q29udGFpbnNcIjogXCJjb250YWluc1wiIGtleXdvcmQgaWdub3JlZGApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXggIT09IHVuZGVmaW5lZCAmJiBtaW4gPiBtYXgpIHtcbiAgICAgICAgICAgICgwLCB1dGlsXzEuY2hlY2tTdHJpY3RNb2RlKShpdCwgYFwibWluQ29udGFpbnNcIiA+IFwibWF4Q29udGFpbnNcIiBpcyBhbHdheXMgaW52YWxpZGApO1xuICAgICAgICAgICAgY3h0LmZhaWwoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKDAsIHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYSkoaXQsIHNjaGVtYSkpIHtcbiAgICAgICAgICAgIGxldCBjb25kID0gKDAsIGNvZGVnZW5fMS5fKSBgJHtsZW59ID49ICR7bWlufWA7XG4gICAgICAgICAgICBpZiAobWF4ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgY29uZCA9ICgwLCBjb2RlZ2VuXzEuXykgYCR7Y29uZH0gJiYgJHtsZW59IDw9ICR7bWF4fWA7XG4gICAgICAgICAgICBjeHQucGFzcyhjb25kKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpdC5pdGVtcyA9IHRydWU7XG4gICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKTtcbiAgICAgICAgaWYgKG1heCA9PT0gdW5kZWZpbmVkICYmIG1pbiA9PT0gMSkge1xuICAgICAgICAgICAgdmFsaWRhdGVJdGVtcyh2YWxpZCwgKCkgPT4gZ2VuLmlmKHZhbGlkLCAoKSA9PiBnZW4uYnJlYWsoKSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1pbiA9PT0gMCkge1xuICAgICAgICAgICAgZ2VuLmxldCh2YWxpZCwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAobWF4ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0ubGVuZ3RoID4gMGAsIHZhbGlkYXRlSXRlbXNXaXRoQ291bnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ2VuLmxldCh2YWxpZCwgZmFsc2UpO1xuICAgICAgICAgICAgdmFsaWRhdGVJdGVtc1dpdGhDb3VudCgpO1xuICAgICAgICB9XG4gICAgICAgIGN4dC5yZXN1bHQodmFsaWQsICgpID0+IGN4dC5yZXNldCgpKTtcbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGVJdGVtc1dpdGhDb3VudCgpIHtcbiAgICAgICAgICAgIGNvbnN0IHNjaFZhbGlkID0gZ2VuLm5hbWUoXCJfdmFsaWRcIik7XG4gICAgICAgICAgICBjb25zdCBjb3VudCA9IGdlbi5sZXQoXCJjb3VudFwiLCAwKTtcbiAgICAgICAgICAgIHZhbGlkYXRlSXRlbXMoc2NoVmFsaWQsICgpID0+IGdlbi5pZihzY2hWYWxpZCwgKCkgPT4gY2hlY2tMaW1pdHMoY291bnQpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGVJdGVtcyhfdmFsaWQsIGJsb2NrKSB7XG4gICAgICAgICAgICBnZW4uZm9yUmFuZ2UoXCJpXCIsIDAsIGxlbiwgKGkpID0+IHtcbiAgICAgICAgICAgICAgICBjeHQuc3Vic2NoZW1hKHtcbiAgICAgICAgICAgICAgICAgICAga2V5d29yZDogXCJjb250YWluc1wiLFxuICAgICAgICAgICAgICAgICAgICBkYXRhUHJvcDogaSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YVByb3BUeXBlOiB1dGlsXzEuVHlwZS5OdW0sXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvc2l0ZVJ1bGU6IHRydWUsXG4gICAgICAgICAgICAgICAgfSwgX3ZhbGlkKTtcbiAgICAgICAgICAgICAgICBibG9jaygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2hlY2tMaW1pdHMoY291bnQpIHtcbiAgICAgICAgICAgIGdlbi5jb2RlKCgwLCBjb2RlZ2VuXzEuXykgYCR7Y291bnR9KytgKTtcbiAgICAgICAgICAgIGlmIChtYXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke2NvdW50fSA+PSAke21pbn1gLCAoKSA9PiBnZW4uYXNzaWduKHZhbGlkLCB0cnVlKS5icmVhaygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke2NvdW50fSA+ICR7bWF4fWAsICgpID0+IGdlbi5hc3NpZ24odmFsaWQsIGZhbHNlKS5icmVhaygpKTtcbiAgICAgICAgICAgICAgICBpZiAobWluID09PSAxKVxuICAgICAgICAgICAgICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke2NvdW50fSA+PSAke21pbn1gLCAoKSA9PiBnZW4uYXNzaWduKHZhbGlkLCB0cnVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnRhaW5zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy52YWxpZGF0ZVNjaGVtYURlcHMgPSBleHBvcnRzLnZhbGlkYXRlUHJvcGVydHlEZXBzID0gZXhwb3J0cy5lcnJvciA9IHZvaWQgMDtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgY29kZV8xID0gcmVxdWlyZShcIi4uL2NvZGVcIik7XG5leHBvcnRzLmVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IHBhcmFtczogeyBwcm9wZXJ0eSwgZGVwc0NvdW50LCBkZXBzIH0gfSkgPT4ge1xuICAgICAgICBjb25zdCBwcm9wZXJ0eV9pZXMgPSBkZXBzQ291bnQgPT09IDEgPyBcInByb3BlcnR5XCIgOiBcInByb3BlcnRpZXNcIjtcbiAgICAgICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEuc3RyKSBgbXVzdCBoYXZlICR7cHJvcGVydHlfaWVzfSAke2RlcHN9IHdoZW4gcHJvcGVydHkgJHtwcm9wZXJ0eX0gaXMgcHJlc2VudGA7XG4gICAgfSxcbiAgICBwYXJhbXM6ICh7IHBhcmFtczogeyBwcm9wZXJ0eSwgZGVwc0NvdW50LCBkZXBzLCBtaXNzaW5nUHJvcGVydHkgfSB9KSA9PiAoMCwgY29kZWdlbl8xLl8pIGB7cHJvcGVydHk6ICR7cHJvcGVydHl9LFxuICAgIG1pc3NpbmdQcm9wZXJ0eTogJHttaXNzaW5nUHJvcGVydHl9LFxuICAgIGRlcHNDb3VudDogJHtkZXBzQ291bnR9LFxuICAgIGRlcHM6ICR7ZGVwc319YCwgLy8gVE9ETyBjaGFuZ2UgdG8gcmVmZXJlbmNlXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiZGVwZW5kZW5jaWVzXCIsXG4gICAgdHlwZTogXCJvYmplY3RcIixcbiAgICBzY2hlbWFUeXBlOiBcIm9iamVjdFwiLFxuICAgIGVycm9yOiBleHBvcnRzLmVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IFtwcm9wRGVwcywgc2NoRGVwc10gPSBzcGxpdERlcGVuZGVuY2llcyhjeHQpO1xuICAgICAgICB2YWxpZGF0ZVByb3BlcnR5RGVwcyhjeHQsIHByb3BEZXBzKTtcbiAgICAgICAgdmFsaWRhdGVTY2hlbWFEZXBzKGN4dCwgc2NoRGVwcyk7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBzcGxpdERlcGVuZGVuY2llcyh7IHNjaGVtYSB9KSB7XG4gICAgY29uc3QgcHJvcGVydHlEZXBzID0ge307XG4gICAgY29uc3Qgc2NoZW1hRGVwcyA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYSkge1xuICAgICAgICBpZiAoa2V5ID09PSBcIl9fcHJvdG9fX1wiKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnN0IGRlcHMgPSBBcnJheS5pc0FycmF5KHNjaGVtYVtrZXldKSA/IHByb3BlcnR5RGVwcyA6IHNjaGVtYURlcHM7XG4gICAgICAgIGRlcHNba2V5XSA9IHNjaGVtYVtrZXldO1xuICAgIH1cbiAgICByZXR1cm4gW3Byb3BlcnR5RGVwcywgc2NoZW1hRGVwc107XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnR5RGVwcyhjeHQsIHByb3BlcnR5RGVwcyA9IGN4dC5zY2hlbWEpIHtcbiAgICBjb25zdCB7IGdlbiwgZGF0YSwgaXQgfSA9IGN4dDtcbiAgICBpZiAoT2JqZWN0LmtleXMocHJvcGVydHlEZXBzKS5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCBtaXNzaW5nID0gZ2VuLmxldChcIm1pc3NpbmdcIik7XG4gICAgZm9yIChjb25zdCBwcm9wIGluIHByb3BlcnR5RGVwcykge1xuICAgICAgICBjb25zdCBkZXBzID0gcHJvcGVydHlEZXBzW3Byb3BdO1xuICAgICAgICBpZiAoZGVwcy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY29uc3QgaGFzUHJvcGVydHkgPSAoMCwgY29kZV8xLnByb3BlcnR5SW5EYXRhKShnZW4sIGRhdGEsIHByb3AsIGl0Lm9wdHMub3duUHJvcGVydGllcyk7XG4gICAgICAgIGN4dC5zZXRQYXJhbXMoe1xuICAgICAgICAgICAgcHJvcGVydHk6IHByb3AsXG4gICAgICAgICAgICBkZXBzQ291bnQ6IGRlcHMubGVuZ3RoLFxuICAgICAgICAgICAgZGVwczogZGVwcy5qb2luKFwiLCBcIiksXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaXQuYWxsRXJyb3JzKSB7XG4gICAgICAgICAgICBnZW4uaWYoaGFzUHJvcGVydHksICgpID0+IHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGRlcFByb3Agb2YgZGVwcykge1xuICAgICAgICAgICAgICAgICAgICAoMCwgY29kZV8xLmNoZWNrUmVwb3J0TWlzc2luZ1Byb3ApKGN4dCwgZGVwUHJvcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtoYXNQcm9wZXJ0eX0gJiYgKCR7KDAsIGNvZGVfMS5jaGVja01pc3NpbmdQcm9wKShjeHQsIGRlcHMsIG1pc3NpbmcpfSlgKTtcbiAgICAgICAgICAgICgwLCBjb2RlXzEucmVwb3J0TWlzc2luZ1Byb3ApKGN4dCwgbWlzc2luZyk7XG4gICAgICAgICAgICBnZW4uZWxzZSgpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZVByb3BlcnR5RGVwcyA9IHZhbGlkYXRlUHJvcGVydHlEZXBzO1xuZnVuY3Rpb24gdmFsaWRhdGVTY2hlbWFEZXBzKGN4dCwgc2NoZW1hRGVwcyA9IGN4dC5zY2hlbWEpIHtcbiAgICBjb25zdCB7IGdlbiwgZGF0YSwga2V5d29yZCwgaXQgfSA9IGN4dDtcbiAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIik7XG4gICAgZm9yIChjb25zdCBwcm9wIGluIHNjaGVtYURlcHMpIHtcbiAgICAgICAgaWYgKCgwLCB1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEpKGl0LCBzY2hlbWFEZXBzW3Byb3BdKSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBnZW4uaWYoKDAsIGNvZGVfMS5wcm9wZXJ0eUluRGF0YSkoZ2VuLCBkYXRhLCBwcm9wLCBpdC5vcHRzLm93blByb3BlcnRpZXMpLCAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzY2hDeHQgPSBjeHQuc3Vic2NoZW1hKHsga2V5d29yZCwgc2NoZW1hUHJvcDogcHJvcCB9LCB2YWxpZCk7XG4gICAgICAgICAgICBjeHQubWVyZ2VWYWxpZEV2YWx1YXRlZChzY2hDeHQsIHZhbGlkKTtcbiAgICAgICAgfSwgKCkgPT4gZ2VuLnZhcih2YWxpZCwgdHJ1ZSkgLy8gVE9ETyB2YXJcbiAgICAgICAgKTtcbiAgICAgICAgY3h0Lm9rKHZhbGlkKTtcbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlU2NoZW1hRGVwcyA9IHZhbGlkYXRlU2NoZW1hRGVwcztcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlcGVuZGVuY2llcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogXCJwcm9wZXJ0eSBuYW1lIG11c3QgYmUgdmFsaWRcIixcbiAgICBwYXJhbXM6ICh7IHBhcmFtcyB9KSA9PiAoMCwgY29kZWdlbl8xLl8pIGB7cHJvcGVydHlOYW1lOiAke3BhcmFtcy5wcm9wZXJ0eU5hbWV9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwicHJvcGVydHlOYW1lc1wiLFxuICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgc2NoZW1hVHlwZTogW1wib2JqZWN0XCIsIFwiYm9vbGVhblwiXSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgc2NoZW1hLCBkYXRhLCBpdCB9ID0gY3h0O1xuICAgICAgICBpZiAoKDAsIHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYSkoaXQsIHNjaGVtYSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKTtcbiAgICAgICAgZ2VuLmZvckluKFwia2V5XCIsIGRhdGEsIChrZXkpID0+IHtcbiAgICAgICAgICAgIGN4dC5zZXRQYXJhbXMoeyBwcm9wZXJ0eU5hbWU6IGtleSB9KTtcbiAgICAgICAgICAgIGN4dC5zdWJzY2hlbWEoe1xuICAgICAgICAgICAgICAgIGtleXdvcmQ6IFwicHJvcGVydHlOYW1lc1wiLFxuICAgICAgICAgICAgICAgIGRhdGE6IGtleSxcbiAgICAgICAgICAgICAgICBkYXRhVHlwZXM6IFtcInN0cmluZ1wiXSxcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eU5hbWU6IGtleSxcbiAgICAgICAgICAgICAgICBjb21wb3NpdGVSdWxlOiB0cnVlLFxuICAgICAgICAgICAgfSwgdmFsaWQpO1xuICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEubm90KSh2YWxpZCksICgpID0+IHtcbiAgICAgICAgICAgICAgICBjeHQuZXJyb3IodHJ1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFpdC5hbGxFcnJvcnMpXG4gICAgICAgICAgICAgICAgICAgIGdlbi5icmVhaygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjeHQub2sodmFsaWQpO1xuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvcGVydHlOYW1lcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuLi9jb2RlXCIpO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IG5hbWVzXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9uYW1lc1wiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiBcIm11c3QgTk9UIGhhdmUgYWRkaXRpb25hbCBwcm9wZXJ0aWVzXCIsXG4gICAgcGFyYW1zOiAoeyBwYXJhbXMgfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge2FkZGl0aW9uYWxQcm9wZXJ0eTogJHtwYXJhbXMuYWRkaXRpb25hbFByb3BlcnR5fX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCIsXG4gICAgdHlwZTogW1wib2JqZWN0XCJdLFxuICAgIHNjaGVtYVR5cGU6IFtcImJvb2xlYW5cIiwgXCJvYmplY3RcIl0sXG4gICAgYWxsb3dVbmRlZmluZWQ6IHRydWUsXG4gICAgdHJhY2tFcnJvcnM6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgcGFyZW50U2NoZW1hLCBkYXRhLCBlcnJzQ291bnQsIGl0IH0gPSBjeHQ7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIWVycnNDb3VudClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFqdiBpbXBsZW1lbnRhdGlvbiBlcnJvclwiKTtcbiAgICAgICAgY29uc3QgeyBhbGxFcnJvcnMsIG9wdHMgfSA9IGl0O1xuICAgICAgICBpdC5wcm9wcyA9IHRydWU7XG4gICAgICAgIGlmIChvcHRzLnJlbW92ZUFkZGl0aW9uYWwgIT09IFwiYWxsXCIgJiYgKDAsIHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYSkoaXQsIHNjaGVtYSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHByb3BzID0gKDAsIGNvZGVfMS5hbGxTY2hlbWFQcm9wZXJ0aWVzKShwYXJlbnRTY2hlbWEucHJvcGVydGllcyk7XG4gICAgICAgIGNvbnN0IHBhdFByb3BzID0gKDAsIGNvZGVfMS5hbGxTY2hlbWFQcm9wZXJ0aWVzKShwYXJlbnRTY2hlbWEucGF0dGVyblByb3BlcnRpZXMpO1xuICAgICAgICBjaGVja0FkZGl0aW9uYWxQcm9wZXJ0aWVzKCk7XG4gICAgICAgIGN4dC5vaygoMCwgY29kZWdlbl8xLl8pIGAke2VycnNDb3VudH0gPT09ICR7bmFtZXNfMS5kZWZhdWx0LmVycm9yc31gKTtcbiAgICAgICAgZnVuY3Rpb24gY2hlY2tBZGRpdGlvbmFsUHJvcGVydGllcygpIHtcbiAgICAgICAgICAgIGdlbi5mb3JJbihcImtleVwiLCBkYXRhLCAoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFwcm9wcy5sZW5ndGggJiYgIXBhdFByb3BzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgYWRkaXRpb25hbFByb3BlcnR5Q29kZShrZXkpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmlmKGlzQWRkaXRpb25hbChrZXkpLCAoKSA9PiBhZGRpdGlvbmFsUHJvcGVydHlDb2RlKGtleSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaXNBZGRpdGlvbmFsKGtleSkge1xuICAgICAgICAgICAgbGV0IGRlZmluZWRQcm9wO1xuICAgICAgICAgICAgaWYgKHByb3BzLmxlbmd0aCA+IDgpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPIG1heWJlIGFuIG9wdGlvbiBpbnN0ZWFkIG9mIGhhcmQtY29kZWQgOD9cbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wc1NjaGVtYSA9ICgwLCB1dGlsXzEuc2NoZW1hUmVmT3JWYWwpKGl0LCBwYXJlbnRTY2hlbWEucHJvcGVydGllcywgXCJwcm9wZXJ0aWVzXCIpO1xuICAgICAgICAgICAgICAgIGRlZmluZWRQcm9wID0gKDAsIGNvZGVfMS5pc093blByb3BlcnR5KShnZW4sIHByb3BzU2NoZW1hLCBrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocHJvcHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZGVmaW5lZFByb3AgPSAoMCwgY29kZWdlbl8xLm9yKSguLi5wcm9wcy5tYXAoKHApID0+ICgwLCBjb2RlZ2VuXzEuXykgYCR7a2V5fSA9PT0gJHtwfWApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlZmluZWRQcm9wID0gY29kZWdlbl8xLm5pbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXRQcm9wcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBkZWZpbmVkUHJvcCA9ICgwLCBjb2RlZ2VuXzEub3IpKGRlZmluZWRQcm9wLCAuLi5wYXRQcm9wcy5tYXAoKHApID0+ICgwLCBjb2RlZ2VuXzEuXykgYCR7KDAsIGNvZGVfMS51c2VQYXR0ZXJuKShjeHQsIHApfS50ZXN0KCR7a2V5fSlgKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKDAsIGNvZGVnZW5fMS5ub3QpKGRlZmluZWRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBkZWxldGVBZGRpdGlvbmFsKGtleSkge1xuICAgICAgICAgICAgZ2VuLmNvZGUoKDAsIGNvZGVnZW5fMS5fKSBgZGVsZXRlICR7ZGF0YX1bJHtrZXl9XWApO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGFkZGl0aW9uYWxQcm9wZXJ0eUNvZGUoa2V5KSB7XG4gICAgICAgICAgICBpZiAob3B0cy5yZW1vdmVBZGRpdGlvbmFsID09PSBcImFsbFwiIHx8IChvcHRzLnJlbW92ZUFkZGl0aW9uYWwgJiYgc2NoZW1hID09PSBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICBkZWxldGVBZGRpdGlvbmFsKGtleSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNjaGVtYSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBjeHQuc2V0UGFyYW1zKHsgYWRkaXRpb25hbFByb3BlcnR5OiBrZXkgfSk7XG4gICAgICAgICAgICAgICAgY3h0LmVycm9yKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFhbGxFcnJvcnMpXG4gICAgICAgICAgICAgICAgICAgIGdlbi5icmVhaygpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hID09IFwib2JqZWN0XCIgJiYgISgwLCB1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEpKGl0LCBzY2hlbWEpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgICAgICAgICAgICAgIGlmIChvcHRzLnJlbW92ZUFkZGl0aW9uYWwgPT09IFwiZmFpbGluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGFwcGx5QWRkaXRpb25hbFNjaGVtYShrZXksIHZhbGlkLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLm5vdCkodmFsaWQpLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjeHQucmVzZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZUFkZGl0aW9uYWwoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhcHBseUFkZGl0aW9uYWxTY2hlbWEoa2V5LCB2YWxpZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYWxsRXJyb3JzKVxuICAgICAgICAgICAgICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEubm90KSh2YWxpZCksICgpID0+IGdlbi5icmVhaygpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYXBwbHlBZGRpdGlvbmFsU2NoZW1hKGtleSwgdmFsaWQsIGVycm9ycykge1xuICAgICAgICAgICAgY29uc3Qgc3Vic2NoZW1hID0ge1xuICAgICAgICAgICAgICAgIGtleXdvcmQ6IFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIixcbiAgICAgICAgICAgICAgICBkYXRhUHJvcDoga2V5LFxuICAgICAgICAgICAgICAgIGRhdGFQcm9wVHlwZTogdXRpbF8xLlR5cGUuU3RyLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChlcnJvcnMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihzdWJzY2hlbWEsIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9zaXRlUnVsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlRXJyb3JzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgYWxsRXJyb3JzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN4dC5zdWJzY2hlbWEoc3Vic2NoZW1hLCB2YWxpZCk7XG4gICAgICAgIH1cbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkZGl0aW9uYWxQcm9wZXJ0aWVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgdmFsaWRhdGVfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3ZhbGlkYXRlXCIpO1xuY29uc3QgY29kZV8xID0gcmVxdWlyZShcIi4uL2NvZGVcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgYWRkaXRpb25hbFByb3BlcnRpZXNfMSA9IHJlcXVpcmUoXCIuL2FkZGl0aW9uYWxQcm9wZXJ0aWVzXCIpO1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwicHJvcGVydGllc1wiLFxuICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgc2NoZW1hVHlwZTogXCJvYmplY3RcIixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIGRhdGEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGlmIChpdC5vcHRzLnJlbW92ZUFkZGl0aW9uYWwgPT09IFwiYWxsXCIgJiYgcGFyZW50U2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzXzEuZGVmYXVsdC5jb2RlKG5ldyB2YWxpZGF0ZV8xLktleXdvcmRDeHQoaXQsIGFkZGl0aW9uYWxQcm9wZXJ0aWVzXzEuZGVmYXVsdCwgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWxsUHJvcHMgPSAoMCwgY29kZV8xLmFsbFNjaGVtYVByb3BlcnRpZXMpKHNjaGVtYSk7XG4gICAgICAgIGZvciAoY29uc3QgcHJvcCBvZiBhbGxQcm9wcykge1xuICAgICAgICAgICAgaXQuZGVmaW5lZFByb3BlcnRpZXMuYWRkKHByb3ApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpdC5vcHRzLnVuZXZhbHVhdGVkICYmIGFsbFByb3BzLmxlbmd0aCAmJiBpdC5wcm9wcyAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgaXQucHJvcHMgPSB1dGlsXzEubWVyZ2VFdmFsdWF0ZWQucHJvcHMoZ2VuLCAoMCwgdXRpbF8xLnRvSGFzaCkoYWxsUHJvcHMpLCBpdC5wcm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJvcGVydGllcyA9IGFsbFByb3BzLmZpbHRlcigocCkgPT4gISgwLCB1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEpKGl0LCBzY2hlbWFbcF0pKTtcbiAgICAgICAgaWYgKHByb3BlcnRpZXMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIik7XG4gICAgICAgIGZvciAoY29uc3QgcHJvcCBvZiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBpZiAoaGFzRGVmYXVsdChwcm9wKSkge1xuICAgICAgICAgICAgICAgIGFwcGx5UHJvcGVydHlTY2hlbWEocHJvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVfMS5wcm9wZXJ0eUluRGF0YSkoZ2VuLCBkYXRhLCBwcm9wLCBpdC5vcHRzLm93blByb3BlcnRpZXMpKTtcbiAgICAgICAgICAgICAgICBhcHBseVByb3BlcnR5U2NoZW1hKHByb3ApO1xuICAgICAgICAgICAgICAgIGlmICghaXQuYWxsRXJyb3JzKVxuICAgICAgICAgICAgICAgICAgICBnZW4uZWxzZSgpLnZhcih2YWxpZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgZ2VuLmVuZElmKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjeHQuaXQuZGVmaW5lZFByb3BlcnRpZXMuYWRkKHByb3ApO1xuICAgICAgICAgICAgY3h0Lm9rKHZhbGlkKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBoYXNEZWZhdWx0KHByb3ApIHtcbiAgICAgICAgICAgIHJldHVybiBpdC5vcHRzLnVzZURlZmF1bHRzICYmICFpdC5jb21wb3NpdGVSdWxlICYmIHNjaGVtYVtwcm9wXS5kZWZhdWx0ICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYXBwbHlQcm9wZXJ0eVNjaGVtYShwcm9wKSB7XG4gICAgICAgICAgICBjeHQuc3Vic2NoZW1hKHtcbiAgICAgICAgICAgICAgICBrZXl3b3JkOiBcInByb3BlcnRpZXNcIixcbiAgICAgICAgICAgICAgICBzY2hlbWFQcm9wOiBwcm9wLFxuICAgICAgICAgICAgICAgIGRhdGFQcm9wOiBwcm9wLFxuICAgICAgICAgICAgfSwgdmFsaWQpO1xuICAgICAgICB9XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm9wZXJ0aWVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZV8xID0gcmVxdWlyZShcIi4uL2NvZGVcIik7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IHV0aWxfMiA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJwYXR0ZXJuUHJvcGVydGllc1wiLFxuICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgc2NoZW1hVHlwZTogXCJvYmplY3RcIixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgc2NoZW1hLCBkYXRhLCBwYXJlbnRTY2hlbWEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGNvbnN0IHsgb3B0cyB9ID0gaXQ7XG4gICAgICAgIGNvbnN0IHBhdHRlcm5zID0gKDAsIGNvZGVfMS5hbGxTY2hlbWFQcm9wZXJ0aWVzKShzY2hlbWEpO1xuICAgICAgICBjb25zdCBhbHdheXNWYWxpZFBhdHRlcm5zID0gcGF0dGVybnMuZmlsdGVyKChwKSA9PiAoMCwgdXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKShpdCwgc2NoZW1hW3BdKSk7XG4gICAgICAgIGlmIChwYXR0ZXJucy5sZW5ndGggPT09IDAgfHxcbiAgICAgICAgICAgIChhbHdheXNWYWxpZFBhdHRlcm5zLmxlbmd0aCA9PT0gcGF0dGVybnMubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgKCFpdC5vcHRzLnVuZXZhbHVhdGVkIHx8IGl0LnByb3BzID09PSB0cnVlKSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaGVja1Byb3BlcnRpZXMgPSBvcHRzLnN0cmljdFNjaGVtYSAmJiAhb3B0cy5hbGxvd01hdGNoaW5nUHJvcGVydGllcyAmJiBwYXJlbnRTY2hlbWEucHJvcGVydGllcztcbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgICAgICBpZiAoaXQucHJvcHMgIT09IHRydWUgJiYgIShpdC5wcm9wcyBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lKSkge1xuICAgICAgICAgICAgaXQucHJvcHMgPSAoMCwgdXRpbF8yLmV2YWx1YXRlZFByb3BzVG9OYW1lKShnZW4sIGl0LnByb3BzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHByb3BzIH0gPSBpdDtcbiAgICAgICAgdmFsaWRhdGVQYXR0ZXJuUHJvcGVydGllcygpO1xuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZVBhdHRlcm5Qcm9wZXJ0aWVzKCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBwYXQgb2YgcGF0dGVybnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hlY2tQcm9wZXJ0aWVzKVxuICAgICAgICAgICAgICAgICAgICBjaGVja01hdGNoaW5nUHJvcGVydGllcyhwYXQpO1xuICAgICAgICAgICAgICAgIGlmIChpdC5hbGxFcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVQcm9wZXJ0aWVzKHBhdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBnZW4udmFyKHZhbGlkLCB0cnVlKTsgLy8gVE9ETyB2YXJcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVQcm9wZXJ0aWVzKHBhdCk7XG4gICAgICAgICAgICAgICAgICAgIGdlbi5pZih2YWxpZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNoZWNrTWF0Y2hpbmdQcm9wZXJ0aWVzKHBhdCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBwcm9wIGluIGNoZWNrUHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIGlmIChuZXcgUmVnRXhwKHBhdCkudGVzdChwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICAoMCwgdXRpbF8xLmNoZWNrU3RyaWN0TW9kZSkoaXQsIGBwcm9wZXJ0eSAke3Byb3B9IG1hdGNoZXMgcGF0dGVybiAke3BhdH0gKHVzZSBhbGxvd01hdGNoaW5nUHJvcGVydGllcylgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0aWVzKHBhdCkge1xuICAgICAgICAgICAgZ2VuLmZvckluKFwia2V5XCIsIGRhdGEsIChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHsoMCwgY29kZV8xLnVzZVBhdHRlcm4pKGN4dCwgcGF0KX0udGVzdCgke2tleX0pYCwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhbHdheXNWYWxpZCA9IGFsd2F5c1ZhbGlkUGF0dGVybnMuaW5jbHVkZXMocGF0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhbHdheXNWYWxpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3h0LnN1YnNjaGVtYSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5d29yZDogXCJwYXR0ZXJuUHJvcGVydGllc1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjaGVtYVByb3A6IHBhdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhUHJvcDoga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFQcm9wVHlwZTogdXRpbF8yLlR5cGUuU3RyLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgdmFsaWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdC5vcHRzLnVuZXZhbHVhdGVkICYmIHByb3BzICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW4uYXNzaWduKCgwLCBjb2RlZ2VuXzEuXykgYCR7cHJvcHN9WyR7a2V5fV1gLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghYWx3YXlzVmFsaWQgJiYgIWl0LmFsbEVycm9ycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FuIHNob3J0LWNpcmN1aXQgaWYgYHVuZXZhbHVhdGVkUHJvcGVydGllc2AgaXMgbm90IHN1cHBvcnRlZCAob3B0cy5uZXh0ID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9yIGlmIGFsbCBwcm9wZXJ0aWVzIHdlcmUgZXZhbHVhdGVkIChwcm9wcyA9PT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLm5vdCkodmFsaWQpLCAoKSA9PiBnZW4uYnJlYWsoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXR0ZXJuUHJvcGVydGllcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJub3RcIixcbiAgICBzY2hlbWFUeXBlOiBbXCJvYmplY3RcIiwgXCJib29sZWFuXCJdLFxuICAgIHRyYWNrRXJyb3JzOiB0cnVlLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGlmICgoMCwgdXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKShpdCwgc2NoZW1hKSkge1xuICAgICAgICAgICAgY3h0LmZhaWwoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIik7XG4gICAgICAgIGN4dC5zdWJzY2hlbWEoe1xuICAgICAgICAgICAga2V5d29yZDogXCJub3RcIixcbiAgICAgICAgICAgIGNvbXBvc2l0ZVJ1bGU6IHRydWUsXG4gICAgICAgICAgICBjcmVhdGVFcnJvcnM6IGZhbHNlLFxuICAgICAgICAgICAgYWxsRXJyb3JzOiBmYWxzZSxcbiAgICAgICAgfSwgdmFsaWQpO1xuICAgICAgICBjeHQuZmFpbFJlc3VsdCh2YWxpZCwgKCkgPT4gY3h0LnJlc2V0KCksICgpID0+IGN4dC5lcnJvcigpKTtcbiAgICB9LFxuICAgIGVycm9yOiB7IG1lc3NhZ2U6IFwibXVzdCBOT1QgYmUgdmFsaWRcIiB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5vdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuLi9jb2RlXCIpO1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiYW55T2ZcIixcbiAgICBzY2hlbWFUeXBlOiBcImFycmF5XCIsXG4gICAgdHJhY2tFcnJvcnM6IHRydWUsXG4gICAgY29kZTogY29kZV8xLnZhbGlkYXRlVW5pb24sXG4gICAgZXJyb3I6IHsgbWVzc2FnZTogXCJtdXN0IG1hdGNoIGEgc2NoZW1hIGluIGFueU9mXCIgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hbnlPZi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogXCJtdXN0IG1hdGNoIGV4YWN0bHkgb25lIHNjaGVtYSBpbiBvbmVPZlwiLFxuICAgIHBhcmFtczogKHsgcGFyYW1zIH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHtwYXNzaW5nU2NoZW1hczogJHtwYXJhbXMucGFzc2luZ319YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJvbmVPZlwiLFxuICAgIHNjaGVtYVR5cGU6IFwiYXJyYXlcIixcbiAgICB0cmFja0Vycm9yczogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2NoZW1hKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFqdiBpbXBsZW1lbnRhdGlvbiBlcnJvclwiKTtcbiAgICAgICAgaWYgKGl0Lm9wdHMuZGlzY3JpbWluYXRvciAmJiBwYXJlbnRTY2hlbWEuZGlzY3JpbWluYXRvcilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3Qgc2NoQXJyID0gc2NoZW1hO1xuICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5sZXQoXCJ2YWxpZFwiLCBmYWxzZSk7XG4gICAgICAgIGNvbnN0IHBhc3NpbmcgPSBnZW4ubGV0KFwicGFzc2luZ1wiLCBudWxsKTtcbiAgICAgICAgY29uc3Qgc2NoVmFsaWQgPSBnZW4ubmFtZShcIl92YWxpZFwiKTtcbiAgICAgICAgY3h0LnNldFBhcmFtcyh7IHBhc3NpbmcgfSk7XG4gICAgICAgIC8vIFRPRE8gcG9zc2libHkgZmFpbCBzdHJhaWdodCBhd2F5ICh3aXRoIHdhcm5pbmcgb3IgZXhjZXB0aW9uKSBpZiB0aGVyZSBhcmUgdHdvIGVtcHR5IGFsd2F5cyB2YWxpZCBzY2hlbWFzXG4gICAgICAgIGdlbi5ibG9jayh2YWxpZGF0ZU9uZU9mKTtcbiAgICAgICAgY3h0LnJlc3VsdCh2YWxpZCwgKCkgPT4gY3h0LnJlc2V0KCksICgpID0+IGN4dC5lcnJvcih0cnVlKSk7XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlT25lT2YoKSB7XG4gICAgICAgICAgICBzY2hBcnIuZm9yRWFjaCgoc2NoLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHNjaEN4dDtcbiAgICAgICAgICAgICAgICBpZiAoKDAsIHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYSkoaXQsIHNjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLnZhcihzY2hWYWxpZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzY2hDeHQgPSBjeHQuc3Vic2NoZW1hKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleXdvcmQ6IFwib25lT2ZcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjaGVtYVByb3A6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb3NpdGVSdWxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB9LCBzY2hWYWxpZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBnZW5cbiAgICAgICAgICAgICAgICAgICAgICAgIC5pZigoMCwgY29kZWdlbl8xLl8pIGAke3NjaFZhbGlkfSAmJiAke3ZhbGlkfWApXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXNzaWduKHZhbGlkLCBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hc3NpZ24ocGFzc2luZywgKDAsIGNvZGVnZW5fMS5fKSBgWyR7cGFzc2luZ30sICR7aX1dYClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5lbHNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGdlbi5pZihzY2hWYWxpZCwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmFzc2lnbihwYXNzaW5nLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjaEN4dClcbiAgICAgICAgICAgICAgICAgICAgICAgIGN4dC5tZXJnZUV2YWx1YXRlZChzY2hDeHQsIGNvZGVnZW5fMS5OYW1lKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vbmVPZi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJhbGxPZlwiLFxuICAgIHNjaGVtYVR5cGU6IFwiYXJyYXlcIixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgc2NoZW1hLCBpdCB9ID0gY3h0O1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHNjaGVtYSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhanYgaW1wbGVtZW50YXRpb24gZXJyb3JcIik7XG4gICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKTtcbiAgICAgICAgc2NoZW1hLmZvckVhY2goKHNjaCwgaSkgPT4ge1xuICAgICAgICAgICAgaWYgKCgwLCB1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEpKGl0LCBzY2gpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IHNjaEN4dCA9IGN4dC5zdWJzY2hlbWEoeyBrZXl3b3JkOiBcImFsbE9mXCIsIHNjaGVtYVByb3A6IGkgfSwgdmFsaWQpO1xuICAgICAgICAgICAgY3h0Lm9rKHZhbGlkKTtcbiAgICAgICAgICAgIGN4dC5tZXJnZUV2YWx1YXRlZChzY2hDeHQpO1xuICAgICAgICB9KTtcbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFsbE9mLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBwYXJhbXMgfSkgPT4gKDAsIGNvZGVnZW5fMS5zdHIpIGBtdXN0IG1hdGNoIFwiJHtwYXJhbXMuaWZDbGF1c2V9XCIgc2NoZW1hYCxcbiAgICBwYXJhbXM6ICh7IHBhcmFtcyB9KSA9PiAoMCwgY29kZWdlbl8xLl8pIGB7ZmFpbGluZ0tleXdvcmQ6ICR7cGFyYW1zLmlmQ2xhdXNlfX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcImlmXCIsXG4gICAgc2NoZW1hVHlwZTogW1wib2JqZWN0XCIsIFwiYm9vbGVhblwiXSxcbiAgICB0cmFja0Vycm9yczogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgcGFyZW50U2NoZW1hLCBpdCB9ID0gY3h0O1xuICAgICAgICBpZiAocGFyZW50U2NoZW1hLnRoZW4gPT09IHVuZGVmaW5lZCAmJiBwYXJlbnRTY2hlbWEuZWxzZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAoMCwgdXRpbF8xLmNoZWNrU3RyaWN0TW9kZSkoaXQsICdcImlmXCIgd2l0aG91dCBcInRoZW5cIiBhbmQgXCJlbHNlXCIgaXMgaWdub3JlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhhc1RoZW4gPSBoYXNTY2hlbWEoaXQsIFwidGhlblwiKTtcbiAgICAgICAgY29uc3QgaGFzRWxzZSA9IGhhc1NjaGVtYShpdCwgXCJlbHNlXCIpO1xuICAgICAgICBpZiAoIWhhc1RoZW4gJiYgIWhhc0Vsc2UpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIsIHRydWUpO1xuICAgICAgICBjb25zdCBzY2hWYWxpZCA9IGdlbi5uYW1lKFwiX3ZhbGlkXCIpO1xuICAgICAgICB2YWxpZGF0ZUlmKCk7XG4gICAgICAgIGN4dC5yZXNldCgpO1xuICAgICAgICBpZiAoaGFzVGhlbiAmJiBoYXNFbHNlKSB7XG4gICAgICAgICAgICBjb25zdCBpZkNsYXVzZSA9IGdlbi5sZXQoXCJpZkNsYXVzZVwiKTtcbiAgICAgICAgICAgIGN4dC5zZXRQYXJhbXMoeyBpZkNsYXVzZSB9KTtcbiAgICAgICAgICAgIGdlbi5pZihzY2hWYWxpZCwgdmFsaWRhdGVDbGF1c2UoXCJ0aGVuXCIsIGlmQ2xhdXNlKSwgdmFsaWRhdGVDbGF1c2UoXCJlbHNlXCIsIGlmQ2xhdXNlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaGFzVGhlbikge1xuICAgICAgICAgICAgZ2VuLmlmKHNjaFZhbGlkLCB2YWxpZGF0ZUNsYXVzZShcInRoZW5cIikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEubm90KShzY2hWYWxpZCksIHZhbGlkYXRlQ2xhdXNlKFwiZWxzZVwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgY3h0LnBhc3ModmFsaWQsICgpID0+IGN4dC5lcnJvcih0cnVlKSk7XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlSWYoKSB7XG4gICAgICAgICAgICBjb25zdCBzY2hDeHQgPSBjeHQuc3Vic2NoZW1hKHtcbiAgICAgICAgICAgICAgICBrZXl3b3JkOiBcImlmXCIsXG4gICAgICAgICAgICAgICAgY29tcG9zaXRlUnVsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjcmVhdGVFcnJvcnM6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGFsbEVycm9yczogZmFsc2UsXG4gICAgICAgICAgICB9LCBzY2hWYWxpZCk7XG4gICAgICAgICAgICBjeHQubWVyZ2VFdmFsdWF0ZWQoc2NoQ3h0KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZUNsYXVzZShrZXl3b3JkLCBpZkNsYXVzZSkge1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzY2hDeHQgPSBjeHQuc3Vic2NoZW1hKHsga2V5d29yZCB9LCBzY2hWYWxpZCk7XG4gICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgc2NoVmFsaWQpO1xuICAgICAgICAgICAgICAgIGN4dC5tZXJnZVZhbGlkRXZhbHVhdGVkKHNjaEN4dCwgdmFsaWQpO1xuICAgICAgICAgICAgICAgIGlmIChpZkNsYXVzZSlcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmFzc2lnbihpZkNsYXVzZSwgKDAsIGNvZGVnZW5fMS5fKSBgJHtrZXl3b3JkfWApO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgY3h0LnNldFBhcmFtcyh7IGlmQ2xhdXNlOiBrZXl3b3JkIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuZnVuY3Rpb24gaGFzU2NoZW1hKGl0LCBrZXl3b3JkKSB7XG4gICAgY29uc3Qgc2NoZW1hID0gaXQuc2NoZW1hW2tleXdvcmRdO1xuICAgIHJldHVybiBzY2hlbWEgIT09IHVuZGVmaW5lZCAmJiAhKDAsIHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYSkoaXQsIHNjaGVtYSk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pZi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogW1widGhlblwiLCBcImVsc2VcIl0sXG4gICAgc2NoZW1hVHlwZTogW1wib2JqZWN0XCIsIFwiYm9vbGVhblwiXSxcbiAgICBjb2RlKHsga2V5d29yZCwgcGFyZW50U2NoZW1hLCBpdCB9KSB7XG4gICAgICAgIGlmIChwYXJlbnRTY2hlbWEuaWYgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICgwLCB1dGlsXzEuY2hlY2tTdHJpY3RNb2RlKShpdCwgYFwiJHtrZXl3b3JkfVwiIHdpdGhvdXQgXCJpZlwiIGlzIGlnbm9yZWRgKTtcbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRoZW5FbHNlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgYWRkaXRpb25hbEl0ZW1zXzEgPSByZXF1aXJlKFwiLi9hZGRpdGlvbmFsSXRlbXNcIik7XG5jb25zdCBwcmVmaXhJdGVtc18xID0gcmVxdWlyZShcIi4vcHJlZml4SXRlbXNcIik7XG5jb25zdCBpdGVtc18xID0gcmVxdWlyZShcIi4vaXRlbXNcIik7XG5jb25zdCBpdGVtczIwMjBfMSA9IHJlcXVpcmUoXCIuL2l0ZW1zMjAyMFwiKTtcbmNvbnN0IGNvbnRhaW5zXzEgPSByZXF1aXJlKFwiLi9jb250YWluc1wiKTtcbmNvbnN0IGRlcGVuZGVuY2llc18xID0gcmVxdWlyZShcIi4vZGVwZW5kZW5jaWVzXCIpO1xuY29uc3QgcHJvcGVydHlOYW1lc18xID0gcmVxdWlyZShcIi4vcHJvcGVydHlOYW1lc1wiKTtcbmNvbnN0IGFkZGl0aW9uYWxQcm9wZXJ0aWVzXzEgPSByZXF1aXJlKFwiLi9hZGRpdGlvbmFsUHJvcGVydGllc1wiKTtcbmNvbnN0IHByb3BlcnRpZXNfMSA9IHJlcXVpcmUoXCIuL3Byb3BlcnRpZXNcIik7XG5jb25zdCBwYXR0ZXJuUHJvcGVydGllc18xID0gcmVxdWlyZShcIi4vcGF0dGVyblByb3BlcnRpZXNcIik7XG5jb25zdCBub3RfMSA9IHJlcXVpcmUoXCIuL25vdFwiKTtcbmNvbnN0IGFueU9mXzEgPSByZXF1aXJlKFwiLi9hbnlPZlwiKTtcbmNvbnN0IG9uZU9mXzEgPSByZXF1aXJlKFwiLi9vbmVPZlwiKTtcbmNvbnN0IGFsbE9mXzEgPSByZXF1aXJlKFwiLi9hbGxPZlwiKTtcbmNvbnN0IGlmXzEgPSByZXF1aXJlKFwiLi9pZlwiKTtcbmNvbnN0IHRoZW5FbHNlXzEgPSByZXF1aXJlKFwiLi90aGVuRWxzZVwiKTtcbmZ1bmN0aW9uIGdldEFwcGxpY2F0b3IoZHJhZnQyMDIwID0gZmFsc2UpIHtcbiAgICBjb25zdCBhcHBsaWNhdG9yID0gW1xuICAgICAgICAvLyBhbnlcbiAgICAgICAgbm90XzEuZGVmYXVsdCxcbiAgICAgICAgYW55T2ZfMS5kZWZhdWx0LFxuICAgICAgICBvbmVPZl8xLmRlZmF1bHQsXG4gICAgICAgIGFsbE9mXzEuZGVmYXVsdCxcbiAgICAgICAgaWZfMS5kZWZhdWx0LFxuICAgICAgICB0aGVuRWxzZV8xLmRlZmF1bHQsXG4gICAgICAgIC8vIG9iamVjdFxuICAgICAgICBwcm9wZXJ0eU5hbWVzXzEuZGVmYXVsdCxcbiAgICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXNfMS5kZWZhdWx0LFxuICAgICAgICBkZXBlbmRlbmNpZXNfMS5kZWZhdWx0LFxuICAgICAgICBwcm9wZXJ0aWVzXzEuZGVmYXVsdCxcbiAgICAgICAgcGF0dGVyblByb3BlcnRpZXNfMS5kZWZhdWx0LFxuICAgIF07XG4gICAgLy8gYXJyYXlcbiAgICBpZiAoZHJhZnQyMDIwKVxuICAgICAgICBhcHBsaWNhdG9yLnB1c2gocHJlZml4SXRlbXNfMS5kZWZhdWx0LCBpdGVtczIwMjBfMS5kZWZhdWx0KTtcbiAgICBlbHNlXG4gICAgICAgIGFwcGxpY2F0b3IucHVzaChhZGRpdGlvbmFsSXRlbXNfMS5kZWZhdWx0LCBpdGVtc18xLmRlZmF1bHQpO1xuICAgIGFwcGxpY2F0b3IucHVzaChjb250YWluc18xLmRlZmF1bHQpO1xuICAgIHJldHVybiBhcHBsaWNhdG9yO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gZ2V0QXBwbGljYXRvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IHNjaGVtYUNvZGUgfSkgPT4gKDAsIGNvZGVnZW5fMS5zdHIpIGBtdXN0IG1hdGNoIGZvcm1hdCBcIiR7c2NoZW1hQ29kZX1cImAsXG4gICAgcGFyYW1zOiAoeyBzY2hlbWFDb2RlIH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHtmb3JtYXQ6ICR7c2NoZW1hQ29kZX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJmb3JtYXRcIixcbiAgICB0eXBlOiBbXCJudW1iZXJcIiwgXCJzdHJpbmdcIl0sXG4gICAgc2NoZW1hVHlwZTogXCJzdHJpbmdcIixcbiAgICAkZGF0YTogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCwgcnVsZVR5cGUpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIGRhdGEsICRkYXRhLCBzY2hlbWEsIHNjaGVtYUNvZGUsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGNvbnN0IHsgb3B0cywgZXJyU2NoZW1hUGF0aCwgc2NoZW1hRW52LCBzZWxmIH0gPSBpdDtcbiAgICAgICAgaWYgKCFvcHRzLnZhbGlkYXRlRm9ybWF0cylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCRkYXRhKVxuICAgICAgICAgICAgdmFsaWRhdGUkRGF0YUZvcm1hdCgpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB2YWxpZGF0ZUZvcm1hdCgpO1xuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZSREYXRhRm9ybWF0KCkge1xuICAgICAgICAgICAgY29uc3QgZm10cyA9IGdlbi5zY29wZVZhbHVlKFwiZm9ybWF0c1wiLCB7XG4gICAgICAgICAgICAgICAgcmVmOiBzZWxmLmZvcm1hdHMsXG4gICAgICAgICAgICAgICAgY29kZTogb3B0cy5jb2RlLmZvcm1hdHMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGZEZWYgPSBnZW4uY29uc3QoXCJmRGVmXCIsICgwLCBjb2RlZ2VuXzEuXykgYCR7Zm10c31bJHtzY2hlbWFDb2RlfV1gKTtcbiAgICAgICAgICAgIGNvbnN0IGZUeXBlID0gZ2VuLmxldChcImZUeXBlXCIpO1xuICAgICAgICAgICAgY29uc3QgZm9ybWF0ID0gZ2VuLmxldChcImZvcm1hdFwiKTtcbiAgICAgICAgICAgIC8vIFRPRE8gc2ltcGxpZnlcbiAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGB0eXBlb2YgJHtmRGVmfSA9PSBcIm9iamVjdFwiICYmICEoJHtmRGVmfSBpbnN0YW5jZW9mIFJlZ0V4cClgLCAoKSA9PiBnZW4uYXNzaWduKGZUeXBlLCAoMCwgY29kZWdlbl8xLl8pIGAke2ZEZWZ9LnR5cGUgfHwgXCJzdHJpbmdcImApLmFzc2lnbihmb3JtYXQsICgwLCBjb2RlZ2VuXzEuXykgYCR7ZkRlZn0udmFsaWRhdGVgKSwgKCkgPT4gZ2VuLmFzc2lnbihmVHlwZSwgKDAsIGNvZGVnZW5fMS5fKSBgXCJzdHJpbmdcImApLmFzc2lnbihmb3JtYXQsIGZEZWYpKTtcbiAgICAgICAgICAgIGN4dC5mYWlsJGRhdGEoKDAsIGNvZGVnZW5fMS5vcikodW5rbm93bkZtdCgpLCBpbnZhbGlkRm10KCkpKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIHVua25vd25GbXQoKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdHMuc3RyaWN0U2NoZW1hID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvZGVnZW5fMS5uaWw7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEuXykgYCR7c2NoZW1hQ29kZX0gJiYgISR7Zm9ybWF0fWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBpbnZhbGlkRm10KCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxGb3JtYXQgPSBzY2hlbWFFbnYuJGFzeW5jXG4gICAgICAgICAgICAgICAgICAgID8gKDAsIGNvZGVnZW5fMS5fKSBgKCR7ZkRlZn0uYXN5bmMgPyBhd2FpdCAke2Zvcm1hdH0oJHtkYXRhfSkgOiAke2Zvcm1hdH0oJHtkYXRhfSkpYFxuICAgICAgICAgICAgICAgICAgICA6ICgwLCBjb2RlZ2VuXzEuXykgYCR7Zm9ybWF0fSgke2RhdGF9KWA7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsaWREYXRhID0gKDAsIGNvZGVnZW5fMS5fKSBgKHR5cGVvZiAke2Zvcm1hdH0gPT0gXCJmdW5jdGlvblwiID8gJHtjYWxsRm9ybWF0fSA6ICR7Zm9ybWF0fS50ZXN0KCR7ZGF0YX0pKWA7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEuXykgYCR7Zm9ybWF0fSAmJiAke2Zvcm1hdH0gIT09IHRydWUgJiYgJHtmVHlwZX0gPT09ICR7cnVsZVR5cGV9ICYmICEke3ZhbGlkRGF0YX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlRm9ybWF0KCkge1xuICAgICAgICAgICAgY29uc3QgZm9ybWF0RGVmID0gc2VsZi5mb3JtYXRzW3NjaGVtYV07XG4gICAgICAgICAgICBpZiAoIWZvcm1hdERlZikge1xuICAgICAgICAgICAgICAgIHVua25vd25Gb3JtYXQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZm9ybWF0RGVmID09PSB0cnVlKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IFtmbXRUeXBlLCBmb3JtYXQsIGZtdFJlZl0gPSBnZXRGb3JtYXQoZm9ybWF0RGVmKTtcbiAgICAgICAgICAgIGlmIChmbXRUeXBlID09PSBydWxlVHlwZSlcbiAgICAgICAgICAgICAgICBjeHQucGFzcyh2YWxpZENvbmRpdGlvbigpKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIHVua25vd25Gb3JtYXQoKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdHMuc3RyaWN0U2NoZW1hID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmxvZ2dlci53YXJuKHVua25vd25Nc2coKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHVua25vd25Nc2coKSk7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gdW5rbm93bk1zZygpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGB1bmtub3duIGZvcm1hdCBcIiR7c2NoZW1hfVwiIGlnbm9yZWQgaW4gc2NoZW1hIGF0IHBhdGggXCIke2VyclNjaGVtYVBhdGh9XCJgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldEZvcm1hdChmbXREZWYpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2RlID0gZm10RGVmIGluc3RhbmNlb2YgUmVnRXhwXG4gICAgICAgICAgICAgICAgICAgID8gKDAsIGNvZGVnZW5fMS5yZWdleHBDb2RlKShmbXREZWYpXG4gICAgICAgICAgICAgICAgICAgIDogb3B0cy5jb2RlLmZvcm1hdHNcbiAgICAgICAgICAgICAgICAgICAgICAgID8gKDAsIGNvZGVnZW5fMS5fKSBgJHtvcHRzLmNvZGUuZm9ybWF0c30keygwLCBjb2RlZ2VuXzEuZ2V0UHJvcGVydHkpKHNjaGVtYSl9YFxuICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgY29uc3QgZm10ID0gZ2VuLnNjb3BlVmFsdWUoXCJmb3JtYXRzXCIsIHsga2V5OiBzY2hlbWEsIHJlZjogZm10RGVmLCBjb2RlIH0pO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm10RGVmID09IFwib2JqZWN0XCIgJiYgIShmbXREZWYgaW5zdGFuY2VvZiBSZWdFeHApKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbZm10RGVmLnR5cGUgfHwgXCJzdHJpbmdcIiwgZm10RGVmLnZhbGlkYXRlLCAoMCwgY29kZWdlbl8xLl8pIGAke2ZtdH0udmFsaWRhdGVgXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcInN0cmluZ1wiLCBmbXREZWYsIGZtdF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiB2YWxpZENvbmRpdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZvcm1hdERlZiA9PSBcIm9iamVjdFwiICYmICEoZm9ybWF0RGVmIGluc3RhbmNlb2YgUmVnRXhwKSAmJiBmb3JtYXREZWYuYXN5bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzY2hlbWFFbnYuJGFzeW5jKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXN5bmMgZm9ybWF0IGluIHN5bmMgc2NoZW1hXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGNvZGVnZW5fMS5fKSBgYXdhaXQgJHtmbXRSZWZ9KCR7ZGF0YX0pYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBmb3JtYXQgPT0gXCJmdW5jdGlvblwiID8gKDAsIGNvZGVnZW5fMS5fKSBgJHtmbXRSZWZ9KCR7ZGF0YX0pYCA6ICgwLCBjb2RlZ2VuXzEuXykgYCR7Zm10UmVmfS50ZXN0KCR7ZGF0YX0pYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9ybWF0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgZm9ybWF0XzEgPSByZXF1aXJlKFwiLi9mb3JtYXRcIik7XG5jb25zdCBmb3JtYXQgPSBbZm9ybWF0XzEuZGVmYXVsdF07XG5leHBvcnRzLmRlZmF1bHQgPSBmb3JtYXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY29udGVudFZvY2FidWxhcnkgPSBleHBvcnRzLm1ldGFkYXRhVm9jYWJ1bGFyeSA9IHZvaWQgMDtcbmV4cG9ydHMubWV0YWRhdGFWb2NhYnVsYXJ5ID0gW1xuICAgIFwidGl0bGVcIixcbiAgICBcImRlc2NyaXB0aW9uXCIsXG4gICAgXCJkZWZhdWx0XCIsXG4gICAgXCJkZXByZWNhdGVkXCIsXG4gICAgXCJyZWFkT25seVwiLFxuICAgIFwid3JpdGVPbmx5XCIsXG4gICAgXCJleGFtcGxlc1wiLFxuXTtcbmV4cG9ydHMuY29udGVudFZvY2FidWxhcnkgPSBbXG4gICAgXCJjb250ZW50TWVkaWFUeXBlXCIsXG4gICAgXCJjb250ZW50RW5jb2RpbmdcIixcbiAgICBcImNvbnRlbnRTY2hlbWFcIixcbl07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXRhZGF0YS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvcmVfMSA9IHJlcXVpcmUoXCIuL2NvcmVcIik7XG5jb25zdCB2YWxpZGF0aW9uXzEgPSByZXF1aXJlKFwiLi92YWxpZGF0aW9uXCIpO1xuY29uc3QgYXBwbGljYXRvcl8xID0gcmVxdWlyZShcIi4vYXBwbGljYXRvclwiKTtcbmNvbnN0IGZvcm1hdF8xID0gcmVxdWlyZShcIi4vZm9ybWF0XCIpO1xuY29uc3QgbWV0YWRhdGFfMSA9IHJlcXVpcmUoXCIuL21ldGFkYXRhXCIpO1xuY29uc3QgZHJhZnQ3Vm9jYWJ1bGFyaWVzID0gW1xuICAgIGNvcmVfMS5kZWZhdWx0LFxuICAgIHZhbGlkYXRpb25fMS5kZWZhdWx0LFxuICAgICgwLCBhcHBsaWNhdG9yXzEuZGVmYXVsdCkoKSxcbiAgICBmb3JtYXRfMS5kZWZhdWx0LFxuICAgIG1ldGFkYXRhXzEubWV0YWRhdGFWb2NhYnVsYXJ5LFxuICAgIG1ldGFkYXRhXzEuY29udGVudFZvY2FidWxhcnksXG5dO1xuZXhwb3J0cy5kZWZhdWx0ID0gZHJhZnQ3Vm9jYWJ1bGFyaWVzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZHJhZnQ3LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5EaXNjckVycm9yID0gdm9pZCAwO1xudmFyIERpc2NyRXJyb3I7XG4oZnVuY3Rpb24gKERpc2NyRXJyb3IpIHtcbiAgICBEaXNjckVycm9yW1wiVGFnXCJdID0gXCJ0YWdcIjtcbiAgICBEaXNjckVycm9yW1wiTWFwcGluZ1wiXSA9IFwibWFwcGluZ1wiO1xufSkoRGlzY3JFcnJvciB8fCAoZXhwb3J0cy5EaXNjckVycm9yID0gRGlzY3JFcnJvciA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIi4uL2Rpc2NyaW1pbmF0b3IvdHlwZXNcIik7XG5jb25zdCBjb21waWxlXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZVwiKTtcbmNvbnN0IHJlZl9lcnJvcl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvcmVmX2Vycm9yXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IHBhcmFtczogeyBkaXNjckVycm9yLCB0YWdOYW1lIH0gfSkgPT4gZGlzY3JFcnJvciA9PT0gdHlwZXNfMS5EaXNjckVycm9yLlRhZ1xuICAgICAgICA/IGB0YWcgXCIke3RhZ05hbWV9XCIgbXVzdCBiZSBzdHJpbmdgXG4gICAgICAgIDogYHZhbHVlIG9mIHRhZyBcIiR7dGFnTmFtZX1cIiBtdXN0IGJlIGluIG9uZU9mYCxcbiAgICBwYXJhbXM6ICh7IHBhcmFtczogeyBkaXNjckVycm9yLCB0YWcsIHRhZ05hbWUgfSB9KSA9PiAoMCwgY29kZWdlbl8xLl8pIGB7ZXJyb3I6ICR7ZGlzY3JFcnJvcn0sIHRhZzogJHt0YWdOYW1lfSwgdGFnVmFsdWU6ICR7dGFnfX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcImRpc2NyaW1pbmF0b3JcIixcbiAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgIHNjaGVtYVR5cGU6IFwib2JqZWN0XCIsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIGRhdGEsIHNjaGVtYSwgcGFyZW50U2NoZW1hLCBpdCB9ID0gY3h0O1xuICAgICAgICBjb25zdCB7IG9uZU9mIH0gPSBwYXJlbnRTY2hlbWE7XG4gICAgICAgIGlmICghaXQub3B0cy5kaXNjcmltaW5hdG9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkaXNjcmltaW5hdG9yOiByZXF1aXJlcyBkaXNjcmltaW5hdG9yIG9wdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YWdOYW1lID0gc2NoZW1hLnByb3BlcnR5TmFtZTtcbiAgICAgICAgaWYgKHR5cGVvZiB0YWdOYW1lICE9IFwic3RyaW5nXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkaXNjcmltaW5hdG9yOiByZXF1aXJlcyBwcm9wZXJ0eU5hbWVcIik7XG4gICAgICAgIGlmIChzY2hlbWEubWFwcGluZylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImRpc2NyaW1pbmF0b3I6IG1hcHBpbmcgaXMgbm90IHN1cHBvcnRlZFwiKTtcbiAgICAgICAgaWYgKCFvbmVPZilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImRpc2NyaW1pbmF0b3I6IHJlcXVpcmVzIG9uZU9mIGtleXdvcmRcIik7XG4gICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIsIGZhbHNlKTtcbiAgICAgICAgY29uc3QgdGFnID0gZ2VuLmNvbnN0KFwidGFnXCIsICgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0keygwLCBjb2RlZ2VuXzEuZ2V0UHJvcGVydHkpKHRhZ05hbWUpfWApO1xuICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgdHlwZW9mICR7dGFnfSA9PSBcInN0cmluZ1wiYCwgKCkgPT4gdmFsaWRhdGVNYXBwaW5nKCksICgpID0+IGN4dC5lcnJvcihmYWxzZSwgeyBkaXNjckVycm9yOiB0eXBlc18xLkRpc2NyRXJyb3IuVGFnLCB0YWcsIHRhZ05hbWUgfSkpO1xuICAgICAgICBjeHQub2sodmFsaWQpO1xuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZU1hcHBpbmcoKSB7XG4gICAgICAgICAgICBjb25zdCBtYXBwaW5nID0gZ2V0TWFwcGluZygpO1xuICAgICAgICAgICAgZ2VuLmlmKGZhbHNlKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdGFnVmFsdWUgaW4gbWFwcGluZykge1xuICAgICAgICAgICAgICAgIGdlbi5lbHNlSWYoKDAsIGNvZGVnZW5fMS5fKSBgJHt0YWd9ID09PSAke3RhZ1ZhbHVlfWApO1xuICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIGFwcGx5VGFnU2NoZW1hKG1hcHBpbmdbdGFnVmFsdWVdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnZW4uZWxzZSgpO1xuICAgICAgICAgICAgY3h0LmVycm9yKGZhbHNlLCB7IGRpc2NyRXJyb3I6IHR5cGVzXzEuRGlzY3JFcnJvci5NYXBwaW5nLCB0YWcsIHRhZ05hbWUgfSk7XG4gICAgICAgICAgICBnZW4uZW5kSWYoKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhcHBseVRhZ1NjaGVtYShzY2hlbWFQcm9wKSB7XG4gICAgICAgICAgICBjb25zdCBfdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgICAgICAgICAgY29uc3Qgc2NoQ3h0ID0gY3h0LnN1YnNjaGVtYSh7IGtleXdvcmQ6IFwib25lT2ZcIiwgc2NoZW1hUHJvcCB9LCBfdmFsaWQpO1xuICAgICAgICAgICAgY3h0Lm1lcmdlRXZhbHVhdGVkKHNjaEN4dCwgY29kZWdlbl8xLk5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIF92YWxpZDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXRNYXBwaW5nKCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgY29uc3Qgb25lT2ZNYXBwaW5nID0ge307XG4gICAgICAgICAgICBjb25zdCB0b3BSZXF1aXJlZCA9IGhhc1JlcXVpcmVkKHBhcmVudFNjaGVtYSk7XG4gICAgICAgICAgICBsZXQgdGFnUmVxdWlyZWQgPSB0cnVlO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvbmVPZi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBzY2ggPSBvbmVPZltpXTtcbiAgICAgICAgICAgICAgICBpZiAoKHNjaCA9PT0gbnVsbCB8fCBzY2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNjaC4kcmVmKSAmJiAhKDAsIHV0aWxfMS5zY2hlbWFIYXNSdWxlc0J1dFJlZikoc2NoLCBpdC5zZWxmLlJVTEVTKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWYgPSBzY2guJHJlZjtcbiAgICAgICAgICAgICAgICAgICAgc2NoID0gY29tcGlsZV8xLnJlc29sdmVSZWYuY2FsbChpdC5zZWxmLCBpdC5zY2hlbWFFbnYucm9vdCwgaXQuYmFzZUlkLCByZWYpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2NoIGluc3RhbmNlb2YgY29tcGlsZV8xLlNjaGVtYUVudilcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjaCA9IHNjaC5zY2hlbWE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzY2ggPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyByZWZfZXJyb3JfMS5kZWZhdWx0KGl0Lm9wdHMudXJpUmVzb2x2ZXIsIGl0LmJhc2VJZCwgcmVmKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcFNjaCA9IChfYSA9IHNjaCA9PT0gbnVsbCB8fCBzY2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNjaC5wcm9wZXJ0aWVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbdGFnTmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wU2NoICE9IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkaXNjcmltaW5hdG9yOiBvbmVPZiBzdWJzY2hlbWFzIChvciByZWZlcmVuY2VkIHNjaGVtYXMpIG11c3QgaGF2ZSBcInByb3BlcnRpZXMvJHt0YWdOYW1lfVwiYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRhZ1JlcXVpcmVkID0gdGFnUmVxdWlyZWQgJiYgKHRvcFJlcXVpcmVkIHx8IGhhc1JlcXVpcmVkKHNjaCkpO1xuICAgICAgICAgICAgICAgIGFkZE1hcHBpbmdzKHByb3BTY2gsIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0YWdSZXF1aXJlZClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGRpc2NyaW1pbmF0b3I6IFwiJHt0YWdOYW1lfVwiIG11c3QgYmUgcmVxdWlyZWRgKTtcbiAgICAgICAgICAgIHJldHVybiBvbmVPZk1hcHBpbmc7XG4gICAgICAgICAgICBmdW5jdGlvbiBoYXNSZXF1aXJlZCh7IHJlcXVpcmVkIH0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShyZXF1aXJlZCkgJiYgcmVxdWlyZWQuaW5jbHVkZXModGFnTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBhZGRNYXBwaW5ncyhzY2gsIGkpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2NoLmNvbnN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZE1hcHBpbmcoc2NoLmNvbnN0LCBpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2NoLmVudW0pIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB0YWdWYWx1ZSBvZiBzY2guZW51bSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkTWFwcGluZyh0YWdWYWx1ZSwgaSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZGlzY3JpbWluYXRvcjogXCJwcm9wZXJ0aWVzLyR7dGFnTmFtZX1cIiBtdXN0IGhhdmUgXCJjb25zdFwiIG9yIFwiZW51bVwiYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gYWRkTWFwcGluZyh0YWdWYWx1ZSwgaSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGFnVmFsdWUgIT0gXCJzdHJpbmdcIiB8fCB0YWdWYWx1ZSBpbiBvbmVPZk1hcHBpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkaXNjcmltaW5hdG9yOiBcIiR7dGFnTmFtZX1cIiB2YWx1ZXMgbXVzdCBiZSB1bmlxdWUgc3RyaW5nc2ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvbmVPZk1hcHBpbmdbdGFnVmFsdWVdID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwie1xuICBcIiRzY2hlbWFcIjogXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA3L3NjaGVtYSNcIixcbiAgXCIkaWRcIjogXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA3L3NjaGVtYSNcIixcbiAgXCJ0aXRsZVwiOiBcIkNvcmUgc2NoZW1hIG1ldGEtc2NoZW1hXCIsXG4gIFwiZGVmaW5pdGlvbnNcIjoge1xuICAgIFwic2NoZW1hQXJyYXlcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgIFwibWluSXRlbXNcIjogMSxcbiAgICAgIFwiaXRlbXNcIjoge1wiJHJlZlwiOiBcIiNcIn1cbiAgICB9LFxuICAgIFwibm9uTmVnYXRpdmVJbnRlZ2VyXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImludGVnZXJcIixcbiAgICAgIFwibWluaW11bVwiOiAwXG4gICAgfSxcbiAgICBcIm5vbk5lZ2F0aXZlSW50ZWdlckRlZmF1bHQwXCI6IHtcbiAgICAgIFwiYWxsT2ZcIjogW3tcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL25vbk5lZ2F0aXZlSW50ZWdlclwifSwge1wiZGVmYXVsdFwiOiAwfV1cbiAgICB9LFxuICAgIFwic2ltcGxlVHlwZXNcIjoge1xuICAgICAgXCJlbnVtXCI6IFtcImFycmF5XCIsIFwiYm9vbGVhblwiLCBcImludGVnZXJcIiwgXCJudWxsXCIsIFwibnVtYmVyXCIsIFwib2JqZWN0XCIsIFwic3RyaW5nXCJdXG4gICAgfSxcbiAgICBcInN0cmluZ0FycmF5XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICBcIml0ZW1zXCI6IHtcInR5cGVcIjogXCJzdHJpbmdcIn0sXG4gICAgICBcInVuaXF1ZUl0ZW1zXCI6IHRydWUsXG4gICAgICBcImRlZmF1bHRcIjogW11cbiAgICB9XG4gIH0sXG4gIFwidHlwZVwiOiBbXCJvYmplY3RcIiwgXCJib29sZWFuXCJdLFxuICBcInByb3BlcnRpZXNcIjoge1xuICAgIFwiJGlkXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJmb3JtYXRcIjogXCJ1cmktcmVmZXJlbmNlXCJcbiAgICB9LFxuICAgIFwiJHNjaGVtYVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZm9ybWF0XCI6IFwidXJpXCJcbiAgICB9LFxuICAgIFwiJHJlZlwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZm9ybWF0XCI6IFwidXJpLXJlZmVyZW5jZVwiXG4gICAgfSxcbiAgICBcIiRjb21tZW50XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXG4gICAgfSxcbiAgICBcInRpdGxlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXG4gICAgfSxcbiAgICBcImRlc2NyaXB0aW9uXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXG4gICAgfSxcbiAgICBcImRlZmF1bHRcIjogdHJ1ZSxcbiAgICBcInJlYWRPbmx5XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgIFwiZGVmYXVsdFwiOiBmYWxzZVxuICAgIH0sXG4gICAgXCJleGFtcGxlc1wiOiB7XG4gICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgXCJpdGVtc1wiOiB0cnVlXG4gICAgfSxcbiAgICBcIm11bHRpcGxlT2ZcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImV4Y2x1c2l2ZU1pbmltdW1cIjogMFxuICAgIH0sXG4gICAgXCJtYXhpbXVtXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiXG4gICAgfSxcbiAgICBcImV4Y2x1c2l2ZU1heGltdW1cIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCJcbiAgICB9LFxuICAgIFwibWluaW11bVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIlxuICAgIH0sXG4gICAgXCJleGNsdXNpdmVNaW5pbXVtXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiXG4gICAgfSxcbiAgICBcIm1heExlbmd0aFwiOiB7XCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9ub25OZWdhdGl2ZUludGVnZXJcIn0sXG4gICAgXCJtaW5MZW5ndGhcIjoge1wiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvbm9uTmVnYXRpdmVJbnRlZ2VyRGVmYXVsdDBcIn0sXG4gICAgXCJwYXR0ZXJuXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJmb3JtYXRcIjogXCJyZWdleFwiXG4gICAgfSxcbiAgICBcImFkZGl0aW9uYWxJdGVtc1wiOiB7XCIkcmVmXCI6IFwiI1wifSxcbiAgICBcIml0ZW1zXCI6IHtcbiAgICAgIFwiYW55T2ZcIjogW3tcIiRyZWZcIjogXCIjXCJ9LCB7XCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9zY2hlbWFBcnJheVwifV0sXG4gICAgICBcImRlZmF1bHRcIjogdHJ1ZVxuICAgIH0sXG4gICAgXCJtYXhJdGVtc1wiOiB7XCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9ub25OZWdhdGl2ZUludGVnZXJcIn0sXG4gICAgXCJtaW5JdGVtc1wiOiB7XCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9ub25OZWdhdGl2ZUludGVnZXJEZWZhdWx0MFwifSxcbiAgICBcInVuaXF1ZUl0ZW1zXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgIFwiZGVmYXVsdFwiOiBmYWxzZVxuICAgIH0sXG4gICAgXCJjb250YWluc1wiOiB7XCIkcmVmXCI6IFwiI1wifSxcbiAgICBcIm1heFByb3BlcnRpZXNcIjoge1wiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvbm9uTmVnYXRpdmVJbnRlZ2VyXCJ9LFxuICAgIFwibWluUHJvcGVydGllc1wiOiB7XCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9ub25OZWdhdGl2ZUludGVnZXJEZWZhdWx0MFwifSxcbiAgICBcInJlcXVpcmVkXCI6IHtcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL3N0cmluZ0FycmF5XCJ9LFxuICAgIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjoge1wiJHJlZlwiOiBcIiNcIn0sXG4gICAgXCJkZWZpbml0aW9uc1wiOiB7XG4gICAgICBcInR5cGVcIjogXCJvYmplY3RcIixcbiAgICAgIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjoge1wiJHJlZlwiOiBcIiNcIn0sXG4gICAgICBcImRlZmF1bHRcIjoge31cbiAgICB9LFxuICAgIFwicHJvcGVydGllc1wiOiB7XG4gICAgICBcInR5cGVcIjogXCJvYmplY3RcIixcbiAgICAgIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjoge1wiJHJlZlwiOiBcIiNcIn0sXG4gICAgICBcImRlZmF1bHRcIjoge31cbiAgICB9LFxuICAgIFwicGF0dGVyblByb3BlcnRpZXNcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwib2JqZWN0XCIsXG4gICAgICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IHtcIiRyZWZcIjogXCIjXCJ9LFxuICAgICAgXCJwcm9wZXJ0eU5hbWVzXCI6IHtcImZvcm1hdFwiOiBcInJlZ2V4XCJ9LFxuICAgICAgXCJkZWZhdWx0XCI6IHt9XG4gICAgfSxcbiAgICBcImRlcGVuZGVuY2llc1wiOiB7XG4gICAgICBcInR5cGVcIjogXCJvYmplY3RcIixcbiAgICAgIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjoge1xuICAgICAgICBcImFueU9mXCI6IFt7XCIkcmVmXCI6IFwiI1wifSwge1wiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvc3RyaW5nQXJyYXlcIn1dXG4gICAgICB9XG4gICAgfSxcbiAgICBcInByb3BlcnR5TmFtZXNcIjoge1wiJHJlZlwiOiBcIiNcIn0sXG4gICAgXCJjb25zdFwiOiB0cnVlLFxuICAgIFwiZW51bVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgXCJpdGVtc1wiOiB0cnVlLFxuICAgICAgXCJtaW5JdGVtc1wiOiAxLFxuICAgICAgXCJ1bmlxdWVJdGVtc1wiOiB0cnVlXG4gICAgfSxcbiAgICBcInR5cGVcIjoge1xuICAgICAgXCJhbnlPZlwiOiBbXG4gICAgICAgIHtcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL3NpbXBsZVR5cGVzXCJ9LFxuICAgICAgICB7XG4gICAgICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgICAgICBcIml0ZW1zXCI6IHtcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL3NpbXBsZVR5cGVzXCJ9LFxuICAgICAgICAgIFwibWluSXRlbXNcIjogMSxcbiAgICAgICAgICBcInVuaXF1ZUl0ZW1zXCI6IHRydWVcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0sXG4gICAgXCJmb3JtYXRcIjoge1widHlwZVwiOiBcInN0cmluZ1wifSxcbiAgICBcImNvbnRlbnRNZWRpYVR5cGVcIjoge1widHlwZVwiOiBcInN0cmluZ1wifSxcbiAgICBcImNvbnRlbnRFbmNvZGluZ1wiOiB7XCJ0eXBlXCI6IFwic3RyaW5nXCJ9LFxuICAgIFwiaWZcIjoge1wiJHJlZlwiOiBcIiNcIn0sXG4gICAgXCJ0aGVuXCI6IHtcIiRyZWZcIjogXCIjXCJ9LFxuICAgIFwiZWxzZVwiOiB7XCIkcmVmXCI6IFwiI1wifSxcbiAgICBcImFsbE9mXCI6IHtcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL3NjaGVtYUFycmF5XCJ9LFxuICAgIFwiYW55T2ZcIjoge1wiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvc2NoZW1hQXJyYXlcIn0sXG4gICAgXCJvbmVPZlwiOiB7XCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9zY2hlbWFBcnJheVwifSxcbiAgICBcIm5vdFwiOiB7XCIkcmVmXCI6IFwiI1wifVxuICB9LFxuICBcImRlZmF1bHRcIjogdHJ1ZVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1pc3NpbmdSZWZFcnJvciA9IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yID0gZXhwb3J0cy5Db2RlR2VuID0gZXhwb3J0cy5OYW1lID0gZXhwb3J0cy5uaWwgPSBleHBvcnRzLnN0cmluZ2lmeSA9IGV4cG9ydHMuc3RyID0gZXhwb3J0cy5fID0gZXhwb3J0cy5LZXl3b3JkQ3h0ID0gZXhwb3J0cy5BanYgPSB2b2lkIDA7XG5jb25zdCBjb3JlXzEgPSByZXF1aXJlKFwiLi9jb3JlXCIpO1xuY29uc3QgZHJhZnQ3XzEgPSByZXF1aXJlKFwiLi92b2NhYnVsYXJpZXMvZHJhZnQ3XCIpO1xuY29uc3QgZGlzY3JpbWluYXRvcl8xID0gcmVxdWlyZShcIi4vdm9jYWJ1bGFyaWVzL2Rpc2NyaW1pbmF0b3JcIik7XG5jb25zdCBkcmFmdDdNZXRhU2NoZW1hID0gcmVxdWlyZShcIi4vcmVmcy9qc29uLXNjaGVtYS1kcmFmdC0wNy5qc29uXCIpO1xuY29uc3QgTUVUQV9TVVBQT1JUX0RBVEEgPSBbXCIvcHJvcGVydGllc1wiXTtcbmNvbnN0IE1FVEFfU0NIRU1BX0lEID0gXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA3L3NjaGVtYVwiO1xuY2xhc3MgQWp2IGV4dGVuZHMgY29yZV8xLmRlZmF1bHQge1xuICAgIF9hZGRWb2NhYnVsYXJpZXMoKSB7XG4gICAgICAgIHN1cGVyLl9hZGRWb2NhYnVsYXJpZXMoKTtcbiAgICAgICAgZHJhZnQ3XzEuZGVmYXVsdC5mb3JFYWNoKCh2KSA9PiB0aGlzLmFkZFZvY2FidWxhcnkodikpO1xuICAgICAgICBpZiAodGhpcy5vcHRzLmRpc2NyaW1pbmF0b3IpXG4gICAgICAgICAgICB0aGlzLmFkZEtleXdvcmQoZGlzY3JpbWluYXRvcl8xLmRlZmF1bHQpO1xuICAgIH1cbiAgICBfYWRkRGVmYXVsdE1ldGFTY2hlbWEoKSB7XG4gICAgICAgIHN1cGVyLl9hZGREZWZhdWx0TWV0YVNjaGVtYSgpO1xuICAgICAgICBpZiAoIXRoaXMub3B0cy5tZXRhKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBtZXRhU2NoZW1hID0gdGhpcy5vcHRzLiRkYXRhXG4gICAgICAgICAgICA/IHRoaXMuJGRhdGFNZXRhU2NoZW1hKGRyYWZ0N01ldGFTY2hlbWEsIE1FVEFfU1VQUE9SVF9EQVRBKVxuICAgICAgICAgICAgOiBkcmFmdDdNZXRhU2NoZW1hO1xuICAgICAgICB0aGlzLmFkZE1ldGFTY2hlbWEobWV0YVNjaGVtYSwgTUVUQV9TQ0hFTUFfSUQsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5yZWZzW1wiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9zY2hlbWFcIl0gPSBNRVRBX1NDSEVNQV9JRDtcbiAgICB9XG4gICAgZGVmYXVsdE1ldGEoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5vcHRzLmRlZmF1bHRNZXRhID1cbiAgICAgICAgICAgIHN1cGVyLmRlZmF1bHRNZXRhKCkgfHwgKHRoaXMuZ2V0U2NoZW1hKE1FVEFfU0NIRU1BX0lEKSA/IE1FVEFfU0NIRU1BX0lEIDogdW5kZWZpbmVkKSk7XG4gICAgfVxufVxuZXhwb3J0cy5BanYgPSBBanY7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBBanY7XG5tb2R1bGUuZXhwb3J0cy5BanYgPSBBanY7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBBanY7XG52YXIgdmFsaWRhdGVfMSA9IHJlcXVpcmUoXCIuL2NvbXBpbGUvdmFsaWRhdGVcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJLZXl3b3JkQ3h0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB2YWxpZGF0ZV8xLktleXdvcmRDeHQ7IH0gfSk7XG52YXIgY29kZWdlbl8xID0gcmVxdWlyZShcIi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLl87IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzdHJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVnZW5fMS5zdHI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzdHJpbmdpZnlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVnZW5fMS5zdHJpbmdpZnk7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJuaWxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVnZW5fMS5uaWw7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOYW1lXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEuTmFtZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvZGVHZW5cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVnZW5fMS5Db2RlR2VuOyB9IH0pO1xudmFyIHZhbGlkYXRpb25fZXJyb3JfMSA9IHJlcXVpcmUoXCIuL3J1bnRpbWUvdmFsaWRhdGlvbl9lcnJvclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlZhbGlkYXRpb25FcnJvclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsaWRhdGlvbl9lcnJvcl8xLmRlZmF1bHQ7IH0gfSk7XG52YXIgcmVmX2Vycm9yXzEgPSByZXF1aXJlKFwiLi9jb21waWxlL3JlZl9lcnJvclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk1pc3NpbmdSZWZFcnJvclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVmX2Vycm9yXzEuZGVmYXVsdDsgfSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFqdi5qcy5tYXAiLCJpbXBvcnQgeyBzY2hlbWEsIHRhYmxlLCB0fSBmcm9tICdzcGFjZXRpbWVkYi9zZXJ2ZXInO1xuaW1wb3J0IHtBanZ9IGZyb20gJ2Fqdic7XG5cblxuY29uc3QgTExNX1Jlc3VsdHMgPSB0YWJsZShcbiAge1xuICAgIG5hbWU6ICdsbG1fcmVzdWx0JyxcbiAgICBwdWJsaWM6IHRydWVcbiAgfSxcbiAge1xuICAgIGlkOiB0LnUxMjgoKS5hdXRvSW5jKCkucHJpbWFyeUtleSgpLFxuICAgIHByb21wdDogdC5zdHJpbmcoKSxcbiAgICBzY2hlbWE6IHQuc3RyaW5nKCksXG4gICAgcmVzcG9uc2U6IHQuc3RyaW5nKCksXG4gICAgcHJvdmlkZXI6IHQuc3RyaW5nKCksXG4gICAgbW9kZWw6IHQuc3RyaW5nKCksXG4gIH1cbilcblxuXG5leHBvcnQgY29uc3Qgc3BhY2V0aW1lZGIgPSBzY2hlbWEoTExNX1Jlc3VsdHMpXG5cblxuXG5cbnNwYWNldGltZWRiLnJlZHVjZXIoJ2FkZF9jYWxsJywge1xuICBwcm9tcHQ6IHQuc3RyaW5nKCksXG4gIHNjaGVtYTogdC5zdHJpbmcoKSxcbiAgcmVzcG9uc2U6IHQuc3RyaW5nKCksXG4gIHByb3ZpZGVyOiB0LnN0cmluZygpLFxuICBtb2RlbDogdC5zdHJpbmcoKSxcbn0sIChjdHgsIHsgcHJvbXB0LCBzY2hlbWEsIHJlc3BvbnNlLCBwcm92aWRlciwgbW9kZWwgfSkgPT4ge1xuXG5cblxuICBjb25zdCBhanYgPSBuZXcgQWp2KCk7XG4gIGNvbnN0IHZhbGlkYXRlID0gYWp2LmNvbXBpbGUoSlNPTi5wYXJzZShzY2hlbWEpKTtcbiAgY29uc3QgdmFsaWQgPSB2YWxpZGF0ZShKU09OLnBhcnNlKHJlc3BvbnNlKSk7XG4gIGlmICghdmFsaWQpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRVJST1IgcG9zdGluZyB0byBkYXRhYmFzZTogXCIsIHZhbGlkYXRlLmVycm9ycyk7ICBcbiAgICB0aHJvdyBuZXcgRXJyb3IodmFsaWRhdGUuZXJyb3JzID8gdmFsaWRhdGUuZXJyb3JzLm1hcChlPT5lLm1lc3NhZ2UpLmpvaW4oJywgJykgOiAnSW52YWxpZCByZXNwb25zZScpO1xuICB9XG5cbiAgY3R4LmRiLmxsbVJlc3VsdC5pbnNlcnQoe2lkOiAwbiwgcHJvbXB0LCBzY2hlbWEsIHJl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cEIsT0FBTyxFQUFFLFFBQVE7Q0FDbEIsQ0FDRjtBQUdELE1BQWEsY0FBYyxPQUFPLFlBQVk7QUFLOUMsWUFBWSxRQUFRLFlBQVk7Q0FDOUIsUUFBUSxFQUFFLFFBQVE7Q0FDbEIsUUFBUSxFQUFFLFFBQVE7Q0FDbEIsVUFBVSxFQUFFLFFBQVE7Q0FDcEIsVUFBVSxFQUFFLFFBQVE7Q0FDcEIsT0FBTyxFQUFFLFFBQVE7Q0FDbEIsR0FBRyxLQUFLLEVBQUUsUUFBUSxrQkFBUSxVQUFVLFVBQVUsWUFBWTtDQUt6RCxNQUFNLFdBRE0sSUFBSUMsZ0JBQUssQ0FDQSxRQUFRLEtBQUssTUFBTUMsU0FBTyxDQUFDO0FBRWhELEtBQUksQ0FEVSxTQUFTLEtBQUssTUFBTSxTQUFTLENBQUMsRUFDaEM7QUFDVixVQUFRLE1BQU0sK0JBQStCLFNBQVMsT0FBTztBQUM3RCxRQUFNLElBQUksTUFBTSxTQUFTLFNBQVMsU0FBUyxPQUFPLEtBQUksTUFBRyxFQUFFLFFBQVEsQ0FBQyxLQUFLLEtBQUssR0FBRyxtQkFBbUI7O0FBR3RHLEtBQUksR0FBRyxVQUFVLE9BQU87RUFBQyxJQUFJO0VBQUk7RUFBUTtFQUFRO0VBQVU7RUFBVTtFQUFPLENBQUM7RUFHN0UiLCJkZWJ1Z0lkIjoiNTBiODE2NTEtNDIwYy00ZGFjLWE5NDgtZWI4ZjFhZjAzZDk4In0=